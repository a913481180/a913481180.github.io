<!DOCTYPE html>


  <html class="light page-post">


<head>
  <meta charset="utf-8">
  
  <title>数据结构 | KK</title>

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
    <meta name="keywords" content="前端,前端开发,用户体验,设计,design,nodejs,JavaScript" />
  

  <meta name="description" content="数据结构算法时间复杂度T(n)&#x3D;O(f(n))  用常数1取代运行时间中的所有加法常数，如多条pintf语句只运行1次即O(1) 在修改后的运行次数函数中，只保留最高项 如果最高项不是1，则去除最高项的常数如3n^2即O(n^2)  所耗时间O(1)&lt;O(logn)&lt;O(n)&lt;O(nlogn)&lt;O(n^2)&lt;O(2^n)&lt;O(n!)&lt;O(n^n) 线性表由">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构">
<meta property="og:url" content="http://www.baidu.com/2020/11/11/shujujiegou/index.html">
<meta property="og:site_name" content="KK">
<meta property="og:description" content="数据结构算法时间复杂度T(n)&#x3D;O(f(n))  用常数1取代运行时间中的所有加法常数，如多条pintf语句只运行1次即O(1) 在修改后的运行次数函数中，只保留最高项 如果最高项不是1，则去除最高项的常数如3n^2即O(n^2)  所耗时间O(1)&lt;O(logn)&lt;O(n)&lt;O(nlogn)&lt;O(n^2)&lt;O(2^n)&lt;O(n!)&lt;O(n^n) 线性表由">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2020-11-11T12:33:33.000Z">
<meta property="article:modified_time" content="2021-07-19T09:00:42.401Z">
<meta property="article:author" content="KK">
<meta name="twitter:card" content="summary">

  

  
    <link rel="icon" href="/images/1.png">
  

  <link href="/css/styles.css?v=c114cbeddx" rel="stylesheet">


  
    
<link rel="stylesheet" href="/css/personal-style.css">

  

  
<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-38189205-1', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->


  
  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?57e94d016e201fba3603a8a2b0263af0";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>


  
  <script type="text/javascript">
	(function(){
	    var bp = document.createElement('script');
	    var curProtocol = window.location.protocol.split(':')[0];
	    if (curProtocol === 'https') {
	        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
	    }
	    else {
	        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
	    }
	    var s = document.getElementsByTagName("script")[0];
	    s.parentNode.insertBefore(bp, s);
	})();
  </script>



  
    <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.3.0/css/font-awesome.min.css">
  

<meta name="generator" content="Hexo 5.4.0"></head>

<body>


  
    <span id="toolbox-mobile" class="toolbox-mobile">选项</span>
  

  <div class="post-header CENTER">
   
  <div class="toolbox">
    <a class="toolbox-entry" href="/">
      <span class="toolbox-entry-text">选项</span>
      <i class="icon-angle-down"></i>
      <i class="icon-home"></i>
    </a>
    <ul class="list-toolbox">
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/archives/"
            rel="noopener noreferrer"
            target="_self"
            >
            Notes
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/categories/"
            rel="noopener noreferrer"
            target="_self"
            >
            分类
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/about/"
            rel="noopener noreferrer"
            target="_self"
            >
            关于
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/search/"
            rel="noopener noreferrer"
            target="_self"
            >
            搜索
          </a>
        </li>
      
    </ul>
  </div>


</div>


  <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-text">数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-text">算法时间复杂度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8"><span class="toc-text">线性表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%8F%96"><span class="toc-text">顺序存取</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E5%BC%8F%E5%AD%98%E5%8F%96"><span class="toc-text">链式存取</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8"><span class="toc-text">循环链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8"><span class="toc-text">双向链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E9%93%BE%E8%A1%A8"><span class="toc-text">静态链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88"><span class="toc-text">栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%9F%E5%88%97"><span class="toc-text">队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%B2"><span class="toc-text">串</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%B2%E7%9A%84%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95"><span class="toc-text">串的模式匹配算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E5%BD%92"><span class="toc-text">递归</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91"><span class="toc-text">树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">二叉树</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE"><span class="toc-text">图</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-text">图的存储结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%81%8D%E5%8E%86%E6%96%B9%E6%B3%95"><span class="toc-text">遍历方法</span></a></li></ol></li></ol>
  </div>



<div class="content content-post CENTER">
   <article id="post-shujujiegou" class="article article-type-post" itemprop="blogPost">
  <header class="article-header">
    <h1 class="post-title">数据结构</h1>

    <div class="article-meta">
      <span>
        <i class="icon-calendar"></i>
        <span>2020.11.11</span>
      </span>

      
        <span class="article-author">
          <i class="icon-user"></i>
          <span>KK</span>
        </span>
      

      
  <span class="article-category">
    <i class="icon-list"></i>
    <a class="article-category-link" href="/categories/study/">study</a>
  </span>



      

      
      <i class="fa fa-eye"></i> 
        <span id="busuanzi_container_page_pv">
           &nbsp热度 <span id="busuanzi_value_page_pv">
           <i class="fa fa-spinner fa-spin"></i></span>℃
        </span>
      
      
    </div>
  </header>

  <div class="article-content">
    
      <h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h3 id="算法时间复杂度"><a href="#算法时间复杂度" class="headerlink" title="算法时间复杂度"></a>算法时间复杂度</h3><p>T(n)=O(f(n))</p>
<ol>
<li>用常数1取代运行时间中的所有加法常数，如多条pintf语句只运行1次即O(1)</li>
<li>在修改后的运行次数函数中，只保留最高项</li>
<li>如果最高项不是1，则去除最高项的常数如3n^2即O(n^2)</li>
</ol>
<p>所耗时间<code>O(1)&lt;O(logn)&lt;O(n)&lt;O(nlogn)&lt;O(n^2)&lt;O(2^n)&lt;O(n!)&lt;O(n^n)</code></p>
<h3 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h3><p>由零个或多个数据元素组成的有限序列</p>
<p>[a1][a2]…[ai-1][ai][ai+1]….[an]<br>[ai-1]为[ai]的直接前驱元素<br>[ai+1]为[ai]的直接后继元素<br>每个元素有且只有一个前驱和后继元素，不存在一对多</p>
<p>抽象数据类型的形式定义</p>
<p>ADT=(D,S,P)</p>
<p>描述方法（伪码）：</p>
<p>ADT 抽象数据类型名{</p>
<p>数据对象：&lt;数据对象的定义&gt;</p>
<p>数据关系：&lt;数据关系的定义&gt;</p>
<p>基本操作：&lt;基本操作的定义&gt;</p>
<p>}ADT 抽象数据类型名</p>
<p>抽象数据类型的实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#define TRUE 1</span><br><span class="line">#define FALSE 0</span><br><span class="line">#define OK 1</span><br><span class="line">#define ERROR 0</span><br><span class="line">#define INFEASIBLE -1</span><br><span class="line">#define OVERFLOW -2</span><br><span class="line">//Status是函数的类型，其值是函数结果的状态代码</span><br><span class="line">typedef int Status;</span><br><span class="line">Status 函数名&#123;</span><br><span class="line">//算法说明</span><br><span class="line">语句序列;</span><br><span class="line">&#125;//函数名</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">ADT List&#123;</span><br><span class="line">	数据对象：D=&#123;ai|ai∈ElemSet,i=1,2,...,n,n≥0&#125;</span><br><span class="line">	数据关系：R1=&#123;&lt;ai-1,ai&gt;|ai-1,ai∈D,i=2,3,4,...,n&#125;</span><br><span class="line">	基本操作：</span><br><span class="line">	InitList(&amp;L)</span><br><span class="line">		操作结果：构造一个空的线性表L。</span><br><span class="line">	DestroyList(&amp;L)</span><br><span class="line">		初始条件：线性表L已存在。</span><br><span class="line">		操作结果：销毁线性表L。</span><br><span class="line">	ClearList(&amp;L)</span><br><span class="line">		初始条件：线性表L已存在。</span><br><span class="line">		操作结果：将L重置为空表。</span><br><span class="line">	ListEmpty (L)</span><br><span class="line">		初始条件：线性表L已存在。</span><br><span class="line">		操作结果：若L为空表，则返回TRUE，否则返回FALSE。</span><br><span class="line">	ListLength(L)</span><br><span class="line">		初始条件：线性表L已存在。</span><br><span class="line">		操作结果：返回L中数据元素的个数。</span><br><span class="line">	GetElem(L,i,&amp;e)</span><br><span class="line">		初始条件：线性表L已存在，l≤i≤ListLength(L)。</span><br><span class="line">		操作结果：用e返回L中第i个数据元素的值。</span><br><span class="line">	LocateElem(L,e,compare())</span><br><span class="line">		初始条件：线性表L已存在，compare()是数据元素的判定函数。</span><br><span class="line">		操作结果：用e返回L中第1个与e满足关系compare()的数据元素的位序。若这样的数据元素不存在，则返回值为0。</span><br><span class="line">	PriorElem(L,cur_e,&amp;pre_e)</span><br><span class="line">		初始条件：线性表L已存在。</span><br><span class="line">		操作结果：若cur_e是L的数据元素，且不是第一个，则用pre_e返回它的前驱，否则操作失败，pre_e无定义。</span><br><span class="line">	NextElem(L,cur_e,&amp;next_e)</span><br><span class="line">		初始条件：线性表L已存在。</span><br><span class="line">		操作结果：若cur_e是L的数据元素，且不是最后一个，则用next_e返回它的前驱，否则操作失败，next_e无定义。</span><br><span class="line">	ListInsert(&amp;L,i,e)</span><br><span class="line">		初始条件：线性表L已存在，l≤i≤ListLength(L)+1。</span><br><span class="line">		操作结果：在L中第i个位置之前插入新的数据元素e，L的长度加1.</span><br><span class="line">	ListDelete(&amp;L,i,&amp;e)</span><br><span class="line">		初始条件；线性表L已存在且非空，l≤i≤ListLength(L)。</span><br><span class="line">		操作结果：删除L中第i个数据元素，并用e返回其值，L长度减1.</span><br><span class="line">	ListTraverse(L,visit())</span><br><span class="line">		初始条件：线性表L已存在。</span><br><span class="line">		操作结果：依次对L的每个数据元素调用函数visit()。一旦visit()失败，则操作失败。</span><br><span class="line">&#125;ADT List</span><br></pre></td></tr></table></figure>

<h3 id="顺序存取"><a href="#顺序存取" class="headerlink" title="顺序存取"></a>顺序存取</h3><p>数组</p>
<h3 id="链式存取"><a href="#链式存取" class="headerlink" title="链式存取"></a>链式存取</h3><ul>
<li>单链表整表创建的算法思路：</li>
</ul>
<ol>
<li>声明一个结点p和计数器变量n；</li>
<li>初始化一空链表L；</li>
<li>让L的头结点的指针指向NULL；</li>
<li>循环实现后继结点的赋值和插入；</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">	</span><br><span class="line">typedef int DataType;</span><br><span class="line"></span><br><span class="line">typedef struct LNode&#123;</span><br><span class="line">	DataType data;		//数据域</span><br><span class="line">	struct LNode *next;	//指针域，指向下一个节点</span><br><span class="line">&#125;LNode,*LinkList;</span><br><span class="line"></span><br><span class="line">//创建///</span><br><span class="line">//声明函数</span><br><span class="line">LinkList CreateList(int n);	//创建链表</span><br><span class="line">void print(LinkList h);		//打印链表</span><br><span class="line"></span><br><span class="line">//创建链表</span><br><span class="line">LinkList CreateList(int n)&#123;</span><br><span class="line">	//定义指针L指向该链表即头指针，结点q为第一个结点，结点p为下一个结点</span><br><span class="line">	LinkList L,p,q;</span><br><span class="line">	//为头指针申请空间</span><br><span class="line">	L=(LNode*)malloc(sizeof(LNode));</span><br><span class="line">	if(!L)&#123;return 0;&#125;</span><br><span class="line">	//头指针指向NULL即空链表</span><br><span class="line">	L-&gt;next =NULL;</span><br><span class="line">	//第一个结点指向头指针</span><br><span class="line">	q=L;</span><br><span class="line">	//循环创建链表结点</span><br><span class="line">	for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">		//为下一个结点申请空间</span><br><span class="line">		p=(LinkList)malloc(sizeof(LNode));</span><br><span class="line">		printf(&quot;输入第%d个元素的值：&quot;,i);</span><br><span class="line">		//存入数据</span><br><span class="line">		scanf(&quot;%d&quot;,&amp;(p-&gt;data));</span><br><span class="line">		//下一个结点的指针指向NULL，即尾部</span><br><span class="line">		p-&gt;next=NULL;</span><br><span class="line">		//第一个结点的指针指向下一个结点,即上一个结点与该结点相连</span><br><span class="line">		q-&gt;next=p;</span><br><span class="line">		//移动第一个结点到下一个结点</span><br><span class="line">		q=p;</span><br><span class="line">	&#125;</span><br><span class="line">	//返回链表头部</span><br><span class="line">	return L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//打印链表</span><br><span class="line">void print (LinkList h)&#123;</span><br><span class="line">	//创建一个指针指向链表的第一个元素结点；</span><br><span class="line">	LinkList p=h-&gt;next;</span><br><span class="line">	//当不是尾部时</span><br><span class="line">	while(p!=NULL)&#123;</span><br><span class="line">	//打印数据</span><br><span class="line">	printf(&quot;%d &quot;,p-&gt;data);</span><br><span class="line">	//移动到下一个元素</span><br><span class="line">	p=p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main ()&#123;</span><br><span class="line">	//创建一个头指针并指向NULL；即空链表·</span><br><span class="line">	LinkList head=NULL;</span><br><span class="line">	//输入结点个数n</span><br><span class="line">	int n;</span><br><span class="line">	printf(&quot;请输入链表长度：&quot;);</span><br><span class="line">	scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">	//创建链表</span><br><span class="line">	head=CreateList(n);</span><br><span class="line">	//打印链表</span><br><span class="line">	printf(&quot;刚刚建立的各个链表元素的值为:\n&quot;);</span><br><span class="line">	print(head);</span><br><span class="line">	printf(&quot;\n\n&quot;);</span><br><span class="line">	//按下任意键结束</span><br><span class="line">	getchar();</span><br><span class="line">	getchar();</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>单链表整表的删除算法思路：</li>
</ul>
<ol>
<li>声明结点p和q；</li>
<li>将第一个接地赋值给p，下一个结点赋值给q；</li>
<li>循环执行释放p和将q赋值给p的操作；free(p)会同时把数据域和指针域同时删除<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//h为头指针</span><br><span class="line">void delect(LinkList h)&#123;</span><br><span class="line">LinkList p,q;</span><br><span class="line">p=h-&gt;next;	//p指向第一个节点</span><br><span class="line">while(p!=NULL)&#123;</span><br><span class="line">q=p-&gt;next;	//q指向第二个节点</span><br><span class="line">free(p);	//删除第一个节点</span><br><span class="line">p=q;		//p等于第二个节点</span><br><span class="line">&#125;</span><br><span class="line">h-&gt;next==NULL;	//头节点指向空</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>获取第i个数据的算法思路：</li>
</ul>
<ol>
<li>声明一个结点p指向链表第一个结点，初始化j从1开始；</li>
<li>当j&lt;i时,就遍历链表，让p的指针向后移动，不断指向下一个结点，j+1；</li>
<li>若到链表末尾p为空，则说明第i个元素不存在；</li>
<li>若查找成功则返回结点p的数据；</li>
</ol>
<ul>
<li>单链表第i个数据插入结点的算法思路：</li>
</ul>
<ol>
<li>将数据元素e赋值给s-&gt;data即s-&gt;data=e;</li>
<li>s-next=p-&gt;next;</li>
<li>p-next=s;</li>
</ol>
<ul>
<li>单链表的删除</li>
</ul>
<ol>
<li>p-&gt;next=p-&gt;next-&gt;next;</li>
</ol>
<p>头指针不为空，头指针是链表的必要元素，头指针是链表指向第一个节点的指针。头结点在第一个元素的节点前，其数据一般无意义，但也可用来存放链表的长度。空链表头指针直接指向null</p>
<h3 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h3><p>尾指针指向头指针</p>
<h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3><p>结构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef struct DualNode&#123;</span><br><span class="line">int data;</span><br><span class="line">struct DualNode *prior; 	//前驱节点</span><br><span class="line">struct DualNode *next;		//后继节点</span><br><span class="line">&#125;DualNode,*DuLinkList;</span><br></pre></td></tr></table></figure>
<p>插入操作</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//s为插入节点，p为后一个节点；</span><br><span class="line">s-&gt;next=p;</span><br><span class="line">s-&gt;prior=p-&gt;prior;</span><br><span class="line">p-&gt;prior-next=s;</span><br><span class="line">p-&gt;prior=s;</span><br></pre></td></tr></table></figure>
<p>删除操作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//删除p节点</span><br><span class="line">p-&gt;prior-&gt;next=p-&gt;next;</span><br><span class="line">p-&gt;next-&gt;prior=p-&gt;prior;</span><br><span class="line">free(p);</span><br></pre></td></tr></table></figure>
<h3 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h3><p>用数组描述的链表称为静态链表</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#define maxsize 1000</span><br><span class="line">typedef struct&#123;</span><br><span class="line">int  data;//数据</span><br><span class="line">int cut;//游标</span><br><span class="line">&#125;component,staticlinklist[maxsize];	//结构体数组</span><br><span class="line">//静态链表的初始化，相当于初始化数组:</span><br><span class="line">Status InitList(staticlinklist space)&#123;</span><br><span class="line">int i;</span><br><span class="line">for(i=0;i&lt;maxsize-1;i++)</span><br><span class="line">&#123;space[i].cur=i+1;&#125;</span><br><span class="line">space[maxsize-1].cur=0;</span><br><span class="line">return Ok;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//第一个与最后一个元素不存放数据,最后一个元素的游标为0。数组的第一个元素即下标为0的那个元素的cur游标就存放备用链表的第一个结点的下标；最后一个元素即maxsize-1的游标cur则存放第一个有数据的元素的下标，相当于单链表中的头结点作用。 </span><br><span class="line">//静态链表中的插入和删除，只需修改游标</span><br></pre></td></tr></table></figure>

<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>是一个先进后出的线性表，要求只在表尾进行删除和插入操作；对与栈来说，表尾称为栈的栈顶top,表头称为栈底bottom.<br>结构:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef struct&#123;</span><br><span class="line">int *bottom;	//指向栈底的指针；</span><br><span class="line">int *top;</span><br><span class="line">int stacksize;	//指当前可使用的最大总量。</span><br><span class="line">&#125;sqStack;</span><br></pre></td></tr></table></figure>
<p>创建一个栈：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#define STACK_INIT_SIZE 100</span><br><span class="line">initStack(sqStack *s)&#123;</span><br><span class="line">s-&gt;bottom=(int*)malloc(STACK_INIT_SIZE*sizeof(int));</span><br><span class="line">if(!s-&gt;base)&#123;exit(0);&#125;</span><br><span class="line">s-&gt;top=s-&gt;base;		//开始栈顶就是栈底</span><br><span class="line">s-&gt;stacksize=STACK_INIT_SIZE;</span><br><span class="line">&#125;</span><br><span class="line">//初始化</span><br><span class="line">void initstack(sqStack *s)&#123;</span><br><span class="line">s-&gt;bottom=(int*)malloc(STACK_INIT_SIZE*sizeof(int));</span><br><span class="line">if(!s-bottom)&#123;exit(0);&#125;</span><br><span class="line">s-&gt;top=s-&gt;bottom;</span><br><span class="line">s-&gt;stacksize=STACK_INIT_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>入栈操作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#define STACKINCREMENT 10</span><br><span class="line">push(sqStack *s,int e);</span><br><span class="line">&#123;</span><br><span class="line">//栈满追加空间</span><br><span class="line">if (s-&gt;top - s-&gt;bottom==s-&gt;stacksize) &#123;</span><br><span class="line">s-&gt;bottom=(int*)realloc(s-&gt;bottom,(s-&gt;stacksize+STACKINCREMENT)*sizeof(int));</span><br><span class="line">if(!s-&gt;bottom)&#123;exit(0);&#125;</span><br><span class="line">s-&gt;top=s-&gt;bottom+s-&gt;stacksize;			//设置栈顶</span><br><span class="line">s-&gt;stacksize=s-&gt;stacksize+STACKINCREMENT;	//重新设置栈的最大容量</span><br><span class="line">&#125;</span><br><span class="line">*(s-&gt;top)=e;</span><br><span class="line">s-&gt;top++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>出栈操作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pop(sqStack *s, int *e)&#123;</span><br><span class="line">if(s-&gt;top==s-&gt;base)&#123;rerutn;&#125;	//栈空退出；</span><br><span class="line">*e=*--(s-&gt;top);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>清空栈：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">clearsqstack(sqStack *s)&#123;</span><br><span class="line">s-&gt;top=s-&gt;bottom;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>销毁一个栈：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">destroystack(sqStack *s)&#123;</span><br><span class="line">int i,len;</span><br><span class="line">len=s-&gt;stacksize;</span><br><span class="line">for(i=0;i&lt;len;i++)&#123;</span><br><span class="line">free(s-&gt;bottom);</span><br><span class="line">s-&gt;bottom++;</span><br><span class="line">&#125;</span><br><span class="line">s-&gt;bottom=s-&gt;top=NULL;</span><br><span class="line">s-&gt;stacksize=0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>计算栈容量：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int stacklen(sqStack *s)&#123;</span><br><span class="line">return(s.top-s.bottom);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>栈的存储结构：<br>顺序存储<br>链式存储：栈顶为单链表的头部</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">typedef struct stackNode&#123;</span><br><span class="line">ElemType data;		//存放栈的数据</span><br><span class="line">struct stackNode *next;</span><br><span class="line">&#125;stackNode,*LinkStackPtr;</span><br><span class="line">typedef strucct LinkStack&#123;</span><br><span class="line">LinkStackPtr top;	//top指针</span><br><span class="line">int count;		//计数器</span><br><span class="line">&#125;</span><br><span class="line">//栈链的进栈</span><br><span class="line">//s为新节点，top为栈顶指针；</span><br><span class="line">Status push(LinkStack *s,ElemType e)&#123;</span><br><span class="line">LinkStackPtr p=(LinkStackPtr)malloc(sizeof(LinkStackPtr));</span><br><span class="line">p-&gt;data=e;</span><br><span class="line">p-&gt;next=s-&gt;top;</span><br><span class="line">s-&gt;cont++;</span><br><span class="line">return OK;</span><br><span class="line">&#125;</span><br><span class="line">//链表的出栈操作</span><br><span class="line">Status pop(LinkStack *s,ElemType *e)&#123;</span><br><span class="line">LintStack p;</span><br><span class="line">if(StackEmpty(*s))&#123;return ERROR;&#125;	//判断是否为空栈</span><br><span class="line">*e=s-&gt;top-&gt;data;</span><br><span class="line">p=s-&gt;top;</span><br><span class="line">s-&gt;top=s-&gt;top-&gt;next;</span><br><span class="line">free(p);</span><br><span class="line">s-&gt;count--;</span><br><span class="line">return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>队列只允许在一端进行插入操作，在另一端进行删除操作的线性表（先进先出）</p>
<p>队列的链式存储结构</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typedef struct QNode&#123;</span><br><span class="line">ElemType data;</span><br><span class="line">struct QNode *next;</span><br><span class="line">&#125;QNode,*QueuePrt;</span><br><span class="line">type struct&#123;</span><br><span class="line">QueuePrt front,rear;	//队头、尾指针；</span><br><span class="line">&#125;LinkQueue;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>创建队列：在内存中创建一个头结点，将队列的头、尾指针都指向这个生成的头结点，此时为空队列；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">initQueue(LinkQueue *q)</span><br><span class="line">&#123;q-&gt;front=q-&gt;rear=(QueuePtr)malloc(sizeof(QNode));</span><br><span class="line">if(!q-&gt;front)&#123;exit(0);&#125;</span><br><span class="line">q-&gt;front-&gt;next=NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>入队操作</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">InsertQueue(LinkQueue *q,ElemType e)&#123;</span><br><span class="line">QueuePtr p;</span><br><span class="line">p=(QueuePtr)malloc(sizeof(QNode));</span><br><span class="line">if(p==NULL)&#123;eixt(0);&#125;</span><br><span class="line">p-&gt;data=e;</span><br><span class="line">p-&gt;next=NULL;</span><br><span class="line">q-&gt;rear-&gt;next=p;</span><br><span class="line">q-&gt;rear=p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>出队列</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DeleteQueue(LinkQueue *q,ElemType *e)&#123;</span><br><span class="line">Queueptr p;</span><br><span class="line">if(q-&gt;front==q-&gt;rear)&#123;return;&#125;	//判断队列是否为空；</span><br><span class="line">p=q-&gt;front-&gt;next;</span><br><span class="line">*e=p-&gt;data;</span><br><span class="line">q-&gt;front-&gt;next=p-&gt;next;</span><br><span class="line">if(q-&gt;rear==p)&#123;q-&gt;rear=q-&gt;front;&#125;</span><br><span class="line">free(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>销毁一个队列</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DestroyQueue(LinkQueue *q)&#123;</span><br><span class="line">while(q-&gt;front)&#123;</span><br><span class="line">q-&gt;rear=q-&gt;front-next;</span><br><span class="line">free(q-&gt;front);</span><br><span class="line">q-&gt;front=q-&gt;rear;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="串"><a href="#串" class="headerlink" title="串"></a>串</h3><p>有零个或多个字符组成的有限序列<code>S=&#39;a1a2a3a4a5....&#39;</code></p>
<ul>
<li>串的长度：串中字符的个数</li>
<li>子串：串中任意个连续的字符串组成的子序列；</li>
<li>串中的位置：该字节在串中的序号，子串在主串中的位置以子串的第一个字符在主串中的位置来表示</li>
<li>空格串：有一个或多个空格组成的串</li>
<li>空串</li>
</ul>
<p>采用顺序存储称为顺序串，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#define MAXLEN 255</span><br><span class="line">typedef struct&#123;</span><br><span class="line">char ch[MAXLEN+1];	//存储串的一维数组</span><br><span class="line">int length;	//串的当前长度</span><br><span class="line">&#125;SString;</span><br></pre></td></tr></table></figure>


<p>采用链式存储称为链串；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#define CHUNKSIZE 80 	//块大小</span><br><span class="line">typedef struct Chunk&#123;</span><br><span class="line">char ch[CHUNKSIZE];</span><br><span class="line">struct Chunk *next;</span><br><span class="line">&#125;Chunk;</span><br><span class="line"></span><br><span class="line">typedef struct&#123;</span><br><span class="line">Chunk *head *tail;	//串的头尾指针</span><br><span class="line">int curlen;		//串的当前长度</span><br><span class="line">&#125;LString;	//字符串的块链结构</span><br></pre></td></tr></table></figure>


<h4 id="串的模式匹配算法"><a href="#串的模式匹配算法" class="headerlink" title="串的模式匹配算法"></a>串的模式匹配算法</h4><p>确定主串中子串（模式串）第一次出现的位置</p>
<ul>
<li>BF算法(暴力破解法）</li>
</ul>
<p>先匹配第一个元素，再匹配第二个元素…..</p>
<ul>
<li>KMP算法</li>
</ul>
<p>主串的指针i不用回溯，子串的指针j不一定回到开头；</p>
<p>next[j]:j的下一个位置</p>
<p>当j=1时，next[j]=0;<br>其他情况，next[j]=1;<br>next[j]=max{1&lt;k&lt;j且从头开始的k-1个元素等于j前面的k-1个元素”P1…P(k-1)”=”P(j-k+1)….P(j-1)”}</p>
<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>方法或函数调用自身的方式称为递归调用，调用称为递，返回称为归。</p>
<ul>
<li>递归的优缺点？</li>
</ul>
<p>1.优点：代码的表达力很强，写起来简洁。<br>2.缺点：空间复杂度高、有堆栈溢出风险、存在重复计算、过多的函数调用会耗时较多等问题。</p>
<ul>
<li>一个问题只要同时满足以下3个条件，就可以用递归来解决：</li>
</ul>
<p>1.问题的解可以分解为几个子问题的解。何为子问题？就是数据规模更小的问题。<br>2.问题与子问题，除了数据规模不同，求解思路完全一样<br>3.存在递归终止条件</p>
<ul>
<li>解决方案</li>
</ul>
<p>1.警惕堆栈溢出：可以声明一个全局变量来控制递归的深度，从而避免堆栈溢出。<br>2.警惕重复计算：通过某种数据结构来保存已经求解过的值，从而避免重复计算。</p>
<h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><p>在一颗非空树中，有且只有一个根节点，结点拥有的子树树称为度；度为0 的结点称为叶子或终端结点；不为0 的结点称为分支结点或非终端结点；树的度是树内结点度的最大值；同一个双亲的孩子互称为兄弟；从根到该结点所经过分支上的结点称为祖先，从该结点到下面所有结点称为子孙；树中结点的最大层次称为树的深度；</p>
<p>从左到右是有次序的称为该树的有序树，否则称为无序树；<br>森林是m棵互不相交的树的集合；</p>
<h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p>每个结点至多只有两棵子树，子树有左右之分，次序不能颠倒</p>
<p>在二叉树的第i层上至多有2^(i-1)个结点</p>
<p>深度为k的二叉树至多有2^k-1个结点</p>
<p>终端结点数为n0，度为2的结点数为n，则n0=n+1;</p>
<ul>
<li>满二叉树</li>
</ul>
<p>深度为k且结点数为2^k-1的二叉树</p>
<ul>
<li>完全二叉树</li>
</ul>
<p>每个结点都与满二叉树中的编号一一对应。</p>
<p>具有n个结点的完全二叉树的深度为[log(2)n]+1;</p>
<p>若2i&gt;n，则结点i无左孩子，否则其左孩子是结点2i；</p>
<p>若2i+1&gt;n，则结点i无右孩子，否则其右孩子为结点2i+1;</p>
<p>若i&gt;1，则其双亲为结点[i/2]</p>
<ul>
<li><p>二叉树的存储结构</p>
<ul>
<li>顺序存储</li>
</ul>
<p>  将完全二叉树上编号为i的结点元素存储在一维数组中</p>
<ul>
<li>链式存储</li>
</ul>
<p>  链表中的结点至少包含三个域：数据域、左右结点指针域；还可以增加一个指向其双亲的指针域；</p>
</li>
<li><p>遍历二叉树</p>
<ul>
<li>先序遍历</li>
</ul>
<p>  根-左-右</p>
<ul>
<li>中序遍历</li>
</ul>
<p>  左-根-右</p>
<ul>
<li>后续遍历</li>
</ul>
<p>  左-右-根</p>
</li>
<li><p>二叉链表</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">typedef char ElemType;</span><br><span class="line">typedef struct BiTNode</span><br><span class="line">&#123;</span><br><span class="line">ElemType data;</span><br><span class="line">struct BiTNode *lchild, *rchild;</span><br><span class="line">&#125;BidTNode,*BiTree;</span><br><span class="line"></span><br><span class="line">//创建一颗二叉树，按照前序遍历的方式输入数据</span><br><span class="line">CreateBidTree(BiTree *T)</span><br><span class="line">&#123;</span><br><span class="line">char c;</span><br><span class="line">scanf(&quot;%c&quot;,&amp;c);</span><br><span class="line">if(&#x27; &#x27;==c)	//空格表示结点无子树</span><br><span class="line">&#123;</span><br><span class="line">*T=NULL;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">*T=(BiTNode *)malloc(sizeof(BiTNode));</span><br><span class="line">(*T)-&gt;data=c;</span><br><span class="line">CreateBiTree(&amp;(*T)-&gt;lchild);</span><br><span class="line">CreateBiTree(&amp;(*T)-&gt;rchild);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">visit()&#123;</span><br><span class="line">//访问结点时的操作</span><br><span class="line">&#125;</span><br><span class="line">//遍历二叉树</span><br><span class="line">PreOrderTraverse(BidTree T,int level)</span><br><span class="line">&#123;</span><br><span class="line">if(T)</span><br><span class="line">&#123;</span><br><span class="line">visit(T-&gt;data,level);</span><br><span class="line">PreOrderTraverse(T-&gt;lchild,level+1);</span><br><span class="line">PreOrderTraverse(T-&gt;rchild,level+1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int level=1;</span><br><span class="line">BiTree T=NULl;</span><br><span class="line">CreateBiTree(&amp;T);</span><br><span class="line">PreOrderTraverse(T,level);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>线索二叉树</li>
</ul>
<p>将定义好的二叉树结构进行扩容：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>lchild</td>
<td>ltag</td>
<td>data</td>
<td>rtag</td>
<td>rchild</td>
</tr>
</tbody></table>
<blockquote>
<p>ltag=0时,lchild指向该结点的左孩子，为1时指向该结点的前驱。rtag=0，rchild指向该结点的右孩子，为1时指向该结点的后继。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">typedef char ElemType;</span><br><span class="line">//线索存储标志位</span><br><span class="line">//Link(0):表示指向左右孩子的指针</span><br><span class="line">//Thread(1):表示指向前驱后继的线索</span><br><span class="line">typedef enum&#123;Link,Thread&#125; PointerTag;</span><br><span class="line">typedef struct BiThrNode</span><br><span class="line">&#123;</span><br><span class="line">char data;</span><br><span class="line">struct BiThrNode *lchild, *rchild;</span><br><span class="line">PointerNag ltag;</span><br><span class="line">PointerNag rTag;</span><br><span class="line">&#125;BiThrNode,*BiThrTree;</span><br><span class="line"></span><br><span class="line">//全局变量，始终指向刚刚访问过的结点</span><br><span class="line">BiThrTree pre;</span><br><span class="line"></span><br><span class="line">//创建一棵二叉树，按照前序遍历的方式输入数据</span><br><span class="line">CreateBiThrTree(BiThrTree *T)</span><br><span class="line">&#123;</span><br><span class="line">char c;</span><br><span class="line">scanf(&quot;%c&quot;,&amp;c);</span><br><span class="line">if(&#x27; &#x27;==c)&#123;</span><br><span class="line">*T=NULL;</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">*T=(BiThrNode *)malloc(sizeof(BiThrNode));</span><br><span class="line">(*T)-&gt;data=c;</span><br><span class="line">(*T)-&gt;ltag=Link;</span><br><span class="line">(*T)-&gt;rtag=Link;</span><br><span class="line"></span><br><span class="line">CreateBiThrTree(&amp;(*T)-&gt;lchild);</span><br><span class="line">CreateBiThrTree(&amp;(*T)-&gt;rchild);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//中序遍历线索</span><br><span class="line">InThreading(BiThrTree T)</span><br><span class="line">&#123;</span><br><span class="line">if(T)</span><br><span class="line">&#123;</span><br><span class="line">InThreading(T-&gt;lchild);	//递归左孩子线索化</span><br><span class="line">if(!T-&gt;lchild)	//如果该节点没有左孩子，则设置ltag为thread，并把lchild指向刚刚访问过的结点</span><br><span class="line">&#123;</span><br><span class="line">T-&gt;ltag=Thread;</span><br><span class="line">T-&gt;lchild=pre;</span><br><span class="line">&#125;</span><br><span class="line">if(!pre-&gt;rchild)</span><br><span class="line">&#123;</span><br><span class="line">pre-&gt;rtag=Thread;</span><br><span class="line">Pre-&gt;rchild=T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Pre=T;</span><br><span class="line">InThreading(T-&gt;rchild);		//递归右孩子线索化</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">InOrderThreading(BiThrTree *p,BiThrTree T)</span><br><span class="line">&#123;</span><br><span class="line">*p=(BiThrTree)malloc(sizeof(BiThrNode));</span><br><span class="line">(*p)-&gt;ltag=Link;</span><br><span class="line">(*P)-&gt;rtag=Thread;</span><br><span class="line">(*p)-&gt;rchild=*p;</span><br><span class="line">if(!T)&#123;</span><br><span class="line">(*P)-&gt;lchild=*p;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">(*P)-&gt;lchild=T;</span><br><span class="line">Pre=*p;</span><br><span class="line">InThreading(T);</span><br><span class="line">Pre-&gt;rchild=*p;</span><br><span class="line">Pre-&gt;rtag=Thread;</span><br><span class="line">(*P)-&gt;rchild=Pre;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">BiThrTree P,T=NULL;</span><br><span class="line">CreateBiThrTree(&amp;T);</span><br><span class="line">InOrderThreading(&amp;P,T);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>普通树转换为二叉树</p>
<ol>
<li>所有兄弟结点之间加一条连线</li>
<li>对树中的每一个结点，只保留它与第一孩子结点的连线，删除它与其它孩子结点间的连线</li>
</ol>
</li>
<li><p>森林转换为二叉树</p>
<ol>
<li>把每棵树转化为二叉树</li>
<li>第一颗二叉树不动，从第二棵二叉树开始，依次把后一棵二叉树的根结点作为前一棵二叉树的根结点的右孩子，用线连起来</li>
</ol>
</li>
</ul>
<blockquote>
<p>树、森林的前序遍历和二叉树的前序遍历结果相同，后序遍历与二叉树的中序遍历结果相同。</p>
</blockquote>
<h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><p>图（Graph）是由顶点的有穷非空集合和顶点之间边的集合组成，通常表示为：G（V，E）其中，G表示一个图，V是图G中顶点的集合，E是图G中边的集合。</p>
<ul>
<li><p>图按照边的有无方向分为无向图和有向图。无向图由顶点和边组成，有向图由顶点和弧构成。弧有弧尾和弧头之分，带箭头一端为弧头。</p>
</li>
<li><p>图按照边或弧的多少分稀疏图和稠密图。如果图中的任意两个顶点之间都存在边叫做完全图，有向的叫有向完全图。若无重复的边或顶点到自身的边则叫简单图。</p>
</li>
<li><p>图中顶点之间有邻接点、依附的概念。无向图顶点的边数叫做度。有向图顶点分为入度和出度。</p>
</li>
<li><p>图上的边或弧带有权则称为网。</p>
</li>
<li><p>图中顶点间存在路径，两顶点存在路径则说明是连通的，如果路径最终回到起始点则称为环，当中不重复的叫简单路径。若任意两顶点都是连通的，则图就是连通图，有向则称为强连通图。图中有子图，若子图极大连通则就是连通分量，有向的则称为强连通分量。</p>
</li>
<li><p>无向图中连通且n个顶点n-1条边称为生成树。有向图中一顶点入度为0其余顶点入度为1的叫有向树。一个有向图由若干棵有向树构成生成森林。</p>
</li>
</ul>
<h3 id="图的存储结构"><a href="#图的存储结构" class="headerlink" title="图的存储结构"></a>图的存储结构</h3><ul>
<li>邻接矩阵</li>
</ul>
<p>用两个数组来表示图，一个一维数组里储存着顶点的信息，一个二维数组储存着图中的边或弧的信息。</p>
<blockquote>
<p>无向图的邻接矩阵是对称的</p>
</blockquote>
<blockquote>
<p>有向图的邻接矩阵可能是不对称的，顶点的度=顶点的出度+顶点的入度；</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#define MVNum 100	//最大顶点数</span><br><span class="line">typedef char VerTexType;	//设顶点的数据类型为字符型</span><br><span class="line">typedef int ArcType;		//假设边的权值类型为整型</span><br><span class="line">typedef struct&#123;</span><br><span class="line">VerTexType Vexs[MVNum];		//顶点数组</span><br><span class="line">ArcType arcs[MVNum][MVNum]	//邻接矩阵</span><br><span class="line">&#125;AMGraph;	</span><br><span class="line"></span><br><span class="line">//在顶点数组中查找顶点</span><br><span class="line">int LocateVex(AMGraph G,VertexType u)&#123;</span><br><span class="line">//查找顶点u，返回下标</span><br><span class="line">int i;</span><br><span class="line">for (i=0;i&lt;G.vexnum;++i)&#123;</span><br><span class="line">if(U==G.vexs[i])&#123;</span><br><span class="line">return i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">reruen -1;</span><br><span class="line">&#125;</span><br><span class="line">status CreateUDN(AMGraph &amp;G)&#123;</span><br><span class="line">//创建无向网G</span><br><span class="line">cin&gt;&gt;G.vexnum&gt;&gt;G.arcnum;	//输入总顶点数，总边数</span><br><span class="line">for(i=0;i&lt;G.vexnum;++i)</span><br><span class="line">cin&gt;&gt;G.vexs[i];		//依次输入点的信息</span><br><span class="line">for(i=0;i&lt;G.vexnum;++i)	//初始化邻接矩阵</span><br><span class="line">for (j=0;j&lt;G.vexnum;++j)</span><br><span class="line">G.arcs[i][j]=MaxInt;	//边的权值均为最大值</span><br><span class="line">fof(k=0;k&lt;G.arcnum;++k)&#123;	//构造邻接矩阵</span><br><span class="line">cin&gt;&gt;v1&gt;&gt;v2&gt;&gt;w;			//输入一条边所依附的顶点及边的权值</span><br><span class="line">i=LocateVex(G,v1);</span><br><span class="line">j=LocateVex(G,v2);	//确定v1和v2在G中的位置</span><br><span class="line">G.arcs[i][j]=w;		//边&lt;v1,v2&gt;的权值置为w</span><br><span class="line">G.arcs[j][i]=G.arcs[i][j];	//&lt;v1,v2&gt;的对称边&lt;v2,v1&gt;的权值为w</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<ul>
<li>邻接表</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>缺点</th>
<th>改进方法</th>
</tr>
</thead>
<tbody><tr>
<td>有向图</td>
<td>求各结点的度困难</td>
<td>十字链表</td>
</tr>
<tr>
<td>无向图</td>
<td>每条边都要存储两遍</td>
<td>邻接多重表</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">typedef struct VNode&#123;</span><br><span class="line">VerTexType data;	//顶点信息</span><br><span class="line">ArcNode *firstarc;	//指向第一条依附该顶点的边的指针</span><br><span class="line">&#125;VNode，AdjList[MVNum];	//AdjList表示邻接表类型</span><br><span class="line"></span><br><span class="line">status CreateUDG(ALGragh &amp;G)&#123;	//创建无向图G</span><br><span class="line">cin&gt;&gt;G.vexnum&gt;&gt;G.arcnum;	//输入图G的顶点，边个数</span><br><span class="line">for(int i=0;i&lt;G.vexnum;++i)&#123;</span><br><span class="line">cin&gt;&gt;Gvertices[i].data;		//输入顶点值</span><br><span class="line">G.vertices[i].firsarc=NULL;	//初始化表头结点的指针域</span><br><span class="line">&#125;</span><br><span class="line">for(k=0;k&lt;G.arcnum;++k)&#123;	//输入各边</span><br><span class="line">cin&gt;&gt;v1&gt;&gt;v3;</span><br><span class="line">i=LocateVex(G,v1);</span><br><span class="line">j=LocateVex(G,v2);</span><br><span class="line">p1=new ArcNode;		//生成一个新的边结点*p1</span><br><span class="line">p1-&gt;adjvex=j;		//邻接点序号为j</span><br><span class="line">p1-&gt;nextarc=G.vertices[i].firstarc;</span><br><span class="line">G.vertices[i].firstarc=p1;;		//将新结点*p1插入顶点vi的边表头部</span><br><span class="line">p2=new ArcNode;		//生成另一个对称的新的边结点*p2</span><br><span class="line">p2-&gt;adjvex=i;		//邻接点序号为i</span><br><span class="line">p2-&gt;nextarc=G.vertices[j].firstarc;</span><br><span class="line">G.vertices[j].firstarc=p2;	//将新结点*p2插入顶点vj的边表头部</span><br><span class="line">&#125;</span><br><span class="line">return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="遍历方法"><a href="#遍历方法" class="headerlink" title="遍历方法"></a>遍历方法</h2><ul>
<li>深度优先遍历</li>
</ul>
<p>也称深度优先搜索（DFS）</p>
<p>右手原则：在没有碰到重复顶点的情况下，分叉路口始终是向右手边走，每路过一个顶点就做一个记号。</p>
<ul>
<li>广度优先遍历<br>又称广度优先搜索（BFS）</li>
</ul>
<p>普利姆算法<br>克鲁斯卡尔算法</p>

    
  </div>

</article>


   
  <div class="text-center donation">
    <div class="inner-donation">
      <span class="btn-donation">END</span>
      <div class="donation-body">
        <div class="tip text-center">???????</div>
        <ul>
        
          <li class="item">
            
            <img src="/images/2.png" alt="">
          </li>
        
        </ul>
      </div>
    </div>
  </div>


   
  <div class="box-prev-next clearfix">
    <a class="show pull-left" href="/2020/11/11/css/">
        <i class="icon icon-angle-left"></i>
    </a>
    <a class="show pull-right" href="/2020/11/11/windows_tools/">
        <i class="icon icon-angle-right"></i>
    </a>
  </div>




</div>


  <a id="backTop" class="back-top">
    <i class="icon-angle-up"></i>
  </a>




  <div class="modal" id="modal">
  <span id="cover" class="cover hide"></span>
  <div id="modal-dialog" class="modal-dialog hide-dialog">
    <div class="modal-header">
      <span id="close" class="btn-close">关闭</span>
    </div>
    <hr>
    <div class="modal-body">
      <ul class="list-toolbox">
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/archives/"
              rel="noopener noreferrer"
              target="_self"
              >
              Notes
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/categories/"
              rel="noopener noreferrer"
              target="_self"
              >
              分类
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/about/"
              rel="noopener noreferrer"
              target="_self"
              >
              关于
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/search/"
              rel="noopener noreferrer"
              target="_self"
              >
              搜索
            </a>
          </li>
        
      </ul>

    </div>
  </div>
</div>



  
      <div class="fexo-comments comments-post">
    

    

    
    

    

    
    

    

  </div>

  

  <script type="text/javascript">
  function loadScript(url, callback) {
    var script = document.createElement('script')
    script.type = 'text/javascript';

    if (script.readyState) { //IE
      script.onreadystatechange = function() {
        if (script.readyState == 'loaded' ||
          script.readyState == 'complete') {
          script.onreadystatechange = null;
          callback();
        }
      };
    } else { //Others
      script.onload = function() {
        callback();
      };
    }

    script.src = url;
    document.getElementsByTagName('head')[0].appendChild(script);
  }

  window.onload = function() {
    loadScript('/js/bundle.js?235683', function() {
      // load success
    });
  }
</script>

</body>
</html>
