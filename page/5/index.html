<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/1.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/1.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.baidu.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":false,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="KK">
<meta property="og:url" content="http://www.baidu.com/page/5/index.html">
<meta property="og:site_name" content="KK">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="KK">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://www.baidu.com/page/5/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>KK</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">KK</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.baidu.com/2020/12/08/22-23-45/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="KK">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KK">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/08/22-23-45/" class="post-title-link" itemprop="url">Bootloader、Linux内核和文件系统编译</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-08 22:23:45" itemprop="dateCreated datePublished" datetime="2020-12-08T22:23:45+08:00">2020-12-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-28 02:08:57" itemprop="dateModified" datetime="2021-08-28T02:08:57+08:00">2021-08-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/experiments/" itemprop="url" rel="index"><span itemprop="name">experiments</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="交叉编译固件及系统测试"><a href="#交叉编译固件及系统测试" class="headerlink" title="交叉编译固件及系统测试"></a>交叉编译固件及系统测试</h1><h2 id="一、目的"><a href="#一、目的" class="headerlink" title="一、目的"></a>一、目的</h2><p>掌握虚拟机软件的安装和配置，掌握Ubuntu系统的安装和配置，掌握交叉编译器的安装，掌握Bootloader、Linux内核和文件系统编译方法，并进行硬件平台系统功能测试。</p>
<h2 id="二、内容"><a href="#二、内容" class="headerlink" title="二、内容"></a>二、内容</h2><p>1、在Windowns环境下安装虚拟机功能软件，在虚拟机环境下安装Ubuntu系统并对系统进行配置。</p>
<p>2、安装ARM交叉编译器，配置环境变量并功能测试。</p>
<p>3、通过对Bootloader、Linux内核和文件系统源码交叉编译，生成系统固件，记录编译结果。</p>
<p>4、调试串口连接硬件平台，对Bootloader和Linux环境下功能命令测试，记录测试结果。</p>
<h2 id="三、设备"><a href="#三、设备" class="headerlink" title="三、设备"></a>三、设备</h2><p>1、主机电脑。2、ARM实验箱3、调试连接配件</p>
<p><strong>四、实验步骤</strong></p>
<p><strong>4.1</strong> Ubuntu系统的安装和配置</p>
<p>下载Ubuntu系统16.04稳定版系统映像，下载地址：</p>
<p><a target="_blank" rel="noopener" href="http://releases.ubuntu.com/16.04.6/?_ga=2.221103960.1120206391.1590239549-144656828.1590239549"><strong>http://releases.ubuntu.com/16.04.6/?_ga=2.221103960.1120206391.1590239549-144656828.1590239549</strong></a></p>
<p>在虚拟机中安装Ubuntu系统，根据自己电脑的配置情况，选择CPU数量和内存大小，硬盘分区大小等配置，安装结果下图所示。(实验室提供华清远见开发环境参考，无需安装系统)</p>
<p>在虚拟机中配置网络适配器模式，理解NAT模式和桥接模式的区别。</p>
<p>开机进入Ubuntu系统，进行网络配置，掌握图形界面和命令行下配置网络方法，理解ifconfig命令的使用方法，</p>
<p>命令行方式下，vmware虚拟机网络方式为桥接模式，为ubuntu系统配置一个静态的IP地址。假设使用的网络地址为192.168.100.X段，默认为ubuntu系统分配的IP地址是192.168.100.192 。</p>
<p>如果想修改ubuntu系统的IP地址，可以执行以下命令，修改文件内容。</p>
<p>linux@ubuntu64-vm:~$ sudo vim /etc/network/interfaces</p>
<p>修改完成后，重新启动网络配置。</p>
<p>linux@ubuntu64-vm:~$ sudo /etc/init.d/networking restart</p>
<p><strong>4. 3 安装交叉编译器并测试</strong></p>
<p>Ubuntu系统中包含四个版本的交叉编译器，位于路径/usr/local/toolchain目录下，不用解压直接使用即可。</p>
<p>修改bash启动文件，执行以下命令：</p>
<p>linux@ubuntu64-vm:~$ sudo vim /etc/bash.bashrc</p>
<p>在bash.bashrc文件最后添加以下内容并保存退出：</p>
<p>export PATH=$PATH:/usr/local/toolchain/toolchain-4.5.1/bin/</p>
<p>再退出bash终端重新打开，执行ARM交叉编译器命令，获取如下信息说明交叉编译器配置完成。</p>
<p>linux@ubuntu64-vm:~$ arm-none-linux-gnueabi-gcc -v</p>
<p><strong>4.4 Linux内核编译</strong></p>
<ol>
<li>首先在虚拟机工作目录下用个人学号建立自己的工作目录。</li>
</ol>
<p>linux@ubuntu64-vm:~$ mkdir /home/linux/2018011222/ -p</p>
<ol>
<li><p>通过U盘或者共享目录将Linux内核源码压缩包拷贝到该目录里面。</p>
</li>
<li><p>拷贝后进入该目录，解压源码。</p>
</li>
</ol>
<p>linux@ubuntu64-vm:~/2018011222$ tar xvf linux-3.4.39.tar.xz</p>
<ol>
<li><p>拷贝ext4文件系统制作工具到/usr/bin目录下。</p>
</li>
<li><p>进入内核源码目录，查看源码结构。</p>
</li>
<li><p>拷贝硬件平台的标准配置文件为.config文件。</p>
</li>
</ol>
<p>$ cp arch/arm/configs/fs6818M4_defconfig_v5 .config</p>
<ol>
<li>执行内核配置命令进入内核配置界面。</li>
</ol>
<p>$ make menuconfig</p>
<p>查看System type和Deviec Driver配置情况，</p>
<ol>
<li>保存退出后，编译内核，编译结果如下图。(比较耗时间，15分钟左右，可以先做4.5小节内容)</li>
</ol>
<p>$ make uImage</p>
<ol>
<li>执行脚本打包内核镜像，内核镜像文件为boot.img，文件格式是ext4格式，其中包括开机LOGO，ramdisk文件系统和uImage内核镜像，生成boot.img文件，</li>
</ol>
<p>$./mkboot.sh</p>
<p><strong>4.5 Linux文件系统镜像制作</strong></p>
<p>1、通过U盘或者共享目录将文件系统源码压缩包拷贝到/source目录下。</p>
<p>解压文件系统源码压缩包，查看文件系统内容。</p>
<p>$tar xvf rootfs.tar.xz</p>
<p>3、将文件系统打包成ext4格式的镜像，生成system_linux.img文件</p>
<p>$make_ext4fs -s system_linux.img -l 300M rootfs</p>
<p><strong>4.6 Bootloader</strong>** 环境测试**</p>
<ol>
<li>连接实验箱5V电源线，连接终</li>
</ol>
<p>端调试串口线和以太网线到电脑主</p>
<p>机，如右图。</p>
<p>(USB OTA调试线烧写镜像用，</p>
<p>可以不连)</p>
<ol>
<li>安装USB转串口驱动程序，确</li>
</ol>
<p>认当前电脑上使用的串口号，设置</p>
<p>电脑上串口调试软件putty。</p>
<ol>
<li>上电启动实验箱，在终端中可以看到启动信息，快速按空格键进入bootloader环境。</li>
<li>通过print、setenv、saveenv等命令测试bootloader，</li>
</ol>
<p><strong>4.7</strong>  <strong>嵌入式</strong>** Linux **<strong>环境测试</strong></p>
<p>按复位键重启硬件系统，等待平台系统进入Linux环境，测试三条Linux命令，</p>
<h1 id="应用程序开发"><a href="#应用程序开发" class="headerlink" title="应用程序开发"></a>应用程序开发</h1><h2 id="一、目的-1"><a href="#一、目的-1" class="headerlink" title="一、目的"></a>一、目的</h2><p>掌握NFS挂载Linux启动方法，掌握Ubuntu 环境下交叉编译应用程序的方法。</p>
<h2 id="二、内容-1"><a href="#二、内容-1" class="headerlink" title="二、内容"></a>二、内容</h2><p>1、使用Vim或者Gedit 文本编译器编写C 语言、汇编语言程序和Makefile文件，分别计算公式3*x2+2*x3 的值和计算4个输入数的平均数。</p>
<p>2、编写Makefile文件，通过make编译得到ARM 可执行程序formula 和average。</p>
<p>3、配置实验箱启动方式为NFS启动，执行并测试程序。</p>
<h2 id="三、设备-1"><a href="#三、设备-1" class="headerlink" title="三、设备"></a>三、设备</h2><p>1、主机电脑。2、ARM实验箱3、调试连接配件</p>
<h2 id="四、原理"><a href="#四、原理" class="headerlink" title="四、原理"></a>四、原理</h2><p>掌握嵌入式Linux 应用开发所用到的一些常用工具，包括编辑工具vim、gedit、编译工具gcc、MakeFile 文件及调试工具gdb。</p>
<p>正确掌握C 语言、汇编语言程序和Makefile编写语法和格式。</p>
<h2 id="五、步骤"><a href="#五、步骤" class="headerlink" title="五、步骤"></a>五、步骤</h2><h3 id="5-1-计算公式3-x-2-2-x3"><a href="#5-1-计算公式3-x-2-2-x3" class="headerlink" title="5.1 计算公式3*x^2+2*x3"></a>5.1 计算公式3*x^2+2*x3</h3><p>1、在Linux 主机上进入自己学号的工作目录，执行如下命令。</p>
<p>$cd /home/linux/2018011222/</p>
<p>$mkdir exam1</p>
<p>$cd exam1</p>
<p>$ gedit formula.c</p>
<ol>
<li>在formula.c 程序里面输入以下内容。</li>
</ol>
<p>#include&amp;lt;stdio.h&amp;gt;</p>
<p>extern int compute(int data);</p>
<p>int main()</p>
<p>{</p>
<p>int x;</p>
<p>printf(&quot;Input x=&quot;);</p>
<p>scanf(&quot;%d&quot;,&amp;x);</p>
<p>printf(&quot;The result is %d\n&quot;,compute(x));</p>
<p>return 0;</p>
<p>}</p>
<p>3、执行命令生成汇编文件</p>
<p>$ gedit compute.S</p>
<p>包含计算3*x^2+2*x^3过程的汇编文件为compute.S内容如下:.text</p>
<p>.align</p>
<p>.global compute</p>
<p>compute:</p>
<p>stmfd sp!,{r4-r11,r14}</p>
<p>mul r1,r0,r0</p>
<p>mov r3,#2</p>
<p>mul r2,r1,r3</p>
<p>mov r3,#3</p>
<p>mul r4,r1,r3</p>
<p>mla r0,r2,r0,r4</p>
<p>ldmfd sp!,{r4-r11,r15}</p>
<p>4、自行编写Makefile 文件，实现对c语言程序和汇编程序的编译得到formula可执行程序。</p>
<p>5、在exam1目录下执行make命令得到可执行文件formula</p>
<p>$make</p>
<p>6、应用strip工具精简可执行程序</p>
<p>$arm-none-linux-gnueabi-strip formula</p>
<p>7、file命令可以查看formula程序属性，截图保存formula程序信息到实验报告中。</p>
<p>$file formula</p>
<h3 id="5-2-计算4-个数的平均值"><a href="#5-2-计算4-个数的平均值" class="headerlink" title="5.2 计算4 个数的平均值"></a>5.2 计算4 个数的平均值</h3><p>1、在Linux 主机上建立工作目录，执行如下命令。</p>
<p>$cd /home/linux/2018011222/</p>
<p>$mkdir exam2</p>
<p>$cd exam2</p>
<p>$gedit avg.c</p>
<ol>
<li>在avg.c程序里面输入以下内容。</li>
</ol>
<p>#include&amp;lt;stdio.h&amp;gt;</p>
<p>extern int average(int i, int j,int k,int l);</p>
<p>int main(void)</p>
<p>{</p>
<p>int a,b,c,d,avr;</p>
<p>printf(&quot;Input 4 number: \n&quot;);</p>
<p>scanf(&quot;%d&quot;,&amp;a);</p>
<p>scanf(&quot;%d&quot;,&amp;b);</p>
<p>scanf(&quot;%d&quot;,&amp;c);</p>
<p>scanf(&quot;%d&quot;,&amp;d);</p>
<p>printf(&quot;a=%d,b=%d,c=%d,d=%d\n&quot;,a,b,c,d);</p>
<p>avr= average(a,b,c,d);</p>
<p>printf(&quot;(%d+,%d+,%d+,%d)/4=,%d\n&quot;,a,b,c,d,avr);</p>
<p>return 0;</p>
<p>}</p>
<p>3、执行命令生成汇编文件</p>
<p>$gedit average.S</p>
<p>自行编写计算平均值的汇编文件average.S程序。</p>
<p>4、自行编写Makefile 文件，实现对c语言程序和汇编程序的编译得到formula可执行程序。</p>
<p>5、在exam2目录下执行make命令得到可执行文件average</p>
<p>$make</p>
<p>6、应用strip工具精简可执行程序</p>
<p>$ arm-none-linux-gnueabi-strip average</p>
<p>7、file命令可以查看average程序属性，</p>
<p>$file average</p>
<h3 id="5-3配置NFS启动方式"><a href="#5-3配置NFS启动方式" class="headerlink" title="5.3配置NFS启动方式"></a>5.3配置NFS启动方式</h3><p>1、设置好电脑主机的IP地址为192.168.100.192 ，配置好主机的NFS服务，默认是启动的。</p>
<p>2、在Bootloader环境下配置启动参数， <strong>注意格式不要出错！！！</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">FS6818# setenv serverip 192.168.100.192</span><br><span class="line"></span><br><span class="line">FS6818#setenv ipaddr 192.168.100.100</span><br><span class="line"></span><br><span class="line">FS6818# setenv gatewayip 192.168.100.1</span><br><span class="line"></span><br><span class="line">FS6818# setenv bootcmd ext4load mmc 2:1 0x48000000 uImage\;bootm 0x48000000</span><br><span class="line"></span><br><span class="line">FS6818# setenv bootargs root=/dev/nfs nfsroot=192.168.100.192:/source/rootfs console=ttySAC0,115200 init=/linuxrc ip=192.168.100.100:::::eth0:off</span><br><span class="line"></span><br><span class="line">FS6818# saveenv</span><br></pre></td></tr></table></figure>

<p>保存后复位ARM实验箱，等待进入NFS启动的文件系统，如下图。</p>
<p><img src="RackMultipart20210826-4-1d1i54l_html_ea6ac7d22326c54c.png"></p>
<p>拷贝之前编译好的可执行文件formula和average到主机NFS共享目录下wsn6818bp_test，这样在putty终端中就可以运行测试结果，</p>
<p><img src="RackMultipart20210826-4-1d1i54l_html_458a03b2d32152d4.png"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.baidu.com/2020/12/01/20-00-00/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="KK">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KK">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/01/20-00-00/" class="post-title-link" itemprop="url">Vim常用操作</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-01 20:00:00" itemprop="dateCreated datePublished" datetime="2020-12-01T20:00:00+08:00">2020-12-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-28 13:35:07" itemprop="dateModified" datetime="2021-06-28T13:35:07+08:00">2021-06-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Vim常用操作"><a href="#Vim常用操作" class="headerlink" title="Vim常用操作"></a>Vim常用操作</h1><h2 id="常用功能键"><a href="#常用功能键" class="headerlink" title="常用功能键"></a>常用功能键</h2><ol>
<li>插入模式</li>
</ol>
<p>i ：在光标前插内内容:按8，再按i，进入插入模式，输入=， 按esc进入命令模式，就会出现8个=。</p>
<p>a ：在光标后插入内容<br>A: 在当前行最后插入；</p>
<p>o ：在所在行的下一行插入新行<br>O ：在所在行的上一行插入新行</p>
<ol start="2">
<li>删除文本</li>
</ol>
<p>x：删除光标后面的字符<br>X：删除光标前面的字符</p>
<p>nx：删除光标后面n个字符<br>nX：删除光标前面的n个字符</p>
<p>d0：删除光标至行首的内容<br>d$：删除光标至行尾的内容</p>
<p>dd ：删除整行<br>ndd ：向下删除n行</p>
<ol start="3">
<li>移动光标</li>
</ol>
<p>vi可以直接用键盘上的光标来上下左右移动，但正规的vi是用小写英文字母「h」、「j」、「k」、「l」，分别控制光标左、下、上、右移一格。</p>
<p>按「ctrl」+「b」：屏幕往“后”移动一页。</p>
<p>按「ctrl」+「f」：屏幕往“前”移动一页。</p>
<p>按「ctrl」+「u」：屏幕往“后”移动半页。</p>
<p>按「ctrl」+「d」：屏幕往“前”移动半页。</p>
<p>按数字「gg」:移动到文章开头<br>按「G」：移动到文章的最后。</p>
<p>按「$」：移动到光标所在行的“行尾”。</p>
<p>按「0」：移动到光标所在行的“行首”</p>
<p>按「w」：光标跳到下个字的开头</p>
<p>按「e」：光标跳到下个字的字尾</p>
<p>按「b」：光标回到上个字的开头</p>
<p>按「nl」：光标移到该行的第n个位置，如：5l,56l。</p>
<ol start="4">
<li>查找文本</li>
</ol>
<p>/pattern ：向下查找</p>
<p>?pattern ：向上查找</p>
<p>n ：顺序查找</p>
<p>N ：反向查找</p>
<p>:s/p1/p2/g ：在当前行，将p1替换成p2</p>
<p>:n1,n2s/p1/p2/g ：将n1至n2行之间的p1替换成p2<br>5. 复制<br>「yw」：将光标所在之处到字尾的字符复制到缓冲区中。<br>「nyw」：复制n个字到缓冲区<br>yy ：复制整行</p>
<p>nyy ：复制n行</p>
<p>p ：在所在行下一行粘贴</p>
<p>P ：在所在行上一行粘贴</p>
<p>在Vim中你可以把两行合并为一行，也就是说两行之间的换行符被删除了：命令是”J”。<br>dd ：剪切</p>
<p>复制vim里面的内容至系统粘贴板：”+y</p>
<p>粘贴系统粘贴板里面的内容至vim：”+p</p>
<p>:n1,n2 co n3  ：将n1至n2行复制到n3行的下面</p>
<p>:n1,n2 m n3 ：将n1至n2行剪切至n3行的下面</p>
<p>:n1,n2 d ：将n1至n2行删除<br>6. 替换<br>「r」：替换光标所在处的字符。<br>「R」：替换光标所到之处的字符，直到按下「ESC」键为止。</p>
<ol start="7">
<li><p>回复上一次操作<br>「u」：如果您误执行一个命令，可以马上按下「u」，回到上一个操作。按多次“u”可以执行多次回复。<br>CTRL-R(重做)来反转撤消的动作</p>
</li>
<li><p>更改<br>「cw」：更改光标所在处的字到字尾处<br>「c#w」：例如，「c3w」表示更改3个字</p>
</li>
<li><p>跳至指定的行<br>「ctrl」+「g」列出光标所在行的行号。<br>「#G」：例如，「15G」，表示移动光标至文章的第15行行首。</p>
</li>
</ol>
<p> 跳到文件中的某一行<br>「#」：「#」号表示一个数字，在冒号后输入一个数字，再按回车键就会跳到该行了<br>10. 宏<br>. –重复上一个编辑动作<br>qa：开始录制宏a（键盘操作记录）<br>q：停止录制<br>@a：播放宏a</p>
<ol start="11">
<li>vi命令列表<br>ctrl+v进入可视块模式，之后使用 j/k/h/l键可以选中一块<br>ggVG 选中全部的文本， 其中gg为跳到行首，V选中整行，G末尾<br>:pwd 显示vim的工作目录<br>:Sex – 水平分割一个窗口，浏览文件系统；<br>:Vex – 垂直分割一个窗口，浏览文件系统<br>:ce(nter) 本行文字居中<br>:le(ft) 本行文字靠左<br>:ri(ght) 本行文字靠右<h2 id="命令："><a href="#命令：" class="headerlink" title="命令："></a>命令：</h2></li>
</ol>
<p>设置backspace的工作方式<br>:set backspace=indent,eol,start<br>:set spell－开启拼写检查功能<br>:set nospell－关闭拼写检查功能<br>「set nu」后，会在文件中的每一行前面列出行号。<br>高亮显示搜索结果用”:set hlsearch”<br>:set ruler  会在屏幕右下角显示当前光标所处位置</p>
<h2 id="Gvim配置："><a href="#Gvim配置：" class="headerlink" title="Gvim配置："></a>Gvim配置：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">（“为注释）</span><br><span class="line">&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;</span><br><span class="line">&quot; 代码补全</span><br><span class="line">&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;</span><br><span class="line">set wildmenu        &quot;vim自身命令行模式智能补全</span><br><span class="line">set completeopt-=preview    &quot;补全时不显示窗口，只显示补全列表</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;</span><br><span class="line">&quot;代码折叠</span><br><span class="line">&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;</span><br><span class="line">set foldmethod=syntax       &quot;设置基于语法进行代码折叠</span><br><span class="line">set nofoldenable            &quot;关闭代码折叠</span><br><span class="line">&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;</span><br><span class="line">&quot; 缓存设置</span><br><span class="line">&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;</span><br><span class="line">set nobackup        &quot;设置不备份</span><br><span class="line">set noswapfile      &quot;禁止生成临时文件</span><br><span class="line">set noundofile		&quot; 操作记录</span><br><span class="line">set autoread        &quot;文件在vim之外修改过，自动重新载入</span><br><span class="line">set autowrite       &quot;设置自动保存</span><br><span class="line">set confirm         &quot;在处理未保存或只读文件时，弹出确认</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;</span><br><span class="line">&quot; 编码设置</span><br><span class="line">&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;</span><br><span class="line">&quot; Lang &amp; Encoding &#123;&#123;&#123;</span><br><span class="line">set fileencodings=utf-8,gbk2312,gbk,gb18030,cp936</span><br><span class="line">set encoding=utf-8</span><br><span class="line">set langmenu=zh_CN</span><br><span class="line">let $LANG = &#x27;en_US.UTF-8&#x27;</span><br><span class="line">&quot;language messages zh_CN.UTF-8</span><br><span class="line">&quot; &#125;&#125;&#125;</span><br><span class="line">&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;</span><br><span class="line">&quot; 隐藏GVIM菜单及设置</span><br><span class="line">&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;</span><br><span class="line">source $VIMRUNTIME/delmenu.vim</span><br><span class="line">source $VIMRUNTIME/menu.vim</span><br><span class="line">&quot; 窗口大小</span><br><span class="line">set lines=35 columns=140</span><br><span class="line">&quot; 分割出来的窗口位于当前窗口下边/右边</span><br><span class="line">set splitbelow</span><br><span class="line">set splitright</span><br><span class="line">&quot;不显示工具/菜单栏</span><br><span class="line">set guioptions-=T</span><br><span class="line">set guioptions-=m</span><br><span class="line">set guioptions-=L</span><br><span class="line">set guioptions-=r</span><br><span class="line">set guioptions-=b</span><br><span class="line">&quot; 使用内置 tab 样式而不是 gui</span><br><span class="line">set guioptions-=e</span><br><span class="line">set nolist</span><br><span class="line"></span><br><span class="line">set nu</span><br><span class="line">set guifont=Consolas:h11:cANSI:qDRAFT</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.baidu.com/2020/11/28/19-22-34/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="KK">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KK">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/28/19-22-34/" class="post-title-link" itemprop="url">调用百度语音识别api</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-11-28 19:22:34" itemprop="dateCreated datePublished" datetime="2020-11-28T19:22:34+08:00">2020-11-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-28 13:35:07" itemprop="dateModified" datetime="2021-06-28T13:35:07+08:00">2021-06-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">嵌入式</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="注册账号申请api-key"><a href="#注册账号申请api-key" class="headerlink" title="注册账号申请api key"></a>注册账号申请api key</h3><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><ul>
<li>源码：语音识别、语音合成</li>
</ul>
<p><code>git clone https://github.com/Baidu-AIP/speech-demo</code></p>
<ul>
<li>依赖(curl.h)：</li>
</ul>
<p><code>apt install libcurl4-openssl-dev</code></p>
<h3 id="编辑源文件"><a href="#编辑源文件" class="headerlink" title="编辑源文件"></a>编辑源文件</h3><p>编辑<code>asrmain.c</code> <code>ttsmain.c</code>填入自己的keys，修改相应参数</p>
<p>编译<code>sh build_xxxxxxx</code></p>
<h2 id="语音唤醒"><a href="#语音唤醒" class="headerlink" title="语音唤醒"></a>语音唤醒</h2><h3 id="snowboy下载"><a href="#snowboy下载" class="headerlink" title="snowboy下载"></a>snowboy下载</h3><p><code>git clone https://github.com/Kitt-AI/snowboy.git</code></p>
<h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><p><code>sudo apt-get -y install libasound2-dev</code><br><code>sudo apt-get install python3-pyaudio</code><br><code>sudo apt-get install swig3.0 sox</code><br><code>sudo apt-get install libatlas-base-dev</code>  </p>
<p>通过ffplay工具(安装ffmpeg会带上这个工具)。</p>
<p><code>ffplay -ar 44100 -channels 2 -f s16le -i 123.pcm</code></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.baidu.com/2020/11/22/22-33-33/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="KK">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KK">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/22/22-33-33/" class="post-title-link" itemprop="url">C语言常见例题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-11-22 22:33:33" itemprop="dateCreated datePublished" datetime="2020-11-22T22:33:33+08:00">2020-11-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-28 13:35:07" itemprop="dateModified" datetime="2021-06-28T13:35:07+08:00">2021-06-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/study/" itemprop="url" rel="index"><span itemprop="name">study</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><hr>
<ul>
<li>求闰年</li>
</ul>
<p>能被4整除且不能被100整除,或能够被400整除的年份就是闰年</p>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.baidu.com/2020/11/22/22-11-33/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="KK">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KK">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/22/22-11-33/" class="post-title-link" itemprop="url">Alsa库移植和安装</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-11-22 22:11:33" itemprop="dateCreated datePublished" datetime="2020-11-22T22:11:33+08:00">2020-11-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-28 13:35:07" itemprop="dateModified" datetime="2021-06-28T13:35:07+08:00">2021-06-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">嵌入式</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="alsa库下载"><a href="#alsa库下载" class="headerlink" title="alsa库下载"></a>alsa库下载</h3><p><code>ftp://ftp.alsa-project.org/pub</code></p>
<h3 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h3><p>解压进入文件夹<br><code>./configure  --prefix=/home/mine/alsa    //生成文件存放的位置</code><br>开始安装驱动<br><code>make &amp;&amp; sudo make install </code></p>
<h3 id="交叉编译"><a href="#交叉编译" class="headerlink" title="交叉编译"></a>交叉编译</h3><p>使用命令</p>
<p><code>./configure --host=arm-jyxtec-linux-gnueabi --prefix=/usr/share/arm-alsa</code></p>
<blockquote>
<p>–host参数指定了交叉编译器为“arm-jyxtec-linux-gnueabi（根据自己板子上的工具链稳准）”，因此必须确保交叉编译器已成功配置（也就是已经导出为全局环境变量，切记！切记！我就在这浪费了很多时间，我的习惯是添加据对路径），且可以在shell里直接调用；–prefix参数指定了alsa-lib的目标安装目录，之后的alsa-util配置也一样</p>
</blockquote>
<p>使用命令</p>
<p><code>./configure --host=arm-jyxtec-linux-gnueabi --prefix=/usr/share/arm-alsa --with-alsa-inc-prefix=/usr/share/arm-alsa/include --with-alsa-prefix=/usr/share/arm-alsa/lib --disable-alsamixer --disable-xmlto</code></p>
<blockquote>
<p>–with-alsa-inc-prefix和–with-alsa-prefix分别指定了交叉编译util应用所需要的alsa-lib的头文件和库文件；–disable-alsamixer表示不编译生成alsamixer这个应用程序，因为该程序依赖于ncurses这个图形界面库，目前我们对于该库还不能交叉编译，故放弃</p>
</blockquote>
<h3 id="可能出现的错误"><a href="#可能出现的错误" class="headerlink" title="可能出现的错误"></a>可能出现的错误</h3><hr>
<p><code> error: this packages requires a curses library</code>  </p>
<p><strong>解决办法：</strong>  </p>
<p><code>apt-get install libncurses5-dev</code></p>
<hr>
<p><code> error: panelw library not found</code>  </p>
<p><strong>解决办法：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo ln -s libpanelw.so.5 /usr/lib/libpanelw.so</span><br><span class="line">sudo ln -s libformw.so.5 /usr/lib/libformw.so</span><br><span class="line">sudo ln -s libmenuw.so.5 /usr/lib/libmenuw.so</span><br><span class="line">sudo ln -s libncursesw.so.5 /lib/libncursesw.so</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>解决办法：</strong></p>
<p>根据自己的错误提示来输入命令  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">如果提示是t-ru.gmo的话，就用命令：touch alsaconf/po/t-ru.gmo</span><br><span class="line">如果提示是t-ja.gmo的话，就用命令：touch alsaconf/po/t-ja.gmo</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.baidu.com/2020/11/22/20-22-22/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="KK">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KK">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/22/20-22-22/" class="post-title-link" itemprop="url">安装archlinux系统</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-11-22 20:22:22" itemprop="dateCreated datePublished" datetime="2020-11-22T20:22:22+08:00">2020-11-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-28 13:35:07" itemprop="dateModified" datetime="2021-06-28T13:35:07+08:00">2021-06-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="archlinux-安装过程"><a href="#archlinux-安装过程" class="headerlink" title="archlinux 安装过程"></a>archlinux 安装过程</h1><h2 id="连接wifi"><a href="#连接wifi" class="headerlink" title="连接wifi"></a>连接wifi</h2><p><code>ip link //查看wifi设备</code></p>
<p><code>ip link set 设备 up //启用设备</code></p>
<p><code>iwlist 设备 scan | grep ESSID //扫描查看wifi名称</code></p>
<p>或者使用</p>
<p><code>iw dev scan ....</code></p>
<p><code>wifi-menu</code></p>
<h3 id="连接wpa加密wifi"><a href="#连接wpa加密wifi" class="headerlink" title="连接wpa加密wifi"></a>连接wpa加密wifi</h3><p><code>wpa_passphrase wifi名称 密码 &gt; internet.conf</code></p>
<p><code>wpa_supplicant -i 网卡 -c internet.conf &amp;</code></p>
<p><code>dhcpcd 网卡 &amp;</code></p>
<h2 id="检查是否联通"><a href="#检查是否联通" class="headerlink" title="检查是否联通"></a>检查是否联通</h2><p>(ctrl+c停止)</p>
<p><code>ping www.baidu.com</code></p>
<h2 id="更新系统时钟"><a href="#更新系统时钟" class="headerlink" title="更新系统时钟"></a>更新系统时钟</h2><p><code>timedatectl set-ntp true</code></p>
<h2 id="查看当前的可用磁盘"><a href="#查看当前的可用磁盘" class="headerlink" title="查看当前的可用磁盘"></a>查看当前的可用磁盘</h2><p><code>fdisk -l</code></p>
<h2 id="创建新分区"><a href="#创建新分区" class="headerlink" title="创建新分区"></a>创建新分区</h2><p><code>fdisk /dev/sda    //注意磁盘名称</code></p>
<p>–&gt;n –&gt;回车 –&gt;回车 –&gt;回车 –&gt;+500m  （boot分区）</p>
<p>–&gt;n –&gt;回车 –&gt;回车 –&gt;回车 –&gt;+6G      （根分区）</p>
<p>–&gt;n –&gt;回车 –&gt;回车 –&gt;回车 –&gt;回车  （将剩余空间全部分配给该分区）</p>
<p>–&gt;w    （写入）</p>
<h2 id="根目录格式化为ext4"><a href="#根目录格式化为ext4" class="headerlink" title="根目录格式化为ext4"></a>根目录格式化为ext4</h2><p>请注意自己的对应的目录是那块区域</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkfs.fat -F32 /dev/sda1     /// boot分区</span><br><span class="line">mkswap /dev/sda2   //swap 分区</span><br><span class="line">mkfs.ext4 /dev/sda3</span><br></pre></td></tr></table></figure>
<h2 id="打开swap分区"><a href="#打开swap分区" class="headerlink" title="打开swap分区#"></a>打开swap分区#</h2><p>请注意自己的 swap分区是哪块</p>
<p><code>swapon /dev/sda2</code></p>
<h2 id="更改pacman配置文件"><a href="#更改pacman配置文件" class="headerlink" title="更改pacman配置文件"></a>更改pacman配置文件</h2><p><code>vim /etc/pacman.conf</code></p>
<p>去掉Color的注释,用于安装时提示信息</p>
<h2 id="挂载分区"><a href="#挂载分区" class="headerlink" title="挂载分区#"></a>挂载分区#</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mount  /dev/sda3 /mnt     //主分区内</span><br><span class="line">ls /mnt  /////查看是否挂载成功，若出现lost+found 则代表挂载成功</span><br><span class="line">mkdir /mnt/boot</span><br><span class="line">mount /dev/sda1 /mnt/boot      /// boot分区</span><br></pre></td></tr></table></figure>
<h2 id="配置源"><a href="#配置源" class="headerlink" title="配置源#"></a>配置源#</h2><p>将国内源放到第一位 </p>
<p><code>vim /etc/pacman.d/mirrorlist</code></p>
<h2 id="刷新源"><a href="#刷新源" class="headerlink" title="刷新源#"></a>刷新源#</h2><p><code> pacman -Syy</code></p>
<h2 id="安装基本包"><a href="#安装基本包" class="headerlink" title="安装基本包"></a>安装基本包</h2><p><code>pacstrap /mnt linux linux-firmware base base-devel</code></p>
<h2 id="生成fstab文件"><a href="#生成fstab文件" class="headerlink" title="生成fstab文件"></a>生成fstab文件</h2><p><code>genfstab -U /mnt &gt;&gt; /mnt/etc/fstab</code></p>
<h2 id="切换环境"><a href="#切换环境" class="headerlink" title="切换环境"></a>切换环境</h2><p><code>arch-chroot /mnt</code></p>
<h2 id="配置时区"><a href="#配置时区" class="headerlink" title="配置时区"></a>配置时区</h2><p><code>ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</code></p>
<h2 id="硬件时间"><a href="#硬件时间" class="headerlink" title="硬件时间"></a>硬件时间</h2><p><code>hwclock --systohc</code></p>
<h2 id="安装vim"><a href="#安装vim" class="headerlink" title="安装vim"></a>安装vim</h2><p><code>pacman -S vim</code></p>
<h2 id="退出"><a href="#退出" class="headerlink" title="退出"></a>退出</h2><p><code>exit</code></p>
<h2 id="设置语言"><a href="#设置语言" class="headerlink" title="设置语言"></a>设置语言</h2><p>//将/etc/locale.gen中en_US.UTF-8的注释去掉,避免中文乱码,推荐先使用英文//</p>
<p><code>vim /mnt/etc/locale.gen</code></p>
<h3 id="切换环境-1"><a href="#切换环境-1" class="headerlink" title="切换环境"></a>切换环境</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arch-chroot /mnt</span><br><span class="line">locale-gen</span><br><span class="line">exit</span><br></pre></td></tr></table></figure>
<h2 id="配置-etc-locale-conf文件"><a href="#配置-etc-locale-conf文件" class="headerlink" title="配置 /etc/locale.conf文件"></a>配置 /etc/locale.conf文件</h2><p><code>vim /mnt/etc/locale.conf</code></p>
<p>写入</p>
<p><code>LANG=en_US.UTF-8</code></p>
<h3 id="切换环境-2"><a href="#切换环境-2" class="headerlink" title="切换环境"></a>切换环境</h3><p><code>arch-chroot /mnt</code></p>
<h3 id="重置root密码"><a href="#重置root密码" class="headerlink" title="重置root密码"></a>重置root密码</h3><p><code>passwd</code></p>
<h2 id="安装网络相关的包"><a href="#安装网络相关的包" class="headerlink" title="安装网络相关的包#"></a>安装网络相关的包#</h2><p><code> pacman -S iw wpa_supplicant dialog net-tools networkmanager dhcpcd netctl</code></p>
<h2 id="安装编码"><a href="#安装编码" class="headerlink" title="安装编码"></a>安装编码</h2><p><code>pacman -S intel-ucode（amd-ucode） os-prober(寻找其他系统的工具） efibootmgr（efi启动）</code></p>
<h2 id="安装引导"><a href="#安装引导" class="headerlink" title="安装引导"></a>安装引导</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pacman -S grub</span><br><span class="line">mkdir /boot/grub</span><br><span class="line">grub-mkconfig -o /boot/grub/grub.cfg</span><br><span class="line">grub-install --target=i386-pc /dev/sda (整个磁盘） //// efi:grub-install --target=x86_64-efi --efi-directory=/boot</span><br></pre></td></tr></table></figure>
<h3 id="退出当前环境"><a href="#退出当前环境" class="headerlink" title="退出当前环境#"></a>退出当前环境#</h3><p><code> exit</code></p>
<h2 id="关闭网络"><a href="#关闭网络" class="headerlink" title="关闭网络"></a>关闭网络</h2><p><code>killall wpa_supplicant dhcpcd</code></p>
<h2 id="重启"><a href="#重启" class="headerlink" title="重启"></a>重启</h2><p><code>reboot</code></p>
<h2 id="拔u盘"><a href="#拔u盘" class="headerlink" title="拔u盘"></a>拔u盘</h2><h2 id="安装软件"><a href="#安装软件" class="headerlink" title="安装软件"></a>安装软件</h2><ul>
<li>图形界面：<code>xorg</code> <code>xorg-server</code> <code>xorg-xinit</code></li>
<li>男人：<code>man</code> </li>
</ul>
<ul>
<li>文件管理器：<code>ranger</code></li>
<li>电脑参数：<code>neofetch</code><h3 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h3>xrandr<br>xrandr –output screen –mode 1280x800<br>feh –randomize –bg-fill /地址<br>picom</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.baidu.com/2020/11/21/11-22-12/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="KK">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KK">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/21/11-22-12/" class="post-title-link" itemprop="url">C++</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-11-21 11:22:12" itemprop="dateCreated datePublished" datetime="2020-11-21T11:22:12+08:00">2020-11-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-28 13:35:07" itemprop="dateModified" datetime="2021-06-28T13:35:07+08:00">2021-06-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/study/" itemprop="url" rel="index"><span itemprop="name">study</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Helloword"><a href="#Helloword" class="headerlink" title="Helloword"></a>Helloword</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;	//名字空间</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;&quot;helo word&quot;&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;&quot;helo word\n&quot;;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h3><p>cin、cout是istream类的对象</p>
<h3 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h3><h3 id="复杂的数据类型"><a href="#复杂的数据类型" class="headerlink" title="复杂的数据类型"></a>复杂的数据类型</h3><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Test</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>定义构造器<br>构造器的名字必须与它所在的类的名字一样<br>构造器没有返回值  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class Car&#123;</span><br><span class="line">public:</span><br><span class="line">	Car(void);	//名称与类名一致</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Car::Car(void)</span><br><span class="line">&#123;</span><br><span class="line">xxx</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">调用：</span><br><span class="line"></span><br><span class="line">class Car&#123;</span><br><span class="line">public:</span><br><span class="line">	Car(void);	//名称与类名一致</span><br><span class="line">	void runing();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Car::Car(void)</span><br><span class="line">&#123;</span><br><span class="line">xxx</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void runing()&#123;</span><br><span class="line">xxx</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main ()&#123;</span><br><span class="line">Car mycar;</span><br><span class="line">mycar.runing();</span><br><span class="line">return 0;</span><br></pre></td></tr></table></figure>

<p>数组：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Car mycar[10];</span><br><span class="line">调用：</span><br><span class="line">mycar[x].runing;	//x为给定数组元素的下标</span><br></pre></td></tr></table></figure>


<p>副本构造器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyClass（const MyClass &amp;rhs);</span><br></pre></td></tr></table></figure>

<p>析构器：与构造器一样，只是前边多了一个波浪符<code>~</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Car</span><br><span class="line">&#123;</span><br><span class="line">Car(void);</span><br><span class="line">~Car();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Car::Car()</span><br><span class="line">&#123;</span><br><span class="line">xxx</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Car::~Car()&#123;</span><br><span class="line">xxx</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>this指针:让构造器知道哪个是参数哪个是属性</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">如果代码中不存在二义性，则不必使用this指针</span><br><span class="line">this-&gt;fish=fish;</span><br></pre></td></tr></table></figure>

<h3 id="继承："><a href="#继承：" class="headerlink" title="继承："></a>继承：</h3><p>基类即父类<br>子类即从基类派生出来的类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class SubCar(子类):public Car(基类) &#123;...&#125;;</span><br><span class="line">子类也可以调用基类的成员</span><br></pre></td></tr></table></figure>
<ul>
<li>继承里的含参数构造器</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Animal</span><br><span class="line">&#123;</span><br><span class="line">Animal(std::string Name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Pig:public Animal</span><br><span class="line">&#123;</span><br><span class="line">Pig(std::string Name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//构造器</span><br><span class="line">Animal::Animal(std::string Name)</span><br><span class="line">&#123;</span><br><span class="line">name=Name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Pig::Pig(std::string Name) : Animal(Name)</span><br><span class="line">&#123;</span><br><span class="line">xxx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h3><p>保护类里的方法和属性的手段</p>
<blockquote>
<p>public：任何代码<br>protected：这个类本身和它的子类<br>private：只有这个类本身</p>
</blockquote>
<h3 id="覆盖方法"><a href="#覆盖方法" class="headerlink" title="覆盖方法"></a>覆盖方法</h3><p>在类里重新声明这个方法</p>
<h3 id="重载-1"><a href="#重载-1" class="headerlink" title="重载"></a>重载</h3><p>可以定义多个同名的函数，只要它们输入的参数不同</p>
<ul>
<li>运算符的重载</li>
</ul>
<p>重载不能改变运算符的操作个数，优先级，结核性</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">函数类型 operator 运算符（形参）</span><br><span class="line">&#123;</span><br><span class="line">运算符的重载操作</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">如：</span><br><span class="line">int operator +(int a,int b)</span><br><span class="line">&#123;</span><br><span class="line">return (a-b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>以下五个运算符不允许重载：<br><code>.</code>;<code>*</code>;<code>::</code>;<code>sizeof</code>;<code>?:</code>;</p>
</blockquote>
<h3 id="友元关系"><a href="#友元关系" class="headerlink" title="友元关系"></a>友元关系</h3><p>友元关系是类中的一种特殊关系，允许友元类访问对方pubulic、protected、private中的方法和属性</p>
<p>只要在类的声明里的地方加上<code>friend class **类名字***</code></p>
<h3 id="静态属性和静态方法"><a href="#静态属性和静态方法" class="headerlink" title="静态属性和静态方法"></a>静态属性和静态方法</h3><p>只要在它的声明前加上<code>static</code>即可</p>
<h3 id="虚方法"><a href="#虚方法" class="headerlink" title="虚方法"></a>虚方法</h3><p>只需要在其原型前加上<code>virtual</code>即可</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">每一个new操作都要对应一个delete操作</span><br><span class="line">int *p=new int;</span><br><span class="line">*p=10;</span><br><span class="line">std::cout&lt;&lt;*p;</span><br><span class="line">delete p;</span><br></pre></td></tr></table></figure>

<h3 id="抽象方法"><a href="#抽象方法" class="headerlink" title="抽象方法"></a>抽象方法</h3><p>在原型的末尾加上<code>=0</code></p>
<h3 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class TeachingStudent:public Student,public Teacher</span><br><span class="line">&#123;</span><br><span class="line">xxxx</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="虚继承"><a href="#虚继承" class="headerlink" title="虚继承"></a>虚继承</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Teacher:virtual public Person</span><br><span class="line">&#123;</span><br><span class="line">xxx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="动态内存"><a href="#动态内存" class="headerlink" title="动态内存"></a>动态内存</h3><p>new语句申请内存，delete语句释放内存,再将指针指向NULL</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int *i=new int;</span><br><span class="line">delete i;</span><br><span class="line">i=NULL;</span><br></pre></td></tr></table></figure>
<ul>
<li>动态数组</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int *=new int[10];</span><br><span class="line">x[1]=1;</span><br><span class="line">....</span><br><span class="line">delete [] x;	//删除动态数组</span><br></pre></td></tr></table></figure>



<h3 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h3><p>静态：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Company *company=new Company(&quot;APPLE&quot;,&quot;iPhone&quot;);</span><br><span class="line">TechCompany *tecCompany=(TecCompany*)company</span><br><span class="line">delete company;</span><br><span class="line">或</span><br><span class="line"></span><br><span class="line">不能两个都删除</span><br><span class="line">company=NULL;</span><br><span class="line">tecCompany=NULL;</span><br></pre></td></tr></table></figure>

<p>动态：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const_cast&lt;MyClass*&gt;(value)	//用来改变value的常量性</span><br><span class="line">dynamic_cast&lt;MyClass*&gt;(value)	//用来把一中类型的对象指针安全地强制转换为另一种类型的对象指针，如果value的类型不是一个MyClass类或其子类的指针，则返回NULL</span><br><span class="line">reinterpret_cast&lt;T&gt;(value)	//在不进行任何实质性的转换的情况下，把一种类型的指针解释为另一种类型的指针或者把一种整数解释为另一种整数</span><br><span class="line">static_cast&lt;T&gt;(value)		//用来进行强制类型转换而不做任何运行时的检查</span><br><span class="line"></span><br><span class="line">例如：</span><br><span class="line">Company *company=new Company(&quot;APPLE&quot;,iPhone&quot;);</span><br><span class="line">TechCompany *techcompany=dynamic_cast&lt;TechCompany *&gt;(company);</span><br></pre></td></tr></table></figure>

<h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">namespace myNamespace</span><br><span class="line">&#123;</span><br><span class="line">....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">使用命名空间</span><br><span class="line">* using namespace myNamespace</span><br><span class="line"></span><br><span class="line">* myNamespace::xxxx</span><br><span class="line"></span><br><span class="line">* using std::cout;</span><br><span class="line">  cout&lt;&lt;&quot;,,,,&quot;;</span><br></pre></td></tr></table></figure>

<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p>当使用编译器建立程序时：<br>1.执行预处理器指令<br>2.把.cpp文件编译成.o文件<br>3.把.o文件链接成一个可执行文件  </p>
<h3 id="泛型编程"><a href="#泛型编程" class="headerlink" title="泛型编程"></a>泛型编程</h3><p>函数模板</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">template &lt;class T&gt;	//字母T表示接下来的函数里代表的一种不确定的数据类型</span><br><span class="line">void swap(T &amp;a,T &amp;b)</span><br><span class="line">&#123;</span><br><span class="line">T i=0;</span><br><span class="line">....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类模板</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class T&gt;</span><br><span class="line">class MyClass</span><br><span class="line">&#123;</span><br><span class="line">MyClass();</span><br><span class="line">void swap(T &amp;a,T &amp;b);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//构造器的实现</span><br><span class="line">Myclass&lt;T&gt;::MyClass()</span><br><span class="line">&#123;</span><br><span class="line">.....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">inline int add (int x,int y,int z)</span><br><span class="line">&#123;</span><br><span class="line">return x+Y+z;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.baidu.com/2020/11/11/22-22-22/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="KK">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KK">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/11/22-22-22/" class="post-title-link" itemprop="url">windows实用工具</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-11-11 22:22:22" itemprop="dateCreated datePublished" datetime="2020-11-11T22:22:22+08:00">2020-11-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-02-21 23:16:02" itemprop="dateModified" datetime="2023-02-21T23:16:02+08:00">2023-02-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/tool/" itemprop="url" rel="index"><span itemprop="name">tool</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="window10-实用软件"><a href="#window10-实用软件" class="headerlink" title="window10 实用软件"></a>window10 实用软件</h1><hr>
<h3 id="PowerToys"><a href="#PowerToys" class="headerlink" title="PowerToys"></a>PowerToys</h3><p>是一款实用工具的集合，它并不是新事物，Windows 95 就曾有过这款工具，只是 Windows 在原来的启发之下开发了这款针对 Window 10 系统更加高效的版本。<br>目前 PowerToys 包括如下 7 项功能，每一项都非常实用，它们分别是：</p>
<ul>
<li>FancyZones</li>
<li>File Explorer Add-ons</li>
<li>Image Resizer</li>
<li>Keyboard Manager</li>
<li>PowerRename</li>
<li>PowerToys Run</li>
<li>Shortcut Guide</li>
</ul>
<hr>
<h3 id="chrome"><a href="#chrome" class="headerlink" title="chrome"></a>chrome</h3><p>插件：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://wwn.lanzouy.com/i6eOx0bmd9ub">油猴</a></li>
<li><a target="_blank" rel="noopener" href="https://wwn.lanzouy.com/iXH250bmd0li">adblockPlus</a></li>
<li><a target="_blank" rel="noopener" href="https://wwn.lanzouy.com/ineO40bme6qf">ublock</a></li>
<li><a target="_blank" rel="noopener" href="https://wwbk.lanzoue.com/iRIjx0bme6uj">草料二维码</a></li>
<li><a target="_blank" rel="noopener" href="https://wwbk.lanzoue.com/i2ykx0ht4wfi">vue2</a></li>
<li><a target="_blank" rel="noopener" href="https://wwbk.lanzoue.com/iOqHN0ht4xaj">vue3</a></li>
<li><a target="_blank" rel="noopener" href="https://wwbk.lanzoue.com/i8wch0ht4xed">react</a></li>
<li><a target="_blank" rel="noopener" href="https://wwbk.lanzoue.com/i5baZ0ht4wwf">redux</a></li>
<li><a target="_blank" rel="noopener" href="https://wwbk.lanzoue.com/iBCXa0ht4wgj">vimiumC</a></li>
<li><a target="_blank" rel="noopener" href="https://wwbk.lanzoue.com/isrNg0ht4wle">editThisCookie</a></li>
</ul>
<h3 id="other"><a href="#other" class="headerlink" title="other"></a>other</h3><ul>
<li><a target="_blank" rel="noopener" href="https://wwbk.lanzoue.com/iduIc0bmfhcd">IDM 下载工具</a></li>
<li><a target="_blank" rel="noopener" href="https://wwbk.lanzoue.com/i7IKb0hsyaid">winscp+putty</a></li>
<li><a target="_blank" rel="noopener" href="https://wwn.lanzouy.com/i0Lmyxe5nwh">截图工具 snipaste</a></li>
<li><a target="_blank" rel="noopener" href="https://wwn.lanzouy.com/iujpA0bm9jda">鼠标右键管理工具</a></li>
<li>无广告输入法：<a target="_blank" rel="noopener" href="http://www.xinshuru.com/">手心输入法</a></li>
<li><a target="_blank" rel="noopener" href="https://wwn.lanzouy.com/izNvH0bm9j9g">解压工具 bandizip 破解版</a></li>
<li><a target="_blank" rel="noopener" href="https://wwn.lanzouy.com/iR7jo0bmclsf">解压工具 7-zip</a></li>
<li>字体：<a target="_blank" rel="noopener" href="https://wwn.lanzouy.com/ifuCp0bm9jah">inconsolata</a>、<a target="_blank" rel="noopener" href="https://wwn.lanzouy.com/i5xTI0bm9jbi">droidsansmono</a>、<a target="_blank" rel="noopener" href="https://wwn.lanzouy.com/iOqD50bm9jcj">monaco</a></li>
<li>免费简洁思维导图<a target="_blank" rel="noopener" href="https://wwn.lanzouy.com/iEtBj0bm9hfa">blumind</a></li>
<li>精简小巧屏幕录制工具<a target="_blank" rel="noopener" href="https://wwn.lanzouy.com/ium4t0bmagsd">FSCature</a></li>
<li>电脑控制手机<a target="_blank" rel="noopener" href="https://wwn.lanzouy.com/iCzdu0bmc0cd">scrcpy</a></li>
<li>window 性能监控<a target="_blank" rel="noopener" href="https://wwbk.lanzoum.com/i2Pkr0o8tdej">Traffic Monitor</a></li>
<li>干净简单轻量级看图工具<a target="_blank" rel="noopener" href="https://wwbk.lanzoum.com/iBWdi0o8tfif">Honeyview</a></li>
<li>WPS 教育考试专用版，纯净无广告<a target="_blank" rel="noopener" href="https://ncre.neea.edu.cn/html1/report/1507/861-1.htm">wps</a></li>
<li>WPS 校园版,去掉了附加的增值服务以及广告（停止维护）</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.baidu.com/2020/11/11/20-33-33/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="KK">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KK">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/11/20-33-33/" class="post-title-link" itemprop="url">vue3</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-11-11 20:33:33" itemprop="dateCreated datePublished" datetime="2020-11-11T20:33:33+08:00">2020-11-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-18 12:49:42" itemprop="dateModified" datetime="2022-08-18T12:49:42+08:00">2022-08-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/web/" itemprop="url" rel="index"><span itemprop="name">web</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="VUE3-0"><a href="#VUE3-0" class="headerlink" title="VUE3.0"></a>VUE3.0</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ol>
<li>查看 vue-cli 版本，必须大于 4.5：<code>vue -V</code><ul>
<li>升级 vue-cli：<code>npm install -g @vue/cli</code></li>
<li>创建：<code>vue create test</code> 选择 vue3</li>
</ul>
</li>
<li>vite 创建：<code>vue init vite-app test</code><ul>
<li><code>vue install</code></li>
<li><code>npm run dev</code><br>或者<code>npm init vite@latest</code>输入工程名称,选择框架为vue</li>
<li><code>vue install</code></li>
<li><code>npm run dev</code><blockquote>
<p><a target="_blank" rel="noopener" href="https://vitejs.cn/">https://vitejs.cn/</a></p>
</blockquote>
<h2 id="main-js"><a href="#main-js" class="headerlink" title="main.js"></a>main.js</h2></li>
</ul>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">///引用的不再是vue的构造函数</span><br><span class="line">import &#123; createApp &#125; from &#x27;vue&#x27;</span><br><span class="line">import App from &#x27;./App.vue&#x27;</span><br><span class="line">//创建应用实例对象</span><br><span class="line">const app=createApp(App);</span><br><span class="line">app.mount(&#x27;#app&#x27;)</span><br><span class="line">//app 比 vm 轻量</span><br><span class="line">//cosnt vm =new  Vue(&#123;</span><br><span class="line">//   render(h=&gt;h(App))</span><br><span class="line">//&#125;)</span><br><span class="line">//vm.$mount(&#x27;#app&#x27;)</span><br></pre></td></tr></table></figure>

<h2 id="App-vue"><a href="#App-vue" class="headerlink" title="App.vue"></a>App.vue</h2><blockquote>
<p>vue3 组件中的模版结构可以没有 div 根标签</p>
</blockquote>
<h3 id="composition-API-组合式-api"><a href="#composition-API-组合式-api" class="headerlink" title="composition API 组合式 api"></a>composition API 组合式 api</h3><h4 id="setup"><a href="#setup" class="headerlink" title="setup"></a>setup</h4><blockquote>
<p>vue2 中的 data、methods、computed 写在 setup 中可以访问到 setup 中的属性和方法，但 setup 却不能访问到 vue2 中的配置。所以不建议混用。<br>如有重名，setup 中的优先，非异步组件，setup 中不能加 async，否则 return 返回的是 promise ，模版将读取不到<br>setup 在 beforeCreate 前会执行一次，其中的 this 为 undefined</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import &#123;h&#125; from &#x27;vue&#x27;</span><br><span class="line">export default&#123;</span><br><span class="line">   name:&#x27;App&#x27;,</span><br><span class="line">   setup()&#123;</span><br><span class="line">      //非响应式数据</span><br><span class="line">      let a=1;</span><br><span class="line">      let b=2;</span><br><span class="line">     function test()&#123;</span><br><span class="line">      console.log(a,b)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">     return &#123;//返回对象，可在模板中直接使用</span><br><span class="line">         c:1,d:&#x27;xx&#x27;,test</span><br><span class="line">      &#125;</span><br><span class="line">      //也可以返回渲染函数，但此时模板中的内容将全部无效</span><br><span class="line">      //return ()=&gt;&#123;h(&#x27;div&#x27;,&#x27;xxxx&#x27;)&#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>传值</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;child a=&quot;1&quot; b=&quot;2&quot; @test=&quot;handle&quot; &gt; &lt;template v-slot:xxx&gt;s&lt;/template&gt;&lt;/child&gt;</span><br><span class="line">//子组件</span><br><span class="line">props:[&#x27;a&#x27;,&#x27;b&#x27;],</span><br><span class="line">emits:[&#x27;test&#x27;]</span><br><span class="line">setup(props,context)&#123;</span><br><span class="line">//context.attrs-&gt;组件外传来但没有在props声明的属性</span><br><span class="line">//context.emits</span><br><span class="line">//context.slots</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h4><blockquote>
<p>定义一个响应式数据,模板中读取数据不用<code>.value</code>;基本类型使用的是<code>Object.defineProperty()</code>的 getter、setter 实现的，对象数据使用 reactive 函数</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import &#123;ref&#125; from &#x27;vue&#x27;</span><br><span class="line">export default&#123;</span><br><span class="line">   name:&#x27;App&#x27;,</span><br><span class="line">   setup()&#123;</span><br><span class="line">      //响应式数据</span><br><span class="line">      let a=ref(1);//引用实例对象</span><br><span class="line">      let b=ref(&#123;c:1&#125;);</span><br><span class="line">     function test()&#123;</span><br><span class="line">        a.value=2;</span><br><span class="line">        b.value.c=3;</span><br><span class="line">      console.log(a,b)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">     return &#123;//返回对象，可在模板中直接使用</span><br><span class="line">         a,b,test</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="reative"><a href="#reative" class="headerlink" title="reative"></a>reative</h4><blockquote>
<p>定义一个对象类型的响应式数据（基本数据类型不用它)</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import &#123;ref,reactive&#125; from &#x27;vue&#x27;</span><br><span class="line">export default&#123;</span><br><span class="line">   name:&#x27;App&#x27;,</span><br><span class="line">   setup()&#123;</span><br><span class="line">      //响应式数据</span><br><span class="line">      let a=ref(1);//引用实例对象</span><br><span class="line">      let b=reactive(&#123;c:1&#125;);</span><br><span class="line">     function test()&#123;</span><br><span class="line">        a.value=2;</span><br><span class="line">        b.c=3;//不用.value</span><br><span class="line">      console.log(a,b)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">     return &#123;//返回对象，可在模板中直接使用</span><br><span class="line">         a,b,test</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="computed"><a href="#computed" class="headerlink" title="computed"></a>computed</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import &#123;computed&#125; from &#x27;vue&#x27;</span><br><span class="line">export default&#123;</span><br><span class="line">   name:&#x27;App&#x27;,</span><br><span class="line">   setup()&#123;</span><br><span class="line">      //响应式数据</span><br><span class="line">      let a=1;//引用实例对象</span><br><span class="line"></span><br><span class="line">     let d= computed(()=&gt;&#123;</span><br><span class="line">        return 100</span><br><span class="line">      &#125;)</span><br><span class="line">let b=computed(&#123;</span><br><span class="line">   get()&#123;</span><br><span class="line">      return 1</span><br><span class="line">   &#125;,</span><br><span class="line">   set(value)&#123;&#125;</span><br><span class="line">&#125;)</span><br><span class="line">     return &#123;//返回对象，可在模板中直接使用</span><br><span class="line">         a,b,test,d</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">import &#123;watch,ref&#125; from &#x27;vue&#x27;</span><br><span class="line">export default&#123;</span><br><span class="line">   name:&#x27;App&#x27;,</span><br><span class="line">   setup()&#123;</span><br><span class="line">      //响应式数据</span><br><span class="line">      let a=ref(1);//引用实例对象</span><br><span class="line">      let b=ref(1);//引用实例对象</span><br><span class="line">  watch(a,(newVal,oldVal)=&gt;&#123;//监听ref定义的响应式数据,不用加.value</span><br><span class="line"></span><br><span class="line">      &#125;,&#123;immediate:true,depp:true&#125;)</span><br><span class="line">watch([a,b],(newVal,oldVal)=&gt;&#123;//监听多个ref定义的响应式数据</span><br><span class="line">newVal-&gt;[.....]</span><br><span class="line">      &#125;)</span><br><span class="line">      let person=ref(&#123;</span><br><span class="line">         a:1,</span><br><span class="line">         b:&#123;c:2&#125;</span><br><span class="line">      &#125;)</span><br><span class="line">watch(person,(newVal,oldVal)=&gt;&#123;&#125;)//不会有效果，因为value的值为proxy属性，只有它变才会检测到，内部的数据变不会触发</span><br><span class="line">//应使用</span><br><span class="line">watch(person.value,(newVal,oldVal)=&gt;&#123;&#125;)//或</span><br><span class="line">watch(person,(newVal,oldVal)=&gt;&#123;&#125;,&#123;deep:true&#125;)</span><br><span class="line">//-------------------------------------------------</span><br><span class="line">      //使用reative定义的数据，无法正确获取oldvalue,无法关闭深度监视，</span><br><span class="line">      let person=reative(&#123;</span><br><span class="line">         a:1,</span><br><span class="line">         b:&#123;c:2&#125;</span><br><span class="line">      &#125;)</span><br><span class="line">watch(person,(newVal,oldVal)=&gt;&#123;&#125;)</span><br><span class="line">//监听reative定义的对象的某一属性,必须写成函数</span><br><span class="line">watch(()=&gt;&#123;return person.a&#125;,(newval)=&gt;&#123;&#125;)</span><br><span class="line">//监听reative定义的对象的某些属性,必须写成函数</span><br><span class="line">watch([()=&gt;&#123;return person.a&#125;,...],(newval)=&gt;&#123;&#125;)</span><br><span class="line"> //监听reative定义的对象的某个对象,必须加上deep</span><br><span class="line">watch(()=&gt;&#123;return person.b&#125;,(newval)=&gt;&#123;&#125;,&#123;deep:true&#125;)</span><br><span class="line">//-----------------------------------------------------------</span><br><span class="line">watchEffect(()=&gt;&#123;//内部用到谁，就会监测谁</span><br><span class="line">let x=person.a</span><br><span class="line">&#125;)</span><br><span class="line">     return &#123;//返回对象，可在模板中直接使用</span><br><span class="line">         a,b,</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="自定义-hock-函数"><a href="#自定义-hock-函数" class="headerlink" title="自定义 hock 函数"></a>自定义 hock 函数</h4><blockquote>
<p>本质是个函数，将 setup 中的函数进行封装,类似 vue2 中 mixin</p>
</blockquote>
<ul>
<li>test.js</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import &#123;ref&#125; from &#x27;Vue&#x27;</span><br><span class="line">function test()&#123;</span><br><span class="line">   return &#123;</span><br><span class="line">      a:2</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">export defalut test</span><br></pre></td></tr></table></figure>

<ul>
<li>xxx.vue</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">import test form &#x27;./test.js&#x27;</span><br><span class="line">setup()&#123;</span><br><span class="line">let a=test()</span><br><span class="line">return &#123;a&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="toRef"><a href="#toRef" class="headerlink" title="toRef"></a>toRef</h4><blockquote>
<p>创建一个 ref 对象，其 value 值指向另一个对象中的某个属性,将对象中的某个属性单独提供给外部使用</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import &#123;onBeforeMount&#125; from &#x27;Vue&#x27;</span><br><span class="line">setup()&#123;</span><br><span class="line">   let person=reative(&#123;</span><br><span class="line">      name:&#x27;xx&#x27;,</span><br><span class="line">      a:1,</span><br><span class="line">      b:&#123;c:2&#125;</span><br><span class="line">   &#125;)</span><br><span class="line"></span><br><span class="line">   let t=toRefs(person)</span><br><span class="line">   return &#123;</span><br><span class="line">      a:person.a,//不是响应式</span><br><span class="line">      c:ref(person.b.c),//创建了一个新的实例对象，修改数据不会改变原数据</span><br><span class="line">      c:toRef(person.b,&#x27;c&#x27;)</span><br><span class="line">      name:toRef(person,&#x27;name)</span><br><span class="line">      ...toRefs(person)//全部</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="shallowReative-shallowRef"><a href="#shallowReative-shallowRef" class="headerlink" title="shallowReative||shallowRef"></a>shallowReative||shallowRef</h4><blockquote>
<p>shallowReative 只处理对象最外层属性响应式,shallowRef 只处理基本数据响应式，不进行对象的响应式(提升性能)</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let person = shallowReative(&#123;</span><br><span class="line">   a:1,</span><br><span class="line">   b:&#123;</span><br><span class="line">      c:1</span><br><span class="line">   &#125;</span><br><span class="line">&#125;)</span><br><span class="line">let person2=shallowRef(&#123;a:1&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="readonly-shallowReadonly"><a href="#readonly-shallowReadonly" class="headerlink" title="readonly||shallowReadonly"></a>readonly||shallowReadonly</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let person=Reative(&#123;</span><br><span class="line">a:1,</span><br><span class="line">b:&#123;</span><br><span class="line">c:1</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">person =readonly(person)//深只读,保护数据</span><br><span class="line">person =shallowReadonly(person)//浅只读</span><br></pre></td></tr></table></figure>

<h4 id="toRaw-markRaw"><a href="#toRaw-markRaw" class="headerlink" title="toRaw||markRaw"></a>toRaw||markRaw</h4><blockquote>
<p>将 reactive 生成的响应式数据转换为普通对象,ref 的不行</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let person=Reative(&#123;</span><br><span class="line">a:1,</span><br><span class="line">b:&#123;</span><br><span class="line">c:1</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">person =roRaw(person)//转化为原始数据</span><br><span class="line">person =markRaw(person)//标记一个对象，使其永远不再成为响应式对象</span><br></pre></td></tr></table></figure>

<h4 id="provide-inject"><a href="#provide-inject" class="headerlink" title="provide||inject"></a>provide||inject</h4><blockquote>
<p>祖孙组件通信</p>
</blockquote>
<ul>
<li>祖组件</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let person=Reative(&#123;</span><br><span class="line">a:1,</span><br><span class="line">b:&#123;</span><br><span class="line">c:1</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">provide(&#x27;test&#x27;,person)</span><br></pre></td></tr></table></figure>

<ul>
<li>孙组件</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let x=inject(&#x27;test)</span><br></pre></td></tr></table></figure>

<h3 id="teleport"><a href="#teleport" class="headerlink" title="teleport"></a>teleport</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;teleport to=&quot;body&quot;&gt;</span><br><span class="line">&lt;div&gt;xxx&lt;/div&gt;</span><br><span class="line">&lt;/teleport&gt;</span><br><span class="line">&lt;teleport to=&quot;#xxx&quot;&gt;</span><br><span class="line">&lt;div&gt;xxx&lt;/div&gt;</span><br><span class="line">&lt;/teleport&gt;</span><br></pre></td></tr></table></figure>

<h3 id="vue3-0-响应式"><a href="#vue3-0-响应式" class="headerlink" title="vue3.0 响应式"></a>vue3.0 响应式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">let person=&#123;</span><br><span class="line">a:1,</span><br><span class="line">b:&#x27;xxx&#x27;</span><br><span class="line">&#125;</span><br><span class="line">const p=new Proxy(person,&#123;</span><br><span class="line">get(target,propName)&#123;//读取属性</span><br><span class="line">//target:原对象</span><br><span class="line">//propName：读取的属性名</span><br><span class="line">//return target[propName]//普通操作</span><br><span class="line">return Reflect.get(target,propName)//reflect 可减少写错误捕获</span><br><span class="line">&#125;,</span><br><span class="line">set(target,propName,value)&#123;//修改属性或增加属性时调用</span><br><span class="line">//value：修改的值</span><br><span class="line">//target[propName]=value</span><br><span class="line">return Reflect.set(target,prop,value)</span><br><span class="line">&#125;,</span><br><span class="line">deleteProperty(target,propName)&#123;//删除属性</span><br><span class="line">//return delete target[propName]</span><br><span class="line">return Reflect.deleteProperty(target,prop)</span><br><span class="line">&#125;,</span><br><span class="line">&#125;)//代理</span><br></pre></td></tr></table></figure>

<h3 id="vue3-0-生命周期"><a href="#vue3-0-生命周期" class="headerlink" title="vue3.0 生命周期"></a>vue3.0 生命周期</h3><blockquote>
<p>beforeCreate-&gt;created-&gt;beforeMount-&gt;mounted-&gt;beforeUpdate-&gt;updated-&gt;beforeUnmount-&gt;unmounted</p>
</blockquote>
<ul>
<li>组合 api</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">beforeCreate===&gt;setup()</span><br><span class="line">created===&gt;setup()</span><br><span class="line">beforeMount===&gt;onBeforeMount</span><br><span class="line">beforeUpdate===&gt;onBeforeUpdate</span><br><span class="line">Updated===&gt;onUpdated</span><br><span class="line">beforeUnmount===&gt;onBeforeUnmount</span><br><span class="line">unmounted===&gt;onUnmounted</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">....</span><br><span class="line">import &#123;onBeforeMount&#125; from &#x27;Vue&#x27;</span><br><span class="line">setup()&#123;</span><br><span class="line">onBeforeMount(()=&gt;&#123;</span><br><span class="line">console.log()</span><br><span class="line">&#125;)</span><br><span class="line">&#125;,</span><br><span class="line">//配置项写法优先级要低于组合式 api 写法</span><br><span class="line">beforeMount()&#123;</span><br><span class="line">console.log(&#x27;xxx&#x27;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><p>安装 Vue Router：<code>npm install vue-router</code></p>
<ul>
<li>router/index.js</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">// history模式</span><br><span class="line">import &#123;</span><br><span class="line">    createRouter,</span><br><span class="line">    createWebHashHistory,</span><br><span class="line">&#125; from &#x27;vue-router&#x27;</span><br><span class="line"></span><br><span class="line">import Home from &#x27;../pages/Home.vue&#x27;</span><br><span class="line">import About from &#x27;../pages/About.vue&#x27;</span><br><span class="line"></span><br><span class="line">const routes = [</span><br><span class="line">// 路由的默认路径</span><br><span class="line">    &#123;</span><br><span class="line">        path:&#x27;/&#x27;,</span><br><span class="line">        redirect:&quot;/home&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        path: &#x27;/home&#x27;,</span><br><span class="line">         component: () =&gt; import(&#x27;…/pages/Home.vue&#x27;)</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        path: &#x27;/about&#x27;,</span><br><span class="line">        component: About</span><br><span class="line">    &#125;,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">// 创建路由对象</span><br><span class="line">const router = createRouter(&#123;</span><br><span class="line">    history: createWebHashHistory(),</span><br><span class="line">    routes</span><br><span class="line">&#125;)</span><br><span class="line">export default router;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>main.js</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import &#123;</span><br><span class="line">    createApp</span><br><span class="line">&#125; from &#x27;vue&#x27;</span><br><span class="line">import App from &#x27;./App.vue&#x27;</span><br><span class="line">import router from &#x27;./router&#x27;</span><br><span class="line">createApp(App).use(router).mount(&#x27;#app&#x27;)</span><br></pre></td></tr></table></figure>
<ul>
<li><p>使用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import &#123; useRouter &#125; from &#x27;vue-router&#x27;;</span><br><span class="line">  setup() &#123;</span><br><span class="line">    const router = useRouter();</span><br><span class="line">    function goto()&#123;</span><br><span class="line">      router.push(&quot;/about&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return&#123;</span><br><span class="line">       goto  //一定要要放在return里才能在模板上面使用</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h2 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a>vuex</h2><p>npm 安装 vuex。<code>npm install vuex@next --save</code></p>
</li>
<li><p>store/index.js</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import &#123; createStore &#125; from &#x27;vuex&#x27;</span><br><span class="line">export default createStore(&#123;</span><br><span class="line">  state: &#123;&#125;,</span><br><span class="line">  getters: &#123;&#125;,</span><br><span class="line">  mutations: &#123;&#125;,</span><br><span class="line">  actions: &#123;&#125;,</span><br><span class="line">  modules: &#123;&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>首先从vuex中引入useStore函数，他的返回值就是一个vuex实例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;h1&gt;vuex中的数据&#123;&#123; store.state.count &#125;&#125;&lt;/h1&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script lang=&quot;ts&quot;&gt;</span><br><span class="line">import &#123; defineComponent &#125; from &quot;vue&quot;</span><br><span class="line">import &#123; useStore &#125; from &quot;vuex&quot;</span><br><span class="line">export default defineComponent(&#123;</span><br><span class="line">  name: &quot;index&quot;,</span><br><span class="line">  setup() &#123;</span><br><span class="line">    const store = useStore()</span><br><span class="line">    return &#123; store &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>vue3的router文件引入vuex </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//错误引入</span><br><span class="line"></span><br><span class="line">import &#123; useStore &#125; from &#x27;vuex&#x27;</span><br><span class="line">const $store = useStore();</span><br><span class="line">console.log($store) //undefined</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">//正确引入</span><br><span class="line"></span><br><span class="line">import myStore from &#x27;@/store/index.js&#x27;</span><br><span class="line">const $store = myStore;</span><br><span class="line">console.log($store)</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="less"><a href="#less" class="headerlink" title="less"></a>less</h2><p>安装：<code>npm i less-loader less --save-dev</code></p>
<h2 id="sass"><a href="#sass" class="headerlink" title="sass"></a>sass</h2><p>安装：<code>npm install node-sass sass-loader --save-dev</code><br>文件使用scss后缀写style时声明lang=scss</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;style scoped lang=&quot;scss&quot;&gt;</span><br><span class="line">//这里是scss不是sass，这个是因为scss是sass3引入进来的，scss语法有&quot;&#123;&#125;&quot;,&quot;;&quot;而sass没有，所以sass-loader对他们的解析是不一样的</span><br><span class="line"># 这里写样式</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<p>可以声明使用变量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$color:black;</span><br><span class="line">.container&#123;</span><br><span class="line">  a &#123;</span><br><span class="line">    color:$color;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以封装函数，通过 @mixin 声明函数，该函数创建颜色style,不传参默认黑色</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@mixin create_color($color:black)&#123;</span><br><span class="line">  color:$color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过@import引入封装函数的文件，通过@include调用函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;style lang=&quot;scss&quot; scoped&gt;</span><br><span class="line">     @import &quot;src/assets/sass/mixin.scss&quot;;</span><br><span class="line">    .container&#123;</span><br><span class="line">      a &#123;</span><br><span class="line">        @include create_color(red);</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;   </span><br></pre></td></tr></table></figure>

<h2 id="antdesign"><a href="#antdesign" class="headerlink" title="antdesign"></a>antdesign</h2><p>安装antdesign</p>
<p><code>npm i --save ant-design-vue@next</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import &#123; createApp &#125; from &#x27;vue&#x27;</span><br><span class="line">import Antd from &#x27;ant-design-vue&#x27;;</span><br><span class="line">import &#x27;ant-design-vue/dist/antd.css&#x27;;</span><br><span class="line">const app = createApp(App) </span><br><span class="line">app.use(Antd);</span><br></pre></td></tr></table></figure>

<p>vue3引用ant-design-vue编译运行时，可能会报错can’t read property undefine错误</p>
<p>执行下面命令就行</p>
<p><code>npm i --save ant-design-vue@next -S</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vue3解析component: router-view失败  </span><br><span class="line">解决：</span><br><span class="line">//app.use(router) 需放在app.mount(&#x27;#app&#x27;)前面  不然加载时router-view、router-link等未被渲染</span><br></pre></td></tr></table></figure>

<h3 id="清空数组的几个方式"><a href="#清空数组的几个方式" class="headerlink" title="清空数组的几个方式"></a>清空数组的几个方式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//使用ref()</span><br><span class="line">const array = ref([1,2,3]);</span><br><span class="line">array.value = [];</span><br><span class="line"></span><br><span class="line">//使用slice,不过需要注意要使用ref</span><br><span class="line">array.value = array.value.slice(0,0);</span><br><span class="line"></span><br><span class="line">//length赋值为0,支持reactive,而且，这种只会触发一次watch</span><br><span class="line">array.value.length = 0;</span><br><span class="line"></span><br><span class="line">//使用splice,可以使用reactive,不过要注意，watch会触发多次</span><br><span class="line">array.splice(0,array.length)</span><br></pre></td></tr></table></figure>
<h3 id="Vue3中废弃了-set的概念"><a href="#Vue3中废弃了-set的概念" class="headerlink" title="Vue3中废弃了$set的概念"></a>Vue3中废弃了$set的概念</h3><p>原因就是 Vue2 中的数据响应式是利用 object.definedProperty()实现的，它是无法深层监听数据的变化的。</p>
<p>而Vue3，用的是ES6的proxy，对数据响应式进行一个数据的代理。这个就厉害了啊，结合Vue3的 composition API。</p>
<p>Vue3 中的 reactivity API：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">reactive</span><br><span class="line">readonly</span><br><span class="line">ref</span><br><span class="line">computed</span><br></pre></td></tr></table></figure>
<p>如果想要让一个对象变为响应式数据，可以使用reactive或ref</p>
<h3 id="vue3-0中使用nextTick"><a href="#vue3-0中使用nextTick" class="headerlink" title="vue3.0中使用nextTick"></a>vue3.0中使用nextTick</h3><p> nextTick 是将回调推迟到下一个 DOM 更新周期之后执行。在更改了一些数据以等待 DOM 更新后立即使用它</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import &#123; nextTick &#125; from &#x27;vue&#x27;</span><br><span class="line">...</span><br><span class="line"> setup () &#123;    </span><br><span class="line">    let otherParam = reactive(&#123;</span><br><span class="line">      showA:false</span><br><span class="line">    &#125;)</span><br><span class="line">    nextTick(()=&gt;&#123;</span><br><span class="line">      otherParam.showA = true</span><br><span class="line">    &#125;)</span><br><span class="line">  return &#123;</span><br><span class="line">      otherParam</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="vue3使用ref获取元素"><a href="#vue3使用ref获取元素" class="headerlink" title="vue3使用ref获取元素"></a>vue3使用ref获取元素</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div ref=&quot;hello&quot;&gt;xxxx&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script setup lang=&quot;ts&quot;&gt;</span><br><span class="line">import &#123; onMounted, ref &#125; from &quot;vue&quot;;</span><br><span class="line">const hello = ref&lt;any&gt;(null);</span><br><span class="line">onMounted(() =&gt; &#123;</span><br><span class="line">  console.log(hello.value); &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>变量名称必须要与 ref 命名的属性名称一致。<br>通过 hello.value 的形式获取 DOM 元素。<br>必须要在 DOM 渲染完成后才可以获取 hello.value，否则就是 null</p>
<ul>
<li>v-for 中使用 ref</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div v-for=&#x27;i in 10&#x27; ref=&quot;hello&quot;&gt;xxxx&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script setup lang=&quot;ts&quot;&gt;</span><br><span class="line">import &#123; onMounted, ref &#125; from &quot;vue&quot;;</span><br><span class="line">const hello = ref([]);</span><br><span class="line">onMounted(() =&gt; &#123;</span><br><span class="line">  console.log(hello.value); &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>ref 绑定函数 </li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div v-for=&#x27;i in 10&#x27; :ref=&quot;(el)=&gt;&#123;hello(el,i)&#125;&quot;&gt;xxxx&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script setup lang=&quot;ts&quot;&gt;</span><br><span class="line">import &#123; onMounted, ref &#125; from &quot;vue&quot;;</span><br><span class="line">const hello = (el,index)=&gt;&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.baidu.com/2020/11/11/20-33-33/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="KK">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KK">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/11/20-33-33/" class="post-title-link" itemprop="url">数据结构</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-11-11 20:33:33" itemprop="dateCreated datePublished" datetime="2020-11-11T20:33:33+08:00">2020-11-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-07-19 17:00:42" itemprop="dateModified" datetime="2021-07-19T17:00:42+08:00">2021-07-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/study/" itemprop="url" rel="index"><span itemprop="name">study</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h3 id="算法时间复杂度"><a href="#算法时间复杂度" class="headerlink" title="算法时间复杂度"></a>算法时间复杂度</h3><p>T(n)=O(f(n))</p>
<ol>
<li>用常数1取代运行时间中的所有加法常数，如多条pintf语句只运行1次即O(1)</li>
<li>在修改后的运行次数函数中，只保留最高项</li>
<li>如果最高项不是1，则去除最高项的常数如3n^2即O(n^2)</li>
</ol>
<p>所耗时间<code>O(1)&lt;O(logn)&lt;O(n)&lt;O(nlogn)&lt;O(n^2)&lt;O(2^n)&lt;O(n!)&lt;O(n^n)</code></p>
<h3 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h3><p>由零个或多个数据元素组成的有限序列</p>
<p>[a1][a2]…[ai-1][ai][ai+1]….[an]<br>[ai-1]为[ai]的直接前驱元素<br>[ai+1]为[ai]的直接后继元素<br>每个元素有且只有一个前驱和后继元素，不存在一对多</p>
<p>抽象数据类型的形式定义</p>
<p>ADT=(D,S,P)</p>
<p>描述方法（伪码）：</p>
<p>ADT 抽象数据类型名{</p>
<p>数据对象：&lt;数据对象的定义&gt;</p>
<p>数据关系：&lt;数据关系的定义&gt;</p>
<p>基本操作：&lt;基本操作的定义&gt;</p>
<p>}ADT 抽象数据类型名</p>
<p>抽象数据类型的实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#define TRUE 1</span><br><span class="line">#define FALSE 0</span><br><span class="line">#define OK 1</span><br><span class="line">#define ERROR 0</span><br><span class="line">#define INFEASIBLE -1</span><br><span class="line">#define OVERFLOW -2</span><br><span class="line">//Status是函数的类型，其值是函数结果的状态代码</span><br><span class="line">typedef int Status;</span><br><span class="line">Status 函数名&#123;</span><br><span class="line">//算法说明</span><br><span class="line">语句序列;</span><br><span class="line">&#125;//函数名</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">ADT List&#123;</span><br><span class="line">	数据对象：D=&#123;ai|ai∈ElemSet,i=1,2,...,n,n≥0&#125;</span><br><span class="line">	数据关系：R1=&#123;&lt;ai-1,ai&gt;|ai-1,ai∈D,i=2,3,4,...,n&#125;</span><br><span class="line">	基本操作：</span><br><span class="line">	InitList(&amp;L)</span><br><span class="line">		操作结果：构造一个空的线性表L。</span><br><span class="line">	DestroyList(&amp;L)</span><br><span class="line">		初始条件：线性表L已存在。</span><br><span class="line">		操作结果：销毁线性表L。</span><br><span class="line">	ClearList(&amp;L)</span><br><span class="line">		初始条件：线性表L已存在。</span><br><span class="line">		操作结果：将L重置为空表。</span><br><span class="line">	ListEmpty (L)</span><br><span class="line">		初始条件：线性表L已存在。</span><br><span class="line">		操作结果：若L为空表，则返回TRUE，否则返回FALSE。</span><br><span class="line">	ListLength(L)</span><br><span class="line">		初始条件：线性表L已存在。</span><br><span class="line">		操作结果：返回L中数据元素的个数。</span><br><span class="line">	GetElem(L,i,&amp;e)</span><br><span class="line">		初始条件：线性表L已存在，l≤i≤ListLength(L)。</span><br><span class="line">		操作结果：用e返回L中第i个数据元素的值。</span><br><span class="line">	LocateElem(L,e,compare())</span><br><span class="line">		初始条件：线性表L已存在，compare()是数据元素的判定函数。</span><br><span class="line">		操作结果：用e返回L中第1个与e满足关系compare()的数据元素的位序。若这样的数据元素不存在，则返回值为0。</span><br><span class="line">	PriorElem(L,cur_e,&amp;pre_e)</span><br><span class="line">		初始条件：线性表L已存在。</span><br><span class="line">		操作结果：若cur_e是L的数据元素，且不是第一个，则用pre_e返回它的前驱，否则操作失败，pre_e无定义。</span><br><span class="line">	NextElem(L,cur_e,&amp;next_e)</span><br><span class="line">		初始条件：线性表L已存在。</span><br><span class="line">		操作结果：若cur_e是L的数据元素，且不是最后一个，则用next_e返回它的前驱，否则操作失败，next_e无定义。</span><br><span class="line">	ListInsert(&amp;L,i,e)</span><br><span class="line">		初始条件：线性表L已存在，l≤i≤ListLength(L)+1。</span><br><span class="line">		操作结果：在L中第i个位置之前插入新的数据元素e，L的长度加1.</span><br><span class="line">	ListDelete(&amp;L,i,&amp;e)</span><br><span class="line">		初始条件；线性表L已存在且非空，l≤i≤ListLength(L)。</span><br><span class="line">		操作结果：删除L中第i个数据元素，并用e返回其值，L长度减1.</span><br><span class="line">	ListTraverse(L,visit())</span><br><span class="line">		初始条件：线性表L已存在。</span><br><span class="line">		操作结果：依次对L的每个数据元素调用函数visit()。一旦visit()失败，则操作失败。</span><br><span class="line">&#125;ADT List</span><br></pre></td></tr></table></figure>

<h3 id="顺序存取"><a href="#顺序存取" class="headerlink" title="顺序存取"></a>顺序存取</h3><p>数组</p>
<h3 id="链式存取"><a href="#链式存取" class="headerlink" title="链式存取"></a>链式存取</h3><ul>
<li>单链表整表创建的算法思路：</li>
</ul>
<ol>
<li>声明一个结点p和计数器变量n；</li>
<li>初始化一空链表L；</li>
<li>让L的头结点的指针指向NULL；</li>
<li>循环实现后继结点的赋值和插入；</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">	</span><br><span class="line">typedef int DataType;</span><br><span class="line"></span><br><span class="line">typedef struct LNode&#123;</span><br><span class="line">	DataType data;		//数据域</span><br><span class="line">	struct LNode *next;	//指针域，指向下一个节点</span><br><span class="line">&#125;LNode,*LinkList;</span><br><span class="line"></span><br><span class="line">//创建///</span><br><span class="line">//声明函数</span><br><span class="line">LinkList CreateList(int n);	//创建链表</span><br><span class="line">void print(LinkList h);		//打印链表</span><br><span class="line"></span><br><span class="line">//创建链表</span><br><span class="line">LinkList CreateList(int n)&#123;</span><br><span class="line">	//定义指针L指向该链表即头指针，结点q为第一个结点，结点p为下一个结点</span><br><span class="line">	LinkList L,p,q;</span><br><span class="line">	//为头指针申请空间</span><br><span class="line">	L=(LNode*)malloc(sizeof(LNode));</span><br><span class="line">	if(!L)&#123;return 0;&#125;</span><br><span class="line">	//头指针指向NULL即空链表</span><br><span class="line">	L-&gt;next =NULL;</span><br><span class="line">	//第一个结点指向头指针</span><br><span class="line">	q=L;</span><br><span class="line">	//循环创建链表结点</span><br><span class="line">	for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">		//为下一个结点申请空间</span><br><span class="line">		p=(LinkList)malloc(sizeof(LNode));</span><br><span class="line">		printf(&quot;输入第%d个元素的值：&quot;,i);</span><br><span class="line">		//存入数据</span><br><span class="line">		scanf(&quot;%d&quot;,&amp;(p-&gt;data));</span><br><span class="line">		//下一个结点的指针指向NULL，即尾部</span><br><span class="line">		p-&gt;next=NULL;</span><br><span class="line">		//第一个结点的指针指向下一个结点,即上一个结点与该结点相连</span><br><span class="line">		q-&gt;next=p;</span><br><span class="line">		//移动第一个结点到下一个结点</span><br><span class="line">		q=p;</span><br><span class="line">	&#125;</span><br><span class="line">	//返回链表头部</span><br><span class="line">	return L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//打印链表</span><br><span class="line">void print (LinkList h)&#123;</span><br><span class="line">	//创建一个指针指向链表的第一个元素结点；</span><br><span class="line">	LinkList p=h-&gt;next;</span><br><span class="line">	//当不是尾部时</span><br><span class="line">	while(p!=NULL)&#123;</span><br><span class="line">	//打印数据</span><br><span class="line">	printf(&quot;%d &quot;,p-&gt;data);</span><br><span class="line">	//移动到下一个元素</span><br><span class="line">	p=p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main ()&#123;</span><br><span class="line">	//创建一个头指针并指向NULL；即空链表·</span><br><span class="line">	LinkList head=NULL;</span><br><span class="line">	//输入结点个数n</span><br><span class="line">	int n;</span><br><span class="line">	printf(&quot;请输入链表长度：&quot;);</span><br><span class="line">	scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">	//创建链表</span><br><span class="line">	head=CreateList(n);</span><br><span class="line">	//打印链表</span><br><span class="line">	printf(&quot;刚刚建立的各个链表元素的值为:\n&quot;);</span><br><span class="line">	print(head);</span><br><span class="line">	printf(&quot;\n\n&quot;);</span><br><span class="line">	//按下任意键结束</span><br><span class="line">	getchar();</span><br><span class="line">	getchar();</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>单链表整表的删除算法思路：</li>
</ul>
<ol>
<li>声明结点p和q；</li>
<li>将第一个接地赋值给p，下一个结点赋值给q；</li>
<li>循环执行释放p和将q赋值给p的操作；free(p)会同时把数据域和指针域同时删除<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//h为头指针</span><br><span class="line">void delect(LinkList h)&#123;</span><br><span class="line">LinkList p,q;</span><br><span class="line">p=h-&gt;next;	//p指向第一个节点</span><br><span class="line">while(p!=NULL)&#123;</span><br><span class="line">q=p-&gt;next;	//q指向第二个节点</span><br><span class="line">free(p);	//删除第一个节点</span><br><span class="line">p=q;		//p等于第二个节点</span><br><span class="line">&#125;</span><br><span class="line">h-&gt;next==NULL;	//头节点指向空</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>获取第i个数据的算法思路：</li>
</ul>
<ol>
<li>声明一个结点p指向链表第一个结点，初始化j从1开始；</li>
<li>当j&lt;i时,就遍历链表，让p的指针向后移动，不断指向下一个结点，j+1；</li>
<li>若到链表末尾p为空，则说明第i个元素不存在；</li>
<li>若查找成功则返回结点p的数据；</li>
</ol>
<ul>
<li>单链表第i个数据插入结点的算法思路：</li>
</ul>
<ol>
<li>将数据元素e赋值给s-&gt;data即s-&gt;data=e;</li>
<li>s-next=p-&gt;next;</li>
<li>p-next=s;</li>
</ol>
<ul>
<li>单链表的删除</li>
</ul>
<ol>
<li>p-&gt;next=p-&gt;next-&gt;next;</li>
</ol>
<p>头指针不为空，头指针是链表的必要元素，头指针是链表指向第一个节点的指针。头结点在第一个元素的节点前，其数据一般无意义，但也可用来存放链表的长度。空链表头指针直接指向null</p>
<h3 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h3><p>尾指针指向头指针</p>
<h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3><p>结构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef struct DualNode&#123;</span><br><span class="line">int data;</span><br><span class="line">struct DualNode *prior; 	//前驱节点</span><br><span class="line">struct DualNode *next;		//后继节点</span><br><span class="line">&#125;DualNode,*DuLinkList;</span><br></pre></td></tr></table></figure>
<p>插入操作</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//s为插入节点，p为后一个节点；</span><br><span class="line">s-&gt;next=p;</span><br><span class="line">s-&gt;prior=p-&gt;prior;</span><br><span class="line">p-&gt;prior-next=s;</span><br><span class="line">p-&gt;prior=s;</span><br></pre></td></tr></table></figure>
<p>删除操作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//删除p节点</span><br><span class="line">p-&gt;prior-&gt;next=p-&gt;next;</span><br><span class="line">p-&gt;next-&gt;prior=p-&gt;prior;</span><br><span class="line">free(p);</span><br></pre></td></tr></table></figure>
<h3 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h3><p>用数组描述的链表称为静态链表</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#define maxsize 1000</span><br><span class="line">typedef struct&#123;</span><br><span class="line">int  data;//数据</span><br><span class="line">int cut;//游标</span><br><span class="line">&#125;component,staticlinklist[maxsize];	//结构体数组</span><br><span class="line">//静态链表的初始化，相当于初始化数组:</span><br><span class="line">Status InitList(staticlinklist space)&#123;</span><br><span class="line">int i;</span><br><span class="line">for(i=0;i&lt;maxsize-1;i++)</span><br><span class="line">&#123;space[i].cur=i+1;&#125;</span><br><span class="line">space[maxsize-1].cur=0;</span><br><span class="line">return Ok;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//第一个与最后一个元素不存放数据,最后一个元素的游标为0。数组的第一个元素即下标为0的那个元素的cur游标就存放备用链表的第一个结点的下标；最后一个元素即maxsize-1的游标cur则存放第一个有数据的元素的下标，相当于单链表中的头结点作用。 </span><br><span class="line">//静态链表中的插入和删除，只需修改游标</span><br></pre></td></tr></table></figure>

<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>是一个先进后出的线性表，要求只在表尾进行删除和插入操作；对与栈来说，表尾称为栈的栈顶top,表头称为栈底bottom.<br>结构:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef struct&#123;</span><br><span class="line">int *bottom;	//指向栈底的指针；</span><br><span class="line">int *top;</span><br><span class="line">int stacksize;	//指当前可使用的最大总量。</span><br><span class="line">&#125;sqStack;</span><br></pre></td></tr></table></figure>
<p>创建一个栈：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#define STACK_INIT_SIZE 100</span><br><span class="line">initStack(sqStack *s)&#123;</span><br><span class="line">s-&gt;bottom=(int*)malloc(STACK_INIT_SIZE*sizeof(int));</span><br><span class="line">if(!s-&gt;base)&#123;exit(0);&#125;</span><br><span class="line">s-&gt;top=s-&gt;base;		//开始栈顶就是栈底</span><br><span class="line">s-&gt;stacksize=STACK_INIT_SIZE;</span><br><span class="line">&#125;</span><br><span class="line">//初始化</span><br><span class="line">void initstack(sqStack *s)&#123;</span><br><span class="line">s-&gt;bottom=(int*)malloc(STACK_INIT_SIZE*sizeof(int));</span><br><span class="line">if(!s-bottom)&#123;exit(0);&#125;</span><br><span class="line">s-&gt;top=s-&gt;bottom;</span><br><span class="line">s-&gt;stacksize=STACK_INIT_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>入栈操作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#define STACKINCREMENT 10</span><br><span class="line">push(sqStack *s,int e);</span><br><span class="line">&#123;</span><br><span class="line">//栈满追加空间</span><br><span class="line">if (s-&gt;top - s-&gt;bottom==s-&gt;stacksize) &#123;</span><br><span class="line">s-&gt;bottom=(int*)realloc(s-&gt;bottom,(s-&gt;stacksize+STACKINCREMENT)*sizeof(int));</span><br><span class="line">if(!s-&gt;bottom)&#123;exit(0);&#125;</span><br><span class="line">s-&gt;top=s-&gt;bottom+s-&gt;stacksize;			//设置栈顶</span><br><span class="line">s-&gt;stacksize=s-&gt;stacksize+STACKINCREMENT;	//重新设置栈的最大容量</span><br><span class="line">&#125;</span><br><span class="line">*(s-&gt;top)=e;</span><br><span class="line">s-&gt;top++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>出栈操作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pop(sqStack *s, int *e)&#123;</span><br><span class="line">if(s-&gt;top==s-&gt;base)&#123;rerutn;&#125;	//栈空退出；</span><br><span class="line">*e=*--(s-&gt;top);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>清空栈：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">clearsqstack(sqStack *s)&#123;</span><br><span class="line">s-&gt;top=s-&gt;bottom;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>销毁一个栈：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">destroystack(sqStack *s)&#123;</span><br><span class="line">int i,len;</span><br><span class="line">len=s-&gt;stacksize;</span><br><span class="line">for(i=0;i&lt;len;i++)&#123;</span><br><span class="line">free(s-&gt;bottom);</span><br><span class="line">s-&gt;bottom++;</span><br><span class="line">&#125;</span><br><span class="line">s-&gt;bottom=s-&gt;top=NULL;</span><br><span class="line">s-&gt;stacksize=0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>计算栈容量：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int stacklen(sqStack *s)&#123;</span><br><span class="line">return(s.top-s.bottom);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>栈的存储结构：<br>顺序存储<br>链式存储：栈顶为单链表的头部</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">typedef struct stackNode&#123;</span><br><span class="line">ElemType data;		//存放栈的数据</span><br><span class="line">struct stackNode *next;</span><br><span class="line">&#125;stackNode,*LinkStackPtr;</span><br><span class="line">typedef strucct LinkStack&#123;</span><br><span class="line">LinkStackPtr top;	//top指针</span><br><span class="line">int count;		//计数器</span><br><span class="line">&#125;</span><br><span class="line">//栈链的进栈</span><br><span class="line">//s为新节点，top为栈顶指针；</span><br><span class="line">Status push(LinkStack *s,ElemType e)&#123;</span><br><span class="line">LinkStackPtr p=(LinkStackPtr)malloc(sizeof(LinkStackPtr));</span><br><span class="line">p-&gt;data=e;</span><br><span class="line">p-&gt;next=s-&gt;top;</span><br><span class="line">s-&gt;cont++;</span><br><span class="line">return OK;</span><br><span class="line">&#125;</span><br><span class="line">//链表的出栈操作</span><br><span class="line">Status pop(LinkStack *s,ElemType *e)&#123;</span><br><span class="line">LintStack p;</span><br><span class="line">if(StackEmpty(*s))&#123;return ERROR;&#125;	//判断是否为空栈</span><br><span class="line">*e=s-&gt;top-&gt;data;</span><br><span class="line">p=s-&gt;top;</span><br><span class="line">s-&gt;top=s-&gt;top-&gt;next;</span><br><span class="line">free(p);</span><br><span class="line">s-&gt;count--;</span><br><span class="line">return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>队列只允许在一端进行插入操作，在另一端进行删除操作的线性表（先进先出）</p>
<p>队列的链式存储结构</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typedef struct QNode&#123;</span><br><span class="line">ElemType data;</span><br><span class="line">struct QNode *next;</span><br><span class="line">&#125;QNode,*QueuePrt;</span><br><span class="line">type struct&#123;</span><br><span class="line">QueuePrt front,rear;	//队头、尾指针；</span><br><span class="line">&#125;LinkQueue;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>创建队列：在内存中创建一个头结点，将队列的头、尾指针都指向这个生成的头结点，此时为空队列；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">initQueue(LinkQueue *q)</span><br><span class="line">&#123;q-&gt;front=q-&gt;rear=(QueuePtr)malloc(sizeof(QNode));</span><br><span class="line">if(!q-&gt;front)&#123;exit(0);&#125;</span><br><span class="line">q-&gt;front-&gt;next=NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>入队操作</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">InsertQueue(LinkQueue *q,ElemType e)&#123;</span><br><span class="line">QueuePtr p;</span><br><span class="line">p=(QueuePtr)malloc(sizeof(QNode));</span><br><span class="line">if(p==NULL)&#123;eixt(0);&#125;</span><br><span class="line">p-&gt;data=e;</span><br><span class="line">p-&gt;next=NULL;</span><br><span class="line">q-&gt;rear-&gt;next=p;</span><br><span class="line">q-&gt;rear=p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>出队列</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DeleteQueue(LinkQueue *q,ElemType *e)&#123;</span><br><span class="line">Queueptr p;</span><br><span class="line">if(q-&gt;front==q-&gt;rear)&#123;return;&#125;	//判断队列是否为空；</span><br><span class="line">p=q-&gt;front-&gt;next;</span><br><span class="line">*e=p-&gt;data;</span><br><span class="line">q-&gt;front-&gt;next=p-&gt;next;</span><br><span class="line">if(q-&gt;rear==p)&#123;q-&gt;rear=q-&gt;front;&#125;</span><br><span class="line">free(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>销毁一个队列</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DestroyQueue(LinkQueue *q)&#123;</span><br><span class="line">while(q-&gt;front)&#123;</span><br><span class="line">q-&gt;rear=q-&gt;front-next;</span><br><span class="line">free(q-&gt;front);</span><br><span class="line">q-&gt;front=q-&gt;rear;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="串"><a href="#串" class="headerlink" title="串"></a>串</h3><p>有零个或多个字符组成的有限序列<code>S=&#39;a1a2a3a4a5....&#39;</code></p>
<ul>
<li>串的长度：串中字符的个数</li>
<li>子串：串中任意个连续的字符串组成的子序列；</li>
<li>串中的位置：该字节在串中的序号，子串在主串中的位置以子串的第一个字符在主串中的位置来表示</li>
<li>空格串：有一个或多个空格组成的串</li>
<li>空串</li>
</ul>
<p>采用顺序存储称为顺序串，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#define MAXLEN 255</span><br><span class="line">typedef struct&#123;</span><br><span class="line">char ch[MAXLEN+1];	//存储串的一维数组</span><br><span class="line">int length;	//串的当前长度</span><br><span class="line">&#125;SString;</span><br></pre></td></tr></table></figure>


<p>采用链式存储称为链串；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#define CHUNKSIZE 80 	//块大小</span><br><span class="line">typedef struct Chunk&#123;</span><br><span class="line">char ch[CHUNKSIZE];</span><br><span class="line">struct Chunk *next;</span><br><span class="line">&#125;Chunk;</span><br><span class="line"></span><br><span class="line">typedef struct&#123;</span><br><span class="line">Chunk *head *tail;	//串的头尾指针</span><br><span class="line">int curlen;		//串的当前长度</span><br><span class="line">&#125;LString;	//字符串的块链结构</span><br></pre></td></tr></table></figure>


<h4 id="串的模式匹配算法"><a href="#串的模式匹配算法" class="headerlink" title="串的模式匹配算法"></a>串的模式匹配算法</h4><p>确定主串中子串（模式串）第一次出现的位置</p>
<ul>
<li>BF算法(暴力破解法）</li>
</ul>
<p>先匹配第一个元素，再匹配第二个元素…..</p>
<ul>
<li>KMP算法</li>
</ul>
<p>主串的指针i不用回溯，子串的指针j不一定回到开头；</p>
<p>next[j]:j的下一个位置</p>
<p>当j=1时，next[j]=0;<br>其他情况，next[j]=1;<br>next[j]=max{1&lt;k&lt;j且从头开始的k-1个元素等于j前面的k-1个元素”P1…P(k-1)”=”P(j-k+1)….P(j-1)”}</p>
<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>方法或函数调用自身的方式称为递归调用，调用称为递，返回称为归。</p>
<ul>
<li>递归的优缺点？</li>
</ul>
<p>1.优点：代码的表达力很强，写起来简洁。<br>2.缺点：空间复杂度高、有堆栈溢出风险、存在重复计算、过多的函数调用会耗时较多等问题。</p>
<ul>
<li>一个问题只要同时满足以下3个条件，就可以用递归来解决：</li>
</ul>
<p>1.问题的解可以分解为几个子问题的解。何为子问题？就是数据规模更小的问题。<br>2.问题与子问题，除了数据规模不同，求解思路完全一样<br>3.存在递归终止条件</p>
<ul>
<li>解决方案</li>
</ul>
<p>1.警惕堆栈溢出：可以声明一个全局变量来控制递归的深度，从而避免堆栈溢出。<br>2.警惕重复计算：通过某种数据结构来保存已经求解过的值，从而避免重复计算。</p>
<h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><p>在一颗非空树中，有且只有一个根节点，结点拥有的子树树称为度；度为0 的结点称为叶子或终端结点；不为0 的结点称为分支结点或非终端结点；树的度是树内结点度的最大值；同一个双亲的孩子互称为兄弟；从根到该结点所经过分支上的结点称为祖先，从该结点到下面所有结点称为子孙；树中结点的最大层次称为树的深度；</p>
<p>从左到右是有次序的称为该树的有序树，否则称为无序树；<br>森林是m棵互不相交的树的集合；</p>
<h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p>每个结点至多只有两棵子树，子树有左右之分，次序不能颠倒</p>
<p>在二叉树的第i层上至多有2^(i-1)个结点</p>
<p>深度为k的二叉树至多有2^k-1个结点</p>
<p>终端结点数为n0，度为2的结点数为n，则n0=n+1;</p>
<ul>
<li>满二叉树</li>
</ul>
<p>深度为k且结点数为2^k-1的二叉树</p>
<ul>
<li>完全二叉树</li>
</ul>
<p>每个结点都与满二叉树中的编号一一对应。</p>
<p>具有n个结点的完全二叉树的深度为[log(2)n]+1;</p>
<p>若2i&gt;n，则结点i无左孩子，否则其左孩子是结点2i；</p>
<p>若2i+1&gt;n，则结点i无右孩子，否则其右孩子为结点2i+1;</p>
<p>若i&gt;1，则其双亲为结点[i/2]</p>
<ul>
<li><p>二叉树的存储结构</p>
<ul>
<li>顺序存储</li>
</ul>
<p>  将完全二叉树上编号为i的结点元素存储在一维数组中</p>
<ul>
<li>链式存储</li>
</ul>
<p>  链表中的结点至少包含三个域：数据域、左右结点指针域；还可以增加一个指向其双亲的指针域；</p>
</li>
<li><p>遍历二叉树</p>
<ul>
<li>先序遍历</li>
</ul>
<p>  根-左-右</p>
<ul>
<li>中序遍历</li>
</ul>
<p>  左-根-右</p>
<ul>
<li>后续遍历</li>
</ul>
<p>  左-右-根</p>
</li>
<li><p>二叉链表</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">typedef char ElemType;</span><br><span class="line">typedef struct BiTNode</span><br><span class="line">&#123;</span><br><span class="line">ElemType data;</span><br><span class="line">struct BiTNode *lchild, *rchild;</span><br><span class="line">&#125;BidTNode,*BiTree;</span><br><span class="line"></span><br><span class="line">//创建一颗二叉树，按照前序遍历的方式输入数据</span><br><span class="line">CreateBidTree(BiTree *T)</span><br><span class="line">&#123;</span><br><span class="line">char c;</span><br><span class="line">scanf(&quot;%c&quot;,&amp;c);</span><br><span class="line">if(&#x27; &#x27;==c)	//空格表示结点无子树</span><br><span class="line">&#123;</span><br><span class="line">*T=NULL;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">*T=(BiTNode *)malloc(sizeof(BiTNode));</span><br><span class="line">(*T)-&gt;data=c;</span><br><span class="line">CreateBiTree(&amp;(*T)-&gt;lchild);</span><br><span class="line">CreateBiTree(&amp;(*T)-&gt;rchild);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">visit()&#123;</span><br><span class="line">//访问结点时的操作</span><br><span class="line">&#125;</span><br><span class="line">//遍历二叉树</span><br><span class="line">PreOrderTraverse(BidTree T,int level)</span><br><span class="line">&#123;</span><br><span class="line">if(T)</span><br><span class="line">&#123;</span><br><span class="line">visit(T-&gt;data,level);</span><br><span class="line">PreOrderTraverse(T-&gt;lchild,level+1);</span><br><span class="line">PreOrderTraverse(T-&gt;rchild,level+1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int level=1;</span><br><span class="line">BiTree T=NULl;</span><br><span class="line">CreateBiTree(&amp;T);</span><br><span class="line">PreOrderTraverse(T,level);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>线索二叉树</li>
</ul>
<p>将定义好的二叉树结构进行扩容：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>lchild</td>
<td>ltag</td>
<td>data</td>
<td>rtag</td>
<td>rchild</td>
</tr>
</tbody></table>
<blockquote>
<p>ltag=0时,lchild指向该结点的左孩子，为1时指向该结点的前驱。rtag=0，rchild指向该结点的右孩子，为1时指向该结点的后继。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">typedef char ElemType;</span><br><span class="line">//线索存储标志位</span><br><span class="line">//Link(0):表示指向左右孩子的指针</span><br><span class="line">//Thread(1):表示指向前驱后继的线索</span><br><span class="line">typedef enum&#123;Link,Thread&#125; PointerTag;</span><br><span class="line">typedef struct BiThrNode</span><br><span class="line">&#123;</span><br><span class="line">char data;</span><br><span class="line">struct BiThrNode *lchild, *rchild;</span><br><span class="line">PointerNag ltag;</span><br><span class="line">PointerNag rTag;</span><br><span class="line">&#125;BiThrNode,*BiThrTree;</span><br><span class="line"></span><br><span class="line">//全局变量，始终指向刚刚访问过的结点</span><br><span class="line">BiThrTree pre;</span><br><span class="line"></span><br><span class="line">//创建一棵二叉树，按照前序遍历的方式输入数据</span><br><span class="line">CreateBiThrTree(BiThrTree *T)</span><br><span class="line">&#123;</span><br><span class="line">char c;</span><br><span class="line">scanf(&quot;%c&quot;,&amp;c);</span><br><span class="line">if(&#x27; &#x27;==c)&#123;</span><br><span class="line">*T=NULL;</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">*T=(BiThrNode *)malloc(sizeof(BiThrNode));</span><br><span class="line">(*T)-&gt;data=c;</span><br><span class="line">(*T)-&gt;ltag=Link;</span><br><span class="line">(*T)-&gt;rtag=Link;</span><br><span class="line"></span><br><span class="line">CreateBiThrTree(&amp;(*T)-&gt;lchild);</span><br><span class="line">CreateBiThrTree(&amp;(*T)-&gt;rchild);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//中序遍历线索</span><br><span class="line">InThreading(BiThrTree T)</span><br><span class="line">&#123;</span><br><span class="line">if(T)</span><br><span class="line">&#123;</span><br><span class="line">InThreading(T-&gt;lchild);	//递归左孩子线索化</span><br><span class="line">if(!T-&gt;lchild)	//如果该节点没有左孩子，则设置ltag为thread，并把lchild指向刚刚访问过的结点</span><br><span class="line">&#123;</span><br><span class="line">T-&gt;ltag=Thread;</span><br><span class="line">T-&gt;lchild=pre;</span><br><span class="line">&#125;</span><br><span class="line">if(!pre-&gt;rchild)</span><br><span class="line">&#123;</span><br><span class="line">pre-&gt;rtag=Thread;</span><br><span class="line">Pre-&gt;rchild=T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Pre=T;</span><br><span class="line">InThreading(T-&gt;rchild);		//递归右孩子线索化</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">InOrderThreading(BiThrTree *p,BiThrTree T)</span><br><span class="line">&#123;</span><br><span class="line">*p=(BiThrTree)malloc(sizeof(BiThrNode));</span><br><span class="line">(*p)-&gt;ltag=Link;</span><br><span class="line">(*P)-&gt;rtag=Thread;</span><br><span class="line">(*p)-&gt;rchild=*p;</span><br><span class="line">if(!T)&#123;</span><br><span class="line">(*P)-&gt;lchild=*p;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">(*P)-&gt;lchild=T;</span><br><span class="line">Pre=*p;</span><br><span class="line">InThreading(T);</span><br><span class="line">Pre-&gt;rchild=*p;</span><br><span class="line">Pre-&gt;rtag=Thread;</span><br><span class="line">(*P)-&gt;rchild=Pre;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">BiThrTree P,T=NULL;</span><br><span class="line">CreateBiThrTree(&amp;T);</span><br><span class="line">InOrderThreading(&amp;P,T);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>普通树转换为二叉树</p>
<ol>
<li>所有兄弟结点之间加一条连线</li>
<li>对树中的每一个结点，只保留它与第一孩子结点的连线，删除它与其它孩子结点间的连线</li>
</ol>
</li>
<li><p>森林转换为二叉树</p>
<ol>
<li>把每棵树转化为二叉树</li>
<li>第一颗二叉树不动，从第二棵二叉树开始，依次把后一棵二叉树的根结点作为前一棵二叉树的根结点的右孩子，用线连起来</li>
</ol>
</li>
</ul>
<blockquote>
<p>树、森林的前序遍历和二叉树的前序遍历结果相同，后序遍历与二叉树的中序遍历结果相同。</p>
</blockquote>
<h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><p>图（Graph）是由顶点的有穷非空集合和顶点之间边的集合组成，通常表示为：G（V，E）其中，G表示一个图，V是图G中顶点的集合，E是图G中边的集合。</p>
<ul>
<li><p>图按照边的有无方向分为无向图和有向图。无向图由顶点和边组成，有向图由顶点和弧构成。弧有弧尾和弧头之分，带箭头一端为弧头。</p>
</li>
<li><p>图按照边或弧的多少分稀疏图和稠密图。如果图中的任意两个顶点之间都存在边叫做完全图，有向的叫有向完全图。若无重复的边或顶点到自身的边则叫简单图。</p>
</li>
<li><p>图中顶点之间有邻接点、依附的概念。无向图顶点的边数叫做度。有向图顶点分为入度和出度。</p>
</li>
<li><p>图上的边或弧带有权则称为网。</p>
</li>
<li><p>图中顶点间存在路径，两顶点存在路径则说明是连通的，如果路径最终回到起始点则称为环，当中不重复的叫简单路径。若任意两顶点都是连通的，则图就是连通图，有向则称为强连通图。图中有子图，若子图极大连通则就是连通分量，有向的则称为强连通分量。</p>
</li>
<li><p>无向图中连通且n个顶点n-1条边称为生成树。有向图中一顶点入度为0其余顶点入度为1的叫有向树。一个有向图由若干棵有向树构成生成森林。</p>
</li>
</ul>
<h3 id="图的存储结构"><a href="#图的存储结构" class="headerlink" title="图的存储结构"></a>图的存储结构</h3><ul>
<li>邻接矩阵</li>
</ul>
<p>用两个数组来表示图，一个一维数组里储存着顶点的信息，一个二维数组储存着图中的边或弧的信息。</p>
<blockquote>
<p>无向图的邻接矩阵是对称的</p>
</blockquote>
<blockquote>
<p>有向图的邻接矩阵可能是不对称的，顶点的度=顶点的出度+顶点的入度；</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#define MVNum 100	//最大顶点数</span><br><span class="line">typedef char VerTexType;	//设顶点的数据类型为字符型</span><br><span class="line">typedef int ArcType;		//假设边的权值类型为整型</span><br><span class="line">typedef struct&#123;</span><br><span class="line">VerTexType Vexs[MVNum];		//顶点数组</span><br><span class="line">ArcType arcs[MVNum][MVNum]	//邻接矩阵</span><br><span class="line">&#125;AMGraph;	</span><br><span class="line"></span><br><span class="line">//在顶点数组中查找顶点</span><br><span class="line">int LocateVex(AMGraph G,VertexType u)&#123;</span><br><span class="line">//查找顶点u，返回下标</span><br><span class="line">int i;</span><br><span class="line">for (i=0;i&lt;G.vexnum;++i)&#123;</span><br><span class="line">if(U==G.vexs[i])&#123;</span><br><span class="line">return i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">reruen -1;</span><br><span class="line">&#125;</span><br><span class="line">status CreateUDN(AMGraph &amp;G)&#123;</span><br><span class="line">//创建无向网G</span><br><span class="line">cin&gt;&gt;G.vexnum&gt;&gt;G.arcnum;	//输入总顶点数，总边数</span><br><span class="line">for(i=0;i&lt;G.vexnum;++i)</span><br><span class="line">cin&gt;&gt;G.vexs[i];		//依次输入点的信息</span><br><span class="line">for(i=0;i&lt;G.vexnum;++i)	//初始化邻接矩阵</span><br><span class="line">for (j=0;j&lt;G.vexnum;++j)</span><br><span class="line">G.arcs[i][j]=MaxInt;	//边的权值均为最大值</span><br><span class="line">fof(k=0;k&lt;G.arcnum;++k)&#123;	//构造邻接矩阵</span><br><span class="line">cin&gt;&gt;v1&gt;&gt;v2&gt;&gt;w;			//输入一条边所依附的顶点及边的权值</span><br><span class="line">i=LocateVex(G,v1);</span><br><span class="line">j=LocateVex(G,v2);	//确定v1和v2在G中的位置</span><br><span class="line">G.arcs[i][j]=w;		//边&lt;v1,v2&gt;的权值置为w</span><br><span class="line">G.arcs[j][i]=G.arcs[i][j];	//&lt;v1,v2&gt;的对称边&lt;v2,v1&gt;的权值为w</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<ul>
<li>邻接表</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>缺点</th>
<th>改进方法</th>
</tr>
</thead>
<tbody><tr>
<td>有向图</td>
<td>求各结点的度困难</td>
<td>十字链表</td>
</tr>
<tr>
<td>无向图</td>
<td>每条边都要存储两遍</td>
<td>邻接多重表</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">typedef struct VNode&#123;</span><br><span class="line">VerTexType data;	//顶点信息</span><br><span class="line">ArcNode *firstarc;	//指向第一条依附该顶点的边的指针</span><br><span class="line">&#125;VNode，AdjList[MVNum];	//AdjList表示邻接表类型</span><br><span class="line"></span><br><span class="line">status CreateUDG(ALGragh &amp;G)&#123;	//创建无向图G</span><br><span class="line">cin&gt;&gt;G.vexnum&gt;&gt;G.arcnum;	//输入图G的顶点，边个数</span><br><span class="line">for(int i=0;i&lt;G.vexnum;++i)&#123;</span><br><span class="line">cin&gt;&gt;Gvertices[i].data;		//输入顶点值</span><br><span class="line">G.vertices[i].firsarc=NULL;	//初始化表头结点的指针域</span><br><span class="line">&#125;</span><br><span class="line">for(k=0;k&lt;G.arcnum;++k)&#123;	//输入各边</span><br><span class="line">cin&gt;&gt;v1&gt;&gt;v3;</span><br><span class="line">i=LocateVex(G,v1);</span><br><span class="line">j=LocateVex(G,v2);</span><br><span class="line">p1=new ArcNode;		//生成一个新的边结点*p1</span><br><span class="line">p1-&gt;adjvex=j;		//邻接点序号为j</span><br><span class="line">p1-&gt;nextarc=G.vertices[i].firstarc;</span><br><span class="line">G.vertices[i].firstarc=p1;;		//将新结点*p1插入顶点vi的边表头部</span><br><span class="line">p2=new ArcNode;		//生成另一个对称的新的边结点*p2</span><br><span class="line">p2-&gt;adjvex=i;		//邻接点序号为i</span><br><span class="line">p2-&gt;nextarc=G.vertices[j].firstarc;</span><br><span class="line">G.vertices[j].firstarc=p2;	//将新结点*p2插入顶点vj的边表头部</span><br><span class="line">&#125;</span><br><span class="line">return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="遍历方法"><a href="#遍历方法" class="headerlink" title="遍历方法"></a>遍历方法</h2><ul>
<li>深度优先遍历</li>
</ul>
<p>也称深度优先搜索（DFS）</p>
<p>右手原则：在没有碰到重复顶点的情况下，分叉路口始终是向右手边走，每路过一个顶点就做一个记号。</p>
<ul>
<li>广度优先遍历<br>又称广度优先搜索（BFS）</li>
</ul>
<p>普利姆算法<br>克鲁斯卡尔算法</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/4/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/6/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">KK</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">60</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/a913481180" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;a913481180" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:kangkanghuang@foxmail.com" title="E-Mail → mailto:kangkanghuang@foxmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="http://www.baidu.com/" title="http:&#x2F;&#x2F;www.baidu.com">百度</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">KK</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>

<script src="/js/utils.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
