<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/1.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/1.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.baidu.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":false,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="KK">
<meta property="og:url" content="http://www.baidu.com/page/2/index.html">
<meta property="og:site_name" content="KK">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="KK">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://www.baidu.com/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>KK</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">KK</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.baidu.com/2021/12/01/10-12-33/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="KK">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KK">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/01/10-12-33/" class="post-title-link" itemprop="url">Three.js</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-12-01 10:12:33" itemprop="dateCreated datePublished" datetime="2021-12-01T10:12:33+08:00">2021-12-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-02-06 11:30:12" itemprop="dateModified" datetime="2023-02-06T11:30:12+08:00">2023-02-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/web/" itemprop="url" rel="index"><span itemprop="name">web</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Threejs"><a href="#Threejs" class="headerlink" title="Threejs"></a>Threejs</h1><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><h3 id="创建一个场景"><a href="#创建一个场景" class="headerlink" title="创建一个场景"></a>创建一个场景</h3><p>场景、相机和渲染器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const scene = new THREE.Scene();</span><br><span class="line">const camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );</span><br><span class="line"></span><br><span class="line">const renderer = new THREE.WebGLRenderer();</span><br><span class="line">renderer.setSize( window.innerWidth, window.innerHeight );</span><br><span class="line">document.body.appendChild( renderer.domElement );</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>相机：<br>three.js里有几种不同的相机，在这里，我们使用的是PerspectiveCamera（透视摄像机）。</li>
</ul>
<p>第一个参数是视野角度（FOV）。视野角度就是无论在什么时候，你所能在显示器上看到的场景的范围，它的单位是角度(与弧度区分开)。</p>
<p>第二个参数是长宽比（aspect ratio）。 也就是你用一个物体的宽除以它的高的值。比如说，当你在一个宽屏电视上播放老电影时，可以看到图像仿佛是被压扁的。</p>
<p>接下来的两个参数是近截面（near）和远截面（far）。 当物体某些部分比摄像机的远截面远或者比近截面近的时候，该这些部分将不会被渲染到场景中。或许现在你不用担心这个值的影响，但未来为了获得更好的渲染性能，你将可以在你的应用程序里去设置它。</p>
<ul>
<li>渲染器：<br>除了创建一个渲染器的实例之外，我们还需要在我们的应用程序里设置一个渲染器的尺寸。比如说，我们可以使用所需要的渲染区域的宽高，来让渲染器渲染出的场景填充满我们的应用程序。因此，我们可以将渲染器宽高设置为浏览器窗口宽高。对于性能比较敏感的应用程序来说，你可以使用setSize传入一个较小的值，例如window.innerWidth/2和window.innerHeight/2，这将使得应用程序在渲染时，以一半的长宽尺寸渲染场景。</li>
</ul>
<p>如果你希望保持你的应用程序的尺寸，但是以较低的分辨率来渲染，你可以在调用setSize时，将updateStyle（第三个参数）设为false。例如，假设你的<canvas> 标签现在已经具有了100%的宽和高，调用setSize(window.innerWidth/2, window.innerHeight/2, false)将使得你的应用程序以一半的分辨率来进行渲染。</p>
<h3 id="创建一个立方体"><a href="#创建一个立方体" class="headerlink" title="创建一个立方体"></a>创建一个立方体</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const geometry = new THREE.BoxGeometry();</span><br><span class="line">const material = new THREE.MeshBasicMaterial( &#123; color: 0x00ff00 &#125; );</span><br><span class="line">const cube = new THREE.Mesh( geometry, material );</span><br><span class="line">scene.add( cube );</span><br><span class="line"></span><br><span class="line">camera.position.z = 5;</span><br></pre></td></tr></table></figure>
<p>创建一个立方体，我们需要一个BoxGeometry（立方体）对象. 这个对象包含了一个立方体中所有的顶点（vertices）和面（faces）。接下来，对于这个立方体，我们需要给它一个材质，来让它有颜色。第三步，我们需要一个Mesh（网格）。 网格包含一个几何体以及作用在此几何体上的材质，我们可以直接将网格对象放入到我们的场景中，并让它在场景中自由移动。</p>
<h3 id="渲染场景"><a href="#渲染场景" class="headerlink" title="渲染场景"></a>渲染场景</h3><p>现在，如果将之前写好的代码复制到HTML文件中，你不会在页面中看到任何东西。这是因为我们还没有对它进行真正的渲染。为此，我们需要使用一个被叫做“渲染循环”（render loop）或者“动画循环”（animate loop）的东西。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function animate() &#123;</span><br><span class="line">	requestAnimationFrame( animate );</span><br><span class="line">	renderer.render( scene, camera );</span><br><span class="line">&#125;</span><br><span class="line">animate();</span><br></pre></td></tr></table></figure>
<p>在这里我们创建了一个使渲染器能够在每次屏幕刷新时对场景进行绘制的循环（在大多数屏幕上，刷新率一般是60次/秒）。如果你是一个浏览器游戏开发的新手，你或许会说“为什么我们不直接用setInterval来实现刷新的功能呢？”当然啦，我们的确可以用setInterval，但是，requestAnimationFrame有很多的优点。最重要的一点或许就是当用户切换到其它的标签页时，它会暂停，因此不会浪费用户宝贵的处理器资源，也不会损耗电池的使用寿命。</p>
<h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h2><h3 id="相机"><a href="#相机" class="headerlink" title="相机"></a>相机</h3><ul>
<li><p>摄像机阵列（ArrayCamera）<br>ArrayCamera 用于更加高效地使用一组已经预定义的摄像机来渲染一个场景。这将能够更好地提升VR场景的渲染性能。<br>一个 ArrayCamera 的实例中总是包含着一组子摄像机，应当为每一个子摄像机定义viewport（视口）这个属性，这一属性决定了由该子摄像机所渲染的视口区域的大小。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">const cameras = [];</span><br><span class="line">     for (let i = 1; i &lt; 4; i++) &#123;</span><br><span class="line">       const subcamera = new THREE.PerspectiveCamera(40, 1, 0.1, 10);</span><br><span class="line">       subcamera.viewport = new THREE.Vector4(</span><br><span class="line">         Math.floor(i * 200),</span><br><span class="line">         Math.floor(1 * 200), //视口高</span><br><span class="line">         Math.ceil(200), //宽</span><br><span class="line">         Math.ceil(200) //视口高</span><br><span class="line">       );</span><br><span class="line">       subcamera.position.x = i / 3 - 0.5;</span><br><span class="line">       subcamera.position.y = 0.5 + i;</span><br><span class="line">       subcamera.position.z = 1.5;</span><br><span class="line">       subcamera.position.multiplyScalar(2);</span><br><span class="line">       subcamera.lookAt(0, 0, 0);</span><br><span class="line">       subcamera.updateMatrixWorld();</span><br><span class="line">       cameras.push(subcamera);</span><br><span class="line">     &#125;</span><br><span class="line">     let camera = new THREE.ArrayCamera(cameras);</span><br></pre></td></tr></table></figure></li>
<li><p>立方相机（CubeCamera）<br>创建6个渲染到WebGLCubeRenderTarget的摄像机<br>构造器<br>CubeCamera( near : Number, far : Number, renderTarget : WebGLCubeRenderTarget )<br>near – 近剪切面的距离<br>far – 远剪切面的距离<br>renderTarget – The destination cube render target.</p>
</li>
</ul>
<p>构造一个包含6个PerspectiveCameras（透视摄像机）的立方摄像机， 并将其拍摄的场景渲染到一个WebGLCubeRenderTarget上。</p>
<ul>
<li>正交相机（OrthographicCamera）<br>这一摄像机使用orthographic projection（正交投影）来进行投影。</li>
</ul>
<p>在这种投影模式下，无论物体距离相机距离远或者近，在最终渲染的图片中物体的大小都保持不变。</p>
<p>这对于渲染2D场景或者UI元素是非常有用的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const camera = new THREE.OrthographicCamera( width / - 2, width / 2, height / 2, height / - 2, 1, 1000 );</span><br><span class="line">scene.add( camera );</span><br></pre></td></tr></table></figure>
<p>构造器<br>OrthographicCamera( left : Number, right : Number, top : Number, bottom : Number, near : Number, far : Number )<br>left — 摄像机视锥体左侧面。<br>right — 摄像机视锥体右侧面。<br>top — 摄像机视锥体上侧面。<br>bottom — 摄像机视锥体下侧面。<br>near — 摄像机视锥体近端面。<br>far — 摄像机视锥体远端面。</p>
<ul>
<li>透视相机（PerspectiveCamera）<br>这一摄像机使用perspective projection（透视投影）来进行投影。</li>
</ul>
<p>这一投影模式被用来模拟人眼所看到的景象，它是3D场景的渲染中使用得最普遍的投影模式。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const camera = new THREE.PerspectiveCamera( 45, width / height, 1, 1000 );</span><br><span class="line">scene.add( camera );</span><br></pre></td></tr></table></figure>
<p>构造器<br>PerspectiveCamera( fov : Number, aspect : Number, near : Number, far : Number )<br>fov — 摄像机视锥体垂直视野角度<br>aspect — 摄像机视锥体长宽比<br>near — 摄像机视锥体近端面<br>far — 摄像机视锥体远端面</p>
<ul>
<li>立体相机（StereoCamera）<br>双透视摄像机（立体相机）常被用于创建3D Anaglyph（3D立体影像） 或者Parallax Barrier（视差屏障）。</li>
</ul>
<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><h3 id="Scene"><a href="#Scene" class="headerlink" title="Scene"></a>Scene</h3><h4 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h4><p>Scene()<br>创建一个新的场景对象。</p>
<h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><ul>
<li><p>.autoUpdate : Boolean<br>默认值为true，若设置了这个值，则渲染器会检查每一帧是否需要更新场景及其中物体的矩阵。 当设为false时，你必须亲自手动维护场景中的矩阵。</p>
</li>
<li><p>.background : Object<br>若不为空，在渲染场景的时候将设置背景，且背景总是首先被渲染的。 可以设置一个用于的“clear”的Color（颜色）、一个覆盖canvas的Texture（纹理）， 或是 a cubemap as a CubeTexture or an equirectangular as a Texture。默认值为null。<br><code>scene.background = new THREE.Color( 0xbfe3dd );</code></p>
</li>
<li><p>.environment : Texture<br>若该值不为null，则该纹理贴图将会被设为场景中所有物理材质的环境贴图。 然而，该属性不能够覆盖已存在的、已分配给 MeshStandardMaterial.envMap 的贴图。默认为null。<br><code>scene.environment = pmremGenerator.fromScene( new RoomEnvironment(), 0.04 ).texture;</code></p>
</li>
<li><p>.overrideMaterial : Material<br>如果不为空，它将强制场景中的每个物体使用这里的材质来渲染。默认值为null。</p>
</li>
<li><p>.fog : Fog<br>一个fog实例定义了影响场景中的每个物体的雾的类型。默认值为null。<br><code>scene.fog=new THREE.FogExp2( 0xefd1b5, 0.0025 );</code></p>
</li>
</ul>
<h3 id="雾（Fog）"><a href="#雾（Fog）" class="headerlink" title="雾（Fog）"></a>雾（Fog）</h3><p>这个类中的参数定义了线性雾。也就是说，雾的密度是随着距离线性增大的。</p>
<h4 id="构造器-1"><a href="#构造器-1" class="headerlink" title="构造器"></a>构造器</h4><p>Fog( color : Integer, near : Float, far : Float )<br>颜色参数传入Color构造函数中，来设置颜色属性。颜色可以是一个十六进制的整型数，或者是CSS风格的字符串。</p>
<h4 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h4><ul>
<li><p>.name : String<br>对象的名称，可选、不必唯一。默认值是一个空字符串。</p>
</li>
<li><p>.color : Color<br>雾的颜色。比如说，如果将其设置为黑色，远处的物体将被渲染成黑色。</p>
</li>
<li><p>.near : Float<br>开始应用雾的最小距离。距离小于活动摄像机“near”个单位的物体将不会被雾所影响。<br>默认值是1。</p>
</li>
<li><p>.far : Float<br>结束计算、应用雾的最大距离，距离大于活动摄像机“far”个单位的物体将不会被雾所影响。<br>默认值是1000。</p>
</li>
</ul>
<h3 id="雾-指数（FogExp2）"><a href="#雾-指数（FogExp2）" class="headerlink" title="雾-指数（FogExp2）"></a>雾-指数（FogExp2）</h3><p>该类所包含的参数定义了指数雾，它可以在相机附近提供清晰的视野，且距离相机越远，雾的浓度随着指数增长越快。</p>
<h4 id="构造器-2"><a href="#构造器-2" class="headerlink" title="构造器"></a>构造器</h4><p>FogExp2( color : Integer, density : Float )<br>颜色参数传入Color构造函数中，来设置颜色属性。颜色可以是一个十六进制的整型数，或者是CSS风格的字符串。</p>
<h4 id="属性-2"><a href="#属性-2" class="headerlink" title="属性"></a>属性</h4><ul>
<li><p>.name : String<br>对象的名称，可选、不必唯一。默认值是一个空字符串。</p>
</li>
<li><p>.color : Color<br>雾的颜色。比如说，如果将其设置为黑色，远处的物体将被渲染成黑色。</p>
</li>
<li><p>.density : Float<br>定义雾的密度将会增长多块。<br>默认值是0.00025.</p>
</li>
</ul>
<h2 id="全屏"><a href="#全屏" class="headerlink" title="全屏"></a>全屏</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">window.addEventListener(&#x27;dblclick&#x27;,()=&gt;&#123;</span><br><span class="line"></span><br><span class="line">  let isFull=document.fullscreenElement;</span><br><span class="line">  if(!isFull)&#123;</span><br><span class="line">    renderer.domElement.requestFullscreen(); </span><br><span class="line">  &#125;else&#123;</span><br><span class="line"></span><br><span class="line">    document.exitFullscreen(); </span><br><span class="line">  &#125;else&#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="自适应屏幕"><a href="#自适应屏幕" class="headerlink" title="自适应屏幕"></a>自适应屏幕</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">window.addEventListener(&#x27;resize&#x27;,()=&gt;&#123;</span><br><span class="line">  //更新摄像头</span><br><span class="line">  camera.aspect=window.innerWidth/window.innerHeight</span><br><span class="line">  //更新摄像机投影矩阵</span><br><span class="line">  camera.updateProjectionMatrix();</span><br><span class="line">  //更新渲染器</span><br><span class="line">  renderer.setSize(window.innerWidth,window.innerHeight)</span><br><span class="line">  //设置渲染器的像素比</span><br><span class="line">  renderer.setPixelRatio(window.devicePixelRatio)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.baidu.com/2021/12/01/10-12-33/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="KK">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KK">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/01/10-12-33/" class="post-title-link" itemprop="url">MySql</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-12-01 10:12:33" itemprop="dateCreated datePublished" datetime="2021-12-01T10:12:33+08:00">2021-12-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-09-14 21:38:01" itemprop="dateModified" datetime="2022-09-14T21:38:01+08:00">2022-09-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/web/" itemprop="url" rel="index"><span itemprop="name">web</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="MySql"><a href="#MySql" class="headerlink" title="MySql"></a>MySql</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ul>
<li>MySQL 官网下载最新版<code>https://dev.mysql.com/downloads/installer/</code></li>
<li>然后在 cmd 里面 cd 到<code>D:\mysql-8.0.11</code>安装目录</li>
<li>在该文件夹下创建 my.ini 配置文件编辑 my.ini 配置以下基本信息</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[client]</span><br><span class="line"># 设置mysql客户端默认字符集</span><br><span class="line">default-character-set=utf8</span><br><span class="line"></span><br><span class="line">[mysqld]</span><br><span class="line"># 设置3306端口</span><br><span class="line">port = 3306</span><br><span class="line"># 设置mysql的安装目录</span><br><span class="line">basedir=C:\\web\\mysql-8.0.11</span><br><span class="line"># 设置 mysql数据库的数据的存放目录MySQL 8+ 不需要以下配置，系统自己生成即可否则有可能报错</span><br><span class="line"># datadir=C:\\web\\sqldata</span><br><span class="line"># 允许最大连接数</span><br><span class="line">max_connections=20</span><br><span class="line"># 服务端使用的字符集默认为8比特编码的latin1字符集</span><br><span class="line">character-set-server=utf8</span><br><span class="line"># 创建新表时将使用的默认存储引擎</span><br><span class="line">default-storage-engine=INNODB</span><br></pre></td></tr></table></figure>

<blockquote>
<p>MySQL 数据库进行初始化命令操作时提示 my.ini 配置文件错误的解决方法<br>通过修改 MySQL 数据库中 my.ini 配置文件编码格式的方法解决此问题。<br>步骤：用记事本打开 my.ini 文件——》点击“文件”选择“另存为”——》将编码选为 ANSI——》保存覆盖——》重启 MySQL 。</p>
</blockquote>
<ul>
<li>以管理员身份打开 cmd 命令行工具切换目录<code>cd D:\mysql-8.0.11\bin</code></li>
<li>初始化数据库<code>mysqld --initialize --console</code>执行完成后会输出 root 用户的初始默认密码!!!!</li>
<li>安装<code>mysqld install</code></li>
<li>启动输入以下命令<code>net start mysql</code></li>
<li>停止<code>net stop mysql</code></li>
<li>登录 MySQL<code>mysql -u root -p</code></li>
<li>修改初始密码<code>ALTER USER USER() IDENTIFIED BY &#39;123456&#39;;</code></li>
</ul>
<h3 id="mysql-数据类型"><a href="#mysql-数据类型" class="headerlink" title="mysql 数据类型"></a>mysql 数据类型</h3><table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>整数类型</td>
<td>tinyint\smallint\mediumint\int\bigint</td>
</tr>
<tr>
<td>浮点小数类型</td>
<td>float\double</td>
</tr>
<tr>
<td>定点小数类型</td>
<td>decimal</td>
</tr>
<tr>
<td>时间、日期类型</td>
<td>year\time\date\datetime\timestamp</td>
</tr>
<tr>
<td>文本字符串</td>
<td>char\varchar\tinytext\text\mediumtext\longtext\enum\set</td>
</tr>
<tr>
<td>二进制字符串</td>
<td>bit\binary\varbinary\tinyblob\blog\mediumblob\longblob</td>
</tr>
</tbody></table>
<blockquote>
<p>char(n)和 varchar(n)中括号中 n 代表字符的个数并不代表字节个数比如 CHAR(30)就可以存储 30 个字符。</p>
</blockquote>
<h3 id="mysql-常用语句"><a href="#mysql-常用语句" class="headerlink" title="mysql 常用语句"></a>mysql 常用语句</h3><blockquote>
<p>不区分大小写</p>
</blockquote>
<table>
<thead>
<tr>
<th>语句</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>use xxx;</td>
<td>选择数据库</td>
</tr>
<tr>
<td>show databases;</td>
<td>显示数据库</td>
</tr>
<tr>
<td>show columns from customers;</td>
<td>获取 customers 表的一个列</td>
</tr>
<tr>
<td>CREATE DATABASE xxx;</td>
<td>创建数据库</td>
</tr>
<tr>
<td>drop database xxxx;</td>
<td>删除数据库</td>
</tr>
<tr>
<td>show create database xxxx;</td>
<td>查看数据库信息</td>
</tr>
<tr>
<td>alter database 库名 选项信息;</td>
<td>修改库信息</td>
</tr>
<tr>
<td>CREATE TABLE table_name (column_name column_type,….);</td>
<td>创建表</td>
</tr>
<tr>
<td>show tables;</td>
<td>查看所有表</td>
</tr>
<tr>
<td>show tables from xxx;</td>
<td>查看所有表</td>
</tr>
<tr>
<td>ALTER TABLE 表名 表的选项</td>
<td>修改表信息</td>
</tr>
<tr>
<td>RENAME TABLE 原表名 TO 新表名</td>
<td>对表进行重命名</td>
</tr>
<tr>
<td>RENAME TABLE 原表名 TO 库名.表名</td>
<td>可将表移动到另一个数据库</td>
</tr>
<tr>
<td>ALTER TABLE 表名 操作名</td>
<td>操作名:<code>ADD[ COLUMN] 字段名</code>– 增加字段;<code>AFTER 字段名</code>– 表示增加在该字段名后面;<code>FIRST</code>– 表示增加在第一个;<code>ADD PRIMARY KEY(字段名)</code>– 创建主键; <code>ADD UNIQUE [索引名] (字段名)</code>– 创建唯一索引;<code>ADD INDEX [索引名] (字段名)</code>– 创建普通索引;<code>DROP[ COLUMN] 字段名</code>– 删除字段;<code>MODIFY[ COLUMN] 字段名 字段属性</code>– 支持对字段属性进行修改不能修改字段名(所有原有属性也需写上);<code>CHANGE[ COLUMN] 原字段名 新字段名 字段属性</code>– 支持对字段名修改;<code>DROP PRIMARY KEY</code>– 删除主键(删除主键前需删除其 AUTO_INCREMENT 属性);<code>DROP INDEX 索引名</code>– 删除索引;<code>DROP FOREIGN KEY 外键</code> – 删除外键;</td>
</tr>
<tr>
<td>DROP TABLE[ IF EXISTS] 表名</td>
<td>删除表</td>
</tr>
<tr>
<td>TRUNCATE [TABLE] 表名</td>
<td>清空表</td>
</tr>
</tbody></table>
<blockquote>
<p>对于字段的定义<br>字段名 数据类型 [NOT NULL | NULL] [DEFAULT default_value] [AUTO_INCREMENT] [UNIQUE [KEY] | [PRIMARY] KEY] [COMMENT ‘string’]<br>– 表选项</p>
</blockquote>
<pre><code>-- 字符集
    CHARSET = charset_name
    如果表没有设定则使用数据库字符集
-- 存储引擎
    ENGINE = engine_name
    表在管理数据时采用的不同的数据结构结构不同会导致处理方式、提供的特性操作等不同
    常见的引擎InnoDB MyISAM Memory/Heap BDB Merge Example CSV MaxDB Archive
    不同的引擎在保存表的结构和数据时采用不同的方式
    MyISAM表文件含义.frm表定义.MYD表数据.MYI表索引
    InnoDB表文件含义.frm表定义表空间数据和日志文件
    SHOW ENGINES -- 显示存储引擎的状态信息
    SHOW ENGINE 引擎名 &#123;LOGS|STATUS&#125; -- 显示存储引擎的日志或状态信息
-- 数据文件目录
    DATA DIRECTORY = &#39;目录&#39;
-- 索引文件目录
    INDEX DIRECTORY = &#39;目录&#39;
-- 表注释
    COMMENT = &#39;string&#39;
-- 分区选项
    PARTITION BY ... (详细见手册)
</code></pre>
<p>/_ 列属性列约束 _/</p>
<ol>
<li>主键</li>
</ol>
<ul>
<li>能唯一标识记录的字段可以作为主键。</li>
<li>一个表只能有一个主键。</li>
<li>主键具有唯一性。</li>
<li>声明字段时用 primary key 标识。<br>也可以在字段列表之后声明</li>
</ul>
<p>例 create table tab ( id int, stu varchar(10), primary key (id));</p>
<ul>
<li>主键字段的值不能为 null。</li>
<li>主键可以由多个字段共同组成。此时需要在字段列表后声明的方法。</li>
</ul>
<p>例 create table tab ( id int, stu varchar(10), age int, primary key (stu, age));</p>
<ol start="2">
<li>unique 唯一索引唯一约束</li>
</ol>
<p>使得某字段的值也不能重复。</p>
<ol start="3">
<li><p>null 约束</p>
<p>null 不是数据类型是列的一个属性。<br>表示当前列是否可以为 null 表示什么都没有。<br>null, 允许为空。默认。<br>not null, 不允许为空。<br>insert into tab values (null, ‘val’);<br>– 此时表示将第一个字段的值设为 null, 取决于该字段是否允许为 null</p>
</li>
<li><p>default 默认值属性</p>
</li>
</ol>
<p>当前字段的默认值。<br>insert into tab values (default, ‘val’); – 此时表示强制使用默认值。<br>create table tab ( add_time timestamp default current_timestamp );<br>– 表示将当前时间的时间戳设为默认值。<br>current_date, current_time</p>
<ol start="5">
<li>auto_increment 自动增长约束</li>
</ol>
<p>自动增长必须为索引主键或 unique</p>
<p>只能存在一个字段为自动增长。</p>
<p>默认为 1 开始自动增长。可以通过表属性 auto_increment = x 进行设置或 alter table tbl auto_increment = x;</p>
<ol start="6">
<li>comment 注释</li>
</ol>
<p>例：create table tab ( id int ) comment ‘注释内容’;</p>
<ol start="7">
<li>foreign key 外键约束</li>
</ol>
<p>用于限制主表与从表数据完整性。</p>
<p>alter table t1 add constraint <code>t1_t2_fk</code> foreign key (t1_id) references t2(id);<br>– 将表 t1 的 t1_id 外键关联到表 t2 的 id 字段。<br>– 每个外键都有一个名字可以通过 constraint 指定</p>
<p>存在外键的表称之为从表子表外键指向的表称之为主表父表。</p>
<p>作用保持数据一致性完整性主要目的是控制存储在外键表从表中的数据。</p>
<p>MySQL 中可以对 InnoDB 引擎使用外键约束</p>
<p>语法</p>
<p>foreign key (外键字段 references 主表名 (关联字段) [主表记录删除时的动作] [主表记录更新时的动作]</p>
<p>此时需要检测一个从表的外键需要约束为主表的已存在的值。外键在没有关联的情况下可以设置为 null.前提是该外键列没有 not null。</p>
<p>可以不指定主表记录更改或更新时的动作那么此时主表的操作被拒绝。</p>
<p>如果指定了 on update 或 on delete 在删除或更新时有如下几个操作可以选择</p>
<ol>
<li><p>cascade 级联操作。主表数据被更新主键值更新从表也被更新外键值更新。主表记录被删除从表相关记录也被删除。</p>
</li>
<li><p>set null 设置为 null。主表数据被更新主键值更新从表的外键被设置为 null。主表记录被删除从表相关记录外键被设置成 null。但注意要求该外键列没有 not null 属性约束。</p>
</li>
<li><p>restrict 拒绝父表删除和更新。</p>
</li>
</ol>
<p>注意外键只被 InnoDB 存储引擎所支持。其他引擎是不支持的。</p>
<h3 id="增删查改"><a href="#增删查改" class="headerlink" title="增删查改"></a>增删查改</h3><ul>
<li>创建表</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE IF NOT EXISTS `runoob_tbl`(</span><br><span class="line">   `runoob_id` INT UNSIGNED AUTO_INCREMENT,</span><br><span class="line">   `runoob_title` VARCHAR(100) NOT NULL,</span><br><span class="line">   `runoob_author` VARCHAR(40) NOT NULL,</span><br><span class="line">   `submission_date` DATE,</span><br><span class="line">   PRIMARY KEY ( `runoob_id` )</span><br><span class="line">)ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br></pre></td></tr></table></figure>

<ul>
<li>增</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">INSERT [INTO] 表名 [(字段列表)] VALUES (值列表)[, (值列表), ...]</span><br><span class="line">        -- 如果要插入的值列表包含所有字段并且顺序一致，则可以省略字段列表。</span><br><span class="line">        -- 可同时插入多条数据记录！</span><br><span class="line">        REPLACE 与 INSERT 完全一样，可互换。</span><br><span class="line">INSERT [INTO] 表名 SET 字段名=值[, 字段名=值, ...]</span><br></pre></td></tr></table></figure>

<ul>
<li>查</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SELECT column_name,column_name</span><br><span class="line">FROM table_name</span><br><span class="line">[WHERE Clause]</span><br><span class="line">[LIMIT N][ OFFSET M]</span><br><span class="line">        -- 可来自多个表的多个字段</span><br><span class="line">        -- 其他子句可以不使用</span><br><span class="line">        -- 字段列表可以用*代替表示所有字段</span><br><span class="line">        你可以使用 LIMIT 属性来设定返回的记录数。</span><br><span class="line">你可以通过OFFSET指定SELECT语句开始查询的数据偏移量。默认情况下偏移量为0。</span><br></pre></td></tr></table></figure>

<ul>
<li>删</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DELETE FROM 表名[ 删除条件子句]</span><br><span class="line"></span><br><span class="line">没有条件子句则会删除全部</span><br></pre></td></tr></table></figure>

<ul>
<li>改</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">UPDATE table_name SET field1=new-value1, field2=new-value2</span><br><span class="line">[WHERE Clause]</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT * from runoob_tbl WHERE runoob_id=3;</span><br></pre></td></tr></table></figure>

<ul>
<li>WHERE 子句</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">   SELECT field1, field2,...fieldN FROM table_name1, table_name2...</span><br><span class="line">[WHERE condition1 [AND [OR]] condition2.....</span><br></pre></td></tr></table></figure>

<blockquote>
<p>MySQL 的 WHERE 子句的字符串比较是不区分大小写的。 你可以使用 BINARY 关键字来设定 WHERE 子句的字符串比较是区分大小写的。</p>
</blockquote>
<p><code>mysql&gt; SELECT * from runoob_tbl WHERE BINARY runoob_author=&#39;RUNOOB.COM&#39;;</code></p>
<ul>
<li>LIKE 子句</li>
</ul>
<blockquote>
<p>LIKE 子句中使用百分号 %字符来表示任意字符类似于 UNIX 或正则表达式中的星号 *。如果没有使用百分号 %, LIKE 子句与等号= 的效果是一样的。</p>
</blockquote>
<p><code>mysql&gt; SELECT * from runoob_tbl WHERE runoob_author LIKE &#39;%COM&#39;;</code></p>
<h3 id="nodejs-连接数据库"><a href="#nodejs-连接数据库" class="headerlink" title="nodejs 连接数据库"></a>nodejs 连接数据库</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">client does not support authentication protocol requested by server</span><br><span class="line">//出现连接失败的原因mysql8之前的版本中加密规则是mysql_native_password,而在mysql8之后,加密规则是caching_sha2_password。并提供了两种解决方案</span><br><span class="line">//把用户密码登录的加密规则还原成mysql_native_password这种加密方式</span><br><span class="line">ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;password&#x27; PASSWORD EXPIRE NEVER;这里的password是你正在使用的密码</span><br></pre></td></tr></table></figure>

<p>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD<br>方式1：直接使用数据库提供的SQL语句<br>=======</p>
<h3 id="MySQL-分页查询的-5-种方法"><a href="#MySQL-分页查询的-5-种方法" class="headerlink" title="MySQL 分页查询的 5 种方法"></a>MySQL 分页查询的 5 种方法</h3><blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>3c5cfeb51abb6cea4e5e0de711a8fed595408289</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>方式 1：</p>
<p>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD<br>适应场景: 适用于数据量较少的情况(元组百/千级)。很简单，该语句的意思就是查询m+n条记录，去掉前m条，返回后n条。无疑该查询能够实现分页，但m越大，查询性能就越低，因为MySQL需要扫描全部m+n条记录。</p>
<h1 id="方式2：基于索引再排序"><a href="#方式2：基于索引再排序" class="headerlink" title="方式2：基于索引再排序"></a>方式2：基于索引再排序</h1><p>select * from table order by id limit m, n;</p>
<p>很简单，该语句的意思就是查询 m+n 条记录，去掉前 m 条，返回后 n 条。无疑该查询能够实现分页，但 m 越大，查询性能就越低，因为 MySQL 需要扫描全部 m+n 条记录。</p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>3c5cfeb51abb6cea4e5e0de711a8fed595408289</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>方式 2：</p>
<p>select * from table where id &gt; #max_id# order by id limit n;</p>
<p>该查询同样会返回后 n 条记录，却无需像方式 1 扫描前 m 条记录，但必须在每次查询时拿到上一次查询（上一页）的最大 id（或最小 id），是比较常用的方式。</p>
<p>当然该查询的问题也在于我们不一定能拿到这个 id，比如当前在第 3 页，需要查询第 5 页的数据，就不行了。</p>
<p>方式 3：</p>
<p>为了避免方式 2 不能实现的跨页查询，就需要结合方式 1。</p>
<p>性能需要，m 得尽量小。比如当前在第 3 页，需要查询第 5 页，每页 10 条数据，且当前第 3 页的最大 id 为#max_id#，则：</p>
<p>select * from table where id &gt; #max_id# order by id limit 10, 10;</p>
<p>该方式就部分解决了方式 2 的问题，但如果当前在第 2 页，要查第 1000 页，性能仍然较差。</p>
<p>方式 4：</p>
<p>select * from table as a inner join (select id from table order by id limit m, n) as b on a.id = b.id order by a.id;</p>
<p>该查询同方式 1 一样，m 的值可能很大，但由于内部的子查询只扫描了 id 字段，而非全表，所以性能要强于方式 1，并且能够解决跨页查询问题。</p>
<p>方式 5：</p>
<p>select * from table where id &gt; (select id from table order by id limit m, 1) limit n;</p>
<p>该查询同样是通过子查询扫描字段 id，效果同方式 4。但方式 5 的性能会略好于方式 4，因为它不需要进行表的关联，而是一个简单的比较，在不知道上一页最大 id 的情况下，是比较推荐的用法。</p>
<h2 id="插入表情"><a href="#插入表情" class="headerlink" title="插入表情"></a>插入表情</h2><ol>
<li>MySQL 的版本</li>
</ol>
<p>utf8mb4 的最低 mysql 版本支持版本为 5.5.3+，若不是，请升级到较新版本。</p>
<ol start="2">
<li>MySQL 驱动</li>
</ol>
<p>5.1.34 可用,最低不能低于 5.1.13</p>
<ol start="3">
<li>修改 MySQL 配置文件</li>
</ol>
<p>修改 mysql 配置文件 my.cnf</p>
<p>my.cnf 一般在 etc/mysql/my.cnf 位置。找到后请在以下三部分里添加如下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[client]</span><br><span class="line">default-character-set = utf8mb4</span><br><span class="line"></span><br><span class="line">[mysql]</span><br><span class="line">default-character-set = utf8mb4</span><br><span class="line"></span><br><span class="line">[mysqld]</span><br><span class="line">character-set-client-handshake = FALSE</span><br><span class="line">character-set-server = utf8mb4</span><br><span class="line">collation-server = utf8mb4_unicode_ci</span><br><span class="line">init_connect=&#x27;SET NAMES utf8mb4&#x27;</span><br></pre></td></tr></table></figure>

<p>重启 mysql:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">一、MySQL启动方式</span><br><span class="line">1、使用 service 启动：service mysqld start</span><br><span class="line">2、使用 mysqld 脚本启动：/etc/init.d/mysqld start</span><br><span class="line">3、使用 safe_mysqld 启动：safe_mysqld&amp;</span><br><span class="line">二、MySQL停止</span><br><span class="line">1、使用 service 启动： service mysqld stop</span><br><span class="line">2、使用 mysqld 脚本启动：/etc/init.d/mysqld stop</span><br><span class="line">3、mysqladmin shutdown</span><br><span class="line">三、MySQL重启</span><br><span class="line">1、使用 service 启动：service mysqld restart</span><br><span class="line">2、使用 mysqld 脚本启动：/etc/init.d/mysqld restart</span><br><span class="line">四、强制关闭</span><br><span class="line">以上方法都无效的时候，可以通过强行命令：“killall mysql”来关闭MySQL，但是不建议用这样的方式，</span><br><span class="line">据库服务，有可能导致表损坏……所以自己掂量着用。</span><br><span class="line">Windows下重启MySQL服务,对于没装mysql图形管理端的用户来说启动和停止mysql服务：</span><br><span class="line">…\…\bin&gt;net stop mysql</span><br><span class="line">…\…\bin&gt;net start mysql</span><br></pre></td></tr></table></figure>

<blockquote>
<p>当数据库中涉及编码类型改变的时候，需要统一数据库，表，字段的编码类型，少一个都不行。</p>
</blockquote>
<p> 修改数据库字符集：<br> <code>ALTER DATABASE database_name CHARACTER SET = utf8mb4 COLLATE = utf8mb4_unicode_ci;</code><br> 修改表的字符集：<br> <code>ALTER TABLE table_name CONVERT TO CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;</code><br> 修改字段的字符集：<br> <code>ALTER TABLE table_name CHANGE column_name column_name VARCHAR(191) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;</code></p>
<ol start="4">
<li>查看是否成功修改<br>使用<code>SHOW VARIABLES WHERE Variable_name LIKE &#39;character_set_%&#39; OR Variable_name LIKE &#39;collation%&#39;;</code>查看当前编码,结果中的 collation_connection 、collation_database 、collation_server 是什么没关系。但必须保证系统变量 描述</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">character_set_client (客户端来源数据使用的字符集)</span><br><span class="line">character_set_connection (连接层字符集)</span><br><span class="line">character_set_database (当前选中数据库的默认字符集)</span><br><span class="line">character_set_results (查询结果字符集)</span><br><span class="line">character_set_server (默认的内部操作字符集)</span><br></pre></td></tr></table></figure>

<p>这几个变量必须是 utf8mb4,才能插入表情。</p>
<p>查看表编码<br><code>mysql&gt; show create table dictionary; # dictionary 是表名</code></p>
<ol start="5">
<li>数据库连接的配置<br>数据库连接参数中也要设置为 utf8bm4 格式，否则是无法插入的<br><code>charset=utf8mb4</code></li>
</ol>
<h2 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h2><ul>
<li>多表查询语法<br><code>select  字段1,字段2... from 表1,表2... [where 条件]</code></li>
<li>多表链接查询<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">多表连接查询语法(重点)</span><br><span class="line">SELECT 字段列表</span><br><span class="line">    FROM 表1  INNER|LEFT|RIGHT JOIN  表2</span><br><span class="line">ON 表1.字段 = 表2.字段;</span><br></pre></td></tr></table></figure>
内连接查询与多表联合查询的效果是一样的,左外连接查询 (左边表中的数据优先全部显示),右外连接查询 (右边表中的数据优先全部显示)</li>
</ul>
<p>全连接查询(显示左右表中全部数据)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//全连接查询：是在内连接的基础上增加 左右两边没有显示的数据</span><br><span class="line">//注意: mysql并不支持全连接 full JOIN 关键字</span><br><span class="line">//注意: 但是mysql 提供了 UNION 关键字.使用 UNION 可以间接实现 full JOIN 功能</span><br><span class="line">select * from student left join sc on student.sid = sc.sid</span><br><span class="line">UNION</span><br><span class="line">select * from student right join sc on student.sid = sc.sid;</span><br><span class="line">/注意: UNION 和 UNION ALL 的区别:UNION 会去掉重复的数据,而 UNION ALL 则直接显示结果/</span><br></pre></td></tr></table></figure>
<ul>
<li>三表查询</li>
</ul>
<p><code>select 表1.字段,表2.字段,表3.字段 from 表1 join 表2 on 表1.关联字段 = 表2.关联字段 join 表3 on 表2.关联字段 = 表3.关联字段 where....;</code></p>
<p>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD<br>方式3：基于索引再排序<br>=======</p>
<h2 id="数据库备份与还原"><a href="#数据库备份与还原" class="headerlink" title="数据库备份与还原"></a>数据库备份与还原</h2><blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>3c5cfeb51abb6cea4e5e0de711a8fed595408289</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<ol>
<li><p>备份原文件<br>MySQL中的每一个数据库和数据表分别对应文件系统中的目录和其下的文件。在Linux下数据库文件的存放目录一般为/var/lib/mysql。在Windows下这个目录视MySQL的安装路径而定。备份文件前，需要将MySQL服务停止，然后将数据库目录拷贝即可。恢复数据数据库时，需要先创建好一个数据库(不一定同名)，然后将备份出来的文件(注意，不是目录)复制到对应的MySQL数据库目录中。使用这一方法备份和恢复数据库时，需要新旧的MySQL版本一致，否则可能会出现错误。</p>
</li>
<li><p>使用命令</p>
</li>
</ol>
<p>备份数据库：<br><code>mysqldump –user=root –password=root密码 –lock-all-tables 数据库名 &gt; 备份文件.sql</code></p>
<p>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD<br>该方式就部分解决了方式2的问题，但如果当前在第2页，要查第1000页，性能仍然较差。</p>
<p>方式4：</p>
<p>select * from table as a inner join (select id from table order by id limit m, n) as b on a.id = b.id order by a.id;</p>
<p>该查询同方式1一样，m的值可能很大，但由于内部的子查询只扫描了id字段，而非全表，所以性能要强于方式1，并且能够解决跨页查询问题。</p>
<p>方式5：</p>
<p>select * from table where id &gt; (select id from table order by id limit m, 1) limit n;</p>
<p>该查询同样是通过子查询扫描字段id，效果同方式4。但方式5的性能会略好于方式4，因为它不需要进行表的关联，而是一个简单的比较，在不知道上一页最大id的情况下，是比较推荐的用法。</p>
<p>方法6: 基于索引使用prepare<br>（第一个问号表示pageNum，第二个？表示每页元组数）</p>
<p>—语句样式: MySQL中,可用如下方法:</p>
<p>代码如下:</p>
<p>PREPARE stmt_name FROM SELECT * FROM 表名称 WHERE id_pk &gt; (？* ？) ORDER BY id_pk<br>ASC LIMIT M<br>—适应场景: 大数据量。</p>
<p>—原因: 索引扫描,速度会很快. prepare语句又比一般的查询语句快一点。</p>
<p>方法7:利用MySQL支持ORDER操作可以利用索引快速定位部分元组,避免全表扫描<br>—比如: 读第1000到1019行元组(pk是主键/唯一键)。</p>
<p>代码如下:</p>
<h1 id="—SELECT-FROM-your-table-WHERE-pk-gt-1000-ORDER-BY-pk-ASC-LIMIT-0-20"><a href="#—SELECT-FROM-your-table-WHERE-pk-gt-1000-ORDER-BY-pk-ASC-LIMIT-0-20" class="headerlink" title="—SELECT * FROM your_table WHERE pk&gt;=1000 ORDER BY pk ASC LIMIT 0,20"></a>—SELECT * FROM your_table WHERE pk&gt;=1000 ORDER BY pk ASC LIMIT 0,20</h1><p>恢复数据库：<br><code>mysql -u root –password=root密码 数据库名 &lt; 备份文件.sql</code></p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>3c5cfeb51abb6cea4e5e0de711a8fed595408289</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.baidu.com/2021/11/12/22-23-33/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="KK">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KK">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/11/12/22-23-33/" class="post-title-link" itemprop="url">echart</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-11-12 22:23:33" itemprop="dateCreated datePublished" datetime="2021-11-12T22:23:33+08:00">2021-11-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-02-06 11:30:12" itemprop="dateModified" datetime="2023-02-06T11:30:12+08:00">2023-02-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/web/" itemprop="url" rel="index"><span itemprop="name">web</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="echart"><a href="#echart" class="headerlink" title="echart"></a>echart</h1><ol>
<li>echarts的图表是画在canvas上的， 可以通过grid设置来调整图表与canvas的间距：grid:{ x:50, y:50,x2:50,  y2:60,}</li>
<li>通过回调函数判断是否是第一个数据（params.dataIndex 的值）来决定是否显示相应的内容：formatter:(n)=&gt;{return n.dataIndex}</li>
<li>echarts3.0已支持多标题的设置</li>
<li>Echarts设置tooltip层级z-index<br>tooltip有一个extraCssText属性。所以可以设置该属性来修改它的样式：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tooltip:&#123;extraCssText:&#x27;z-index:2&#x27;&#125;</span><br></pre></td></tr></table></figure></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.baidu.com/2021/11/12/22-23-33/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="KK">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KK">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/11/12/22-23-33/" class="post-title-link" itemprop="url">wifiDog</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-11-12 22:23:33" itemprop="dateCreated datePublished" datetime="2021-11-12T22:23:33+08:00">2021-11-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-02-06 11:30:12" itemprop="dateModified" datetime="2023-02-06T11:30:12+08:00">2023-02-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/web/" itemprop="url" rel="index"><span itemprop="name">web</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="wifiDog"><a href="#wifiDog" class="headerlink" title="wifiDog"></a>wifiDog</h1><p>首先简介一下什么是Portal认证。Portal认证。通常也会叫Web认证。未认证用户上网时，设备强制用户登录到特定站点，用户能够免费訪问当中的服务。当用户须要使用互联网中的其他信息时，必须在门户站点进行认证。仅仅有认证通过后才干够使用互联网资源。</p>
<p>现金非常多中国移动CMCC、中国联通、中国电信ChinaNet的WIFI都使用这样的认证接入方式。</p>
<p>在OpenWRT上实现Portal认证，实际上早已有解决方式：</p>
<ol>
<li>chillispot，但原维护作者停止更新。被chillispot.info接管继续开发；</li>
</ol>
<p>2.coova-chilli，它是基于chillispot开发拓展的，功能最为强大；能够去官方看一下Coova-chilli；</p>
<p>3.wifidog</p>
<p>前两个因为原维护作者停止更新。笔者也没有深入研究，重点钻研了wifidog，Wifidog也是OpenWRT和DD-WRT中实现Portal比較出名的。</p>
<p>可是。Wifidog仅仅是实现AP认证网关，须要配合外部的Portalserver才干使用。Portal主要是提供认证所需的WEB页面且实现认证计费等的功能。尽管这也有非常多商用解决方式，比如wiwiz、wifiap等，可是这些商业解决方式的目标都是盈利。即使能够免费使用。免费账号的功能和权限都受到了非常大的限制，比如不能自己定义页面。Web认证页面有广告等等。有条件的人可能打算自己搭建Portalserver。可是看看Wifidog的官方Wiki。对搭建过程实在是难以理解。后来，笔者发现网络上另一个authpuppy方案，官方站点<a target="_blank" rel="noopener" href="http://www.authpuppy.org.是一个已实现好的wifidog认证server,里面包括各种插件供你使用,官方的安装过程也非常easy,假设你懂的html和面向对象编程的相关知识且拥有一个server,能够自行改动认证页面.使用authpuppy也是一个不错的方案./">www.authpuppy.org。是一个已实现好的Wifidog认证server，里面包括各种插件供你使用，官方的安装过程也非常easy，假设你懂的HTML和面向对象编程的相关知识且拥有一个server，能够自行改动认证页面。使用authpuppy也是一个不错的方案。</a></p>
<p>可是。即便如此，这些方案还是不够灵活，经过笔者认真钻研。查阅大量资料并经过多次抓包分析，最终理解了Wifidog的工作原理。</p>
<p>接下来笔者将会跟你介绍怎样自行编写一个轻量级的Web Portal认证server。当然。这须要你具有程序设计基础，HTML、CSS当然是少不得的。后端开发语言能够使用PHP或Python或Java等。</p>
<p>首先，须要简介一下Wifidog的工作原理：</p>
<p>1.client发出初始化请求，比方訪问 <a target="_blank" rel="noopener" href="http://www.baidu.com./">www.baidu.com。</a></p>
<p>2.网关的防火墙规则将这个请求重定向到本地网关的port上。这个port是Wifidog监听的port。</p>
<p>3.Wfidog提供一个HTTP重定向回复，重定向到Web认证页面。重定向的Url的Querystring中包括了Gateway的ID，Gateway的FQDN以及其它的信息。</p>
<p>4.用户向认证server发出认证请求</p>
<p><a href="http://portal_server:port/login_script">http://portal_server:port/login_script</a>?</p>
<p>gw_id=[GatewayID, default: “default”]</p>
<p>gw_address=[GatewayAddress, internal IP of router]</p>
<p>gw_port=[GatewayPort, port that wifidog Gateway is listening on]</p>
<p>url=[user requested url]；</p>
<p>5.网关返回一个（能够是自己定义的）splash（也称作“登录”）页面。</p>
<p>6.用户提供他的凭据信息，比方username和password。</p>
<p>7.成功认证的话，client将会被重定向到网关的自己的web页面上，而且带有一个认证凭据（一个一次性的token），内容比方：</p>
<p><a href="http://GatewayIP:GatewayPort/wifidog/auth?token=[auth">http://GatewayIP:GatewayPort/wifidog/auth?token=[auth</a> token]；</p>
<p>8.用户就是用获取到的凭据訪问网关。</p>
<p>9.网关去认证server询问token的有效性。</p>
<p>10.认证server确认token的有效性。</p>
<p>11.网关发送重定向给client。以从认证服务器上获取 成功提示页面，重定向到 <a href="http://portal_server:port/portal_script">http://portal_server:port/portal_script</a> 这个位置。</p>
<p>12.认证server通知客户请求成功，能够上网了。</p>
<p>图解:</p>
<p>图解Wifidog工作原理</p>
<p>然后考察一下Wifidog的配置文件/etc/wifidog.conf，关键的配置项是：</p>
<p>AuthServer {</p>
<p>Hostname             (Mandatory; Default: NONE)</p>
<p>SSLAvailable           (Optional; Default: no; Possible values: yes, no)</p>
<p>SSLPort               (Optional; Default: 443)</p>
<p>HTTPPort             (Optional; Default: 80)</p>
<p>Path                  (Optional; Default: /wifidog/ Note:  The path must be both prefixed and suffixed by /.  Use a single / for server root.)</p>
<p>LoginScriptPathFragment  (Optional; Default: login/?</p>
<p>Note:  This is the script the user will be sent to for login.)</p>
<p>PortalScriptPathFragment (Optional; Default: portal/? Note:  This is the script the user will be sent to after a successfull login.)</p>
<p>MsgScriptPathFragment    (Optional; Default: gw_message.php? Note:  This is the script the user will be sent to upon error to read a readable message.)</p>
<p>PingScriptPathFragment    (Optional; Default: ping/?</p>
<p>Note:  This is the script the user will be sent to upon error to read a readable message.)</p>
<p>AuthScriptPathFragment    (Optional; Default: auth/?</p>
<p>Note:  This is the script the user will be sent to upon error to read a readable message.)</p>
<p>}</p>
<h1 id="Listen-on-this-port"><a href="#Listen-on-this-port" class="headerlink" title="Listen on this port"></a>Listen on this port</h1><p>GatewayPort 2060</p>
<h1 id="Parameter-CheckInterval"><a href="#Parameter-CheckInterval" class="headerlink" title="Parameter: CheckInterval"></a>Parameter: CheckInterval</h1><h1 id="Default-60"><a href="#Default-60" class="headerlink" title="Default: 60"></a>Default: 60</h1><h1 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h1><h1 id=""><a href="#" class="headerlink" title=""></a></h1><h1 id="How-many-seconds-should-we-wait-between-timeout-checks-This-is-also"><a href="#How-many-seconds-should-we-wait-between-timeout-checks-This-is-also" class="headerlink" title="How many seconds should we wait between timeout checks.  This is also"></a>How many seconds should we wait between timeout checks.  This is also</h1><h1 id="how-often-the-gateway-will-ping-the-auth-server-and-how-often-it-will"><a href="#how-often-the-gateway-will-ping-the-auth-server-and-how-often-it-will" class="headerlink" title="how often the gateway will ping the auth server and how often it will"></a>how often the gateway will ping the auth server and how often it will</h1><h1 id="update-the-traffic-counters-on-the-auth-server-Setting-this-too-low"><a href="#update-the-traffic-counters-on-the-auth-server-Setting-this-too-low" class="headerlink" title="update the traffic counters on the auth server.  Setting this too low"></a>update the traffic counters on the auth server.  Setting this too low</h1><h1 id="wastes-bandwidth-setting-this-too-high-will-cause-the-gateway-to-take"><a href="#wastes-bandwidth-setting-this-too-high-will-cause-the-gateway-to-take" class="headerlink" title="wastes bandwidth, setting this too high will cause the gateway to take"></a>wastes bandwidth, setting this too high will cause the gateway to take</h1><h1 id="a-long-time-to-switch-to-it’s-backup-auth-server-s"><a href="#a-long-time-to-switch-to-it’s-backup-auth-server-s" class="headerlink" title="a long time to switch to it’s backup auth server(s)."></a>a long time to switch to it’s backup auth server(s).</h1><p>CheckInterval 60</p>
<h1 id="Parameter-ClientTimeout"><a href="#Parameter-ClientTimeout" class="headerlink" title="Parameter: ClientTimeout"></a>Parameter: ClientTimeout</h1><h1 id="Default-5"><a href="#Default-5" class="headerlink" title="Default: 5"></a>Default: 5</h1><h1 id="Optional-1"><a href="#Optional-1" class="headerlink" title="Optional"></a>Optional</h1><h1 id="-1"><a href="#-1" class="headerlink" title=""></a></h1><h1 id="Set-this-to-the-desired-of-number-of-CheckInterval-of-inactivity-before-a-client-is-logged-out"><a href="#Set-this-to-the-desired-of-number-of-CheckInterval-of-inactivity-before-a-client-is-logged-out" class="headerlink" title="Set this to the desired of number of CheckInterval of inactivity before a client is logged out"></a>Set this to the desired of number of CheckInterval of inactivity before a client is logged out</h1><h1 id="The-timeout-will-be-INTERVAL-TIMEOUT"><a href="#The-timeout-will-be-INTERVAL-TIMEOUT" class="headerlink" title="The timeout will be INTERVAL * TIMEOUT"></a>The timeout will be INTERVAL * TIMEOUT</h1><p>ClientTimeout 5</p>
<p>AuthServer是Portalserver的配置项。GatewayPort是Wifidog监听的地址。默认是2060。一般保持默认就可以；CheckInterval是心跳时长。单位是秒。什么是心跳呢，client认证成功之后，假设有网络訪问动作，Wifidog getway就会每隔一段时间訪问Portalserver的一个脚本。用于认证计费。当然。假设客户使用超时或超流量，也能够通过心跳强制client下线。ClientTimeout是用户一次认证成功后的网络訪问时长，超过这个时间须要又一次认证，这个时长并不是由ClientTimeout单独决定。取决于INTERVAL * TIMEOUT。</p>
<p>具体的配置信息能够訪问：<a target="_blank" rel="noopener" href="http://dev.wifidog.org/browser/trunk/wifidog/wifidog.conf%E3%80%82">http://dev.wifidog.org/browser/trunk/wifidog/wifidog.conf。</a></p>
<p>我们重点讨论Portalserver的配置项，Hostname是Portalserver的ip或者是域名。SSLAvailable和SSLPort是SSL加密配置，假设你的Portalserver有配置HTTPS加密，则须要配置这两项。Path是指你的脚本路径(举例。<a target="_blank" rel="noopener" href="http://a.com/to/%EF%BC%8C%E5%88%99a.com%E6%98%AF%E5%9F%9F%E5%90%8D%E3%80%82/to/%E6%98%AF%E8%B7%AF%E5%BE%84)%EF%BC%8C%E6%B3%A8%E6%84%8F%E8%B7%AF%E5%BE%84%E5%BF%85%E9%A1%BB%E4%BB%A5%E2%80%9C/%E2%80%9D%E5%BC%80%E5%A4%B4%E5%92%8C%E7%BB%93%E5%B0%BE%EF%BC%8C%E5%81%87%E8%AE%BE%E6%98%AF%E6%A0%B9%E8%B7%AF%E5%BE%84%E3%80%82%E5%88%99%E5%A1%AB%E4%B8%80%E4%B8%AA%E2%80%9C/%E2%80%9D%E5%B0%B1%E5%8F%AF%E4%BB%A5%EF%BC%9B%E6%8E%A5%E4%B8%8B%E6%9D%A5%E7%9A%845%E4%B8%AA%E9%85%8D%E7%BD%AE%E6%8C%87%E6%98%8E%E4%BD%A0%E7%9A%84%E8%84%9A%E6%9C%AC%E5%90%8D%EF%BC%8C%E8%BF%99%E8%AF%B4%E6%98%8E%E4%BA%86%E6%88%91%E4%BB%AC%E9%A1%BB%E8%A6%81%E5%86%99%E4%BA%94%E4%B8%AA%E8%84%9A%E6%9C%AC%EF%BC%8C%E6%88%91%E4%BC%9A%E5%85%B7%E4%BD%93%E8%AF%B4%E6%98%8E%E3%80%82">http://a.com/to/，则a.com是域名。/to/是路径)，注意路径必须以“/”开头和结尾，假设是根路径。则填一个“/”就可以；接下来的5个配置指明你的脚本名，这说明了我们须要写五个脚本，我会具体说明。</a></p>
<p>(下面文中涉及的“第几步”均是指Wifidog认证过程的步骤)</p>
<p>LoginScriptPathFragment配置项配置的是登陆脚本，它通过GET方式接受传入參数gw_address、gw_port、gw_id、mac和url。gw_address是AP Getway的ip地址；gw_port是Wifidog监听的端口。即上面介绍的wifidog.conf中的GatewayPort配置；gw_id是AP Getway的id。配置文件wifidog.conf中能够配置，默认值是default，这个值的作用是当存在多个AP是，server或管理员能够依据不同的id确定用户的接入点；mac是客户计算机的网卡物理地址。注意不是AP网关的mac。这个mac是用来识别客户计算机的；url是客户初始訪问的Url。这些Querystring都是AP Getway向client发出重定向请求自己主动生成的。</p>
<p>这个脚本同一时候须要提供登陆页面，假设登陆成功，须要向客户。端返回302重定向，重定向到：<a href="http://gw_address:gw_port/wifidog/auth">http://gw_address:gw_port/wifidog/auth</a>?</p>
<p>token=[token]；即实现第7步。当中[token]是你自己自己主动生成的token字符串，随机生成一个字符串就可以，可是长度最好长些，安全性更高，另外，token须要依据不同用户保存，最好保存于数据库中，之后的AP Getway询问token有效性(第9步)还须要用到。这里最好使用cookie或session，使之后的登陆成功页面能够推断用户已经成功，阻止未登录成功的人訪问认证成功页面。</p>
<p>PortalScriptPathFragment配置项配置的是登陆成功后server展示的脚本(第11步)，它通过GET方式接受1个传入參数，gw_id。这个脚本比較简单。告知用户登陆成功就可以，当然，最好重定向到用户之前想要方位的url。即第1步用户输入的URL。</p>
<p>MsgScriptPathFragment配置项配置的是错误信息展示脚本，它通过GET方式接受一个传入參数message，这个脚本也非常easy，展示message的内容就可以。目的是当认证过程出现错误，AP Getway会重定向到这个脚本，URL中含有错误的信息。</p>
<p>PingScriptPathFragment配置项配置的是心跳脚本。这个脚本它通过GET方式接受5个传入參数，gw_id，sys.uptime，sys.memfree，sys.load，wifidog.uptime，当中，sys.uptime指的是AP Getway的启动时间。sys.memfree指的是AP Getway的空暇内存，sys.load指的是AP Getway的CPU负载。wifidog.uptime指的是wifidog的启动时间，这个脚本每隔一段时间(Wifidog.conf里配置的CheckInterval)，Wifidog会自己主动訪问，可是其目的不是用户验证，而是帮助管理员管理AP节点，了解AP节点的负载情况，适时添加节点等，Wifidog訪问这个脚本时，须要这个脚本返回Pong。假设你没有统计AP节点负载数据的需求，能够丢弃这些数据。直接回应Pong，注意，这个回应仅仅包括“Pong”字符串。无需包括其它html标签。</p>
<p>AuthScriptPathFragment是用户认证脚本。实现的是第10步的功能。这个脚本它通过GET方式接受7个传入參数：stage、ip、mac、token、incoming、outcoming和gw_id。当中stage的值是login，ip是client的ip，注意不是AP Getwap的ip；mac是client的网卡物理地址。token就是你在认证脚本生成并返回给client的。incoming和outcoming用于流量控制，默认值为0；gw_id同上。</p>
<p>怎样识别用户登录成功，通过mac和token吧，LoginScriptPathFragment登陆脚本在用户登陆成功后须要记录用户的mac和token。然后在此处验证，假设匹配。回复Auth: 1，否则。回复Auth: 0。</p>
<p>另外，这个脚本也是心跳脚本。每隔一段时间Wifidog会自己主动訪问，假设用户使用时间超过限制或流量超过额度。server能够及时回应Auth: 0结束用户的訪问。</p>
<p>另外须要注意的是。回应相同无需包括html标签，另外，在Auth后的冒号和0/1之间，有一个空格，缺少这个空格也会导致出错。</p>
<p>在配置Wifidog的配置文件wifidog.conf是。配置脚本的配置项都必须以“?</p>
<p>”结尾，否则以GET方式传递的QueryString会因Url缺少问号訪问错误的脚本。</p>
<p>看到了吧。只5个简单脚本。就能够实现利用Wifidog的Portal认证，当然。这过中还能够有非常多应用尚未发掘，比方流量控制、带宽控制、结合Radiusserver实现认证等。你的开发也能够更上一层楼。实现很多其它功能。只是笔者另一个建议。在登录页面除了username和password意外，最好加个验证码，防止不怀好意之人暴力破解。</p>
<p>这样，你仅仅须要一个免费的空间，甚至是简单的百度云、新浪SAE等。就能够实现一个认证server。有的人可能还会问，能不能把这些脚本集成到路由器其中，我的回答是能，仅仅要你的脚本的功能不多。问题应该不大，可是这么做的风险比較大，路由的负载比較高，导致路由的执行会非常不稳定，甚至常常死机，这也是笔者亲身实践的结果，所以笔者不建议这么做。</p>
<p>最后啰嗦提醒的是，WiFidog是使用iptables基于三层协议工作的，所以使用Wifidog的结果是。不仅是Wifi接入须要Portal认证，有线接入相同须要认证。</p>
<p>避免这样的情况最简单的做法是设立mac白名单。可能有的人又会问。能不能做到仅是Wifi接入须要认证，有线接入的无需认证。有的人可能想更上一层楼，能不能开两个Wifi，仅当中一个Wifi须要认证，还有一个Wifi和有线网络不须要Portal认证，我的回答是能。至于详细做法，以后再介绍。</p>
<hr>
<ol>
<li><p>在这个配置文件里面第一格不能是空格，否则就会出错。</p>
</li>
<li><p>GatewayAddress  192.168.1.1 //路由器地址</p>
</li>
<li><p>GatewayID 123456789 //与服务器authpuppy中对应</p>
</li>
<li><p>ExternalInterface eth0.2  //外网接口，这个是wan口，连接到Internet的接口</p>
</li>
<li><p>GatewayInterface  br-lan  //内网接口，这个是lan口，连接到局域网的接口</p>
</li>
<li><p>AuthServer {                        //认证服务器配置项                             </p>
</li>
</ol>
<p>Hostname xx.xx.xx.xx //认证服务器IP地址或者名                                                 </p>
<p>SSLAvailable no //认证服务器有HTTPS加密则配置该项，此处无</p>
<p>SSLPort //认证服务器有HTTPS加密则配置该项，此处无</p>
<p>Path /authpuppy/web/        (认证路径)</p>
<p>/<strong><strong><strong><strong><strong><strong><strong><strong>此处为wifidog认证服务器的五个脚本文件，用于认证</strong></strong></strong></strong></strong></strong></strong></strong>****/</p>
<p>LoginScriptPathFragment //登录展示的脚本，以get的方式传入gw_address、gw_port、gw_id、mac、url(AP的IP地址，wifidog监听端口，AP的ID，客户端mac地址，客户初始访问的url)</p>
<p>PortalScriptPathFragment //客户端登陆成功后展示的脚本，之传入gw_id一个参数，用于告知用户登陆成功</p>
<p>MsgScriptPathFragment //错误信息展示脚本，通过get方式传入一个参数message，用于展示认证中出现错误的页面</p>
<p>PingScriptPathFragment //心跳脚本，通过get方式传入5个参数，gw_id，sys.uptime，sys.memfree，sys.load，wifidog.uptime；wifidog每隔一段时间访问一次这个脚本(时间间隔由CheckInterval决定)。注意，此脚本需要返回“Pong”字符串</p>
<p>AuthScriptPathFragment //用户认证脚本，通过get的方式接受7各参数，stage,ip,mac,token,incoming,outcoming和gw_id；stage的值为login,ip为客户端IP，mac为客户端的mac地址，                  }还有这个Path，一开始我是设置成  /   根目录，结果不行，出现了这个问题：HTTP Response from Server: [HTTP/1.1 404 Not Found后来设置成这个目录才可以。还有一点要注意的是Path的目录两边都要加/，不然也会出错。</p>
<ol start="7">
<li><p>GatewayPort 2060 //wifidog的监听地址，通常保持默认</p>
</li>
<li><p>CheckInterval 60 //心跳时长，单位是秒，</p>
</li>
</ol>
<p>心跳：客户端认证成功，如果有网络访问动作，Wifidog getway就会每隔一段时间访问Portal服务器的一个脚本，用于认证计费，当然，如果客户使用超时或超流量，也可以通过心跳强制客户端下线</p>
<ol start="9">
<li>ClientTimeout 5 //ClientTimeout是用户一次认证成功后的网络访问时长，超过这个时间需要重新认证</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.baidu.com/2021/11/12/20-23-33/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="KK">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KK">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/11/12/20-23-33/" class="post-title-link" itemprop="url">element UI</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-11-12 20:23:33" itemprop="dateCreated datePublished" datetime="2021-11-12T20:23:33+08:00">2021-11-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-02-06 11:33:46" itemprop="dateModified" datetime="2023-02-06T11:33:46+08:00">2023-02-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/web/" itemprop="url" rel="index"><span itemprop="name">web</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="element-UI"><a href="#element-UI" class="headerlink" title="element UI"></a>element UI</h1><h2 id="element的表单校验输入框有值但校验未通过："><a href="#element的表单校验输入框有值但校验未通过：" class="headerlink" title="element的表单校验输入框有值但校验未通过："></a>element的表单校验输入框有值但校验未通过：</h2><ul>
<li><p><code>:model=&quot;ruleForm&quot;</code> 绑定的<code>ruleForm</code>值是否挂载成功并且操作的是否是这个表单。</p>
</li>
<li><p><code>:rules=&quot;rules&quot;</code> 校验的规则格式绑定的<code>rules</code>是否定义并且格式正确为对象数组。</p>
</li>
<li><p><code>el-form-item中的</code>prop=”name”<code>是否和rules中的</code>name: [ { required: true, message: ‘请输入活动名称’, trigger: ‘blur’ }, ], <code>的名称一致，两个</code>name`相同的，element的校验就是根据这个prop找对应的输入框的。</p>
</li>
<li><p><code>&lt;el-input v-model=&quot;ruleForm.name&quot;&gt;&lt;/el-input&gt;</code> 的<code>v-model=&quot;ruleForm.name&quot;</code>确保对象<code>ruleForm</code>中有<code>name</code>这个属性！</p>
</li>
</ul>
<h2 id="el-table格式化el-table-column内容："><a href="#el-table格式化el-table-column内容：" class="headerlink" title="el-table格式化el-table-column内容："></a>el-table格式化el-table-column内容：</h2><ul>
<li>v-if判断<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;template slot-scope=&quot;scope&quot;&gt;</span><br><span class="line">        &lt;span v-if=&quot;scope.row.xxxx == 0&quot;&gt;&lt;/span&gt;</span><br><span class="line">    &lt;/template&gt;</span><br></pre></td></tr></table></figure></li>
<li>使用formatter属性<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;el-table-column prop=&quot;xxx&quot;   :formatter=&quot;function(row, column)&#123;xxxx&#125;&quot;&gt;</span><br></pre></td></tr></table></figure>
<h2 id="ElementUI的el-table-默认内容不换行，让el-table-column根据占位符-n换行："><a href="#ElementUI的el-table-默认内容不换行，让el-table-column根据占位符-n换行：" class="headerlink" title="ElementUI的el-table 默认内容不换行，让el-table-column根据占位符\n换行："></a>ElementUI的el-table 默认内容不换行，让el-table-column根据占位符\n换行：</h2></li>
</ul>
<p>添加css样式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.el-table &gt;&gt;&gt;.cell &#123;</span><br><span class="line">    white-space: pre-line;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="点击时获取列表的值，可通过给节点添加data自定义属性，通过点击事件e-currentTarget-dataset获取属性值"><a href="#点击时获取列表的值，可通过给节点添加data自定义属性，通过点击事件e-currentTarget-dataset获取属性值" class="headerlink" title="点击时获取列表的值，可通过给节点添加data自定义属性，通过点击事件e.currentTarget.dataset获取属性值"></a>点击时获取列表的值，可通过给节点添加data自定义属性，通过点击事件e.currentTarget.dataset获取属性值</h2><h2 id="element获取table表格行数据，可通过template设置slot-scope-“scope”属性，在传参时使用scope-row-xxxx拿到当前行的数据"><a href="#element获取table表格行数据，可通过template设置slot-scope-“scope”属性，在传参时使用scope-row-xxxx拿到当前行的数据" class="headerlink" title="element获取table表格行数据，可通过template设置slot-scope=“scope”属性，在传参时使用scope.row.xxxx拿到当前行的数据"></a>element获取table表格行数据，可通过template设置slot-scope=“scope”属性，在传参时使用scope.row.xxxx拿到当前行的数据</h2><h2 id="当只有⼀个el-input的时候，可以⽤elementUI的⾃带的回车键触发提交事件但是有时候会同时触发刷新页⾯，这样可以在el-form上添加-submit-native-prevent来解决"><a href="#当只有⼀个el-input的时候，可以⽤elementUI的⾃带的回车键触发提交事件但是有时候会同时触发刷新页⾯，这样可以在el-form上添加-submit-native-prevent来解决" class="headerlink" title="当只有⼀个el-input的时候，可以⽤elementUI的⾃带的回车键触发提交事件但是有时候会同时触发刷新页⾯，这样可以在el-form上添加@submit.native.prevent来解决"></a>当只有⼀个el-input的时候，可以⽤elementUI的⾃带的回车键触发提交事件但是有时候会同时触发刷新页⾯，这样可以在el-form上添加@submit.native.prevent来解决</h2><h2 id="element-el-input的autofocus失效问题解决"><a href="#element-el-input的autofocus失效问题解决" class="headerlink" title="element el-input的autofocus失效问题解决"></a>element el-input的autofocus失效问题解决</h2><blockquote>
<p>autofocus是input的原生属性,饿了么组件也支持这种方法, 但是input外面还有其他组件, 导致autofocus失效, 只能手动调用focus方法:组件上绑定ref，手动调用focus()</p>
</blockquote>
<h2 id="elementUI选择器select获取选中对象"><a href="#elementUI选择器select获取选中对象" class="headerlink" title="elementUI选择器select获取选中对象"></a>elementUI选择器select获取选中对象</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">有些情况下需要获取选中对象的全部数据，添加 value-key=&quot;id&quot; ，value-key 为唯一性标识, 将 value 绑定为item</span><br><span class="line">&lt;el-select v-model=&quot;area&quot; value-key=&quot;id&quot; placeholder=&quot;请选择区域&quot;&gt;</span><br><span class="line">    &lt;el-option v-for=&quot;item in areaLsit&quot; :key=&quot;item.id&quot; :label=&quot;item.areaName&quot; :value=&quot;item&quot;&gt;</span><br><span class="line">    &lt;/el-option&gt;</span><br><span class="line">&lt;/el-select&gt;</span><br></pre></td></tr></table></figure>

<h2 id="vue-css-gt-gt-gt-deep-穿透，深度查询样式在chrome89-edge新版本中无效问题"><a href="#vue-css-gt-gt-gt-deep-穿透，深度查询样式在chrome89-edge新版本中无效问题" class="headerlink" title="vue css &gt;&gt;&gt; /deep/穿透，深度查询样式在chrome89 edge新版本中无效问题"></a>vue css &gt;&gt;&gt; /deep/穿透，深度查询样式在chrome89 edge新版本中无效问题</h2><p>大概理解应该是<code>/deep/</code>基本上无效了，直接替换成“”空格，或者<code>&gt;&gt;&gt;</code>代替处理；</p>
<p>于是，在项目中全局替换<code>/deep/</code>为空格，但是部分页面会有错乱问题，于是将替换为空格后，仍然无效的样式部分，添加<code>&gt;&gt;&gt;</code>,居然可以了，但是对于Sass Less之类的预处理器是无法正确解析 <code>&gt;&gt;&gt;</code>的，所以要保证样式是css文件；</p>
<p>还有一点要强调，<code>&gt;&gt;&gt;</code>在html单页面下貌似无效，在vue项目中有效；</p>
<p>项目问题基本解决后，做一下汇总的情况下，上网查看关于样式穿透，发现除了<code>&gt;&gt;&gt;</code>、<code>/deep/</code>外，还有一个<code>::v-deep</code>，写法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;style lang=&quot;scss&quot; scoped&gt;</span><br><span class="line">/用法1/</span><br><span class="line">.a&#123;</span><br><span class="line">::v-deep .b &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line">/用法2/</span><br><span class="line">.a ::v-deep .b &#123;&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.baidu.com/2021/11/12/20-21-33/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="KK">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KK">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/11/12/20-21-33/" class="post-title-link" itemprop="url">subline text 编辑器</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-11-12 20:21:33" itemprop="dateCreated datePublished" datetime="2021-11-12T20:21:33+08:00">2021-11-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-11-28 20:22:29" itemprop="dateModified" datetime="2021-11-28T20:22:29+08:00">2021-11-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/tool/" itemprop="url" rel="index"><span itemprop="name">tool</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="subline-text-编辑器使用"><a href="#subline-text-编辑器使用" class="headerlink" title="subline text 编辑器使用"></a>subline text 编辑器使用</h1><h2 id="安装package-control"><a href="#安装package-control" class="headerlink" title="安装package control"></a>安装package control</h2><ol>
<li>首先打开编辑器，然后找到顶部菜单的<code>Tools</code>菜单</li>
<li>然后选择<code>Tools</code>菜单下面的<code>Command Paletter</code>选项</li>
<li>在打开的命令行模式输入框中输入<code>pac</code>,然后回车安装</li>
<li>稍等片刻以后,软件会提示信息,安装完了重新启动软件</li>
<li>重启以后,在菜单栏的<code>preferences</code>菜单下你会看到<code>Package Settings</code>和<code>Package Control</code>两个选项，以后会用到他们</li>
</ol>
<h2 id="设置为中文"><a href="#设置为中文" class="headerlink" title="设置为中文"></a>设置为中文</h2><ol>
<li>点击Package Control选项</li>
<li>选择installPackage</li>
<li>搜索ChineseLocalizations</li>
<li>点击安装</li>
</ol>
<h2 id="代码高亮"><a href="#代码高亮" class="headerlink" title="代码高亮"></a>代码高亮</h2><ol>
<li>将鼠标移至右下角的按钮区、点击</li>
<li>在弹出的菜单中找到当前文件类型</li>
<li>如果你想每次打开页面都出现语法高亮，可以将鼠标移至顶部“open all with current extension as…”，在弹出选项中选择“html”（按照你常用的文件类型设置），即可再下次打开文件后就出现高亮显示</li>
</ol>
<h2 id="设置自动保存"><a href="#设置自动保存" class="headerlink" title="设置自动保存"></a>设置自动保存</h2><ol>
<li>点击<code>Preferences</code>里的设置-用户</li>
<li><code>ctrl+f</code>找到<code>save_on_focus_lost</code>，把后面的<code>false</code>改成<code>true</code>就好</li>
</ol>
<h2 id="设置vim模式"><a href="#设置vim模式" class="headerlink" title="设置vim模式"></a>设置vim模式</h2><ol>
<li>点击<code>Preferences</code>里的设置-用户</li>
<li>编辑<code>Preferences.sublime-settings--User</code>文件</li>
<li>设置中的ignored_packages对应的列表中去掉Vintage这一项,没有ignored_packages这项就添加</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;ignored_packages&quot;:</span><br><span class="line">[</span><br><span class="line">//&quot;Vintage&quot;</span><br><span class="line">],</span><br></pre></td></tr></table></figure>
<h2 id="分屏"><a href="#分屏" class="headerlink" title="分屏"></a>分屏</h2><ol>
<li><p><code>Shift+Alt</code>+<code>1,2,3,4,5</code></p>
</li>
<li><p>文件克隆,拖放到另一个窗口上</p>
</li>
</ol>
<p>##关闭更新</p>
<p><code>Preferencens</code>设置用户, 添加<code>&quot;update_check&quot;: false</code></p>
<h2 id="关闭缩略图"><a href="#关闭缩略图" class="headerlink" title="关闭缩略图"></a>关闭缩略图</h2><p>关闭这个缩略图,需要到菜单视图里面设置，首先点击菜单栏<code>view</code>——<code>hideMiniMap</code></p>
<h2 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h2><p>按键绑定-用户-&gt;打开后在最后面添加</p>
<p><code>&#123; &quot;keys&quot;: [&quot;ctrl+shift+q&quot;], &quot;command&quot;: &quot;reindent&quot;&#125;,</code></p>
<h2 id="sublime-中用正则-去除空行、html注释和js注释"><a href="#sublime-中用正则-去除空行、html注释和js注释" class="headerlink" title="sublime 中用正则 去除空行、html注释和js注释"></a>sublime 中用正则 去除空行、html注释和js注释</h2><ol>
<li>去除空行</li>
</ol>
<p><code>CTRL+H</code>打开<code>replace</code>功能，勾选上左侧的<code>regular expression</code>，并填写 </p>
<p><code>find what</code>栏 : <code>\s+$</code>  （正则表达式）<br><code>replace with</code>栏 : （这行留空） </p>
<p>接着点<code>replace all</code>即可</p>
<ol start="2">
<li>去除html注释</li>
</ol>
<p><code>CTRL+H</code>打开<code>replace</code>功能，勾选上左侧的<code>regular expression</code>，并填写 </p>
<p><code>find what</code>栏 :<code> &lt;!--[\s\S]*?--&gt;</code>  （正则表达式）<br><code>replace with</code>栏 : （这行留空） </p>
<p>接着点<code>replace all</code>即可</p>
<ol start="3">
<li>去除js注释</li>
</ol>
<p><code>CTRL+H</code>打开<code>replace</code>功能，勾选上左侧的<code>regular expression</code>，并填写 </p>
<p><code>find what</code>栏 : <code>/\*[\s\S]*?/ </code> （正则表达式）<br><code>replace with</code>栏 : （这行留空） </p>
<p>接着点<code>replace all</code>即可</p>
<h2 id="解决文件名方格乱码"><a href="#解决文件名方格乱码" class="headerlink" title="解决文件名方格乱码"></a>解决文件名方格乱码</h2><p>可以在Sublime的user-settings中，覆盖默认的dpi，让Sublime以一个较小的文字显示</p>
<ol>
<li><p>点击Preferences –&gt; Settings–User</p>
</li>
<li><p>在最后一行加上”dpi_scale”: 1.0 （注意：在加上最后一段的时候，前面的字段要加上逗号“，”这是Sublime自己的命名规范）</p>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.baidu.com/2021/08/22/20-22-11/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="KK">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KK">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/22/20-22-11/" class="post-title-link" itemprop="url">VScode</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-08-22 20:22:11" itemprop="dateCreated datePublished" datetime="2021-08-22T20:22:11+08:00">2021-08-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-02-15 20:53:15" itemprop="dateModified" datetime="2023-02-15T20:53:15+08:00">2023-02-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/tool/" itemprop="url" rel="index"><span itemprop="name">tool</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ul>
<li>VScode关闭右侧预览功能：在设置中搜索”editor.minimap.enabled”把勾去掉</li>
<li>修改vscode配置文件改字体大小：打开VSCode安装目录下的如下文件VSCode\resources\app\out\vs\workbench\workbench.desktop.main.css查找 .part&gt;.content修改字体大小即可</li>
<li>自动保存：打开vscode窗口，单击左下角的设置(齿轮状)图标</li>
</ul>
<p>在设定按钮显示的菜单中，选择【Settings】选项。 这里是整个vs代码的设置入口</p>
<p>打开【settings】画面时，默认的【Auto Save】=【off】表示不自动保存，每次都需要用户自己手动保存</p>
<p>【后延迟】</p>
<p>1 )这是以一定的间隔自动保存的</p>
<p>2 )该【自动保存】选项需要指定间隔时间，以匹配下一个【自动保存延迟】配置项目，单位为毫秒</p>
<p>【onFocusChange】</p>
<p>1 )当焦点偏离编辑器当前窗口时自动保存</p>
<p>2 )即，即使在编辑器内部切换标签，也会触发自动保存</p>
<p>3 )本项目不需要【自动保存延迟】的设定值，此值也会被忽略</p>
<p>【onWindowChange】</p>
<p>1 )编辑器窗口失去焦点时，自动保存</p>
<p>2 )只有在焦点偏离整个编辑器时才会触发保存，在编辑器内部切换标签时不会自动保存</p>
<p>3 )本项目不需要【自动保存延迟】的设定值，此值也会被忽略</p>
<p>在【Settings】画面中修正值后，不点击追加保存按钮，自动保存设定的内容。</p>
<h2 id="vscode好用的插件系列"><a href="#vscode好用的插件系列" class="headerlink" title="vscode好用的插件系列"></a>vscode好用的插件系列</h2><p>git相关插件：gitLens、Git History、Git History Diff<br>汉化插件： Chinese (Simplified)<br>开发提示相关插件： Tabnine AI（强推）、Path Intellisense（路径提示）、Vetur、Volar、Auto Close Tag、Auto Complete Tag、Auto Rename Tag、HTML Snippets、Wrap Console Log Lite<br>浏览器调试插件： JavaScript Debugger、Debug Visualizer、scode-js-debug<br>静态服务器：Live Server<br>代码运行器： Code Runner<br>正则提示插件： any-rule、Regex Previewer（辅助验证正则结果）<br>Docker插件： Docker<br>格式化类插件： EditorConfig for VS Code、ESLint<br>进制文件查看： Hex Editor<br>TODO提示： Todo Tree<br>流程图绘制： drawio<br>PDF查看： vscode-pdf<br>Markdown预览：Markdown Preview Enhanced<br>SVG文件预览：SVG Viewer<br>图片预览（在html或者css写地址的时候可直接预览）：Image Preview<br>文件依赖分析（如：.vue文件可以通过该插件看到引用了哪些依赖）：Dependency Cruiser Extension<br>颜色选择、设置：Color Highlight、Color Picker<br>快速生成注释：vscode-fileheader 和 koroFileHeader <br>npm模块导入智能提示： npm Intellisense<br>接口请求：REST Client</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.baidu.com/2021/06/12/20-11-33/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="KK">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KK">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/12/20-11-33/" class="post-title-link" itemprop="url">NodeJs</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-06-12 20:11:33" itemprop="dateCreated datePublished" datetime="2021-06-12T20:11:33+08:00">2021-06-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-01-23 19:49:50" itemprop="dateModified" datetime="2022-01-23T19:49:50+08:00">2022-01-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/web/" itemprop="url" rel="index"><span itemprop="name">web</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="NodeJs"><a href="#NodeJs" class="headerlink" title="NodeJs"></a>NodeJs</h1><h2 id="Node-js模块化开发"><a href="#Node-js模块化开发" class="headerlink" title="Node.js模块化开发"></a>Node.js模块化开发</h2><p>Node.js规定一个Javascript文件就是一个模块，模块内部定义的变量和函数默认情况下外部无法得到。<br>模块内部可以使用exports对象进行成员导出，使用require方法导入其他模块。</p>
<h3 id="模块成员导出"><a href="#模块成员导出" class="headerlink" title="模块成员导出"></a>模块成员导出</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//a.js</span><br><span class="line">//在模块中定义变量</span><br><span class="line">let version=1.0;</span><br><span class="line">//模块中定义方法</span><br><span class="line">const sayHi=name=&gt;`hello！$&#123;name&#125;`	//es6新语法</span><br><span class="line">//向模块外部导出数据</span><br><span class="line">exports.version=version;</span><br><span class="line">exports.sayHi=sayHi;</span><br></pre></td></tr></table></figure>

<h3 id="模块成员的导入"><a href="#模块成员的导入" class="headerlink" title="模块成员的导入"></a>模块成员的导入</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//b.js</span><br><span class="line">//在b.js模块中导入模块a</span><br><span class="line">let a=require(&#x27;./b.js&#x27;);</span><br><span class="line">//输出b模块中的version变量</span><br><span class="line">console.log(a.version);</span><br><span class="line">//调用b模块中的sayHi方法</span><br><span class="line">console.log(a.sayHi(&#x27;XiaoMing&#x27;));</span><br></pre></td></tr></table></figure>
<p>模块成员导出的另一种方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">module.exports.version=version;</span><br><span class="line">module.exports.sayHi=sayHi;</span><br></pre></td></tr></table></figure>
<p>exports是module.exports的别名，导出对象最终以module.exports为准；</p>
<h2 id="package-json文件的作用"><a href="#package-json文件的作用" class="headerlink" title="package.json文件的作用"></a>package.json文件的作用</h2><p>项目描述文件，记录了当前项目信息。如：项目版本、作者、依赖的模块等等；使用<code>npm init -y</code>生成。其作用为（一）锁定包的版本，确保再次下载时不会因为包版本不同而产生问题。（二）加快下载速度，其记录着依赖的下载地址。</p>
<ul>
<li>开发依赖</li>
</ul>
<p>在项目开发阶段所需要的依赖，线上运营阶段不需要依赖的第三方包,称为开发依赖；可使用<code>npm install 包名 --save-dev</code>将包添加到package.json文件的devDependencies字段中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&quot;devDependencies&quot;:&#123;</span><br><span class="line">		&quot;gulp&quot;:&quot;^3.9.1&quot;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="Node-js中模块的加载机制"><a href="#Node-js中模块的加载机制" class="headerlink" title="Node.js中模块的加载机制"></a>Node.js中模块的加载机制</h2><p>模块查找规则</p>
<ul>
<li>当模块有路径没后缀时</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">require(&#x27;./find.js);</span><br><span class="line">require(&#x27;./find&#x27;);</span><br></pre></td></tr></table></figure>

<ol>
<li>require方法根据路径查找模块</li>
<li>如果模块后缀省略，则先找同名JS文件再找同名JS文件夹</li>
<li>如果找到同名文件夹，则继续寻找其中的index.js文件</li>
<li>如果没有index.js文件，就会去当前文件夹中的package.js文件中查找main选项中的入口文件</li>
<li>如果入口文件不存在或没有指定入口文件，则报错：模块未找到</li>
</ol>
<ul>
<li>当模块即没路径也没后缀时</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">require(&quot;find&quot;);</span><br></pre></td></tr></table></figure>
<ol>
<li>Node.js会假设它是系统模块，会去node_modules文件中寻找</li>
<li>先查看是否有同名js文件</li>
<li>在看有没有同名文件夹</li>
<li>若有，则继续寻找其中的index.js文件</li>
<li>如没有，则查看该文件夹中的package.json中的main选项确定模块的入口文件</li>
<li>若都没有，则报错</li>
</ol>
<h2 id="系统模块-Node运行环境提供的API"><a href="#系统模块-Node运行环境提供的API" class="headerlink" title="系统模块:Node运行环境提供的API"></a>系统模块:Node运行环境提供的API</h2><h3 id="fs文件操作"><a href="#fs文件操作" class="headerlink" title="fs文件操作"></a>fs文件操作</h3><p><code>const fs=require(&#39;fs&#39;);</code></p>
<p>读取文件内容:<code>fs.readFile(&#39;文件路径/文件名&#39;[,&#39;文件编码&#39;],callback);</code>(括号内为可选项)</p>
<p>实例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//读取上一级css目录下的base.css</span><br><span class="line">fs.readFile(&#x27;../css/base.css&#x27;,&#x27;utf-8&#x27;,(err,doc)=&gt;&#123;</span><br><span class="line">//如果读取错误参数err的值为错误对象，否则err的值为null</span><br><span class="line">//doc参数为文件内容</span><br><span class="line">if(err==null)&#123;</span><br><span class="line">//控制台中输出文件内容</span><br><span class="line">console.log(doc);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>写入文件内容：`fs.writeFile(‘文件路径/文件名称’,’数据’,callback);</p>
<p>实例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const conetent=&#x27;&lt;h3&gt;!!!!!!!!!!&lt;/h3&gt;&#x27;;</span><br><span class="line">fs.writeFile(&#x27;../index.html&#x27;,content,err=&gt;&#123;</span><br><span class="line">if(err!=null)&#123;</span><br><span class="line">console.log(err);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">console.log(&#x27;文件写入成功&#x27;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="路径拼接"><a href="#路径拼接" class="headerlink" title="路径拼接"></a>路径拼接</h3><p><code>path.join(&#39;路径&#39;,&#39;路径&#39;,..);</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//导入path模块</span><br><span class="line">const path=require(&#x27;path&#x27;);</span><br><span class="line">//路径拼接</span><br><span class="line">let finialPath=path.join(&#x27;itcast&#x27;,&#x27;a,&#x27;css&#x27;,&#x27;test.css&#x27;);</span><br><span class="line">//输出</span><br><span class="line">console.log(finialPath);</span><br><span class="line">//用__dirname获取当前文件的绝对路径</span><br><span class="line">const fs=require(&#x27;fs&#x27;);</span><br><span class="line">fs.readFile(path.join(__dirname,&#x27;test.css&#x27;),&#x27;utf-8&#x27;,(err,doc)=&gt;&#123;</span><br><span class="line">console.log(err);</span><br><span class="line">console.log(doc);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="第三方模块"><a href="#第三方模块" class="headerlink" title="第三方模块"></a>第三方模块</h2><p>npm(node package manager):node的第三方模块管理工具</p>
<ul>
<li>下载：<code>npm install 模块名</code></li>
<li>卸载：<code>npm uninstall package 模块名</code></li>
</ul>
<p>全局安装和本地安装：一般命令行工具全局安装，库文件本地安装</p>
<h3 id="第三方模块mine"><a href="#第三方模块mine" class="headerlink" title="第三方模块mine"></a>第三方模块mine</h3><p>其中mine.getType(路径);可根据路径返回请求的文件类型;可用于res.writeHead(200,{‘content-type’:’text/css;charset=utf8’})</p>
<h3 id="第三方模块art-template模板引擎"><a href="#第三方模块art-template模板引擎" class="headerlink" title="第三方模块art-template模板引擎"></a>第三方模块art-template模板引擎</h3><ol>
<li><p>下载：<code>npm install art-template</code></p>
</li>
<li><p>引入：<code>const template = require(&#39;art-template&#39;);</code></p>
</li>
<li><p>告诉模板引擎要拼接的数据和模板地址:<code>const html=template(&#39;模板数据&#39;,数据);</code></p>
</li>
</ol>
<p>实例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//导入模块</span><br><span class="line">const template = require(&#x27;art-template&#x27;);</span><br><span class="line">//拼接</span><br><span class="line">const html=template(&#x27;./index.art&#x27;,&#123;</span><br><span class="line">data:&#123;</span><br><span class="line">name: &#x27;xioaming&#x27;,</span><br><span class="line">age: 29</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//index.art</span><br><span class="line">&lt;div&gt;</span><br><span class="line">	&lt;span&gt;&#123;&#123;data.name&#125;&#125;&lt;/span&gt;</span><br><span class="line">	&lt;span&gt;&#123;&#123;data.age&#125;&#125;&lt;/span&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>模板语法</p>
<ul>
<li><p>数据输出<br>标准语法：<code>&#123;&#123;数据&#125;&#125;</code><br>原始语法：<code>&lt;%=数据%&gt;</code></p>
</li>
<li><p>原文输出：数据中带有HTML标签，默认情况下模板引擎不会解析标签,会转义后输出,若要解析则<br>标准语法：<code>&#123;&#123;@数据&#125;&#125;</code><br>原始语法：<code>&lt;%-数据%&gt;</code></p>
</li>
<li><p>条件判断<br>标准语法：<code>&#123;&#123;if 条件&#125;&#125;....&#123;&#123;else if 条件&#125;&#125;....&#123;&#123;/if&#125;&#125;</code><br>原始语法：<code>&lt;%if (条件) &#123;%>....<%&#125; else if(条件) &#123;%>....<%&#125;  %&gt;</code></p>
</li>
<li><p>循环<br>标准语法：<code>&#123;&#123;each 数据&#125;&#125; &#123;&#123;$index&#125;&#125; &#123;&#123;$value&#125;&#125;  &#123;&#123;/each&#125;&#125;</code><br>原始语法：<code>&lt;% for() &#123;%> ....<%&#125; %&gt;</code></p>
</li>
</ul>
</li>
<li><p>子模板</p>
</li>
</ul>
<p>将网站的公共区域（头部、页脚）抽离到单独文件中<br>标准语法：<code>&#123;include &#39;模板路径/footer.art&#39;&#125;</code><br>原始语法：<code>&lt;%include(&#39;模板路径&#39;)%&gt;</code></p>
<ul>
<li>模板继承</li>
</ul>
<p>将网站HTML骨架抽离到单独文件中，其他页面模板可以继承</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">!&lt;DOCTYPE HTML&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">	&lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">	&lt;title&gt;骨架模板&lt;/title&gt;</span><br><span class="line">	&#123;&#123;block &#x27;head&#x27;&#125;&#125; &#123;&#123;/block&#125;&#125;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">	&#123;&#123;block &#x27;content&#x27;&#125;&#125; &#123;&#123;/block&#125;&#125;	&lt;!--预留位置--&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>模板继承</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;extend &#x27;./test.art&#x27;&#125;&#125;</span><br><span class="line">&#123;&#123;block &#x27;head&#x27;&#125;&#125; &lt;link rel=&quot;stylesheet&quot; href=&quot;test.css&quot;&gt; &#123;&#123;/block&#125;&#125;</span><br></pre></td></tr></table></figure>


<ul>
<li><p>模板配置</p>
<ol>
<li>向模板中导入变量<code>template.default.imports.变量名=变量值(第三方模板的方法);</code>  在模板test.art中使用<code>&#123;&#123;dateFormat(time,'yyyy-mm-dd')&#125;&#125;</code></li>
<li>设置模板根目录<code>template.defaults.root=模板目录</code></li>
<li>设置模板默认后缀<code>template.defaults.extname=&#39;.art&#39;</code></li>
</ol>
</li>
</ul>
<h3 id="第三方模块router"><a href="#第三方模块router" class="headerlink" title="第三方模块router"></a>第三方模块router</h3><p>功能：实现路由<br>使用步骤：获取路由对象；调用路由对象提供的方法创建路由；启用路由；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const getRouter=require(&#x27;router&#x27;);</span><br><span class="line">const router=getRounter();</span><br><span class="line">router.get(&#x27;/add&#x27;,(req,res)=&gt;&#123;</span><br><span class="line">	res.end(&#x27;hello world!&#x27;);</span><br><span class="line">&#125;);</span><br><span class="line">server.on(&#x27;request&#x27;,(req,res)=&gt;&#123;</span><br><span class="line">router(req,res);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>


<h3 id="第三方模块serve-static"><a href="#第三方模块serve-static" class="headerlink" title="第三方模块serve-static"></a>第三方模块serve-static</h3><p>功能：静态资源访问服务</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const serverStatic=require(&#x27;serve-static&#x27;);</span><br><span class="line">const serve=serverStatic(&#x27;./pulic&#x27;);</span><br><span class="line">serve.on(&#x27;request&#x27;,()=&gt;&#123;</span><br><span class="line">serve(req,res);</span><br><span class="line">&#125;);</span><br><span class="line">server.listen(3000);</span><br></pre></td></tr></table></figure>


<h3 id="第三方模块Express-框架"><a href="#第三方模块Express-框架" class="headerlink" title="第三方模块Express 框架"></a>第三方模块Express 框架</h3><p>基于node平台的web应用开发框架，可使用<code>npm install express</code>下载</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//引用框架</span><br><span class="line">const express=require(&#x27;express&#x27;);</span><br><span class="line">//创建网站服务器</span><br><span class="line">const app=express();</span><br><span class="line"></span><br><span class="line">//当客户端以get方式访问/时</span><br><span class="line">app.get(&#x27;/&#x27;,(req.res)=&gt;&#123;</span><br><span class="line">//获取get参数</span><br><span class="line">console.log(req.query);</span><br><span class="line">//响应:sen方法会自动设置http状态码，响应头部,类型</span><br><span class="line">res.send(&#x27;hello!!!!&#x27;);</span><br><span class="line">&#125;);</span><br><span class="line">//当客户端以post方式访问/add时</span><br><span class="line">app.post(&#x27;/add&#x27;,(req.res)=&gt;&#123;</span><br><span class="line">//获取post参数：需要第三方模块body-parser</span><br><span class="line">console.log(req.body);</span><br><span class="line">res.send(&#x27;hello!!!!&#x27;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(3000);</span><br><span class="line">console.log(&#x27;server is runningn ...&#x27;);</span><br></pre></td></tr></table></figure>

<ul>
<li>第三方模块body-parser</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const bodyParser=require(&#x27;body-parser&#x27;);</span><br><span class="line">//配置body-parser模块</span><br><span class="line">app.use(bodyParser.urlencoded(&#123; extender: false &#125;));</span><br><span class="line">//接收请求</span><br><span class="line">app.post(&#x27;/add&#x27;,(req,res)=&gt;&#123;</span><br><span class="line"></span><br><span class="line">console.log(req.body);</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>构建模块化路由</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const express=require(&#x27;express&#x27;);</span><br><span class="line">//创建路由对象</span><br><span class="line">const home=express.Router();</span><br><span class="line">//将路由和请求路径进行匹配</span><br><span class="line">app.use(&#x27;/home&#x27;,home);</span><br><span class="line">//在home路由下继续创建路由</span><br><span class="line">home.get(&#x27;/index&#x27;,()=&gt;&#123;</span><br><span class="line">// 响应/home/index</span><br><span class="line">res.send(&#x27;welcome&#x27;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>参数路由</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//服务端</span><br><span class="line">app.get(&#x27;/find/:id&#x27;,(req,res)=&gt;&#123;</span><br><span class="line">	console.log(req.params);	//&#123;id:124&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//客户端</span><br><span class="line">localhost:3000/find/124</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>中间件:将客户端发来的请求进行拦截处理</li>
</ul>
<p>如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">app.get(&#x27;请求地址&#x27;,&#x27;处理函数&#x27;);</span><br><span class="line">app.post(&#x27;请求地址&#x27;,&#x27;处理函数&#x27;);</span><br></pre></td></tr></table></figure>
<p>针对一个请求可设置多个中间件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">app.get(&#x27;/&#x27;,(req,res,next)=&gt;&#123;	//next方法：该中间件处理后会将请求的控制权交给下一个中间件</span><br><span class="line">req.name=&#x27;xiaoming&#x27;;</span><br><span class="line">&#125;);</span><br><span class="line">app.get(&#x27;/&#x27;,(req,res)=&gt;&#123;</span><br><span class="line">console.log(req.name);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>app.use中间件用法</li>
</ul>
<p>会匹配所有的请求方法,直接传入请求处理函数代表接收所有请求</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app.use((req,res)=&gt;&#123;</span><br><span class="line">console.log(req.url);</span><br><span class="line">next();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>用于错误处理</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">app.get(&#x27;/index&#x27;,(req,res)=&gt;&#123;</span><br><span class="line">	throw new Error(&#x27;程序发生未知错误&#x27;);	//易出现错误的地方</span><br><span class="line">&#125;);</span><br><span class="line">app.use((err,req,res,next)=&gt;&#123;</span><br><span class="line">	res.status(500).send(err.message);	//只能用于处理同步代码错误</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//异步代码错误需要手动触发错误</span><br><span class="line">app.get(&#x27;/index&#x27;,(req,res,next)=&gt;&#123;</span><br><span class="line">	fs.readFile(&#x27;./test.c&#x27;,&#x27;utf-8&#x27;,(err,data)=&gt;&#123;</span><br><span class="line">	if(err)&#123;</span><br><span class="line">	next(err);	//易出现错误的地方</span><br><span class="line">&#125;</span><br><span class="line">&#125;&#125;);</span><br><span class="line">app.use((err,req,res,next)=&gt;&#123;</span><br><span class="line">	res.status(500).send(err.message);	//只能用于处理同步代码错误</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>静态资源的处理</li>
</ul>
<p>通过express内置的express.static托管静态文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.use(express.static(&#x27;./pulic&#x27;));</span><br></pre></td></tr></table></figure>

<ul>
<li>express模板引擎</li>
</ul>
<p>在原art-template模板引擎的基础上进行封装:<code>npm install art-template express-art-template</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//当渲染后缀为art的模板时，使用express-art-template</span><br><span class="line">app.engine(&#x27;art&#x27;,require(&#x27;express-art-template&#x27;));</span><br><span class="line">//设置模板存放目录</span><br><span class="line">app.set(&#x27;views&#x27;,path.jon(__dirname,&#x27;views&#x27;));</span><br><span class="line">//渲染模板时不写后缀，默认拼接art后缀</span><br><span class="line">app.set(&#x27;view engine&#x27;,&#x27;art&#x27;);</span><br><span class="line">//渲染模板</span><br><span class="line">app.get(&#x27;/&#x27;,(req,res)=&gt;&#123;</span><br><span class="line">res.render(&#x27;index&#x27;,&#123; mes:&#x27;模板数据&#x27;&#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>将变量设置到app.locals对象下，则所有的模板都可以获取到</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">app.locals.users=[&#123;	//users是自定义的</span><br><span class="line">	name: &#x27;xiaoming&#x27;,</span><br><span class="line">	age: 22</span><br><span class="line">&#125;,&#123;</span><br><span class="line">	name: &#x27;xiaomei&#x27;,</span><br><span class="line">	age:20</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure>

<h3 id="第三方模块Gulp"><a href="#第三方模块Gulp" class="headerlink" title="第三方模块Gulp"></a>第三方模块Gulp</h3><p>功能：项目上线，HTML、CSS、JS文件压缩合并，语法转换（es6、less）</p>
<p>使用：</p>
<ul>
<li>使用<code>npm install gulp</code>下载gulp库文件</li>
<li>在项目根目录下建立gulpfile.js文件</li>
<li>重构项目的文件夹结构src目录放置源代码文件，dist目录放置构建后文件</li>
<li>在gulpfile.js文件中编写任务</li>
<li>在命令行工具中执行gulp任务</li>
</ul>
<p>gulp提供的方法：</p>
<ul>
<li>gulp.src():获取任务要处理的文件</li>
<li>gulp.dest():输出文件</li>
<li>gulp.task():建立gulp任务</li>
<li>gulp.watch():监控文件的变化</li>
</ul>
<p>gulp插件：</p>
<ul>
<li>gulp-htmlminn: html文件压缩</li>
<li>gulp-csso:  css文件压缩</li>
<li>gulp-babel: javascript语法转化</li>
<li>gulp-less: less 语法转化</li>
<li>gulp-uglify: 压缩混淆JavaScript</li>
<li>gulp-file-include:公共文件包含</li>
<li>browsersync:浏览器实时同步</li>
</ul>
<h2 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h2><p>超文本传输协议。规定了客户端（浏览器）与服务器（网站服务器）之间请求和应答的标准</p>
<ul>
<li>静态资源：服务器不需要处理，可以直接响应给客户端的资源，如：css，JavaScript，image文件</li>
<li>动态资源：相同的请求地址，不同的响应资源</li>
</ul>
<h3 id="报文"><a href="#报文" class="headerlink" title="报文"></a>报文</h3><p>在HTTP请求和响应的过程中传递的数据块叫做报文</p>
<ul>
<li><p>请求报文</p>
<ol>
<li>请求方式：GET、POST</li>
<li>请求地址</li>
</ol>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">app.on(&#x27;request&#x27;,(req,res)=&gt;&#123;</span><br><span class="line">req.headers	//请求报文</span><br><span class="line">req.url		//请求地址</span><br><span class="line">req.method	//请求方法</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>请求参数</li>
</ol>
<ul>
<li><p>响应报文</p>
<ol>
<li>HTTP状态码： 200(请求成功)、400(客户端请求语法有误)、404(请求的资源未找到)、500(服务器错误)、</li>
<li>内容类型：<ul>
<li>text/html</li>
<li>text/css</li>
<li>application/javascript </li>
<li>image/jpeg</li>
<li>application/json</li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><p>指客户端请求地址,如：<code>http://localhost:8080/index</code>与服务端程序代码的对应关系，即请求什么响应什么；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">app.on(&#x27;request&#x27;,(req,res)=&gt;&#123;</span><br><span class="line">//获取客户端的请求路径</span><br><span class="line">let &#123;pathname&#125;=url.parse(req.url);</span><br><span class="line">//或写成</span><br><span class="line">//let pathname=url.parse(req.url).pathname;</span><br><span class="line">if(pathname==&#x27;/&#x27;||pathname==&#x27;/index&#x27;)&#123;</span><br><span class="line">res.end(&#x27;欢迎来到首页&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">res.end(&#x27;页面不存在&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>


<h2 id="创建web服务器"><a href="#创建web服务器" class="headerlink" title="创建web服务器"></a>创建web服务器</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//引用系统模块</span><br><span class="line">const http =require(&#x27;http&#x27;);</span><br><span class="line">//创建web服务器</span><br><span class="line">const app = http.createServer();</span><br><span class="line">//当客户端发送请求的时候</span><br><span class="line">app.on(&#x27;request&#x27;,(req,res)=&gt;&#123;</span><br><span class="line">//响应</span><br><span class="line"></span><br><span class="line">res.end(&#x27;hello&#x27;);</span><br><span class="line"></span><br><span class="line">//返回状态码和返回资源类型,若无，低级浏览器可能出问题</span><br><span class="line"></span><br><span class="line">res.writeHead(400,&#123;&#x27;content-type&#x27;:&#x27;text/html;charset=utf8&#x27;&#125;);</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//监听端口</span><br><span class="line">app.listen(3000);</span><br><span class="line">console.log(&quot;Server is running....&quot;);</span><br></pre></td></tr></table></figure>


<p>完善：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">//引用系统模块</span><br><span class="line">const http =require(&#x27;http&#x27;);</span><br><span class="line">const url=require(&#x27;url&#x27;);	//处理url地址模块</span><br><span class="line">const querystring=require(&#x27;querystring&#x27;);	//处理参数模块</span><br><span class="line"></span><br><span class="line">//创建web服务器</span><br><span class="line">const app = http.createServer();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//当客户端发送请求的时候</span><br><span class="line">app.on(&#x27;request&#x27;,(req,res)=&gt;&#123;</span><br><span class="line">//post参数是通过事件的方式接受的</span><br><span class="line">//data当请求参数传递的时候发出data事件</span><br><span class="line">//end当参数传递完成的时候时发出end事件</span><br><span class="line">//获取POST参数需要使用data事件和end事件；</span><br><span class="line">let postParams=&#x27;&#x27;;</span><br><span class="line">req.on(&#x27;data&#x27;,(params)=&gt;&#123;</span><br><span class="line">postParams+=params;	//接收的数据不是一次性发完的</span><br><span class="line">&#125;);</span><br><span class="line">req.on(&#x27;end&#x27;,()=&gt;&#123;</span><br><span class="line">console.log(postParams);</span><br><span class="line">console.log(querystring.parse(postParams));	//将参数转换为对象格式</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//响应</span><br><span class="line">res.end(&#x27;hello&#x27;);</span><br><span class="line"></span><br><span class="line">//返回状态码和相关信息</span><br><span class="line"></span><br><span class="line">res.writeHead(400,&#123;&#x27;content-type&#x27;:&#x27;text/html;charset=utf8&#x27;&#125;);</span><br><span class="line"></span><br><span class="line">//调用url模块方法parse();第一个参数为要处理的地址，第二个参数为是否处理为对象格式，true为是；</span><br><span class="line">console.log(url.parse(res.url,true));</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//监听端口</span><br><span class="line">app.listen(3000);</span><br><span class="line">console.log(&quot;Server is running....&quot;);</span><br></pre></td></tr></table></figure>


<h2 id="Node-js异步编程"><a href="#Node-js异步编程" class="headerlink" title="Node.js异步编程"></a>Node.js异步编程</h2><h4 id="同步api-当前api执行完成后，才能继续执行下一个api-同步代码执行完后才开始执行异步代码，再执行回调函数"><a href="#同步api-当前api执行完成后，才能继续执行下一个api-同步代码执行完后才开始执行异步代码，再执行回调函数" class="headerlink" title="同步api:当前api执行完成后，才能继续执行下一个api;同步代码执行完后才开始执行异步代码，再执行回调函数"></a>同步api:当前api执行完成后，才能继续执行下一个api;同步代码执行完后才开始执行异步代码，再执行回调函数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//同步api可以从返回值中拿到api执行结果，而异步api不行</span><br><span class="line"></span><br><span class="line">funciotn sum(x,y)&#123;</span><br><span class="line">return x+y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const re=sum(2,1);</span><br><span class="line"></span><br><span class="line">//异步</span><br><span class="line">function getMsg()&#123;</span><br><span class="line">setTimeout(function()&#123;</span><br><span class="line">return &#123;msg:&#x27;hello&#x27;&#125;,1000);</span><br><span class="line">&#125;</span><br><span class="line">const res=getMsg();	//undefined</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="异步api-当前api的执行，不会阻塞后续代码的执行-异步api通过回调函数获取返回值；"><a href="#异步api-当前api的执行，不会阻塞后续代码的执行-异步api通过回调函数获取返回值；" class="headerlink" title="异步api:当前api的执行，不会阻塞后续代码的执行;异步api通过回调函数获取返回值；"></a>异步api:当前api的执行，不会阻塞后续代码的执行;异步api通过回调函数获取返回值；</h4><ul>
<li>回调函数：自己定义函数让别人去调用</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function getData(callback)&#123;</span><br><span class="line">callback(&#x27;XiaoMing&#x27;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getData(function(n)&#123; console.log(&#x27;hello&#x27;+n);&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>promise解决回调地狱问题</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ler promise=new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">setTimeout(()=&gt;&#123;</span><br><span class="line">if(true)&#123;</span><br><span class="line">resolve(&#123;name:&#x27;xiaoming&#x27;&#125;);</span><br><span class="line">&#125;else&#123;</span><br><span class="line">reject(&#x27;error&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;,2000);</span><br><span class="line">&#125;):</span><br><span class="line">promise.then(result=&gt;console.log(result);//&#123;name:&#x27;xioaming&#x27;&#125;).catch(error=&gt;console.log(error);//error);</span><br></pre></td></tr></table></figure>

<ul>
<li>异步函数：终极方案，让异步代码写成同步代码形式，让代码不再有回调函数嵌套</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//在普通函数定义前加上async关键字</span><br><span class="line">//异步函数默认返回的时promise对象</span><br><span class="line">//在异步函数使用throw关键字进行错误抛出，之后的代码将不会执行</span><br><span class="line">const fn=async()=&gt;&#123;&#125;;</span><br><span class="line">async function fn()&#123;</span><br><span class="line">throw &#x27;error&#x27;;</span><br><span class="line"></span><br><span class="line">return ok;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(fn());</span><br><span class="line">fn().then(function(data)&#123;</span><br><span class="line">console.log(data);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">//awaite关键字只能出现在异步函数中</span><br><span class="line">//awaite promise对象； 暂停异步函数的执行，等待promise对象返回结果后在向下执行</span><br><span class="line">async function run()&#123;</span><br><span class="line">await p1();</span><br><span class="line">await p2();</span><br><span class="line">await p3();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>返回promise对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//使用util模块的promisify方法</span><br><span class="line">const fs=require(&#x27;fs&#x27;);</span><br><span class="line">const promisify=require(&#x27;util&#x27;).promisify;</span><br><span class="line">const readFile=pronisify(fs.readFile);</span><br><span class="line">async function run()&#123;</span><br><span class="line"></span><br><span class="line">let r1=awaite readFile(&#x27;./1.txt&#x27;,&#x27;utf8&#x27;);</span><br><span class="line">let r2=awaite readFile(&#x27;./2.txt&#x27;,&#x27;utf8&#x27;);</span><br><span class="line">console.log(r1,r2);</span><br><span class="line">&#125;</span><br><span class="line">run();</span><br></pre></td></tr></table></figure>

<p>捕获错误:</p>
<p><code>try catch</code>可以捕获异步函数以及其他同步代码在执行过程中发生的错误，但不能捕获其他类型api发生的错误。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">app.get(&#x27;/&#x27;,async(req,res,next)=&gt;&#123;</span><br><span class="line">try&#123;</span><br><span class="line">await User.fid(&#123;name:&#x27;xiaoming&#x27;&#125;);</span><br><span class="line">&#125;</span><br><span class="line">catch(er)&#123;</span><br><span class="line">next(er);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>




<h2 id="全局对象global"><a href="#全局对象global" class="headerlink" title="全局对象global"></a>全局对象global</h2><p>在浏览器中全局对象时window,在node中全局对象是global</p>
<p>Node中的全局对象有以下方法，可省略global：<code>console.log()</code>,<code>setTimeout()</code>,clearEimeout()<code>,</code>setInternal()<code>,</code>clearInterval`</p>
<h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><p>存储数据的仓库：mysql、MongoDB、Oracle</p>
<p>相关概念：</p>
<table>
<thead>
<tr>
<th>术语</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>database</td>
<td>数据仓库,可建立多个数据库</td>
</tr>
<tr>
<td>collection</td>
<td>集合，一组数据的集合</td>
</tr>
<tr>
<td>document</td>
<td>文档，一条具体的数据</td>
</tr>
<tr>
<td>field</td>
<td>字段,文档中的属性名称</td>
</tr>
</tbody></table>
<h3 id="第三方包Mongoose"><a href="#第三方包Mongoose" class="headerlink" title="第三方包Mongoose"></a>第三方包Mongoose</h3><p>使用node.js操作MongoDB数据库,下载<code>npm install mongoose</code></p>
<ul>
<li>数据库的连接</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const mongoose=require(&#x27;mongoose&#x27;);</span><br><span class="line">mongoose.connect(&#x27;mongodb://localhost/test&#x27;)</span><br><span class="line">.then(()=&gt;console.log(&#x27;数据库连接成功&#x27;))</span><br><span class="line">.catch(err=&gt;console.log(&#x27;fail!&#x27;,err));</span><br></pre></td></tr></table></figure>

<ul>
<li>创建数据库</li>
</ul>
<p>在MongoDB中不需要显示创建数据库，如果使用的数据库不存在，MongoDB会自动创建。</p>
<h4 id="MongoDB增删查改操作"><a href="#MongoDB增删查改操作" class="headerlink" title="MongoDB增删查改操作"></a>MongoDB增删查改操作</h4><ul>
<li>创建集合</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//对集合设定规则</span><br><span class="line">const courseSchema= new mongoose.Schema(&#123;</span><br><span class="line">name: String,</span><br><span class="line">author: String,</span><br><span class="line">isPublished: Boolean</span><br><span class="line">&#125;);</span><br><span class="line">//创建集合并合并规则</span><br><span class="line">const Course=mongoose.model(&#x27;Course&#x27;,courseSchema);//返回构造函数</span><br></pre></td></tr></table></figure>


<ul>
<li>创建文档</li>
</ul>
<p>即向集合中插入元素</p>
<p>第一种方法:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//创建集合实例</span><br><span class="line">const course=new Course(&#123;</span><br><span class="line">name: &#x27;tset&#x27;,</span><br><span class="line">author: &#x27;xiaoming&#x27;</span><br><span class="line">isPubulished: true</span><br><span class="line">&#125;);</span><br><span class="line">//保存数据</span><br><span class="line">course.save();</span><br></pre></td></tr></table></figure>

<p>第二种方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Course.create(&#123;</span><br><span class="line">name: &#x27;tset&#x27;,</span><br><span class="line">author: &#x27;xiaoming&#x27;</span><br><span class="line">isPubulished: true</span><br><span class="line">&#125;,</span><br><span class="line">(err,doc)=&gt;&#123;</span><br><span class="line">//错误对象</span><br><span class="line">console.log(err);</span><br><span class="line">//当前文档</span><br><span class="line">console.log(doc);</span><br><span class="line">&#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">//create返回的也是promise对象</span><br><span class="line">Course.create(&#123;</span><br><span class="line">name: &#x27;tset&#x27;,</span><br><span class="line">author: &#x27;xiaoming&#x27;</span><br><span class="line">isPubulished: true</span><br><span class="line">&#125;).then(doc=&gt;console.log(doc)).catch(err=&gt;console.log(err));</span><br></pre></td></tr></table></figure>

<ul>
<li>mongoose验证</li>
</ul>
<p>在创建集合规则时，可以设置当前字段的验证规则，验证失败则输入插入失败</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">const postSchema=new mongoose.Schema(&#123;</span><br><span class="line">	title:&#123;</span><br><span class="line">		type: String,		//字段类型</span><br><span class="line">		required: true		//true时代表该字段必填,不能为空</span><br><span class="line">		default: &#x27;默认title&#x27;	//默认值</span><br><span class="line">		validate:&#123;		//自定义验证器</span><br><span class="line">		validator: v=&gt;&#123;</span><br><span class="line">			//返回布尔值，true代表验证成功</span><br><span class="line">			//v要验证的值</span><br><span class="line">			return v.length&gt;4</span><br><span class="line">		&#125;</span><br><span class="line">			masseage: &#x27;error!!!!!&#x27;;</span><br><span class="line">		&#125;</span><br><span class="line">		&#125;,</span><br><span class="line">	authod:&#123;</span><br><span class="line">		type: String,		//字段类型</span><br><span class="line">		trim:true	//自动去除字符串两边的空格</span><br><span class="line">		required: [true,&#x27;错误信息&#x27;],	//自定义错误信息</span><br><span class="line">		minlength: 2,		//字符串最小长度</span><br><span class="line">		maxlength: [10,&#x27;长度错误&#x27;],		//字符串最大长度</span><br><span class="line">		</span><br><span class="line">		&#125;,</span><br><span class="line">	age:&#123;</span><br><span class="line">		type: Number,</span><br><span class="line">		min: 2,		//数值的最小值</span><br><span class="line">		max: 100	//数值的最大值	</span><br><span class="line">	&#125;,</span><br><span class="line">	category:&#123;</span><br><span class="line">		type:String,</span><br><span class="line">		enum:[&#x27;html&#x27;,&#x27;css&#x27;,&#x27;js&#x27;]		//枚举,输入的值必须在其中,否则报错</span><br><span class="line">		/*</span><br><span class="line">		enum:&#123;</span><br><span class="line">			values: [&#x27;html&#x27;,&#x27;css&#x27;,&#x27;js&#x27;],		</span><br><span class="line">			message: &#x27;error message&#x27;</span><br><span class="line">		&#125;</span><br><span class="line">		*/</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">const Post=mongoose.model(&#x27;Post&#x27;,postSchema);</span><br><span class="line">post.create(&#123;&#125;).then(re=&gt;console.log(re)).catch(err=&gt;console.log(err));</span><br></pre></td></tr></table></figure>

<ul>
<li><p>集合关联</p>
<ol>
<li>使用id对集合进行关联</li>
<li>使用populate方法进行关联集合查询<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//用户集合</span><br><span class="line">const User=mongoose.model(&#x27;User&#x27;,new mongoose.Schema(&#123;name:&#123;type: String&#125;&#125;));</span><br><span class="line">//文章集合</span><br><span class="line">const Post=mongoose.model(&#x27;Post&#x27;,new mongoose.Schema(&#123;</span><br><span class="line">	title:&#123;type: String&#125;,</span><br><span class="line">//使用id将文章集合和作者集合进行关联</span><br><span class="line">	author:&#123;type: mongoose.Schema.Types.ObjectId, ref: &#x27;User&#x27;&#125;</span><br><span class="line">&#125;)):</span><br><span class="line"></span><br><span class="line">//联合查询</span><br><span class="line">Post.find().populate(&#x27;author&#x27;).then((err,result)=&gt;console.log(result));</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>导入数据</p>
</li>
</ul>
<p>shell 命令：<code>mongoimport -d 数据库名称 -c 集合名称 -file 要导入的数据文件（josn格式）</code></p>
<ul>
<li>查询文档</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//根据条件查询文档，若为空则查询所有文档</span><br><span class="line">Course.find().then(result=&gt;console.log(result));	//返回的是文档的集合数组</span><br><span class="line"></span><br><span class="line">//实例</span><br><span class="line">Course.find(&#123;name:&#x27;xiaoming&#x27;&#125;).then(result=&gt;console.log(result));</span><br><span class="line">User.find(&#123;age:&#123;$gt:20,$lt:50&#125;&#125;).then(result=&gt;console.log(result));	//查询大于20小于50</span><br><span class="line">User.find(&#123;hobbies:&#123;$in:[&#x27;运动&#x27;]&#125;&#125;).then(result=&gt;console.log(result));	//查询包含运动的</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//只查询一条数据</span><br><span class="line">Course.findOne(&#123;name:&#x27;xiaoming&#x27;&#125;).then(result=&gt;console.log(result));	</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//选择要查询的字段</span><br><span class="line">User.find().select(&#x27;name age -_id&#x27;).then(result=&gt;console.log(result)).catch(err=&gt;console.log(err));	//只返回查询的字段，不查询的字段前加-</span><br></pre></td></tr></table></figure>


<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//将查询出来的数据进行升序排序(从小到大）</span><br><span class="line">User.find().sort(&#x27;age&#x27;).then(result=&gt;console.log(result));	</span><br><span class="line"></span><br><span class="line">//将查询出来的数据进行降序排序(从大到小）</span><br><span class="line">User.find().sort(&#x27;-age&#x27;).then(result=&gt;console.log(result));	</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//skip跳过多条数据，limit限制查询数量</span><br><span class="line">User.find().skip(2).limit(2).then(result=&gt;console.log(result));		//分页查询时常用</span><br></pre></td></tr></table></figure>

<ul>
<li>删除文档</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//删除第一个文档</span><br><span class="line">Course.findOndeAndDelete(&#123;&#125;).then(result=&gt;console.log(result));		//返回删除的文档</span><br></pre></td></tr></table></figure>


<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//删除多个文档</span><br><span class="line">User.deleteMany(&#123;&#125;).then(result=&gt;console.log(result));</span><br></pre></td></tr></table></figure>

<ul>
<li>更新文档</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//更新单个</span><br><span class="line">User.updateOne(&#123;查询条件&#125;,&#123;要修改的值&#125;).then(re=&gt;console.log(re));</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//更新多个</span><br><span class="line">User.updateMany(&#123;查询条件&#125;,&#123;要修改的值&#125;).then(re=&gt;console.log(re));</span><br></pre></td></tr></table></figure>
<h4 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h4><h5 id="综合案例"><a href="#综合案例" class="headerlink" title="综合案例"></a>综合案例</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//301代表重定向</span><br><span class="line">//location 跳转地址</span><br><span class="line">req.on(&#x27;end&#x27;,()=&gt;&#123;</span><br><span class="line">res.writeHead(301,&#123;</span><br><span class="line">Location: &#x27;/list&#x27;</span><br><span class="line">&#125;);</span><br><span class="line">res.end();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>





<p><code>npm i nodemon -g </code><br><code>nodemon test.js</code></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.baidu.com/2021/06/07/20-00-00/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="KK">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KK">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/07/20-00-00/" class="post-title-link" itemprop="url">Vue2</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-06-07 20:00:00" itemprop="dateCreated datePublished" datetime="2021-06-07T20:00:00+08:00">2021-06-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-04-19 14:31:24" itemprop="dateModified" datetime="2022-04-19T14:31:24+08:00">2022-04-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/web/" itemprop="url" rel="index"><span itemprop="name">web</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Vue2-0"><a href="#Vue2-0" class="headerlink" title="Vue2.0"></a>Vue2.0</h1><blockquote>
<p>一套用于构建用户界面的渐进式 javascrip 框架</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js&quot;&gt; //引入 Vue&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> window.onload=function()&#123;</span><br><span class="line"> Vue.config.productionTip=false;//阻止vue启动时的生成的提醒</span><br><span class="line">//创建vue实例</span><br><span class="line">const vu= new Vue(&#123;</span><br><span class="line">   el:&#x27;#root&#x27;, //挂载点，指定容器,可写类名，不能用在html和body上；第二种写法可用vu.$mount(&#x27;#root&#x27;);代替</span><br><span class="line">    data:&#123;</span><br><span class="line">           msg:&#x27;hello&#x27;,</span><br><span class="line">           name:&#x27;xiaomi&#x27;,</span><br><span class="line">          &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">  test()&#123;...&#125; //不建议在data中写函数，因为会data中的属性会进行数据代理，而方法并不需要进行数据代理</span><br><span class="line"> //data第二种写成函数式,由Vue管理的函数不能写成箭头函数，对象里的方法可省略:function</span><br><span class="line"> /*</span><br><span class="line"> data:function()&#123;</span><br><span class="line"> return&#123;</span><br><span class="line">  name:&#x27;xiaoming&#x27;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&#x27;root&#x27;&gt;&#123;&#123;msg&#125;&#125; &#123;&#123;name&#125;&#125; &lt;/div&gt;  &lt;!-- &#123;&#123;&#125;&#125;中可写js表达式--&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="MVVM-模型"><a href="#MVVM-模型" class="headerlink" title="MVVM 模型"></a>MVVM 模型</h2><blockquote>
<p>一种软件架构</p>
</blockquote>
<ul>
<li>M:模型 model:对应 data 中的数据</li>
<li>V：视图 view:模板</li>
<li>VM：视图模型 view model：vue 实例</li>
<li>数据代理</li>
</ul>
<p><code>Object.defineproperty()</code>第一个参数为对象，第二个为对象的属性，第三个为配置项</p>
<p>如添加属性：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">let person&#123;</span><br><span class="line">name:&#x27;xiaomei&#x27;</span><br><span class="line">&#125;</span><br><span class="line">Object.defineproperty(person,&#x27;age&#x27;,&#123;</span><br><span class="line">value:18,</span><br><span class="line">//默认情况下添加的属性不可枚举，即无法遍历出来</span><br><span class="line">enumerable:true  //true表示可以枚举</span><br><span class="line">//默认情况下添加的属性的值无法更改</span><br><span class="line">writable:true //控制属性是否可修改</span><br><span class="line">//默认情况下添加的属性无法删除</span><br><span class="line">configurable: true ////控制属性是否可删除</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//当读取person的age属性时，get函数会被调用，且返回age的值</span><br><span class="line">get:function()&#123;</span><br><span class="line">return &#x27;hello&#x27;</span><br><span class="line">&#125;</span><br><span class="line">//当修改person的age属性时，set函数会被调用</span><br><span class="line">set:function(value)&#123;</span><br><span class="line">age=value;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>通过一个对象对另一个对象中的属性的操作</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">var object=&#123;//原数据</span><br><span class="line">    name:&#x27;xiaomei&#x27;,</span><br><span class="line">    sex:&#x27;female&#x27;,</span><br><span class="line">&#125;</span><br><span class="line">var test=&#123;</span><br><span class="line">    age:3,</span><br><span class="line">    hobby:&#x27;swing&#x27;</span><br><span class="line">&#125;</span><br><span class="line">Object.defineProperty(object,&#x27;age&#x27;,&#123;</span><br><span class="line">//默认情况下添加的属性不可枚举，即无法遍历出来</span><br><span class="line"></span><br><span class="line">get()&#123;</span><br><span class="line"></span><br><span class="line">    console.log(&#x27;getter&#x27;)</span><br><span class="line">    return test.age;  //通过object中的age控制test中的age,即数据代理</span><br><span class="line">&#125;,</span><br><span class="line">set(n)&#123;</span><br><span class="line">console.log(&quot;set&quot;,n)</span><br><span class="line">test.age=n;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>vue 中的数据代理：通过 vm 对象来代理 data 对象中属性的操作</p>
<p>通过 Object.defineProperty()把 data 对象中所有属性添加到 vm 上，为每一个添加到 vm 上的属性，都指定一个 getter/setter 方法,在它们内部去对 data 中的数据进行操作</p>
<h2 id="数据监听"><a href="#数据监听" class="headerlink" title="数据监听"></a>数据监听</h2><p>通过<code>vm._data</code>也可以访问到 data 中的数据,但其是经过加工的,即形成 getter、setter 形式</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//###只能监测一层</span><br><span class="line">let data=&#123;name:&#x27;xiaomei&#x27;&#125;</span><br><span class="line">//创建一个监视的实例对象，用于监视data中的属性变化</span><br><span class="line">const obs=new Observer(data);</span><br><span class="line">function Observer(obj)&#123;</span><br><span class="line">//汇总对象中所有的属性形成一个数组</span><br><span class="line">const keys=Object.keys(obj);</span><br><span class="line">//遍历</span><br><span class="line">keys.forEach((k)=&gt;&#123;</span><br><span class="line">Object.defineProperty(this,k,&#123;</span><br><span class="line">get()&#123;</span><br><span class="line">return obj;</span><br><span class="line">&#125;,</span><br><span class="line">set(val)&#123;</span><br><span class="line">console.log(&#x27;数据被修改了&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原理：通过 setter 实现监测，且要在 new Vue 时就传入要监测的数据;</p>
<ul>
<li>对象中后追加的属性，vue 默认不做响应式处理；如要给后添加的属性做响应式处理，需要用<code>Vue.set(对象,&#39;添加的属性&#39;,&#39;属性值&#39;)或vm.$set(对象,&#39;添加的属性&#39;,&#39;属性值&#39;)</code></li>
<li>删除属性也会做响应式更新，可使用<code>this.$delete(&#39;属性&#39;)</code>删除</li>
<li>数组更新检测<br>vue 将被侦听的数组的变更方法进行了包裹，所以会触发视图的更新，即先调用原生方法对数组进行修改，接着重新解模板，进行更新页面。被包裹的方法有<code>push()</code>,<code>pop()</code>,<code>shift()</code>,<code>unshift()</code>,<code>splice()</code>,<code>sort()</code>,<code>reverse()</code>.或使用<code>Vue.set(数组,下标,&#39;修改的值&#39;)或vm.$set(数组,下标,&#39;修改的值&#39;)</code></li>
</ul>
<blockquote>
<p>!注意：Vue.set();和 vm.$set()不能给 vm 或 vm 的根数据对象添加属性</p>
</blockquote>
<h2 id="模板语法"><a href="#模板语法" class="headerlink" title="模板语法"></a>模板语法</h2><ul>
<li><p>插值语法<br>用于解析标签体内容<br><code>&#123;&#123;xxx&#125;&#125;</code>xxx 为 js 表达式，可以直接读取到 data 中的属性</p>
</li>
<li><p>指令语法<br>用于解析标签</p>
</li>
</ul>
<p><code>v-bind:href=&quot;xxx&quot;</code>或简写为<code>:href=&quot;xxx&quot;</code></p>
<ul>
<li><p>数据绑定</p>
<ul>
<li><p>单向数据绑定<br>数据只能从 data 流向页面;<code>v-bind:href=&quot;xxx&quot;</code>或简写为<code>:href=&quot;xxx&quot;</code></p>
</li>
<li><p>双向数据绑定</p>
</li>
</ul>
</li>
</ul>
<p>数据能从 data 流向页面,也能从页面流向 data<br><code>v-model:value=&quot;xxx&quot;</code>或简写<code>v-model=&quot;xxx&quot;</code></p>
<blockquote>
<p>v-model 指令只能用在表单类（输入类 input、select）元素上</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--收集表单数据--&gt;</span><br><span class="line">&lt;input type=&quot;text&quot;  v-model=&quot;keyWords/&gt; &lt;!--用户输入就是value值，v-model收集的就是value值;v0model的三个修饰符：lazy失去焦点在收集数据，number输入的字符串转为有效数字，trim去除首尾的空格--&gt;</span><br><span class="line">&lt;input type=&quot;radio&quot; v-model=&quot;radio&quot; value=&quot;radio1&quot; /&gt; &lt;!--单选框--&gt;</span><br><span class="line">&lt;input type=&quot;checkbox&quot; v-model=&quot;hobby&quot; value=&quot;study&quot;/&gt; &lt;!--多选框--&gt;</span><br><span class="line">&lt;input type=&quot;checkbox&quot; v-model=&quot;hobby&quot; value=&quot;reading&quot;/&gt; &lt;!--若没有配置value，则当v-model初始值为数组时，勾选时收集的是null，为字符串时，收集的是布尔值--&gt;</span><br><span class="line">&lt;input type=&quot;checkbox&quot; v-model=&quot;hobby&quot; value=&quot;sports&quot;/&gt;</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">el:&#x27;#root&#x27;,</span><br><span class="line">data:&#123;</span><br><span class="line"> keyWords:&#x27;&#x27;,</span><br><span class="line"> hobby:[],</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>数据处理</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;button v-on:cllick=&quot;showhello&quot;&gt;test&lt;/button&gt;</span><br><span class="line">&lt;!--或简写成--&gt;</span><br><span class="line">&lt;button @cllick=&quot;showhello($event,22)&quot;&gt;test&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">new Vue(&#123;</span><br><span class="line">el:&#x27;.button1&#x27;,</span><br><span class="line">data:&#123;</span><br><span class="line">name:&#x27;xiaomei&#x27;</span><br><span class="line">&#125;,</span><br><span class="line">methods:&#123;</span><br><span class="line">showhello(e,n)&#123;</span><br><span class="line">alert(&#x27;hello&#x27;);</span><br><span class="line">console.log(e.target,n);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>事件修饰符<br>vue 中的事件修饰符：<ul>
<li>prevent:阻止默认事件</li>
<li>stop:阻止事件冒泡</li>
<li>once：事件只触发一次</li>
<li>capture:使用事件的捕获模式</li>
<li>sefl:只有 event.target 是当前操作的元素时才触发事件</li>
<li>passive:事件的默认行为立即执行，无需等待事件回调执行完毕</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&#x27;www.baidu.com&#x27; v-on:click.prevent.stop=&quot;showhello()&quot;&gt;test&lt;a&gt; &lt;!--阻止a标签自动跳转,可连续写--&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>键盘事件<ul>
<li>vue 中的按键别名<code>回车enter</code>,<code>删除delete</code> , <code>退出esc</code>, <code>空格space</code>, <code>换行tap(必须配合keydown使用)</code>, <code>上up下down左left右right</code></li>
<li>vue 中未提供的按键别名，可使用按键原始名去绑定，注意要转换为 kebab-case（短横线命名）</li>
<li>系统修饰键：<code>ctrl</code>,<code>alt</code>,<code>shift</code>,<code>meta</code>;<ul>
<li>配合 keyup 使用时：需再按下其他键，随后释放其他键才能触发</li>
<li>配合 keydown 使用时：正常触发</li>
</ul>
</li>
<li>Vue.config.keyCodes.自定义键名=键码</li>
</ul>
</li>
</ul>
<p><code>&lt;input type=&quot;text&quot; placeholder=&quot;tips&quot; @keyup.enter=&quot;showhello&quot;&gt;</code></p>
<ul>
<li>条件渲染</li>
</ul>
<p>语法： <code>&lt;h2 v-show=&quot;false&quot;&gt; test&lt;/h2&gt; &lt;!--元素还存在--&gt;</code></p>
<p>v-if 与 v-show 的区别：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> &lt;h2 v-if=&quot;false&quot;&gt; test&lt;/h2&gt; &lt;!--元素直接消失,中间不能被打断--&gt;</span><br><span class="line">&lt;template v-else-if=&quot;true&quot;&gt; &lt;a&gt;test&lt;/a&gt;&lt;/template&gt; &lt;!--template不影响结构，但必须和v-if配合使用--&gt;</span><br><span class="line"> &lt;h2 v-else&gt; test&lt;/h2&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>渲染文本</p>
<p><code>v-text</code> 指令,向其所在的节点中渲染文本内容,其会替换掉节点中的内容，<code>&#123;&#123;xxx&#125;&#125;</code>插值语法则不会,可以替换指定内容。</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;h3 v-text=&quot;keyword&quot;&gt;&lt;/h3&gt;</span><br></pre></td></tr></table></figure>

<p><code>v-html</code> 指令,向其所在的节点中渲染文本内容,其会替换掉节点中的内容,且会解析 html 标签，<code>v-text</code>则不会。其具有安全性问题，在网页上动态渲染 html 标签是非常危险的，易导致 XSS 攻击。</p>
<ul>
<li>列表渲染</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;#root&quot;&gt;</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">&lt;!--遍历数组--&gt;</span><br><span class="line">&lt;li v-for=&quot;n in persons&quot; :key=&quot;n.id&quot; &gt;</span><br><span class="line">&#123;&#123;index&#125;&#125; &lt;!--索引值--&gt;</span><br><span class="line">&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--遍历对象--&gt;</span><br><span class="line">&lt;li v-for=&quot;(k,index2) of persons&quot; :key=&quot;index2&quot; &gt;</span><br><span class="line">&#123;&#123;index2&#125;&#125; &lt;!--索引值--&gt;</span><br><span class="line">&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;!-- 除此之外还可以遍历字符串，数字--&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">const vm=new Vue(&#123;</span><br><span class="line">el:&#x27;#root&#x27;,</span><br><span class="line">data:&#123;</span><br><span class="line"> persons:[</span><br><span class="line">  &#123;id:001,name:&#x27;xiaoMei&#x27;,age:18&#125;,</span><br><span class="line">  &#123;id:002,name:&#x27;xiaoHong&#x27;,age:22&#125;,</span><br><span class="line">  &#123;id:003,name:&#x27;xiaoLan&#x27;,age:12&#125;,</span><br><span class="line">  ]</span><br><span class="line">&#125;,</span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p><em>key 原理</em></p>
<p>给节点提供唯一标识</p>
<ol>
<li>虚拟 DOM 中的 key 的作用：key 是虚拟 DOM 对象的标识，当数据发送变化时，vue 会根据新数据生成新的虚拟 DOM，随后 vue 将新的虚拟 DOM 与旧的虚拟 DOM 进行差异比较</li>
<li>对比规则为：<ul>
<li>旧虚拟 DOM 中找到与新虚拟 DOM 相同的 key：<ul>
<li>若虚拟 DOM 中的内容没有改变，则直接使用之前的真实 DOM</li>
<li>若虚拟 DOM 中的内容改变了，则生成新的真实 DOM，随后替换掉页面中之前的真实 DOM</li>
</ul>
</li>
<li>旧虚拟 DOM 中未找到与新虚拟 DOM 相同的 key：创建新的真实 DOM，随后渲染到页面。 3. index 作为 key 可能发生的问题：对数据进行逆序添加、删除时，会产生没有必要的真实 dom，界面虽然没问题，但效率低。当结构中存在输入类的 DOM 时，界面会出现问题。</li>
</ul>
</li>
</ol>
<hr>
<ul>
<li><p>其他指令</p>
<p><code>v-cloak</code>指令，Vue 实例创建完毕并接管容器后，会删除所有 v-cloak 属性，常用于解决网速不好加载 vue 慢而显示问题</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">[v-cloak]&#123;display:none;&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;h2 v-cloak&gt; &#123;&#123;keyword&#125;&#125;&lt;/h2&gt;</span><br></pre></td></tr></table></figure>

<p><code>v-once</code>指令，其所在的节点在初次渲染后，就视为静态内容了，以后即使数据变化了，其也不再变化</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;h2 v-once&gt; &#123;&#123;keyword&#125;&#125;&lt;/h2&gt;</span><br></pre></td></tr></table></figure>

<p><code>v-pre</code>指令，跳过其所在节点的编译过程，可用于跳过没有指令语法、插值语法的节点，加快编译速度。</p>
<ul>
<li>自定义指令</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">el:&#x27;#root&#x27;,</span><br><span class="line">data:&#123;&#125;,</span><br><span class="line">directives:&#123;</span><br><span class="line">//局部指令</span><br><span class="line">//指令与元素成功绑定时即一开始就被调用，当指令所在模板被重新解析时会被调用。</span><br><span class="line">//简写</span><br><span class="line">test(element,binding)&#123; //element,binding为规定写法</span><br><span class="line">console.log(this); //这里的this为window</span><br><span class="line">element.innerText=bindding.value;</span><br><span class="line">&#125;</span><br><span class="line">//标准写法</span><br><span class="line">test2:&#123; //命名：多个单词用-分割，使用时不用-,后一个首字母改为大写</span><br><span class="line">bind(element,binding)&#123;//指令与元素成功绑定时调用&#125;,</span><br><span class="line">inserted(element,binding)&#123;//指令所在元素插入页面时调用&#125;,</span><br><span class="line">update(element,binding)&#123;//指令所在模板被重新解析时被调用&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">//全局指令</span><br><span class="line">Vue.directive(指令名，回调函数);</span><br><span class="line">;</span><br></pre></td></tr></table></figure>

<h2 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h2><p>要用的属性不存在，利用已有属性计算而得来</p>
<p>内部有缓存机制，多次调用时只运行一次，效率更高,但不能开启异步任务如:<code>setTimeout()</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">el:&#x27;.box&#x27;,</span><br><span class="line">data:&#123;</span><br><span class="line">name:&#x27;xiaomei&#x27;,</span><br><span class="line">hoby:&#x27;reading&#x27;</span><br><span class="line">&#125;,</span><br><span class="line">computed:&#123;</span><br><span class="line">fullName:&#123;</span><br><span class="line">//初次读取fullName时，get会被调用;所依赖的数据改变时会调用,即data中的属性被改变时。</span><br><span class="line">get()&#123;</span><br><span class="line">return this.name+&#x27;-&#x27;+this.hoby;</span><br><span class="line">&#125;,</span><br><span class="line">//当fullname被修改时，会被调用</span><br><span class="line">set()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">//当数据只读不修改时，可采用简写</span><br><span class="line">fullName()&#123;</span><br><span class="line">return this.name+&#x27;-&#x27;+this.hoby;</span><br><span class="line">&#125;</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="监听属性"><a href="#监听属性" class="headerlink" title="监听属性"></a>监听属性</h2><p>能开启异步操作如:<code>setTimeout(()=&gt;&#123;&#125;,1000)</code>;所有不被 vue 所管理的函数最好写成箭头函数，这样 this 的指向才是 vm</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">const vm = new Vue(&#123;</span><br><span class="line"> el:&#x27;#test&#x27;,</span><br><span class="line"> data:&#123;</span><br><span class="line"> istrue: false</span><br><span class="line"> number:&#123;</span><br><span class="line">  a:1,</span><br><span class="line">  b:2&#125;,</span><br><span class="line"> &#125;,</span><br><span class="line"> methods:&#123;&#125;,</span><br><span class="line"> computed:&#123;&#125;,</span><br><span class="line"> wantch&#123;</span><br><span class="line"> &#x27;istrue&#x27;:&#123;</span><br><span class="line"> immediate:true, ///初始化时调用一下handler</span><br><span class="line"> //当istrue发生改变时调用</span><br><span class="line"> handler(newValue,oldValue)&#123;</span><br><span class="line"> console.log(newValue,oldValue);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> //简写，当只有handler()时</span><br><span class="line"> /*istrue(newValue,oldValue)&#123;console.log(&#x27;test&#x27;);&#125;*/</span><br><span class="line"> &#x27;number&#x27;:&#123;</span><br><span class="line"> deep:true, //深度监视，当对象内的属性发生变化时,能检测到多层级内容的改变</span><br><span class="line"> handler(newValue,oldValue)&#123;</span><br><span class="line"> console.log(newValue,oldValue);</span><br><span class="line"> &#125;&#125;</span><br><span class="line"> &#125;);</span><br><span class="line">/*//第二种写法</span><br><span class="line">vm.$watch(&#x27;istrue&#x27;,&#123; handler()&#123;&#125; &#125; );</span><br><span class="line">//简写</span><br><span class="line">vm.$watch(&#x27;istrue&#x27;,function()&#123; console.log(&#x27;test&#x27;);&#125;);</span><br><span class="line">*/</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h2 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h2><p>对要显示的数据进行特定格式化后在显示（常用于一些简单逻辑的处理）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">new Vue(&#123;</span><br><span class="line">el:&#x27;#root&#x27;</span><br><span class="line">data:&#123;</span><br><span class="line">time:24356765432,</span><br><span class="line">&#125;,</span><br><span class="line">computed:&#123;&#125;,</span><br><span class="line">//注册过滤器</span><br><span class="line">filters:&#123;</span><br><span class="line">timeFormater1(value)&#123;</span><br><span class="line">console.log(value);</span><br><span class="line">return value; //返回数据</span><br><span class="line">&#125;,</span><br><span class="line">timeFormater2(value)&#123;</span><br><span class="line">console.log(value);</span><br><span class="line">return value; //返回数据</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//注册全局过滤器</span><br><span class="line">Vue.filter(&#x27;myName&#x27;,function(value)&#123;return value;&#125;);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h3&gt;</span><br><span class="line">&lt;!--使用过滤器--&gt;</span><br><span class="line">&#123;\&#123;time|timeFormater1()|timeFormater2&#125;&#125;</span><br><span class="line">&lt;!--或者v-bind:属性=&quot;xxx|过滤器名&quot;--&gt;</span><br><span class="line">&lt;!--过滤器可额外接收参数，多个过滤器可串联，原始数据未改变，产生的是新的数据--&gt;</span><br><span class="line">&lt;/h3&gt;</span><br><span class="line">&lt;body&gt;</span><br></pre></td></tr></table></figure>

<h2 id="绑定样式"><a href="#绑定样式" class="headerlink" title="绑定样式"></a>绑定样式</h2><p>适用于动态指定类名<br><code>&lt;div class=&#39;box&#39; :class=&#39;xxx&#39; :style=&quot;&#123;fontSize: n +&#39;px&#39; &#125;&quot; &gt;test&lt;/div&gt;</code>;xxx 可为字符串、数组[‘box1’,’box2’]、对象{box1:false,box2:true}。</p>
<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>又名生命周期回调函数、生命周期函数、生命周期钩子，是 vue 在关键时刻帮我们调用的一些特殊名称的函数，其名字不可更改，其中的 this 指向 vm 或组件实例对象。</p>
<table>
<thead>
<tr>
<th>生命周期</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>初始化：生命周期、事件</td>
<td>但数据代理还未开始</td>
</tr>
<tr>
<td>beforeCreate</td>
<td>无法通过 vm 访问到 data 中的数据已经 methods 中的方法</td>
</tr>
<tr>
<td>初始化：数据检测、数据代理</td>
<td></td>
</tr>
<tr>
<td>created</td>
<td>可以通过 vm 可访问到 data 中的数据、methods 中的方法</td>
</tr>
<tr>
<td>解析模板，生成虚拟 DOM</td>
<td>此时页面还不能显示解析好的内容</td>
</tr>
<tr>
<td>beforeMount</td>
<td>页面呈现的是未经 Vue 编译的 DOM 结构，此时所有对 DOM 的操作，最终都不奏效</td>
</tr>
<tr>
<td>创建 vm $el</td>
<td>将内存中的虚拟 DOM 转为真实 DOM 插入页面</td>
</tr>
<tr>
<td>mounted</td>
<td>页面中呈现的是经过 Vue 编译的 DOM，对 DOM 的操作均有效，到此初始化过程结束。一般在此进行开启定时器、发送网络请求、订阅消息、绑定自定义事件等操作</td>
</tr>
<tr>
<td>beforeUpdate</td>
<td>此时数据是新的，但页面是旧的，即页面未与数据保持同步</td>
</tr>
<tr>
<td>根据新的数据，生成新的虚拟 DOM，随后与旧的虚拟 DOM 进行比较，最终完成页面的更新</td>
<td></td>
</tr>
<tr>
<td>updated</td>
<td>此时数据和页面保持同步</td>
</tr>
<tr>
<td>beforeDestroy</td>
<td>此时 vm 中所有的 data、methods、指令等都处于可用状态，马上要执行销毁过程，一般在此进行关闭定时器、取消订阅消息、解绑自定义事件等操作</td>
</tr>
<tr>
<td>destroyed</td>
<td>销毁 vue 实例后自定义事件会失效，但原生 DOM 事件依然有效</td>
</tr>
</tbody></table>
<h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><p>实现应用中局部功能代码和资源的集合</p>
<blockquote>
<p>模块：向外提供特定功能的 js 程序</p>
</blockquote>
<ul>
<li>非单文件组件：一个文件中包含有 n 个组件</li>
</ul>
<p>创建 school 组件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//简写</span><br><span class="line">const school=&#123;&#125;;</span><br><span class="line">//标准写法</span><br><span class="line">const school=Vue.extend(&#123;</span><br><span class="line">//组件定义时，不要写el配置项,最终所有的组件都要进过一个vm的管理</span><br><span class="line">//名字</span><br><span class="line">name:&#x27;xuexiao&#x27;,</span><br><span class="line"></span><br><span class="line">//使用template可以配置组件结果。</span><br><span class="line">template:`</span><br><span class="line">&lt;div&gt;</span><br><span class="line">&lt;h3&gt;test&lt;/h3&gt;</span><br><span class="line">&lt;/div&gt;`,</span><br><span class="line"></span><br><span class="line">data()&#123; //data必须写成函数，为避免组件被复用时，数据存在引用关系</span><br><span class="line">return &#123;</span><br><span class="line"> schoolName:&#x27;BST&#x27;,</span><br><span class="line"> address:&#x27;beijing&#x27;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>定义 app 组件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const app=Vue.extend(&#123;&#125;);</span><br></pre></td></tr></table></figure>

<p>创建 vm</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">el:&#x27;#root&#x27;,</span><br><span class="line">template:&#x27;&lt;app&gt;&lt;/app&gt;&#x27;,</span><br><span class="line">//局部注册组件</span><br><span class="line">components:&#123;</span><br><span class="line"> xuexioa:school,  //组件名：一个单词通常首字母大小，多个单词通常用-分隔，或首字母大写（需要Vue脚手架支持）</span><br><span class="line"> app</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//全局注册组件</span><br><span class="line">Vue.component(&#x27;xuexiao&#x27;,school);</span><br></pre></td></tr></table></figure>

<p>使用组件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;xuexiao&gt;&lt;/xuexiao&gt;</span><br><span class="line">&lt;xuexiao /&gt;&lt;!--需要脚手架支持，否则多个组件时，后续组件将不能渲染--&gt;</span><br></pre></td></tr></table></figure>

<p>关于 VueComponent，组件本质是一个名为 VueComponent 的构造函数，是由 Vue.extend 生成的。当我们写<code>&lt;xuexiao&gt;&lt;/xuexiao&gt;</code>，Vue 解析时会帮我们创建 school 组件的实例对象，即 vue 帮我们执行<code>new VueComponent();</code>。当我们每次调用 Vue.extend()时,返回的都是一个全新的 VueComponent。在组件配置中，data 函数、methods 中的函数、watch 中的函数等，它们的 this 都指向 VueComponent 实例对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//定义一个构造函数</span><br><span class="line">function Demo()&#123;</span><br><span class="line">this.a=1;</span><br><span class="line">this.b=2;</span><br><span class="line">&#125;</span><br><span class="line">//创建一个Demo实例对象</span><br><span class="line">const d=new Demo();</span><br><span class="line">console.log(Demo.prototype); //显示原型属性</span><br><span class="line">console.log(d.__proto__); //隐式原型属性</span><br><span class="line">//显示原型属性与隐式原型属性都指向原型对象</span><br><span class="line">//通过显示原型属性操作原型对象</span><br><span class="line">Demo.prototype.e=21;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>!!重要内置关系：VueComponent.prototype.<strong>proto</strong>===Vue.prototype;其可以让组件实例对象访问到 Vue 原型上的属性和方法。</p>
</blockquote>
<ul>
<li>单文件组件：一个文件中只包含有一个组件<ul>
<li>school.vue 组件</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;!--组件的结构--&gt;</span><br><span class="line"> &lt;div class=&quot;demo&quot;&gt;</span><br><span class="line"> &lt;h2&gt;&#123;&#123;schoolName&#125;&#125;&lt;/h2&gt;</span><br><span class="line"> &lt;h2&gt;&#123;&#123;address&#125;&#125;&lt;/h2&gt;</span><br><span class="line"> &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">//组件交互的代码</span><br><span class="line"> export default&#123;</span><br><span class="line"> name:&#x27;School&#x27;,</span><br><span class="line"> data()&#123;</span><br><span class="line"> return&#123;</span><br><span class="line">   schoolName:&#x27;daxue&#x27;</span><br><span class="line">   address:&#x27;beijing&#x27;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;,</span><br><span class="line"> methods:&#123;</span><br><span class="line">    showName()&#123;</span><br><span class="line">  alert(this.schoolName);</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;,</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">/*样式*/</span><br><span class="line">.demoo&#123;</span><br><span class="line">background-color:red;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>App.vue 组件</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">&lt;School/&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">//引入组件</span><br><span class="line">import School from &#x27;./School&#x27;</span><br><span class="line"></span><br><span class="line">export default&#123;</span><br><span class="line">name:&#x27;App&#x27;,</span><br><span class="line">components:&#123;School&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>main.js</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import App from &#x27;./App.vue&#x27;</span><br><span class="line">new Vue(&#123;</span><br><span class="line">el:&#x27;#root&#x27;,</span><br><span class="line">components:&#123;App&#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>index.html</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line"> &lt;meta charset=&#x27;utf-8&quot;/&gt;</span><br><span class="line"> &lt;title&gt;test&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div id=&quot;root&quot;&gt;&lt;div&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;./vue.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;./main.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<h2 id="脚手架-vue-cli-command-line-interface"><a href="#脚手架-vue-cli-command-line-interface" class="headerlink" title="脚手架 vue.cli(command line interface)"></a>脚手架 vue.cli(command line interface)</h2><ol>
<li>全局安装@vue/cli:<code>npm install -g @vue/cli</code></li>
<li>切换到要创建项目的目录，然后创建项目：<code>vue create xxxx</code></li>
<li>启动项目：<code>npm run serve</code></li>
</ol>
<blockquote>
<ol>
<li>配置 npm 淘宝镜像：<code>npm config set registry https://registry.npm.taobao.org</code></li>
<li>Vue 脚手架隐藏了所有 webpack 相关的配置，若想查看具体 webpack 配置，执行：<code>vue inspect &gt; output.js</code></li>
</ol>
</blockquote>
<ul>
<li>main.js 项目的入口文件</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//引入vue.runtime.xxx.js，其是运行版的vue,只包含核心功能，没有模板解析器,而完整版的Vue才有。</span><br><span class="line">import Vue from &#x27;vue&#x27;</span><br><span class="line">//引入App组件</span><br><span class="line">import App from &#x27;./App.vue&#x27;</span><br><span class="line">//关闭生产提示</span><br><span class="line">Vue.config.productionTip=false;</span><br><span class="line"></span><br><span class="line">//创建VUe实例对象</span><br><span class="line">new Vue(&#123;</span><br><span class="line">el:&#x27;#root&#x27;,</span><br><span class="line">//将App组件放入容器中</span><br><span class="line">render:h=&gt;h(app), //没有模板解析器，不能使用template配置项，需要使用render函数接收到的createElement函数去指定具体内容</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>vue.config.js 配置</li>
</ul>
<p>使用 vue.config.js 可以对脚手架进行个性化定制</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">module.exports=&#123;</span><br><span class="line"> pages:&#123;</span><br><span class="line">   index:&#123;</span><br><span class="line">  //入口</span><br><span class="line">  entry:&#x27;src/main.js&#x27;,</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"> lintOnSave:false, //关闭语法检查</span><br><span class="line"> //代理</span><br><span class="line"> devServer:&#123;</span><br><span class="line">  proxy:&#123;</span><br><span class="line">   &#x27;/api&#x27;::&#123;</span><br><span class="line">    target:&#x27;http://xxxx&#x27;</span><br><span class="line">    changeOrigin:true,</span><br><span class="line">    pathRewrite:&#123;</span><br><span class="line">     &#x27;^/api&#x27;:&#x27;/api&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> configureWebpack:(config)=&gt;&#123;//地址</span><br><span class="line">  config.resolve=&#123;</span><br><span class="line">   extensions:[&#x27;.js&#x27;,&#x27;.json&#x27;,&#x27;.vue&#x27;],</span><br><span class="line">   alias:&#123;</span><br><span class="line">    &#x27;@&#x27;:path.resolve(__dirname,&#x27;./src&#x27;)</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>脚手架文件结构</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">|--node_modules</span><br><span class="line">|--public</span><br><span class="line">|--src</span><br><span class="line">    |--assets:静态资源文件夹</span><br><span class="line">    |--component:存放组件文件夹</span><br><span class="line">    |--App.vue：汇总所有组件</span><br><span class="line">    |--mian.js：入口文件</span><br><span class="line">|--.gitignore: git版本管制忽略的配置</span><br><span class="line">|--babel.config.js</span><br><span class="line">|--package.json: 应用包配置文件</span><br><span class="line">|--package-lock.json: 包版本控制文件</span><br></pre></td></tr></table></figure>

<ul>
<li>ref 属性</li>
</ul>
<p>id 的替代者,用来给元素或组件注册引用信息,应用在 html 标签上获取的是真实 DOM 元素，应用组件标签上获取的是组件的实例对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">&lt;h1 v-text=&quot;msg&quot; ref=&quot;title&quot;&gt;&lt;/h1&gt;</span><br><span class="line">&lt;button ref=&quot;btn&quot; @click=&quot;showDOM&quot;&gt;outPut_DOM&lt;/button&gt;</span><br><span class="line">&lt;School ref=&quot;sch&quot; /&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import School from &#x27;./component/school&#x27;</span><br><span class="line">export default &#123;</span><br><span class="line"> name:&#x27;App&#x27;,</span><br><span class="line"> components:&#123;School&#125;</span><br><span class="line"> data()&#123;</span><br><span class="line"> return&#123;</span><br><span class="line"> msg:&#x27;hello&#x27;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;,</span><br><span class="line"> methods:&#123;</span><br><span class="line"> showDOM()&#123;</span><br><span class="line"> console.log(this.$ref.title); //真实DOM元素</span><br><span class="line"> console.log(this.$ref.sch); //School组件的实例对象</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>props 配置项</li>
</ul>
<p>让组件接收外部传来的数据,props 是只读的，Vue 底层会监测(非深度监测)props，若发生修改会发出警告。若要修改数据，请复制一份到 data 中,再修改。</p>
<blockquote>
<p>Vue 使用 props 时父组件给子组件传值后，子组件可用 props 配置项接收，但不要忘了加引号！！！！！！！否则使用它会出现 undefined！<br>v-modle 绑定的值不应是 props 传过来的值，当其为对象类型时，修改对象中的属性时，vue 无法发现</p>
</blockquote>
<p>子组件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">data:&#123;&#125;,</span><br><span class="line">//简单声明接收</span><br><span class="line">props:[&#x27;name&#x27;,&#x27;age&#x27;,&#x27;sex&#x27;]</span><br><span class="line">//接收的同时对数据进行类型限制</span><br><span class="line">props:&#123;</span><br><span class="line">name:String,</span><br><span class="line">age:Number,</span><br><span class="line">sex:String</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">//接收的同时对数据进行类型限制和默认值的指定</span><br><span class="line">props:&#123;</span><br><span class="line">name:&#123;</span><br><span class="line"> type:String,</span><br><span class="line">   required:true, //name必填</span><br><span class="line">  &#125;,</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>父组件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line"> &lt;!--传递数据--&gt;</span><br><span class="line"> &lt;Student name=&quot;xiaoMei&quot; sex=&quot;female&quot; :age=&quot;12&quot;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import Student from &#x27;./components/Student&#x27;</span><br><span class="line">export default&#123;</span><br><span class="line"> name:&#x27;App&quot;,</span><br><span class="line"> components:&#123;Student&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>props 适用于父组件和子组件的通信，子组件与父组件的通信要求父先给子一个函数，子再通过形参的形式传递数据</p>
</blockquote>
<h2 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h2><p>子组件跟父组件通信可使用 Vue 的自定义事件，父组件通过@xxx=“function(){}”给子组件绑定自定义事件，然后子组件通过$emit 触发事件，第一个参数为触发的事件，第二个为要传递的数据，便可实现子与父的通信。<br>适用于子组件与父组件通信<br>App.vue</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;!-- 通过父组件给子组件绑定一个自定义事件：用于子给父传递数据 --&gt;</span><br><span class="line">&lt;Student v-on:test=&quot;getStudentName&quot;/&gt;</span><br><span class="line">&lt;!-- 第二种写法,使用ref--&gt;</span><br><span class="line">&lt;!-- &lt;student ref=&quot;student&quot;/&gt;  --&gt;</span><br><span class="line">&lt;!-- &lt;student ref=&quot;student&quot;  @click.native=&quot;show&quot;/&gt;  组件绑定原生DOM事件，需要使用native修饰符 --&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import School from &#x27;./components/School.vue&#x27;</span><br><span class="line">import Student from &#x27;./components/Student&#x27;</span><br><span class="line"></span><br><span class="line">export default&#123;</span><br><span class="line">name:&#x27;App&#x27;, components:&#123;School,Student&#125;</span><br><span class="line">data()&#123;</span><br><span class="line"> return &#123;</span><br><span class="line">    msg: &#x27;test1!!!!!!!!&#x27;</span><br><span class="line"> &#125;&#125;</span><br><span class="line">methods:&#123;</span><br><span class="line"> getStudentName(name)&#123;</span><br><span class="line">  console.log(name);</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;,</span><br><span class="line"> // 第二种写法,使用ref--&gt;</span><br><span class="line"> /*</span><br><span class="line"> mounted()&#123;</span><br><span class="line"> this.$refs.student.$on(&#x27;test&#x27;,this.getStudentName);</span><br><span class="line"> //this.$refs.student.$on(&#x27;test&#x27;,(name,...params)=&gt;&#123;...//要用箭头函数，否则this指向出错&#125;);</span><br><span class="line"> &#125;</span><br><span class="line"> */</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<p>Student.vue</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;h2&gt;&#123;&#123;name&#125;&#125;&lt;/h2&gt;</span><br><span class="line">&lt;h2&gt;&#123;&#123;sex&#125;&#125;&lt;/h2&gt;</span><br><span class="line">&lt;button @click=&quot;sendStudentName&quot;&gt;test&lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">name:&#x27;Student&#x27;</span><br><span class="line">data()&#123;</span><br><span class="line">return&#123;</span><br><span class="line">name:&#x27;xiaoHu&#x27;,</span><br><span class="line">sex:&#x27;man&#x27;</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">methods:&#123;</span><br><span class="line">sendStudentName()&#123;</span><br><span class="line">//触发student组件实例身上的test(getStudentName)事件;即this.$emit(&#x27;传过来的事件名&#x27;,参数数据）；</span><br><span class="line">this.$emit(&#x27;test&#x27;,this.name,xx,32);</span><br><span class="line">&#125;</span><br><span class="line">unbind()&#123;</span><br><span class="line">//this.$off(&#x27;demo1&#x27;); //解绑一个自定义事件</span><br><span class="line">//this.$off(&#123;&#x27;xx&#x27;,&#x27;xx&#x27;,&#x27;xx&#x27;&#125;); //解绑多个自定义事件</span><br><span class="line">this.$off(); //解绑所有自定义事件</span><br><span class="line">&#125;,</span><br><span class="line">death()&#123;</span><br><span class="line">this.$destroy(); //销毁当前student组件的实例，销毁后所有student实例的自定义事件全部失效</span><br><span class="line">&#125;</span><br><span class="line"> &#125;</span><br><span class="line"> &lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h2 id="全局事件总线"><a href="#全局事件总线" class="headerlink" title="全局事件总线"></a>全局事件总线</h2><p>适用与任意组件间的通信</p>
<p>main.js</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &#x27;vue&#x27;</span><br><span class="line">import App from &#x27;./App.vue&#x27;</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line"> el:&#x27;#root&#x27;,</span><br><span class="line"> render:h=&gt;h(App),</span><br><span class="line"> beforeCreate()&#123;</span><br><span class="line">    Vue.prototype.$bus=this //安装全局事件总线</span><br><span class="line"> &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>School.vue</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default&#123;</span><br><span class="line"> name:&#x27;school&#x27;,</span><br><span class="line"> data()&#123;</span><br><span class="line"> return&#123;</span><br><span class="line"> name:&#x27;xuexiao&#x27;,</span><br><span class="line"> address:&#x27;biejing&#x27;</span><br><span class="line"> &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"> mounted()&#123;</span><br><span class="line"> //接受数据</span><br><span class="line"> this.$bus.$on(&#x27;hello&#x27;,(data)=&gt;&#123;</span><br><span class="line"> console.log(&#x27;recieve data&#x27;,data);</span><br><span class="line"> &#125;);</span><br><span class="line"> &#125;,</span><br><span class="line"> beforeDestroy()&#123;</span><br><span class="line"> //解绑事件</span><br><span class="line"> this.$bus.$off(&#x27;hello&#x27;)&#125;</span><br><span class="line"> &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<p>School.vue</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;temlate&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default(&#123;</span><br><span class="line"> name:&#x27;School&#x27;,</span><br><span class="line"> data()&#123;</span><br><span class="line"> return&#123;</span><br><span class="line"> name:&#x27;小米&#x27;,</span><br><span class="line"> sex:&#x27;woman&#x27;,</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;,</span><br><span class="line"> methods:&#123;</span><br><span class="line"> sendStudentName()&#123;</span><br><span class="line"> //提供数据</span><br><span class="line"> this.$bus.$emit(&#x27;hello&#x27;,32)</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;,</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<h2 id="消息发布和订阅"><a href="#消息发布和订阅" class="headerlink" title="消息发布和订阅"></a>消息发布和订阅</h2><p>适用于任意组件间通信</p>
<p>School.vue</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">//安装pubsub: npm i pubsub-js</span><br><span class="line">import pubsub from &#x27;pubsub-js&#x27;</span><br><span class="line">export default&#123;</span><br><span class="line"> name:&#x27;School&#x27;,</span><br><span class="line"> data()&#123;</span><br><span class="line"> return&#123;</span><br><span class="line"> name:&#x27;xuexiao&#x27;,</span><br><span class="line"> address:&#x27;beijing&#x27;</span><br><span class="line"> &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"> mounted()&#123;</span><br><span class="line"> //订阅消息，接收数据</span><br><span class="line"> this.pubId=pubsub.subscribe(&#x27;hello&#x27;,function(msgName,data)&#123;</span><br><span class="line"> console.log(&#x27;有人发布hello消息&#x27;,msgName,data);</span><br><span class="line"> console.log(this);</span><br><span class="line">  &#125;)</span><br><span class="line"> &#125;,</span><br><span class="line"> beforeDestroy()&#123;</span><br><span class="line"> pubsub.unsubscribe(this.pubId);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<p>student.vue</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">import pubsub from &#x27;pubsub-js&#x27;</span><br><span class="line">export default (&#123;</span><br><span class="line"> name:&#x27;Student&#x27;,</span><br><span class="line"> data()&#123;</span><br><span class="line"> return&#123;</span><br><span class="line"> name:&#x27;xiaomei&#x27;,</span><br><span class="line"> sex:&#x27;woman&#x27;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;,</span><br><span class="line"> methods:&#123;</span><br><span class="line"> ///提供数据</span><br><span class="line"> sendData()&#123;</span><br><span class="line"> pubsub.publish(&#x27;hello&#x27;,2222);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;,</span><br><span class="line"> &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>nextTick</li>
</ul>
<p>语法：<code>this.$nextTick(回调函数)</code><br>作用：在下一次 DOM 更新结束后执行其指定的回调,用于当改变数据后，要基于更新后的新 DOM 进行某些操作时，要在 nextTick 所指定的回调函数中执行</p>
<ul>
<li>mixins(混入)配置项</li>
</ul>
<p>可以把多个组件共用的配置提取成一个混入对象<br>school 组件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">&lt;h2 @click=&quot;showName&quot; &gt;&#123;&#123;name&#125;&#125;&lt;/h2&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">//引用一个test</span><br><span class="line">import&#123;test&#125; from &#x27;../mixin&#x27;</span><br><span class="line">//import&#123;test,test2&#125; from &#x27;../mixn&#x27;</span><br><span class="line"></span><br><span class="line">export default&#123;</span><br><span class="line"> name:&#x27;School&#x27;,</span><br><span class="line"> data()&#123;</span><br><span class="line"> return &#123;name:&#x27;daxue&#x27;&#125;</span><br><span class="line"> &#125;,</span><br><span class="line"> mixins:[test]</span><br><span class="line"> //mixins:[test,test2]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//全局混入</span><br><span class="line">//Vue.mixin(xxx)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>mixin.js</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//定义混合</span><br><span class="line">export const test=&#123;</span><br><span class="line"> methods:&#123;</span><br><span class="line">  showNamw()&#123;alert(this.name);&#125;</span><br><span class="line">  &#125;,</span><br><span class="line"> mounted()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">export const test2=&#123;</span><br><span class="line"> data()&#123;</span><br><span class="line"> return&#123;</span><br><span class="line">  x:2,</span><br><span class="line">  y:1</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"> mounted()&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>插件:用于增强 Vue</li>
</ul>
<p>main.js</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//引入Vue</span><br><span class="line">import Vue from &#x27;vue&#x27;</span><br><span class="line">//引入APP</span><br><span class="line">import APP from &#x27;./App.vue&#x27;</span><br><span class="line">//引入插件</span><br><span class="line">import plugins from &#x27;./plugins&#x27;</span><br><span class="line"></span><br><span class="line">//使用插件</span><br><span class="line">Vue.use(plugins,33,2);</span><br><span class="line"></span><br><span class="line">//创建VM</span><br><span class="line">new Vue(&#123;</span><br><span class="line"> el:&#x27;#root&#x27;,</span><br><span class="line"> render:h=&gt;h(App)</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure>

<p>plugins.js</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//定义插件</span><br><span class="line">export default&#123;</span><br><span class="line">install (Vue,x,y)&#123;</span><br><span class="line">console.log(x,y);</span><br><span class="line">//添加全局过滤器</span><br><span class="line">Vue.filter(....)</span><br><span class="line">//添加实例方法</span><br><span class="line">Vue.prototype.$myMethod=function()&#123;..&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>scoped 样式<br>让样式只在本组件内有效，即局部生效，防止冲突。写法：<code>&lt;style scoped&gt;&lt;/style&gt;</code></li>
</ul>
<blockquote>
<p>组件化编码流程：1.拆分成静态组件。2.实现动态组件。3.实现交互即绑定事件</p>
</blockquote>
<ul>
<li>vue 封装的动画与过渡</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">&lt;ransition name=&quot;hello&quot; appear&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">/*动画*/</span><br><span class="line">.hello-enter-active&#123;</span><br><span class="line"> animation: test 0.5s linear;</span><br><span class="line">&#125;</span><br><span class="line">.hello-leave-active&#123;</span><br><span class="line"> animation: test 0.3s linear reverse;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes test&#123;&#125;</span><br><span class="line"></span><br><span class="line">/*详细写法</span><br><span class="line">/*进入的起点*/</span><br><span class="line">.hello-enter&#123;</span><br><span class="line"> transform:translateX(-100x);</span><br><span class="line">&#125;</span><br><span class="line">/*进入的终点*/</span><br><span class="line">.hello-enter-to&#123;</span><br><span class="line"> transform:translateX(0px);</span><br><span class="line">&#125;</span><br><span class="line">/**/</span><br><span class="line">.hello-leave&#123;</span><br><span class="line"> transform:translateX(0px);</span><br><span class="line">&#125;</span><br><span class="line">/**/</span><br><span class="line">.hello-leave-to&#123;</span><br><span class="line"> transform:translateX(-100px);</span><br><span class="line">&#125;</span><br><span class="line">*/</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<h2 id="vue-脚手架配置代理服务"><a href="#vue-脚手架配置代理服务" class="headerlink" title="vue 脚手架配置代理服务"></a>vue 脚手架配置代理服务</h2><p>vue.config.js</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">module.exports=&#123;</span><br><span class="line"></span><br><span class="line"> pages:&#123;</span><br><span class="line">  index:&#123;</span><br><span class="line">   //入口</span><br><span class="line">  entry:&#x27;src/main.js&#x27;</span><br><span class="line">   &#125;,</span><br><span class="line"> &#125;,</span><br><span class="line">lintOnSave:false, //关闭语法检测</span><br><span class="line">//开启代理服务器（一）:配置简单，但不能配置多个代理</span><br><span class="line">/*</span><br><span class="line">devServer:&#123;</span><br><span class="line"> proxy:&#x27;http://localhost:3333&#x27;</span><br><span class="line">&#125;*/</span><br><span class="line">//开启代理服务器（二）:可以配置多个代理</span><br><span class="line">devServer:&#123;</span><br><span class="line">proxy:&#123;</span><br><span class="line">&#x27;/api&#x27;:&#123; //匹配所有以&#x27;/api&#x27;开头的请求路径</span><br><span class="line">target:&#x27;&lt;url&gt;&#x27;,</span><br><span class="line">ws:true, //用于支持websocket</span><br><span class="line">changeOrigin:true //用于控制请求头中的host值,true时，服务器请求头伪装成localhost：5050，false时为localhost:8080</span><br><span class="line">&#125;,</span><br><span class="line">&#x27;/test&#x27;:&#123;</span><br><span class="line">target:&#x27;&lt;other_url&gt;&#x27;</span><br><span class="line">&#125;,</span><br><span class="line">&#x27;/test2&#x27;&#123;</span><br><span class="line">target:&#x27;http://localhost:5000&#x27;,</span><br><span class="line">pathRewrite:&#123;&#x27;^/test2&#x27;:&#x27;&#x27;&#125;, //清除地址前面的协议域名端口http://localhost:8080</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>App.vue</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import axios from &#x27;axios&#x27;</span><br><span class="line">export default &#123;</span><br><span class="line"> name:&#x27;App&#x27;,</span><br><span class="line"> methods:&#123;</span><br><span class="line"> getStudents()&#123;</span><br><span class="line"> aixos.get(&#x27;http://localhost:8081/students&#x27;).then(</span><br><span class="line"> response=&gt;&#123;</span><br><span class="line"> console.log(&#x27;请求成功&#x27;,data);</span><br><span class="line"> &#125;,</span><br><span class="line"> error=&gt;&#123;</span><br><span class="line"> console.log(&#x27;请求fail&#x27;,message);</span><br><span class="line"> &#125;);</span><br><span class="line">//aioxs.post(地址,&#123;key:value,key2:value2&#125;).then(function(response)&#123;&#125;,function(error)&#123;&#125;)</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h2 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h2><p>用于父组件与子组件的通信</p>
<p>Category.vue</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div class=&quot;category&quot;&gt;</span><br><span class="line">&lt;h3&gt;&#123;&#123;title&#125;&#125;&lt;/h3&gt;</span><br><span class="line">&lt;!--定义插槽--&gt;</span><br><span class="line">&lt;!-- 默认插槽 --&gt;</span><br><span class="line">&lt;slot &gt;默认 当没有传递具体结构时，会显示&lt;/slot&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 具名插槽 --&gt;</span><br><span class="line">&lt;slot name=&quot;center&quot;&gt;默认 当没有传递具体结构时，会显示&lt;/slot&gt;</span><br><span class="line">&lt;slot name=&quot;footer&quot;&gt;默认 当没有传递具体结构时，会显示&lt;/slot&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 作用域插槽:数据在组件的自身，但根据数据生成的结构需要组件的使用者来决定 --&gt;</span><br><span class="line">&lt;slot :games=&quot;test&quot;  :games2:&#x27;list&#x27;&gt;默认 当没有传递具体结构时，会显示&lt;/slot&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default&#123;</span><br><span class="line"> name:&#x27;Category&#x27;,</span><br><span class="line"> data()&#123;</span><br><span class="line"> return &#123;</span><br><span class="line"> test:[&#x27;xxx&#x27;,&#x27;0989&#x27;,&#x27;33&#x27;],</span><br><span class="line"> list:[&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;]</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;,</span><br><span class="line"> props:[&#x27;listData&#x27;,&#x27;title&#x27;]</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>App.vue</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;Category&gt;</span><br><span class="line">&lt;img slot=&quot;center&quot; src=&quot;xxx&quot;&gt;</span><br><span class="line">&lt;a slot=&quot;footer&quot; href=&quot;xxxx&quot;&gt;&lt;/a&gt;</span><br><span class="line">&lt;/Category&gt;</span><br><span class="line">&lt;Category&gt;</span><br><span class="line">&lt;template scope=&quot;test1&quot;&gt;</span><br><span class="line">&lt;h1&gt;&#123;&#123;test1.games&#125;&#125;&lt;/h1&gt;</span><br><span class="line">&lt;h1&gt;&#123;&#123;test1.games2&#125;&#125;&lt;/h1&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;/Category&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="webStorage"><a href="#webStorage" class="headerlink" title="webStorage"></a>webStorage</h2><p>存储内容大小一般支持 5MB 左右<br>浏览器端通过 Window.sessionStorage 和 Window.localStorage 属性来实现本地存储。<br>相关 api：</p>
<ol>
<li>xxxxStorage.setItem(‘key’,’value’);接受一个键和值作为参数，把键值添加到存储中，若存在则更新。</li>
<li>xxxxStorage.getItem(‘person’);接受一个键名作为参数,返回键名对应的值。</li>
<li>xxxStorage.removeItem(‘key);接受一个键名作为参数,删除键名和其对应的值。</li>
<li>xxxStorage.clear();清空存储中的所有数据。</li>
</ol>
<p>注意：1.SessionStorage 存储内容会随浏览器窗口的关闭而消失；2.LocalStorage 存储的内容，需手动清除才会消失。3.xxxxx.Storage.getItem(xx);若 xx 对应的值获取不到则返回 null；4.JSON.parse(null)的结果依然是 null。</p>
<h2 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a>vuex</h2><p>专门在 vue 中实现集中式状态（数据）管理的一个 vue 插件,对 vue 应用中多个组件的共享状态进行集中式的管理（读与写），也是一种组件间通信的方式，适用于任意组件间的通信。</p>
<p>使用时机：多个组件需要共享数据时</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/fJo8ZF"><img src="https://z3.ax1x.com/2021/08/10/fJo8ZF.png" alt="fJo8ZF.png"></a></p>
<h3 id="store"><a href="#store" class="headerlink" title="store"></a>store</h3><p>创建文件：src/store/index.js</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &#x27;vue&#x27;</span><br><span class="line">import Vuex from &#x27;vuex&#x27;</span><br><span class="line">//使用vuex插件</span><br><span class="line">Vue.use(Vuex);</span><br><span class="line"></span><br><span class="line">//action--用于响应组件中的动作</span><br><span class="line">const actions=&#123;&#125;</span><br><span class="line">//mutations--用于操作数据state</span><br><span class="line">const mutations=&#123;&#125;</span><br><span class="line">//state--用于储存数据</span><br><span class="line">const state=&#123;&#125;</span><br><span class="line"></span><br><span class="line">//创建store</span><br><span class="line">const store =new Vuex.Store(&#123;</span><br><span class="line">actions,</span><br><span class="line">mutatuons,</span><br><span class="line">state,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//暴露store</span><br><span class="line">expore default store</span><br></pre></td></tr></table></figure>

<p>在 main.js 中创建 vm 时传入 store 配置项</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import Vue form &#x27;vue&#x27;</span><br><span class="line">import App from &#x27;/App.vue&#x27;</span><br><span class="line">//引用插件</span><br><span class="line">import vueResource from &#x27;vue-resource&#x27;</span><br><span class="line">import Vuex form &#x27;vuex&#x27;</span><br><span class="line">import store form  &#x27;./store&#x27;</span><br><span class="line"></span><br><span class="line">//使用插件</span><br><span class="line">Vue.use(vueResource);</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">el:&#x27;#app&#x27;,</span><br><span class="line">render:h=&gt;h(App),</span><br><span class="line">store,</span><br><span class="line">beforeCreate()&#123;</span><br><span class="line">Vue.prototype.$bus=this</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><p>初始化数据、配置 actions、mutations，操作文件 store.js</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &#x27;vue&#x27;</span><br><span class="line">import Vuex form &#x27;vuex&#x27;</span><br><span class="line">Vue.use (Vuex);</span><br><span class="line"></span><br><span class="line">const actions=&#123;</span><br><span class="line">//响应组件中的动组</span><br><span class="line">jia:function(context,value)&#123;</span><br><span class="line"> //context里中存放着一些方法</span><br><span class="line">context.commit(&#x27;JIA&#x27;,value);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const mutations=&#123;</span><br><span class="line">//执行jia</span><br><span class="line">JIA:function(state,value)&#123;</span><br><span class="line">state.sum+=value;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//初始化数据</span><br><span class="line">const state=&#123;sum=0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//创建并暴露store</span><br><span class="line">export default new Vuex.store(&#123;</span><br><span class="line">actions:actions,</span><br><span class="line">mutations,</span><br><span class="line">state,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>组件中读取 vuex 中的数据：<code>$store.state.sum</code><br>组件中修改 vuex 中的数据：<code>$store.dispatch(&#39;actions中的方法名&#39;,数据)</code>或<code>$store.commit(&#39;mutatuins中的方法名&#39;,数据)</code></p>
<blockquote>
<p>若没有网络请求或其他业务逻辑，组件中也可以越过 actions，即不写 dispatch,直接编写 commit</p>
</blockquote>
<h4 id="四个-map-方法的使用"><a href="#四个-map-方法的使用" class="headerlink" title="四个 map 方法的使用"></a>四个 map 方法的使用</h4><ul>
<li>mapState:用于帮助我们映射 state 中的数据为计算属性</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">computed:&#123;</span><br><span class="line">//借助mapState生成计算属性，对象写法</span><br><span class="line">...mapState(&#123;sum:&#x27;sum&#x27;,school:&#x27;shchool&#x27;,subject:&#x27;subject&#x27;&#125;);</span><br><span class="line">//借助mapState生成计算属性，对象写法</span><br><span class="line">...mapState([&#x27;sum&#x27;,&#x27;shchool&#x27;,&#x27;subject&#x27;]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>mapGetters: 帮助我们映射 getters 中的数据为计算属性</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">computed:&#123;</span><br><span class="line">...mapGetters(&#123;b:&#x27;b&#x27;&#125;);</span><br><span class="line">...mapGetters([&#x27;b&#x27;]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>mapActions 方法：帮助我们生成与 action 对法的方法，即包含<code>$store.dispatch(xxx)</code>的函数</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">methods:&#123;</span><br><span class="line">...mapActions(&#123;inicrementOdd:&#x27;jiaOdd&#x27;,incrementWait:&#x27;jiaWait&#x27;&#125;)</span><br><span class="line">...mapActions([&#x27;jiaOdd&#x27;,&#x27;jiaWait&#x27;])</span><br></pre></td></tr></table></figure>

<ul>
<li>mapMutations 方法：用于帮助我们生成与 mutations 对话的方法，即：包含$store.commit(xxx)的函数</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">methods:&#123;</span><br><span class="line">...mapMutations(&#123;increment:&#x27;JIA&#x27;,decrement:&#x27;JIAN&#x27;&#125;)</span><br><span class="line">...mapMutations([&#x27;JIA&#x27;,&#x27;JIAN&#x27;])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>mapActions 与 mapMutations 使用时，若需要传递参数需要在模板中绑定事件时传递好参数，否则参数是事件对象</p>
</blockquote>
<h3 id="store-1"><a href="#store-1" class="headerlink" title="store"></a>store</h3><p>index.js</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//创建store</span><br><span class="line">import vue from &#x27;vue&#x27;</span><br><span class="line">import vuex from &#x27;vuex&#x27;</span><br><span class="line">//应用vuex插件</span><br><span class="line">Vue.use(vuex);</span><br><span class="line"></span><br><span class="line">const test=&#123;</span><br><span class="line">//namespaced:true,</span><br><span class="line">action:&#123;&#125;,</span><br><span class="line">mutations:&#123;&#125;,</span><br><span class="line">state:&#123;&#125;,</span><br><span class="line">getters:&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">//store：actions、mutations、state、getters</span><br><span class="line"></span><br><span class="line">//创建暴露store</span><br><span class="line">export default new Vuex.store&#123;</span><br><span class="line"> modules:&#123;</span><br><span class="line"> a:test,</span><br><span class="line"> b:xxx</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>test.vue</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">,,,</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123;mapState,mapGetters,mapMutations,mapActions &#125; form &#x27;vuex&#x27;</span><br><span class="line">export default &#123;</span><br><span class="line">name:&#x27;test&#x27;</span><br><span class="line">data()&#123;&#125;,</span><br><span class="line">computed:&#123;</span><br><span class="line">personList()&#123;</span><br><span class="line"> return this.$store.state.personAbout</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h3 id="模块化-命名空间"><a href="#模块化-命名空间" class="headerlink" title="模块化+命名空间"></a>模块化+命名空间</h3><p>为了让代码更好维护，让多种数据分类更加明确</p>
<p>修改 store.js</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">const countAbout=&#123;</span><br><span class="line">namespaced:true, //开启命名空间</span><br><span class="line">state:&#123;x:1&#125;,</span><br><span class="line">mutatuions:&#123;.........&#125;,</span><br><span class="line">actions:&#123;..&#125;,</span><br><span class="line">getters:&#123;</span><br><span class="line"></span><br><span class="line">bigSum(state)&#123;</span><br><span class="line"> return state.sum+1;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const personAbout=&#123;</span><br><span class="line">namespaced:true,</span><br><span class="line">state:&#123;..&#125;,</span><br><span class="line">mutations:&#123;&#125;,</span><br><span class="line">actions:&#123;&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const store=new Vuex.Store(&#123;</span><br><span class="line">modules:&#123;</span><br><span class="line">countAbout,</span><br><span class="line">personAbout</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>开启命名空间后，组件读取 state 数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">this.$store.state.personAbout.list</span><br><span class="line">//借助mapState读取</span><br><span class="line">...mapState(&#x27;countAbout&#x27;,[&#x27;sum,&#x27;school&#x27;,&#x27;subject&#x27;]);</span><br></pre></td></tr></table></figure>

<p>开启命名空间后，组件读取 getters 数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">this.$store.getters(&#x27;personAbout/firstPersonName&#x27;)</span><br><span class="line">//借助mapGetters读取</span><br><span class="line">...mapGetters(&#x27;countAbout&#x27;,[&#x27;bigSum&#x27;]);</span><br></pre></td></tr></table></figure>

<p>开启命名空间后，组件读取 dispatch 数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">this.$store.dispatch(&#x27;personAbout/addPersonWang&#x27;person`)</span><br><span class="line">//借助mapActions读取</span><br><span class="line">...mapActions(&#x27;countAbout&#x27;,&#123;incrementOdd:&#x27;jiaOdd&#x27;,incrementWait:&#x27;jiaWait&#x27;&#125;);</span><br></pre></td></tr></table></figure>

<p>开启命名空间后，组件读取 commit 数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">this.$store.commit(&#x27;personAbout/ADD_PERSON&#x27;,person)</span><br><span class="line">...mapMutations(&#x27;countAbout&#x27;,&#123;increment:&quot;JIA&quot;,decrement:&quot;JIAN&quot;&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><p>路由就是一组映射（key-value）的对应关系,key 为路径，value 是 function 或 Component</p>
<ul>
<li>后端路由:value 是 function,用于处理客户端提交的请求，即服务端根据请求路径找到匹配的函数处理数据后，返回响应数据</li>
</ul>
<blockquote>
<p>路由组件一般放在 pages 文件夹，一般组件则放在 Component 文件夹；通过切换，隐藏了的路由组件，默认是被销毁的，需要的时候在去挂载；每个组件都有$route属性，里面存储着自己的路由信息<br>；整个应用只有一个route，可通过组件的$router 属性获取到。</p>
</blockquote>
<h4 id="vue-router：vue-的一个插件库，用来实现-SPA-应用（单个-web-应用，整个页面只有一个完整页面，只会做页面的局部更新，数据需要通过-ajax-请求获取）"><a href="#vue-router：vue-的一个插件库，用来实现-SPA-应用（单个-web-应用，整个页面只有一个完整页面，只会做页面的局部更新，数据需要通过-ajax-请求获取）" class="headerlink" title="vue-router：vue 的一个插件库，用来实现 SPA 应用（单个 web 应用，整个页面只有一个完整页面，只会做页面的局部更新，数据需要通过 ajax 请求获取）"></a>vue-router：vue 的一个插件库，用来实现 SPA 应用（单个 web 应用，整个页面只有一个完整页面，只会做页面的局部更新，数据需要通过 ajax 请求获取）</h4><p>src/router/index.js</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">//引入路由</span><br><span class="line">import VueRouter from &#x27;vue-router&#x27;</span><br><span class="line">//引入组件</span><br><span class="line">import About form &#x27;../components/About.vue&#x27;</span><br><span class="line">import Home form &#x27;../components/Home.vue&#x27;</span><br><span class="line"></span><br><span class="line">//创建并暴露一个路由器</span><br><span class="line">export default new VueRouter(&#123;</span><br><span class="line"></span><br><span class="line">routes:[</span><br><span class="line">&#123;path:&quot;/about&quot;,</span><br><span class="line">component:About</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">path:&quot;/home&quot;</span><br><span class="line">component:Home</span><br><span class="line">children:[ //多级路由</span><br><span class="line">&#123;</span><br><span class="line">path:&#x27;news&#x27;, //不能写‘/news’</span><br><span class="line">component:News,</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>main.js</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//引入Vue</span><br><span class="line">import Vue from &#x27;vue&#x27;</span><br><span class="line">//引入APP</span><br><span class="line">import App form &#x27;./App.vue&#x27;</span><br><span class="line">//引入VueRouter</span><br><span class="line">import VueRouter from &#x27;vue-router&#x27;</span><br><span class="line">//引入路由器</span><br><span class="line">import router form &#x27;./router&#x27;</span><br><span class="line"></span><br><span class="line">//应用插件</span><br><span class="line">Vue.use(VueRouter)</span><br><span class="line"></span><br><span class="line">//创建vm</span><br><span class="line">new Vue(&#123;</span><br><span class="line">el:&quot;#app&quot;,</span><br><span class="line">render:h=&gt;h(App),</span><br><span class="line">router:router</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>index.js 跳转</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;!--用route-link代替a标签去跳转--&gt;</span><br><span class="line">&lt;!--active-class属性：该元素激活时触发样式，可配置高亮样式--&gt;</span><br><span class="line">&lt;router-link  class=&quot;&quot; active-class=&quot;active&quot; to=&quot;/about&quot;&gt;About&lt;/router-link&gt;</span><br><span class="line">&lt;router-link  class=&quot;&quot; to=&quot;/home&quot;&gt;Home&lt;/router-link&gt;</span><br><span class="line">&lt;router-link  class=&quot;&quot; to=&quot;/home/news&quot;&gt;Home&lt;/router-link&gt;</span><br><span class="line">&lt;!--跳转路由并携带query参数（字符串写法）--&gt;</span><br><span class="line">&lt;router-link  class=&quot;&quot; to=&quot;/home/news?id=xxx&amp;titel=xxx&quot;&gt;Home&lt;/router-link&gt;</span><br><span class="line">&lt;!--跳转路由并携带query参数（对象写法）--&gt;</span><br><span class="line">&lt;router-link  class=&quot;&quot; to=&quot;</span><br><span class="line">&#123;path:&#x27;/home/news&#x27;,</span><br><span class="line">query:&#123;id:xxx,titel:xxx&#125;</span><br><span class="line">&#125;&quot;&gt;&lt;/router-link&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;router-view&gt;&lt;/route-view&gt; &lt;!--指定组件呈现的位置--&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<p>接收 query 参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$route.query.id</span><br></pre></td></tr></table></figure>

<h4 id="命名路由"><a href="#命名路由" class="headerlink" title="命名路由"></a>命名路由</h4><p>简化路由跳转</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">path:&#x27;/demo&#x27;,</span><br><span class="line">component:Demo,</span><br><span class="line">children:[</span><br><span class="line">&#123;</span><br><span class="line"> path:&#x27;test&#x27;</span><br><span class="line"> component:Test,</span><br><span class="line"> chilren:[</span><br><span class="line">  &#123;</span><br><span class="line">  name:&#x27;hello&#x27; //给路由命名</span><br><span class="line">  path:&#x27;welcome&#x27;,</span><br><span class="line">  component:Hello</span><br><span class="line">  &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">name:weather</span><br><span class="line">path:&#x27;weather/:id/:title&#x27;, //使用占位符声明接收params参数</span><br><span class="line">component:Weather</span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>跳转</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-link :to=&quot;name:hello&quot;&gt;test&lt;/router-link&gt;</span><br><span class="line">&lt;router-link :to=&quot;</span><br><span class="line">&#123;</span><br><span class="line">name:hello,</span><br><span class="line">query:&#123;id:xxx,title:xxx&#125;</span><br><span class="line">&#125;&quot;&gt;test&lt;/router-link&gt;</span><br><span class="line">&lt;!--跳转路由并携带params参数（字符串写法）--&gt;</span><br><span class="line">&lt;router-link  class=&quot;&quot; to=&quot;/home/news/id/title&quot;&gt;Home&lt;/router-link&gt;</span><br><span class="line">&lt;!--跳转路由并携带params参数（对象写法）--&gt;</span><br><span class="line">&lt;router-link  class=&quot;&quot; to=&quot;</span><br><span class="line">&#123;name:&#x27;weather&#x27;,</span><br><span class="line">params:&#123;id:xxx,titel:xxx&#125;</span><br><span class="line">&#125;&quot;&gt;&lt;/router-link&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>携带 params 参数时，若使用 to 的对象写法，则不能使用 path 配置项，必须用 name 配置下</p>
</blockquote>
<p>接收 params 参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$route.params.id</span><br></pre></td></tr></table></figure>

<h3 id="路由的-props-配置"><a href="#路由的-props-配置" class="headerlink" title="路由的 props 配置"></a>路由的 props 配置</h3><p>index.js</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">export default new VueRouter(&#123;</span><br><span class="line"></span><br><span class="line">routes:[</span><br><span class="line">&#123;</span><br><span class="line">path:&#x27;/home&#x27;,</span><br><span class="line">component:Home,</span><br><span class="line">children:[</span><br><span class="line">&#123;</span><br><span class="line">name:&#x27;test&#x27;,</span><br><span class="line">path:&#x27;detail/:id/:title&#x27;,</span><br><span class="line">compomemt:Detail,</span><br><span class="line">//props的第一种写法，值为对象，该对象中的所有key-value都会以props的形式传给Detail组件</span><br><span class="line">props:&#123;a:1,b:&#x27;hello&#x27;&#125;</span><br><span class="line">//props的第二种写法，值为布尔值，若布尔值为真，就会把该路由组件收到的所有params参数，以props的形式传给detail组件。只能传params参数</span><br><span class="line">props：true</span><br><span class="line">//props的第三种写法，值为函数,该函数返回的对象中每一组key-value都会通过props传给Detail组件</span><br><span class="line">props($route)&#123;</span><br><span class="line">return &#123;id:$route.query.id,title:$route.query.title&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>Detail.vue</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;ul&gt;</span><br><span class="line"> &lt;li&gt;&lt;/li&gt;</span><br><span class="line"> &lt;li&gt;&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default&#123;</span><br><span class="line">name:&#x27;Detail&#x27;,</span><br><span class="line">props:[&#x27;id&#x27;,&#x27;title&#x27;],</span><br><span class="line">computed:&#123;xxx&#125;,</span><br><span class="line">mounted()&#123;xxx&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><router-link>的 replace 属性<ul>
<li>作用：控制路由跳转时操作的浏览器历史记录的模式</li>
<li>历史记录的写入方式：<code>push</code>追加历史记录，<code>replace</code>替换当前记录；路由跳转时默认为<code>push</code></li>
<li><router-link replace >test</router-link></li>
</ul>
</li>
</ul>
<p>message.vue</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">name:&#x27;massage&#x27;,</span><br><span class="line">data()&#123;&#125;,</span><br><span class="line">methods:&#123;</span><br><span class="line">pushShow(m)&#123;</span><br><span class="line">this.$router.push(&#123;</span><br><span class="line"></span><br><span class="line"> name:&#x27;test&#x27;,</span><br><span class="line"> query:&#123;</span><br><span class="line">  id:m.id,</span><br><span class="line">  title:m.title</span><br><span class="line"> &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Banner.vue</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">    name:&#x27;Banner&#x27;</span><br><span class="line"> methods:&#123;</span><br><span class="line"> back()&#123;this.$router.back()&#125;,</span><br><span class="line"> forward()&#123;this.$router.forward()&#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="编程式路由导航"><a href="#编程式路由导航" class="headerlink" title="编程式路由导航"></a>编程式路由导航</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">this.$router.push(&#123;</span><br><span class="line"> name:&#x27;test&#x27;,</span><br><span class="line"> params:&#123;id:xxx,title:xxx&#125;</span><br><span class="line"> &#125;)</span><br><span class="line"></span><br><span class="line">this.$router.replace(&#123;</span><br><span class="line"> name:&#x27;test&#x27;,</span><br><span class="line"> params:&#123;id:xxx,title:xxx&#125;</span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure>

<h3 id="缓存路由组件"><a href="#缓存路由组件" class="headerlink" title="缓存路由组件"></a>缓存路由组件</h3><p>让不展示的路由组件保持挂载，不被销毁</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;keep-alive include=&quot;News&quot;&gt;</span><br><span class="line">&lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">&lt;/keep-alive&gt;</span><br></pre></td></tr></table></figure>

<p>home.vue</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line"> &lt;ul&gt;</span><br><span class="line">  &lt;li&gt;</span><br><span class="line">   &lt;router-link to=&quot;/home/new&quot;&gt;news&lt;/router-link&gt;</span><br><span class="line">  &lt;/li&gt;</span><br><span class="line">  &lt;li&gt;</span><br><span class="line">   &lt;router-link to=&quot;/home/message&quot;&gt;message&lt;/router-link&gt;</span><br><span class="line">  &lt;/li&gt;</span><br><span class="line"> &lt;/ul&gt;</span><br><span class="line">&lt;!--缓存多个路由组件--&gt;</span><br><span class="line">&lt;!-- &lt;keep-alive :include=&quot;[&#x27;&#x27;,&#x27;&#x27;]&quot;&gt;--&gt;</span><br><span class="line">&lt;!--缓存一个路由组价--&gt;</span><br><span class="line">&lt;keep-alive include=&quot;News&quot;&gt;</span><br><span class="line"> &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">&lt;/keep-alive&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default&#123;</span><br><span class="line"> name:&#x27;Home&#x27;,</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>New.vue</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"> export default&#123;</span><br><span class="line"> name:&#x27;News&#x27;,</span><br><span class="line"> data()&#123;</span><br><span class="line">  return&#123;</span><br><span class="line">  opacity:1</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"> //路由组件所独有的两个钩子，用于捕获路由组件的激活状态</span><br><span class="line"> activated()&#123;console.log(&#x27;News组件被激活了&#x27;)&#125;</span><br><span class="line"> deactivated()&#123;console.log(&#x27;News组件失活了&#x27;)&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="路由守卫"><a href="#路由守卫" class="headerlink" title="路由守卫"></a>路由守卫</h3><p>对路由进行权限控制</p>
<ul>
<li>全局守卫</li>
</ul>
<p>index.js</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">const router=new VueRounter(&#123;</span><br><span class="line"> routes:[</span><br><span class="line">  &#123;</span><br><span class="line">  name:&#x27;test&#x27;,</span><br><span class="line">  path:&#x27;/about&#x27;,</span><br><span class="line">  component:About</span><br><span class="line">  meta:&#123;isAuth:true,title:&#x27;新闻&#x27;&#125;,</span><br><span class="line">  &#125;,</span><br><span class="line"> ]</span><br><span class="line">//全局前置路由守卫---初始化时被调用，每次路由切换之前被调用</span><br><span class="line">router.beforeEach((to,from,next)=&gt;&#123;</span><br><span class="line">if(to.meta.isAuth)&#123;//判断当前路由是否需要进行权限控制</span><br><span class="line"> if(localStorage.getItem(&#x27;shool&#x27;)===&#x27;test&#x27;)&#123;next();&#125;</span><br><span class="line"> else&#123;alert(&#x27;学校名不对&#x27;)&#125;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">next(); //放行</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">//全局前置路由守卫---初始化时被调用，每次路由切换之后被调用</span><br><span class="line">router.afterEach((to,from,next)=&gt;&#123;</span><br><span class="line">console.log(&#x27;后置路由守卫&#x27;);</span><br><span class="line">dovument.title=to.meta.title||&#x27;testTitle&#x27;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">export default router;</span><br></pre></td></tr></table></figure>

<ul>
<li>独享守卫</li>
</ul>
<p>index.js</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line">name:&#x27;news&#x27;,</span><br><span class="line">path:&#x27;news&#x27;,</span><br><span class="line">component:News,</span><br><span class="line">meta:&#123;isAuth:true,title:&#x27;新闻&#x27;&#125;,</span><br><span class="line">beforeEnter:(to,from,next)=&gt;&#123;</span><br><span class="line">if(to.meta.isAuth)&#123;//判断当前路由是否需要进行权限控制</span><br><span class="line"> if(localStorage.getItem(&#x27;shool&#x27;)===&#x27;test&#x27;)&#123;next();&#125;</span><br><span class="line"> else&#123;alert(&#x27;学校名不对&#x27;)&#125;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">next(); //放行</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>组件内守卫</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//进入守卫：进入该组件时被调用</span><br><span class="line">beforeRouteEnter(to,from,next)&#123;&#125;,</span><br><span class="line">//离开守卫：离开该组件时被调用</span><br><span class="line">beforeRouteLeave(to,from,next)&#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="路由器工作模式"><a href="#路由器工作模式" class="headerlink" title="路由器工作模式"></a>路由器工作模式</h3><p>对于一个 url 来说<code>#</code>及其后的内容就是 hash 值;hash 值不会包含在 http 请求中，即 hash 值不会带给服务器。</p>
<ul>
<li>hash 模式:</li>
</ul>
<p>地址中永远带着#号，不美观；通过第三方手机 app 分享时可能会标记为不合法；但其兼容性好；</p>
<ul>
<li>history 模式:</li>
</ul>
<p>地址干净，兼容比 hash 略差，应用部署上线时需要后端人员支持，解决刷新页面服务端 404 的问题；</p>
<h2 id="Vue-UI-组件库"><a href="#Vue-UI-组件库" class="headerlink" title="Vue UI 组件库"></a>Vue UI 组件库</h2><p>移动端：<code>Vant</code>,<code>Cube UI</code>,<code>Mint UI</code></p>
<p>PC 端：<code>Element UI</code>, <code>IView UI</code></p>
<p>main.js</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &#x27;vue&#x27;</span><br><span class="line">import App from &#x27;./App.vue&#x27;</span><br><span class="line">//引入ElementUI组件库</span><br><span class="line">import ElementUI from &#x27;element-ui&#x27;</span><br><span class="line">//引入ElementUI全部样式</span><br><span class="line">import &#x27;element-ui/lib/theme-chalk/index.css&#x27;;</span><br><span class="line"></span><br><span class="line">Vue.ues(ElementUI);</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line"> el:&#x27;#app&#x27;</span><br><span class="line"> render:h=&gt;h(App),</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>balel.config.js</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">module.exports=&#123;</span><br><span class="line">presets:[</span><br><span class="line"> &#x27;@vue/cli-plugin-babel/preset&#x27;,</span><br><span class="line"> [&quot;@babel/present-env&quot;,&#123;&quot;modules&quot;:false&#125;],</span><br><span class="line">],</span><br><span class="line">plugins:[</span><br><span class="line">[</span><br><span class="line"> &quot;component&quot;,</span><br><span class="line"> &#123;</span><br><span class="line"> &quot;libraryName&quot;:&#x27;element-ui&#x27;,</span><br><span class="line"> &quot;styleLibraryName&quot;:&quot;theme-chalk&quot;</span><br><span class="line"> &#125;</span><br><span class="line">]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="vue-刷新当前页面"><a href="#vue-刷新当前页面" class="headerlink" title="vue 刷新当前页面"></a>vue 刷新当前页面</h3><p>用 vue-router 重新路由到当前页面，页面是不进行刷新的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//###ctrl+F5刷新</span><br><span class="line">location.reload()；</span><br><span class="line">//或</span><br><span class="line">this.router.go(0);</span><br><span class="line"></span><br><span class="line">//局部刷新</span><br><span class="line">1. 跳转到一个空白页，再跳转回来</span><br><span class="line">2. v-if控制router-view的存亡来实现刷新</span><br></pre></td></tr></table></figure>

<h3 id="在-vue-中-checkbox-用法"><a href="#在-vue-中-checkbox-用法" class="headerlink" title="在 vue 中 checkbox 用法"></a>在 vue 中 checkbox 用法</h3><p>通过 v-model 来判断当前 checkbox 是否被选中， 它绑定一个数组，选中项的值会自动添加到数组中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">              &lt;input type=&quot;checkbox&quot; v-model=&quot;hobby2&quot; value=&quot;游泳&quot;&gt;游泳</span><br><span class="line">&lt;input type=&quot;checkbox&quot; v-model=&quot;hobby2&quot; value=&quot;健身&quot;&gt;健身</span><br><span class="line">&lt;input type=&quot;checkbox&quot; v-model=&quot;hobby2&quot; value=&quot;旅游&quot;&gt;旅游</span><br></pre></td></tr></table></figure>

<h3 id="VUE-实现-checkbox-的勾选"><a href="#VUE-实现-checkbox-的勾选" class="headerlink" title="VUE 实现 checkbox 的勾选"></a>VUE 实现 checkbox 的勾选</h3><p>给选择按钮绑定 v-mode 变量，值为 true 时就是选中状态，绑定点击事件，执行勾选操作</p>
<h3 id="自定义-checkbox-样式"><a href="#自定义-checkbox-样式" class="headerlink" title="自定义 checkbox 样式"></a>自定义 checkbox 样式</h3><p>通过 label 标签将 input 包裹住，通过 label for 绑定 input id，<br>将 input 设置 opacity: 0;不可见，再通过给设置 lable 标签或其中 div 来设置 checkbox 的默认样式及选中状态样式</p>
<h3 id="特殊符号（Unicode）"><a href="#特殊符号（Unicode）" class="headerlink" title="特殊符号（Unicode）"></a>特殊符号（Unicode）</h3><p><code>https://www.cnblogs.com/Whikiey/archive/2011/01/05/1926220.html</code></p>
<h3 id="vue-中native修饰符只对组件有效"><a href="#vue-中native修饰符只对组件有效" class="headerlink" title="vue 中native修饰符只对组件有效"></a>vue 中<code>native</code>修饰符只对组件有效</h3><h3 id="v-model-双向绑定-computed-属性，-若不同时加-get-和-set-则报错"><a href="#v-model-双向绑定-computed-属性，-若不同时加-get-和-set-则报错" class="headerlink" title="v-model 双向绑定 computed 属性， 若不同时加 get 和 set 则报错"></a>v-model 双向绑定 computed 属性， 若不同时加 get 和 set 则报错</h3><h3 id="当一层-flex-布局的时候，设置子元素的-width-100-就没有问题"><a href="#当一层-flex-布局的时候，设置子元素的-width-100-就没有问题" class="headerlink" title="当一层 flex 布局的时候，设置子元素的 width:100%就没有问题"></a>当一层 flex 布局的时候，设置子元素的 width:100%就没有问题</h3><p>当页面中多层 flex 布局嵌套的时候，设置其中子元素的 width：100%会不起作用。可把元素设置为绝对定位来解决该问题。</p>
<h3 id="动态修改样式"><a href="#动态修改样式" class="headerlink" title="动态修改样式"></a>动态修改样式</h3><p>可通过 v-bind 绑定 style+配合模板字符串或者<code>&lt;h2 :style=&quot;&#123;key(属性名):value(属性值)&#125;&quot;&gt;</code>或者<code>&lt;h2 :style=&quot;&#39;key(属性名):&#39;+value(值)+&#39;px&#39;&quot;&gt;</code>来实现。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.baidu.com/2021/05/22/21-22-11/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="KK">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KK">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/22/21-22-11/" class="post-title-link" itemprop="url">JavaScript</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-05-22 21:22:11" itemprop="dateCreated datePublished" datetime="2021-05-22T21:22:11+08:00">2021-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-04-12 17:51:03" itemprop="dateModified" datetime="2022-04-12T17:51:03+08:00">2022-04-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/web/" itemprop="url" rel="index"><span itemprop="name">web</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h3><p>运行在客户端的脚本语言；不需要编译，运行过程中由js引擎逐行解释并执行,也可以用于后端node.js技术<br>浏览器引擎：<br>渲染引擎：内核<br>js引擎：js解释器</p>
<ul>
<li>面向对象编程</li>
</ul>
<p>类：一类具有相同特征事物的抽象概念;<br>对象：具体的某一个个体，具有唯一性的实例；</p>
<p>编程思想：</p>
<ol>
<li>分析有哪些实体</li>
<li>设计实体的属性和功能</li>
<li>实体间的相互作用</li>
</ol>
<ul>
<li>书写位置<ol>
<li>行内式：<code>&lt;input type=&quot;botton&quot; onclick=&quot;alert(&#39;hello!!&#39;) /&gt;</code>Html推荐双引号，js推荐单引号</li>
</ol>
</li>
</ul>
<blockquote>
<p>注释：外部脚本不能包含 <code>&lt;script&gt;</code> 标签。<br>优势：分离了 HTML 和代码,使 HTML 和 JavaScript 更易于阅读和维护,已缓存的 JavaScript 文件可加速页面加载<br>可通过完整的 URL 或相对于当前网页的路径引用外部脚本：<code>&lt;script src=&quot;www.xxx.com/..&quot;&gt;&lt;script&gt;</code></p>
</blockquote>
<ol start="2">
<li>外部链接：<code>&lt;script src=&quot;xxx.js&quot;&gt;&lt;/script&gt;</code></li>
<li>内联式：<code>&lt;script&gt;alert(&#39;hello&#39;)&lt;/script&gt;</code></li>
</ol>
<blockquote>
<p>js脚本可被放置与 HTML 页面的 <code>&lt;body&gt;</code> 或<code> &lt;head&gt;</code> 部分中，或兼而有之。<br>提示：把脚本置于<code> &lt;body&gt;</code> 元素的底部，可改善显示速度，因为脚本编译会拖慢显示。<br>注释：旧的 JavaScript 例子也许会使用 type 属性：<code>&lt;script type=&quot;text/javascript&quot;&gt;</code>。<br>注释：type 属性不是必需的。JavaScript 是 HTML 中的默认脚本语言。</p>
</blockquote>
<h4 id="输入输出语句"><a href="#输入输出语句" class="headerlink" title="输入输出语句"></a>输入输出语句</h4><ul>
<li>alert(msg):浏览器弹窗提示</li>
<li>console.log(msg):控制台打印信息</li>
<li>innerHTML:写入HTML元素<blockquote>
<p>innerHTML 和 outerHTML 的区别：1）innerHTML:从对象的起始位置到终止位置的全部内容, 不包括HTML标签。2）outerHTML:除了包含innerHTML的全部内容外, 还包含对象标签本身。<br>如需访问 HTML 元素，JavaScript 可使用 document.getElementById(id) 方法。如：<code>document.getElementById(&quot;demo&quot;).innerHTML = 5 + 6;</code></p>
</blockquote>
</li>
<li>document.write()：写入HTML输出<blockquote>
<p>注意：在 HTML 文档完全加载后使用 document.write() 将会删除所有的标签 ;</p>
</blockquote>
</li>
<li>prompt(info):浏览器弹出，用户输入</li>
</ul>
<h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><p>变量是弱类型的,重复声明 JavaScript  变量，将不会丢它的值。</p>
<table>
<thead>
<tr>
<th>情况</th>
<th>说明</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td>var age;console.log(age)</td>
<td>只声明不负值</td>
<td>undefined</td>
</tr>
<tr>
<td>console.log(age)</td>
<td>不声明，不负值</td>
<td>报错</td>
</tr>
<tr>
<td>age=10;console.log(age)</td>
<td>不声明，只赋值</td>
<td>10(如果您为尚未声明的变量赋值，此变量会自动成为全局变量。)</td>
</tr>
</tbody></table>
<p>可以在字符串添加转义字符来使用引号：</p>
<p>如果变量在函数内没有声明（没有使用 var 关键字），该变量为全局变量。</p>
<h4 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h4><ul>
<li>区分大小写</li>
<li>不能数字开头</li>
<li>可使用的符号作开头：下划线<code>_</code>，美元符<code>$</code></li>
</ul>
<h4 id="变量数据类型"><a href="#变量数据类型" class="headerlink" title="变量数据类型"></a>变量数据类型</h4><p>动态数据类型。同一变量可做不同数据类型使用<br>类型种类：<code>number</code> <code>boolean</code> <code>string</code> <code>undefined</code> <code>null</code></p>
<ul>
<li>布尔类型<br><code>var flag=true;</code><br>true参加数学加法时当做1，false为0；</li>
</ul>
<p>true:<code>-15</code> <code>&quot;false&quot;</code><br>false:<code>0</code> <code>-0</code> <code>&quot;&quot;</code> <code>undefined</code> <code>null</code>  <code>false</code>  <code>NaN</code></p>
<ul>
<li><p>undefined<br>与数字相加后结果为NaN;任何变量均可通过设置值等于 undefined 或null进行清空。其类型也将是 undefined而null的类型为对象。</p>
</li>
<li><p>typeof</p>
</li>
</ul>
<blockquote>
<p>typeof 运算符不是变量。它属于运算符。运算符（比如 + - * /）没有数据类型。<br>但是，typeof 始终会返回字符串（包含运算数的类型）。</p>
</blockquote>
<p><code>console.log(typeof age);</code><br>查看数据类型</p>
<ul>
<li>constructor 属性</li>
</ul>
<p>constructor 属性返回所有 JavaScript 变量的构造器函数。</p>
<p>实例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&quot;Bill&quot;.constructor                 // 返回 &quot;function String()  &#123; [native code] &#125;&quot;</span><br><span class="line">(3.14).constructor                 // 返回 &quot;function Number()  &#123; [native code] &#125;&quot;</span><br><span class="line">false.constructor                  // 返回 &quot;function Boolean() &#123; [native code] &#125;&quot;</span><br><span class="line">[1,2,3,4].constructor              // 返回 &quot;function Array()   &#123; [native code] &#125;&quot;</span><br><span class="line">&#123;name:&#x27;Bill&#x27;, age:62&#125;.constructor  // 返回&quot; function Object()  &#123; [native code] &#125;&quot;</span><br><span class="line">new Date().constructor             // 返回 &quot;function Date()    &#123; [native code] &#125;&quot;</span><br><span class="line">function () &#123;&#125;.constructor         // 返回 &quot;function Function()&#123; [native code] &#125;&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li>数字型<br>绝不要用前导零写数字（比如 07）。<br>Infinity:无穷大；</li>
<li>Infinity:无穷小；<br>除以 0（零）也会生成 Infinity<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var x =  2 / 0;          // x 将是 Infinity</span><br><span class="line">var y = -2 / 0;          // y 将是 -Infinity</span><br></pre></td></tr></table></figure></li>
</ul>
<p>NaN:非数字<br>尝试用一个非数字字符串进行除法会得到 NaN<br>可使用全局 JavaScript 函数 isNaN() 来确定某个值是否是数：<br>NaN 是数，typeof NaN 返回 number</p>
<p>JavaScript 数值始终是 64 位的浮点数,其中 0 到 51 存储数字（片段），52 到 62 存储指数，63 位存储符号</p>
<p>精度<br>整数（不使用指数或科学计数法）会被精确到 15 位。<br>小数的最大数是 17 位，但是浮点的算数并不总是 100% 精准</p>
<p>数字字符串<br>JavaScript 字符串可以拥有数字内容：</p>
<p>在所有数字运算中，JavaScript 会尝试将字符串转换为数字：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var x = &quot;100&quot;;</span><br><span class="line">var y = &quot;10&quot;;</span><br><span class="line">var z = x / y;       // z 将是 10</span><br><span class="line">var z = x * y;       // z 将是 1000</span><br><span class="line">var z = x - y;       // z 将是 90</span><br><span class="line">//警告！！</span><br><span class="line">//JavaScript 的加法和级联（concatenation）都使用 + 运算符。</span><br><span class="line">//如果您对一个数和一个字符串相加，结果也是字符串级联：</span><br><span class="line">var z = x + y;       // z 不会是 110（而是 10010）</span><br></pre></td></tr></table></figure>

<p>数值属性</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>MAX_VALUE</td>
<td>返回 JavaScript 中可能的最大数。</td>
</tr>
<tr>
<td>MIN_VALUE</td>
<td>返回 JavaScript 中可能的最小数。</td>
</tr>
<tr>
<td>NEGATIVE_INFINITY</td>
<td>表示负的无穷大（溢出返回）。</td>
</tr>
<tr>
<td>NaN</td>
<td>表示非数字值（”Not-a-Number”）。</td>
</tr>
<tr>
<td>POSITIVE_INFINITY</td>
<td>表示无穷大（溢出返回）。</td>
</tr>
</tbody></table>
<blockquote>
<p>数字属性不可用于变量<br>数字属性属于名为 number 的 JavaScript 数字对象包装器。</p>
</blockquote>
<blockquote>
<p>这些属性只能作为 Number.MAX_VALUE 访问。</p>
</blockquote>
<blockquote>
<p>使用 myNumber.MAX_VALUE，其中 myNumber 是变量、表达式或值，将返回 undefined：</p>
</blockquote>
<p>实例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var x = 6;</span><br><span class="line">var y = x.MAX_VALUE;    // y 成为 undefined</span><br><span class="line">//只能如下使用</span><br><span class="line">var x = Number.MIN_VALUE;	//返回 JavaScript 中可能的最小数字。</span><br></pre></td></tr></table></figure>

<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>使用单引号或双引号，推荐单引号。在js中字符串既是基本数据类型，又是复合数据类型.</p>
<ul>
<li><p>声明</p>
<ol>
<li>new运算符声明(对象）<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var str=new String(&quot;100&quot;)</span><br></pre></td></tr></table></figure></li>
<li>省略new</li>
</ol>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var str=String(&quot;jjj&quot;);</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>字符串常量声明<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var str=&quot;jjj&quot;;</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>嵌套：<code>var str=&#39;啥&quot;嘎&quot;嘎和&#39;; var str=&quot;航空&#39;港行&#39;供货商&quot;;</code>也可以加转义符<code>\</code></li>
<li>字符串长度：<code>var str=&#39;画口红管工行&#39;;  alert(str.length);</code><blockquote>
<p>注：中文UTF-8（三个字符代表一个汉字），gbk（两个字符表示一个汉字）但计数时都当成一个字来计数。</p>
</blockquote>
</li>
<li>字符串拼接：<code>字符串+任何类型=拼接后的字符串</code></li>
</ul>
<h4 id="js-判断字符串中是否包含某个字符串"><a href="#js-判断字符串中是否包含某个字符串" class="headerlink" title="js 判断字符串中是否包含某个字符串"></a>js 判断字符串中是否包含某个字符串</h4><ol>
<li>方法一: indexOf()   (推荐)</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var str = &quot;123&quot;;</span><br><span class="line">console.log(str.indexOf(&quot;3&quot;) != -1 );  // 未找到文本将返回-1</span><br><span class="line">//indexOf() 方法可返回某个指定的字符串值在字符串中首次出现的位置。</span><br><span class="line">//lastIndexOf() 方法返回指定文本在字符串中最后一次出现的索引,其为从后向前进行检索</span><br><span class="line">//两种方法都接受作为检索起始位置的第二个参数。如str.indexOf(&quot;China&quot;, 18);</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>方法二: search() </li>
</ol>
<p>找到符合条件的子串第一次出现的位置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var str = &quot;123&quot;;</span><br><span class="line">console.log(str.search(&quot;3&quot;) != -1 );  //并返回匹配位置的下标</span><br><span class="line">//search() 方法用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串。如果没有找到任何匹配的子串，则返回 -1。</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>方法三:match()</li>
</ol>
<p>匹配成功返回匹配的子串数组,否则返回null</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var str = &quot;123&quot;;</span><br><span class="line">var reg = RegExp(/3/);</span><br><span class="line">if(str.match(reg))&#123;</span><br><span class="line">    // 包含        </span><br><span class="line">&#125;</span><br><span class="line">//match() 方法可在字符串内检索指定的值，或找到一个或多个正则表达式的匹配。其为RegExp 对象方法</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>方法四:test() </li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var str = &quot;123&quot;;</span><br><span class="line">var reg = RegExp(/3/);</span><br><span class="line">console.log(reg.test(str)); // true</span><br><span class="line">//test() 方法用于检索字符串中匹配的正则是否存在。若有则返回 true 否则 false。</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>方法五:exec()</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var str = &quot;123&quot;;</span><br><span class="line">var reg = RegExp(/3/);</span><br><span class="line">if(reg.exec(str))&#123;</span><br><span class="line">    // 包含        </span><br><span class="line">&#125;</span><br><span class="line">//exec() 方法用于检索字符串中的正则表达式的匹配。返回一个数组，其中存放匹配的结果。如果未找到匹配，则返回值为 null。</span><br></pre></td></tr></table></figure>
<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>正则表达式是构成搜索模式（search pattern）的字符序列。<br>语法：<code>/pattern/modifiers;</code>如：<code>var patt = /hello/i;</code></p>
<p>声明：</p>
<ol>
<li>new声明</li>
</ol>
<p>参数：第一个为字符串，第二个为修饰符(修饰符无顺序）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var box1=new RegExp(&quot;hello&quot;,&quot;ig&quot;);</span><br><span class="line">var box1= RegExp(&quot;hello&quot;,&quot;ig&quot;);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>省略new声明</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var box1=/hello/gi;</span><br></pre></td></tr></table></figure>



<p>正则表达式修饰符<br>修饰符可用于大小写不敏感的更全局的搜素：</p>
<table>
<thead>
<tr>
<th>修饰符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>i</td>
<td>执行对大小写不敏感的匹配。</td>
</tr>
<tr>
<td>g</td>
<td>执行全局匹配（查找所有匹配而非在找到第一个匹配后停止）。</td>
</tr>
<tr>
<td>m</td>
<td>执行多行匹配。</td>
</tr>
</tbody></table>
<blockquote>
<p>字符串中，遇到换行，重新开始计算行首；</p>
</blockquote>
<p>正则表达式模式<br>括号用于查找一定范围的字符串：</p>
<table>
<thead>
<tr>
<th>表达式</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>[]</td>
<td>查找方括号之间的任何符合的字符。</td>
</tr>
<tr>
<td>[^]</td>
<td>匹配除括号内的字符</td>
</tr>
<tr>
<td>[0-9]</td>
<td>查找任何从 0 至 9 的数字。</td>
</tr>
<tr>
<td>(x|y)</td>
<td>查找由 | 分隔的任何选项。</td>
</tr>
</tbody></table>
<p>元字符（Metacharacter）是拥有特殊含义的字符：</p>
<table>
<thead>
<tr>
<th>元字符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>.</td>
<td>匹配单个任意字符</td>
</tr>
<tr>
<td>\d</td>
<td>查找数字。</td>
</tr>
<tr>
<td>\D</td>
<td>匹配非数字</td>
</tr>
<tr>
<td>\s</td>
<td>查找空白符、空格、制表符、换行符。</td>
</tr>
<tr>
<td>\S</td>
<td>匹配非空白字符</td>
</tr>
<tr>
<td>\b</td>
<td>匹配空格字符。</td>
</tr>
<tr>
<td>\n</td>
<td>查找换行符。</td>
</tr>
<tr>
<td>\r</td>
<td>查找回车符。</td>
</tr>
<tr>
<td>\t</td>
<td>查找制表符。</td>
</tr>
<tr>
<td>\0</td>
<td>查找null符。</td>
</tr>
</tbody></table>
<p>锚字符<br>|||<br>|-|-|<br>|^|行首匹配|<br>|$|行尾匹配|</p>
<p>重复字符：(n为任意的单个字符）</p>
<table>
<thead>
<tr>
<th>量词</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>n?</td>
<td>匹配任何包含零个或一个 n 的字符。</td>
</tr>
<tr>
<td>n+</td>
<td>匹配任何包含至少一个 n 的字符。</td>
</tr>
<tr>
<td>n*</td>
<td>匹配任何个 n 的字符。</td>
</tr>
<tr>
<td>n*</td>
<td>匹配任何包含零个或多个 n 的字符。</td>
</tr>
<tr>
<td>n{m,n}</td>
<td>匹配至少m个，至多n个</td>
</tr>
<tr>
<td>n{m}</td>
<td>必须匹配m个</td>
</tr>
<tr>
<td>(abd)+</td>
<td>小括号中的部分代表一个字符串处理</td>
</tr>
</tbody></table>
<p>提取部分字符串<br>有三种提取部分字符串的方法：</p>
<ul>
<li>slice(start, end)<br>该方法设置两个参数：起始索引（开始位置），终止索引（结束位置）。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var str = &quot;Apple, Banana, Mango&quot;;</span><br><span class="line">var res = str.slice(7,13);</span><br><span class="line">//如果某个参数为负，则从字符串的结尾开始计数。</span><br><span class="line">//如果省略第二个参数，则该 slice() 将删除前面的部分，保留后面的部分。</span><br><span class="line">//提示：负值位置不适用 Internet Explorer 8 及其更早版本。</span><br></pre></td></tr></table></figure>

<ul>
<li>substring(start, end)</li>
</ul>
<p>提取[start,end)这部分字符串，返回新的字符串</p>
<p>不同之处在于 substring() 无法接受负的索引。<br>如果省略第二个参数，则该 substring() 将删除前面的部分，保留后面的部分。</p>
<ul>
<li>substr(start, length)</li>
</ul>
<p>substr() 类似于 slice()。</p>
<p>不同之处在于第二个参数规定被提取部分的长度。<br>如果省略第二个参数，则该 substring() 将删除前面的部分，保留后面的部分。<br>如果首个参数为负，则从字符串的结尾计算位置。第二个参数不能为负，因为它定义的是长度。</p>
<ul>
<li>replace() </li>
</ul>
<p>str.replace(oldstr,newstr);该方法用另一个值替换在字符串中指定的值,会返回替换成功的新字符串：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str = &quot;Please visit Microsoft!&quot;;</span><br><span class="line">var n = str.replace(&quot;Microsoft&quot;, &quot;W3School&quot;);</span><br></pre></td></tr></table></figure>

<p>默认地，replace() 只替换首个匹配：如需替换所有匹配，请使用正则表达式的 g 标志（用于全局搜索)<br>replace() 对大小写敏感。如需执行大小写不敏感的替换，请使用正则表达式 /i（大小写不敏感）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str = &quot;Please visit Microsoft!&quot;;</span><br><span class="line">var n = str.replace(/MICROSOFT/gi, &quot;W3School&quot;);</span><br></pre></td></tr></table></figure>

<ul>
<li>转换为大写和小写<br>通过 toUpperCase() 把字符串转换为大写：通过 toLowerCase() 把字符串转换为小写：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var text1 = &quot;Hello World!&quot;;       // 字符串</span><br><span class="line">var text2 = text1.toUpperCase();  // text2 是被转换为大写的 text1</span><br></pre></td></tr></table></figure>

<ul>
<li>concat() 连接两个或多个字符串：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var text1 = &quot;Hello&quot;;</span><br><span class="line">var text2 = &quot;World&quot;;</span><br><span class="line">text3 = text1.concat(text2);</span><br><span class="line">text4 = text1.concat(&quot;jjjjjj&quot;,text2,&quot;jj&quot;);</span><br></pre></td></tr></table></figure>

<ul>
<li>trim() 方法删除字符串两端的空白符：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var str = &quot;       Hello World!        &quot;;</span><br><span class="line">alert(str.trim());</span><br><span class="line">//Internet Explorer 8 或更低版本不支持 trim() 方法。</span><br><span class="line">//如需支持 IE 8，您可搭配正则表达式使用 replace() 方法代替：</span><br><span class="line">var str = &quot;       Hello World!        &quot;;</span><br><span class="line">alert(str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, &#x27;&#x27;));</span><br></pre></td></tr></table></figure>

<h4 id="提取字符串中的一个字符"><a href="#提取字符串中的一个字符" class="headerlink" title="提取字符串中的一个字符"></a>提取字符串中的一个字符</h4><p>这是两个提取字符串字符的安全方法：</p>
<ul>
<li><p>charAt(position)<br>charAt() 方法返回字符串中指定下标（位置）的字符串：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var str = &quot;HELLO WORLD&quot;;</span><br><span class="line">str.charAt(0);            // 返回 H</span><br></pre></td></tr></table></figure></li>
<li><p>charCodeAt(position)</p>
</li>
</ul>
<p>charCodeAt() 方法返回字符串中指定索引的字符 unicode 编码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var str = &quot;HELLO WORLD&quot;;</span><br><span class="line">str.charCodeAt(0);         // 返回 72</span><br></pre></td></tr></table></figure>

<ul>
<li>String.fromCharCode(码值1，码值2…）<br>用于将ASCII码转换为对应字符,返回值为组合的字符串</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var str=String.fromCharCode(99,93,83);</span><br></pre></td></tr></table></figure>

<ul>
<li>属性访问（Property Access）</li>
</ul>
<p>使用属性访问有点不太靠谱：</p>
<ul>
<li>不适用 Internet Explorer 7 或更早的版本</li>
<li>它让字符串看起来像是数组（其实并不是）</li>
<li>如果找不到字符，[ ] 返回 undefined，而 charAt() 返回空字符串。</li>
<li>字符串是只读的，无法像数组一样通过索引下标去修改单个字符，除非整个修改。str[0] = “A” 不会产生错误（但也不会工作！）</li>
</ul>
<blockquote>
<p>提示：如果您希望按照数组的方式处理字符串，可以先把它转换为数组。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var str = &quot;HELLO WORLD&quot;;</span><br><span class="line">str[0];                   // 返回 H</span><br></pre></td></tr></table></figure>

<p>表单元素，获取其中的内容，可通过<code>.value</code>属性获取<br>双标签节点，用innerHTML属性获取标签间内容</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function test()&#123;</span><br><span class="line">var text=document.ElementById(&quot;id&quot;);</span><br><span class="line">var msg=document.ElementById(&quot;id&quot;);</span><br></pre></td></tr></table></figure>


<ul>
<li>把字符串转换为数组</li>
</ul>
<p>可以通过 split(分割符/正则)分割字符串，返回分割的子串组成的数组。</p>
<p> 将字符串转换为数组：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var txt = &quot;a,b,c,d,e&quot;;   // 字符串</span><br><span class="line">txt.split(&quot;,&quot;);          // 用逗号分隔</span><br><span class="line">txt.split(&quot; &quot;);          // 用空格分隔</span><br><span class="line">txt.split(&quot;|&quot;);          // 用竖线分隔</span><br><span class="line">//如果省略分隔符，被返回的数组将是整个字符串即[&quot;string&quot;]。</span><br><span class="line">//若没有匹配，被返回的数组也是整个字符串即[&quot;string&quot;]</span><br><span class="line">//如果分隔符是 &quot;&quot;，被返回的数组将是间隔单个字符的数组</span><br></pre></td></tr></table></figure>



<h4 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h4><ul>
<li>转为字符串</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>toString()</td>
<td><code>var num=1;alert(num.toString());</code></td>
</tr>
<tr>
<td>String()强制转换</td>
<td><code>var num=1; alert(String(num));</code></td>
</tr>
<tr>
<td>拼接</td>
<td><code>var num=1; alert(num+&quot;&quot;);</code></td>
</tr>
</tbody></table>
<p>能够使用 toString() 方法把数输出为十六进制、八进制或二进制。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var myNumber = 128;</span><br><span class="line">myNumber.toString(16);     // 返回 80</span><br><span class="line">myNumber.toString(8);      // 返回 200</span><br><span class="line">myNumber.toString(2);      // 返回 10000000</span><br></pre></td></tr></table></figure>


<p>toExponential() 返回字符串值，它包含已被四舍五入并使用指数计数法的数字。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var x = 9.656;</span><br><span class="line">x.toExponential(2);     // 返回 9.66e+0</span><br><span class="line">x.toExponential(4);     // 返回 9.6560e+0</span><br><span class="line">x.toExponential(6);     // 返回 9.656000e+0</span><br></pre></td></tr></table></figure>

<p>toFixed() 返回字符串值，它包含了指定位数小数的数字：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var x = 9.656;</span><br><span class="line">x.toFixed(0);           // 返回 10</span><br><span class="line">x.toFixed(2);           // 返回 9.66</span><br><span class="line">x.toFixed(4);           // 返回 9.6560</span><br><span class="line">x.toFixed(6);           // 返回 9.656000</span><br></pre></td></tr></table></figure>

<p>toPrecision() 返回字符串值，它包含了指定长度的数字：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var x = 9.656;</span><br><span class="line">x.toPrecision();        // 返回 9.656</span><br><span class="line">x.toPrecision(2);       // 返回 9.7</span><br><span class="line">x.toPrecision(4);       // 返回 9.656</span><br><span class="line">x.toPrecision(6);       // 返回 9.65600</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在 JavaScript 中，数字可以是原始值（typeof = number）或对象（typeof = object）。<br>在 JavaScript 内部使用 valueOf() 方法可将 Number 对象转换为原始值。<br>所有 JavaScript 数据类型都有 valueOf() 和 toString() 方法。</p>
</blockquote>
<ul>
<li>转数字</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>parseInt(string)保留整数,去掉单位;只返回首个数字;如果无法转换为数值，则返回 NaN</td>
<td><code>parseInt(&#39;11&#39;);</code></td>
</tr>
<tr>
<td>parseFloat(string)只返回首个数字,包括小数部分</td>
<td><code>parseFloat(&#39;222&#39;);</code></td>
</tr>
<tr>
<td>Number()强制转换</td>
<td><code>Number(&#39;22&#39;);</code></td>
</tr>
<tr>
<td>js隐式转换（减，乘，除)</td>
<td><code>&#39;11&#39;-0</code></td>
</tr>
</tbody></table>
<p>Number() 还可以把日期转换为数字：<code>Number(new Date(&quot;2019-04-15&quot;));    // 返回 1506729600000</code>方法返回 1970 年 1 月 1 日至今的毫秒数。</p>
<p><code>==</code>符号会把字符串的数据类型转换为数字型再比较。<br><code>===</code>两侧的值和数据类型一样才相等。</p>
<h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><ul>
<li>逻辑与<br><code>表达式1&amp;&amp;表达式2</code>如果第一个表达式为真，则返回表达式2，否则返回表达式1</li>
</ul>
<blockquote>
<p><code>0</code> <code>&#39;&#39;</code> <code>null</code> <code>undefind</code> <code>NaN</code>为假</p>
</blockquote>
<ul>
<li>逻辑或<br><code>表达式1||表达式2</code>如果表达式1为真则返回表达式1，否则返回表达式2</li>
</ul>
<h3 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h3><p>位运算符处理 32 位数。</p>
<p>该运算中的任何数值运算数都会被转换为 32 位的数。结果会被转换回 JavaScript 数。</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>例子</th>
<th>等同于</th>
<th>结果</th>
<th>十进制</th>
</tr>
</thead>
<tbody><tr>
<td>&amp;</td>
<td>与</td>
<td>5 &amp; 1</td>
<td>0101 &amp; 0001</td>
<td>0001</td>
<td>1</td>
</tr>
<tr>
<td>|</td>
<td>或</td>
<td>5 | 1</td>
<td>0101 | 0001</td>
<td>0101</td>
<td>5</td>
</tr>
<tr>
<td>~</td>
<td>非</td>
<td>~ 5</td>
<td>~0101</td>
<td>1010</td>
<td>10</td>
</tr>
<tr>
<td>^</td>
<td>异或</td>
<td>5 ^ 1</td>
<td>0101 ^ 0001</td>
<td>0100</td>
<td>4</td>
</tr>
<tr>
<td>&lt;&lt;</td>
<td>零填充左位移</td>
<td>5 &lt;&lt; 1</td>
<td>0101 &lt;&lt; 1</td>
<td>1010</td>
<td>10</td>
</tr>
<tr>
<td>&gt;&gt;</td>
<td>有符号右位移</td>
<td>5 &gt;&gt; 1</td>
<td>0101 &gt;&gt; 1</td>
<td>0010</td>
<td>2</td>
</tr>
<tr>
<td>&gt;&gt;&gt;</td>
<td>零填充右位移</td>
<td>5 &gt;&gt;&gt; 1</td>
<td>0101 &gt;&gt;&gt; 1</td>
<td>0010</td>
<td>2</td>
</tr>
</tbody></table>
<blockquote>
<p>上例使用 4 位无符号的例子。但是 JavaScript 使用 32 位有符号数。</p>
</blockquote>
<blockquote>
<p>因此，在 JavaScript 中，~ 5 不会返回 10，而是返回 -6。</p>
</blockquote>
<blockquote>
<p>~00000000000000000000000000000101 将返回 11111111111111111111111111111010。</p>
</blockquote>
<p>幂运算符为<code>**</code>而不是<code>^</code>,也可以用<code>Math.pow(x,y) </code>实现</p>
<h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//switch</span><br><span class="line">var num=3;</span><br><span class="line">switch(num)&#123;</span><br><span class="line">case 2:</span><br><span class="line">console.log(num);</span><br><span class="line">break;</span><br><span class="line">case 3:</span><br><span class="line">console.log(num);</span><br><span class="line">break;</span><br><span class="line">default:</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>continue用于跳出本次循环，继续下一次循环；<br>break用于结束循环；</p>
<h3 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h3><p>数组是对象<br>请不要最后一个元素之后写逗号（比如 “BMW”,）可能存在跨浏览器兼容性问题。<br>JavaScript 方法 toString() 把数组转换为数组值（逗号分隔）的字符串。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//利用new创建数组</span><br><span class="line">var a=new Array();	//注意大写</span><br><span class="line">var a=new Array(2);	//只有一个数字时，为直接创建长度为2的空数组</span><br><span class="line">var cars = new Array(&quot;Saab&quot;, &quot;Volvo&quot;, &quot;BMW&quot;);	//也可以直接赋值</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//数组字面量方式创建</span><br><span class="line">var a=[];</span><br><span class="line">var a=[&#x27;xxx&#x27;,77,true];</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//获取数组元素：数组名[索引号]</span><br><span class="line">console.log(a[0]);</span><br><span class="line">//二位数组,只对字符串有用</span><br><span class="line">console.log(a[0][0]);	//结果为第二个x</span><br><span class="line">console.log(a[2][0]);	//结果为undefined</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//数组长度：数组名.length</span><br><span class="line">console.log(a.length); //新增数组元素</span><br><span class="line">//修改数组索引追加数组元素</span><br><span class="line">//不能直接给数组名赋值，否则会覆盖以前的数据</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//变量里存放的是数组的地址</span><br><span class="line">var arr=[&quot;jjj&quot;,&quot;222&quot;,true,222];</span><br><span class="line">var arr1=arr</span><br><span class="line">console.log(arr1);</span><br><span class="line">arr1.push(&quot;end&quot;);</span><br><span class="line">console.log(&quot;push:&quot;,arr1);</span><br><span class="line">console.log(arr);	//arr也会一起变化</span><br></pre></td></tr></table></figure>

<h3 id="数组遍历"><a href="#数组遍历" class="headerlink" title="数组遍历"></a>数组遍历</h3><ul>
<li>for循环</li>
<li>for ..in 快速遍历（没有判断,速度更快）</li>
<li>forEach</li>
<li>for….of</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var array=[10,11,12,13,14];</span><br><span class="line"></span><br><span class="line">for(var i in array)&#123;</span><br><span class="line">document.write(i,array[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">array.forEach(function(item,n,array)&#123;</span><br><span class="line">document.write(n,item);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">for (var item of array)&#123;</span><br><span class="line">//item为当前遍历到的元素</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数组的操作方法"><a href="#数组的操作方法" class="headerlink" title="数组的操作方法"></a>数组的操作方法</h3><p>10种：push,pop,shift,unshift,splice,slice,concat,join,sort,reverse</p>
<ul>
<li><p>JS数组添加元素</p>
<ol>
<li>在末尾追加push()；</li>
</ol>
</li>
</ul>
<p>示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//向arr数组的末尾追加元素，</span><br><span class="line">arr.push(&#x27;lemon&#x27;, &#x27;cucumber&#x27;);</span><br><span class="line">alert(arr);</span><br><span class="line">//push()方法会返回新数组的长度</span><br></pre></td></tr></table></figure>

<p>也可以使用 length 属性向数组添加新元素：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];</span><br><span class="line">fruits[fruits.length] = &quot;Lemon&quot;;     // 向 fruits 添加一个新元素 (Lemon)</span><br><span class="line">//添加具有高索引的元素会在数组中创建未定义的undefined</span><br><span class="line">fruits[10] = &quot;Lemon&quot;;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在第一位添加unshift()；</li>
</ol>
<p>示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//向arr数组的第一位添加元素，</span><br><span class="line">arr.unshift(&#x27;peach&#x27;, &#x27;pear&#x27;);	//返回新数组的长度。</span><br><span class="line">alert(arr);</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>在指定位置添加splice();</li>
</ol>
<p>示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">///从数组中添加/删除项目，然后返回被删除的项目,如果有的话。</span><br><span class="line">arr.splice(3,0,&#x27;元素1&#x27;,&#x27;元素2&#x27;); </span><br><span class="line">alert(arr);</span><br><span class="line">//arrayObject.splice(index,howmany,item1,.....,itemX)</span><br><span class="line">//index	必需。整数，规定添加/删除项目的位置，使用负数可从数组结尾处规定位置。</span><br><span class="line">//howmany	必需。要删除的项目数量。如果设置为 0，则不会删除项目。</span><br></pre></td></tr></table></figure>


<ul>
<li>pop() 方法从数组中删除最后一个元素：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];</span><br><span class="line">fruits.pop();              // 从 fruits 删除最后一个元素（&quot;Mango&quot;）</span><br></pre></td></tr></table></figure>

<ul>
<li>pop() 方法返回被删除的值：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];</span><br><span class="line">var x = fruits.pop();      // x 的值是 &quot;Mango&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li>shift() 方法会删除首个数组元素，</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];</span><br><span class="line">fruits.shift();            // 从 fruits 删除第一个元素 &quot;Banana&quot;</span><br><span class="line">//shift() 方法返回被删除的字符串即 返回 &quot;Banana&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li>删除元素<br>既然 JavaScript 数组属于对象，其中的元素就可以使用 JavaScript delete 运算符来删除：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];</span><br><span class="line">delete fruits[0];           // 把 fruits 中的首个元素改为 undefined</span><br><span class="line">//用 delete 会在数组留下未定义的空洞。请使用 pop() 或 shift() 取而代之。</span><br></pre></td></tr></table></figure>
<p>使用 splice() 来删除元素</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//通过聪明的参数设定，您能够使用 splice() 在数组中不留“空洞”的情况下移除元素：</span><br><span class="line">var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];</span><br><span class="line">fruits.splice(0, 1);        // 删除 fruits 中的第一个元素</span><br></pre></td></tr></table></figure>


<ul>
<li>拼接数组<br>splice() 方法可用于向数组添加新项：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];</span><br><span class="line">fruits.splice(2, 0, &quot;Lemon&quot;, &quot;Kiwi&quot;);</span><br><span class="line">//第一个参数（2）定义了应添加新元素的位置（拼接）。</span><br><span class="line">//第二个参数（0）定义应删除多少元素。</span><br><span class="line">//其余参数（“Lemon”，“Kiwi”）定义要添加的新元素。</span><br><span class="line">//splice() 方法返回一个包含已删除项的数组：</span><br></pre></td></tr></table></figure>

<ul>
<li>concat() 方法通过合并（连接）现有数组来创建一个新数组：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var myGirls = [&quot;Cecilie&quot;, &quot;Lone&quot;];</span><br><span class="line">var myBoys = [&quot;Emil&quot;, &quot;Tobias&quot;, &quot;Linus&quot;];</span><br><span class="line">var myChildren = myGirls.concat(myBoys,&quot;jjjj&quot;,11);   // 连接 myGirls 和 myBoys,&quot;jjj&quot;等</span><br><span class="line">//concat() 方法不会更改现有数组。它总是返回一个新数组。</span><br><span class="line">//concat() 方法可以使用任意数量的数组参数：</span><br></pre></td></tr></table></figure>

<ul>
<li>join() 方法</li>
</ul>
<p>会将数组内的所有元素结合为一个字符串。当然您还可以规定分隔符(默认以逗号分割)：<code>array.join(&quot;,&quot;)</code></p>
<ul>
<li>裁剪数组<br>slice(start,end) 方法用数组的某个片段切出新数组。原数组不会发生改变</li>
</ul>
<p>本例从数组元素 1 （”Orange”）开始切出一段数组：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Lemon&quot;, &quot;Apple&quot;, &quot;Mango&quot;];</span><br><span class="line">var citrus = fruits.slice(1); 	//默认到结尾</span><br></pre></td></tr></table></figure>

<ul>
<li>sort() 方法以字母顺序对数组进行排序：</li>
</ul>
<p>该函数很适合字符串（”Apple” 会排在 “Banana” 之前）。</p>
<p>不过，如果数字按照字符串来排序，则 “25” 大于 “100”，因为 “2” 大于 “1”。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];</span><br><span class="line">fruits.sort();            // 对 fruits 中的元素进行排序</span><br></pre></td></tr></table></figure>

<p>sort() 方法在对数值排序时会产生不正确的结果。</p>
<p>我们通过一个比值函数来修正此问题：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var points = [40, 100, 1, 5, 25, 10];</span><br><span class="line">points.sort(function(a, b)&#123;return a - b&#125;); </span><br><span class="line">//比值函数</span><br><span class="line">//比较函数的目的是定义另一种排序顺序。</span><br><span class="line">//比较函数应该返回一个负，零或正值，这取决于参数：</span><br><span class="line">//function(a, b)&#123;return a-b&#125;</span><br><span class="line">//当 sort() 函数比较两个值时，会将值发送到比较函数，并根据所返回的值（负、零或正值）对这些值进行排序。</span><br></pre></td></tr></table></figure>

<ul>
<li><p>对数组使用 Math.max()<br>您可以使用 Math.max.array 来查找数组中的最高值;或使用 Math.min.apply 来查找数组中的最低值</p>
</li>
<li><p>反转数组<br>reverse() 方法反转数组中的元素。</p>
</li>
</ul>
<p>您可以使用它以降序对数组进行排序：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];</span><br><span class="line">fruits.sort();            // 对 fruits 中的元素进行排序</span><br><span class="line">fruits.reverse();         // 反转元素顺序</span><br></pre></td></tr></table></figure>

<p>小程序查看对象中是否包含某个属性—–hasOwnProperty</p>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><ul>
<li>声明<br>在函数中，声明的参数是局部变量。只能在函数内访问。局部变量在函数开始时创建，在函数完成时被删除。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//函数关键字声明</span><br><span class="line">function a()&#123;</span><br><span class="line">console.log(&#x27;xxxxxxxxx&#x27;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//函数表达式声明</span><br><span class="line">var b=function()&#123;&#125;;</span><br><span class="line">//function 函数名（形参1，形参2...）&#123;//形参即形式上的参数&#125;</span><br><span class="line">function b(n)&#123;</span><br><span class="line">console.log(n);</span><br><span class="line">&#125;</span><br><span class="line">b(&#x27;xxx&#x27;);</span><br><span class="line">//实参与形参个数一致时，正常输出</span><br><span class="line">//实参小于形参时，多余的形参可看作不用声明的变量，结果为undefined</span><br><span class="line">//实参多于形参时，只取到形参的个数</span><br><span class="line">//#######################################</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//函数的返回值</span><br><span class="line">function c()&#123;</span><br><span class="line">return 返回的内容；</span><br><span class="line">&#125;</span><br><span class="line">var n=c();</span><br><span class="line">//return 之后的代码不会执行；</span><br><span class="line">//return只返回一个值，且只返回最后一个值。</span><br><span class="line">//return可返回数组，字符串，</span><br><span class="line">//如果没有return则返回undefind</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//###########</span><br><span class="line">function fn()&#123;</span><br><span class="line">console.log(arguments);</span><br><span class="line">&#125;</span><br><span class="line">fn(1,2,2,34,9);</span><br><span class="line">//arguments里储存了所有传过来的实参，它是一个伪数组，具有length属性，可用索引的方式遍历，但不具有数组的push，pop等方法</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">window.onload=function()&#123;</span><br><span class="line">写在这的代码会在整个页面加载完后再运行</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//简化写法</span><br><span class="line">function $(id)&#123;</span><br><span class="line">return document.getElenmentById(id);</span><br><span class="line">&#125;</span><br><span class="line">var text=$(&quot;button&quot;);</span><br></pre></td></tr></table></figure>
<ul>
<li>递归</li>
</ul>
<p>函数自己调用自己，一般情况下有参数，有return</p>
<ol>
<li>首先找到临界值，即无需计算获得的值；</li>
<li>找到这一次和上一次的关系</li>
<li>假设当前函数已经可以使用，调用自身计算上一次。</li>
</ol>
<h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><ul>
<li>JavaScript 变量的有效期</li>
</ul>
<p>JavaScript 变量的有效期始于其被创建时。<br>局部变量会在函数完成时被删除。<br>全局变量会在您关闭页面是被删除。</p>
<p>函数参数也是函数内的局部变量。<br>在 HTML 中，全局作用域是 window。所有全局变量均属于 window 对象。<br>实例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var carName = &quot;porsche&quot;;</span><br><span class="line">// 此处的代码能够使用 window.carName</span><br></pre></td></tr></table></figure>

<ul>
<li>JavaScript 声明会被提升<br>在 JavaScript 中，可以在使用变量之后对其进行声明。<br>换句话说，可以在声明变量之前使用它。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//js中没有块级作用域，如&#123;&#125; if&#123;&#125; for&#123;&#125;，只有全局作用域和局部作用域</span><br><span class="line">//作用域链：内部函数访问外部函数变量，采用的是链式查找方式来取值的，其采取就近原则</span><br><span class="line">var num=10;</span><br><span class="line">function fn ()&#123;</span><br><span class="line">var num=20;</span><br><span class="line">function fun()&#123;</span><br><span class="line">console.log(num)	//结果为20</span><br><span class="line">&#125;</span><br><span class="line">return fun();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//js引擎运行分两步</span><br><span class="line">//预解析:js引擎会把js里的所有var， function提升到当前作用域的最前面，但不提升赋值操作</span><br><span class="line">//代码执行：顺序从上往下执行</span><br><span class="line">fun();</span><br><span class="line">var fun=function()&#123;xxx&#125;;//会报错</span><br><span class="line">//-------------</span><br><span class="line">fun();</span><br><span class="line">function fun()&#123;xxx&#125;//正常运行</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//预编译:创建AO对象;找已声明的变量,值都是undefined;实参形参值相等;找函数声明，会覆盖形参的值</span><br><span class="line">function fn(a,c)&#123;</span><br><span class="line">	console.log(c);	//2</span><br><span class="line">	console.log(a);	//function a()</span><br><span class="line">	function a()&#123; &#125;</span><br><span class="line"></span><br><span class="line">	var a=12;</span><br><span class="line">	console.log(a);		//12</span><br><span class="line"></span><br><span class="line">	console.log(b);		//undefined</span><br><span class="line">	var b=function()&#123;&#125;</span><br><span class="line">	console.log(b);		//function b()</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">fn(1,2);</span><br></pre></td></tr></table></figure>


<p>JavaScript 初始化不会被提升<br>JavaScript 只提升声明，而非初始化。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var x = 5; // 初始化 x</span><br><span class="line"> </span><br><span class="line">elem = document.getElementById(&quot;demo&quot;); // 查找元素</span><br><span class="line">elem.innerHTML = x + &quot; &quot; + y;           // 显示 x 和 y</span><br><span class="line"> </span><br><span class="line">var y = 7; // 初始化 y </span><br></pre></td></tr></table></figure>
<h2 id="ES6-中的一些新特性。"><a href="#ES6-中的一些新特性。" class="headerlink" title="ES6 中的一些新特性。"></a>ES6 中的一些新特性。</h2><ul>
<li>JavaScript let</li>
<li>JavaScript const</li>
<li>幂 (**)</li>
<li>默认参数值</li>
<li>Array.find()<br>在数组中查找符合条件的元素，只要找到一个符合条件的元素，就终止遍历，返回值为找到的元素。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var array=[1,2,3,45,5];</span><br><span class="line">var res=arr.find(function(item,idex,array)&#123;</span><br><span class="line">//查找条件</span><br><span class="line">return item&gt;5;</span><br><span class="line">&#125;)</span><br><span class="line">console.log(res);</span><br></pre></td></tr></table></figure></li>
<li>Array.findIndex()</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array.findIndex(item=&gt;item&gt;20);</span><br></pre></td></tr></table></figure>

<ul>
<li>Array.copyWithin()<br>第一个参数：从哪个下标开始<br>第二第三个参数：开始与结束的范围[start,end)<br>把范围里的元素从第一个参数开始覆盖。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var arr=[2,3,4,1,4,5,1,6,7,8,9,1,3];</span><br><span class="line">arr.copyWithin(2,5,7);</span><br></pre></td></tr></table></figure>

<ul>
<li>Object.assign();合并对象</li>
</ul>
<p>将所有传入的对象都合并到第一个对象里。浅拷贝，</p>
<ul>
<li>let 和 const 关键字<br>用 let 或 const 声明的变量和常量不会被提升！遇到大括号就形成作用域。<blockquote>
<p>全局（在函数之外）声明的变量拥有全局作用域。<br>局部（函数内）声明的变量拥有函数作用域。</p>
</blockquote>
</li>
</ul>
<p>通过 var 关键词声明的变量没有块作用域。将变量或者形参所在函数的大括号作为作用域处理。<br>在块 {} 内声明的变量可以从块之外进行访问。</p>
<p>实例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123; </span><br><span class="line">  var x = 10; </span><br><span class="line">&#125;</span><br><span class="line">// 此处可以使用 x</span><br></pre></td></tr></table></figure>

<p>在 ES2015 之前，JavaScript 是没有块作用域的。</p>
<p>可以使用 let 关键词声明拥有块作用域的变量。</p>
<p>在块 {} 内声明的变量无法从块外访问：</p>
<p>实例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123; </span><br><span class="line">  let x = 10;</span><br><span class="line">&#125;</span><br><span class="line">// 此处不可以使用 x</span><br></pre></td></tr></table></figure>

<ul>
<li>重新声明变量</li>
</ul>
<p>使用 var 关键字重新声明变量会带来问题。</p>
<p>在块中重新声明变量也将重新声明块外的变量：</p>
<p>实例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var x = 10;</span><br><span class="line">// 此处 x 为 10</span><br><span class="line">&#123; </span><br><span class="line">  var x = 6;</span><br><span class="line">  // 此处 x 为 6</span><br><span class="line">&#125;</span><br><span class="line">// 此处 x 为 6</span><br></pre></td></tr></table></figure>

<p>使用 let 关键字重新声明变量可以解决这个问题。</p>
<p>在块中重新声明变量不会重新声明块外的变量：</p>
<p>实例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var x = 10;</span><br><span class="line">// 此处 x 为 10</span><br><span class="line">&#123; </span><br><span class="line">  let x = 6;</span><br><span class="line">  // 此处 x 为 6</span><br><span class="line">&#125;</span><br><span class="line">// 此处 x 为 10</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Internet Explorer 11 或更早的版本不完全支持 let 关键词。</p>
</blockquote>
<ul>
<li>var 与let 区别</li>
</ul>
<p>通过 var 关键词定义的全局变量属于 window 对象<br>通过 let 关键词定义的全局变量不属于 window 对象<br>允许在程序的任何位置使用 var 重新声明 JavaScript 变量<br>在相同的作用域，或在相同的块中，通过 let 重新声明一个 var 变量是不允许的<br>在相同的作用域，或在相同的块中，通过 let 重新声明一个 let 变量是不允许的<br>在相同的作用域，或在相同的块中，通过 var 重新声明一个 let 变量是不允许的<br>在不同的作用域或块中，通过 let 重新声明变量是允许的<br>通过 var 声明的变量会提升到顶端<br>通过 let 定义的变量不会被提升到顶端</p>
<ul>
<li>const</li>
</ul>
<p>通过 const 定义的变量与 let 变量类似，但不能重新赋值;const 变量必须在声明时赋值,const 变量不能在声明之前使用</p>
<ul>
<li>但常量对象是可以更改</li>
</ul>
<p>实例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 您可以创建 const 对象：</span><br><span class="line">const car = &#123;type:&quot;porsche&quot;, model:&quot;911&quot;, color:&quot;Black&quot;&#125;;</span><br><span class="line"></span><br><span class="line">// 您可以更改属性：</span><br><span class="line">car.color = &quot;White&quot;;</span><br><span class="line"></span><br><span class="line">// 您可以添加属性：</span><br><span class="line">car.owner = &quot;Bill&quot;;</span><br></pre></td></tr></table></figure>

<p>但是您无法重新为常量对象赋值：</p>
<p>实例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const car = &#123;type:&quot;porsche&quot;, model:&quot;911&quot;, color:&quot;Black&quot;&#125;;</span><br><span class="line">car = &#123;type:&quot;Volvo&quot;, model:&quot;XC60&quot;, color:&quot;White&quot;&#125;;    // ERROR</span><br></pre></td></tr></table></figure>

<p>同理常量数组可以更改；但是您无法重新为常量数组赋值<br>在同一作用域或块中，不允许将已有的 var 或 let 变量重新声明或重新赋值给 const;<br>在同一作用域或块中，为已有的 const 变量重新声明声明或赋值是不允许的;<br>在另外的作用域或块中重新声明 const 是允许的：</p>
<p>实例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const x = 2;       // 允许</span><br><span class="line">&#123;</span><br><span class="line">  const x = 3;   // 允许</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">  const x = 4;   // 允许</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Internet Explorer 10 或更早版本不支持 const 关键词。</p>
</blockquote>
<ul>
<li>声明严格模式</li>
</ul>
<p>通过在脚本或函数的开头添加 “use strict”; 来声明严格模式。(浏览器低版本不兼容)<br>在脚本开头进行声明，拥有全局作用域（脚本中的所有代码均以严格模式来执行）：<br>在函数中声明严格模式，拥有局部作用域（只有函数中的代码以严格模式执行）</p>
<p>实例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;use strict&quot;;</span><br><span class="line">x = 3.14;       // 这会引发错误，因为 x 尚未声明</span><br></pre></td></tr></table></figure>

<ul>
<li>严格模式中不允许的事项：<br>在不声明变量的情况下使用变量，是不允许的;<br>在不声明对象的情况下使用对象也是不允许的：<br>删除变量（或对象）是不允许的<code>delete:x;</code><br>删除函数是不允许的,重复参数名是不允许的,八进制数值文本是不允许的,转义字符是不允许的写入只读属性是不允许的,写入只能获取的属性是不允许的,删除不可删除的属性是不允许的,字符串 “eval” 不可用作变量,字符串 “arguments” 不可用作变量,with 语句是不允许的,处于安全考虑，不允许 eval() 在其被调用的作用域中创建变量,在类似 f() 的函数调用中，this 的值是全局对象。在严格模式中，现在它成为了 undefined。</li>
</ul>
<h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//利用对象字面量创建对象&#123;&#125;</span><br><span class="line">var obj=&#123;&#125;;	//创建了一个空的对象</span><br><span class="line">var obj=&#123;</span><br><span class="line">username:&#x27;张山&#x27;,</span><br><span class="line">age: 18,</span><br><span class="line">sex:&#x27;男&#x27;,</span><br><span class="line">hi:function()&#123;</span><br><span class="line">console.log(&#x27;hello!!!!!!!!!!!!!!&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//#################</span><br><span class="line">//利用new Object 创建对象</span><br><span class="line">var obj1= new Object();//创建一个空对象,可省略new</span><br><span class="line">obj1.username=&#x27;张山&#x27;;</span><br><span class="line">obj1.age= 18;</span><br><span class="line">obj1.sex=&#x27;男&#x27;;</span><br><span class="line">obj1.hi=function()&#123;</span><br><span class="line">console.log(&#x27;hello!!!!!!!!!!!!!!&#x27;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//里面的属性或方法，采用键值对的形式-&gt;  属性名： 属性值</span><br><span class="line">//多个属性或方法中间用逗号隔开</span><br><span class="line">//方法冒号后面跟的是一个匿名函数</span><br><span class="line">//##################################</span><br><span class="line">//调用对象的属性，采用 对象名.属性名</span><br><span class="line">console.log(obj1.uname);</span><br><span class="line">//或者 对象名[&#x27;属性名&#x27;]</span><br><span class="line">console.log(obj1[&#x27;age&#x27;]);</span><br><span class="line">//调用对象的方法-&gt; 对象名.方法名</span><br><span class="line">obj1.hi();</span><br><span class="line">//如果您不使用 () 访问 fullName 方法，则将返回函数的具体内容</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//##############################</span><br><span class="line">//遍历对象</span><br><span class="line">//for(变量 in 对象)&#123;&#125;</span><br><span class="line">for (var i in obj)&#123;</span><br><span class="line">console.log(k);		</span><br><span class="line">console.log(obj[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//################################</span><br><span class="line">//利用构造函数创建对象</span><br><span class="line">//function 构造函数名()&#123;</span><br><span class="line">//this.属性名=值;</span><br><span class="line">//this.方法名=function()&#123;&#125;</span><br><span class="line">//&#125;</span><br><span class="line">// new 构造函数名();</span><br><span class="line">function Star(username,age,sex)&#123;</span><br><span class="line">this.name=username;</span><br><span class="line">this.age=age;</span><br><span class="line">this.sex=sex;</span><br><span class="line">&#125;</span><br><span class="line">new Star(&#x27;刘德华&#x27;,58,&#x27;男&#x27;);</span><br></pre></td></tr></table></figure>

<ul>
<li>箭头函数（Arrow Function）<br>箭头函数允许使用简短的语法来编写函数表达式。</li>
</ul>
<p>您不需要 function 关键字、return 关键字以及花括号。</p>
<blockquote>
<p>注意:箭头函数不能用new，如果返回值是一个对象，一定要加（）；箭头函数中的this，指向的是上层函数的主人；</p>
</blockquote>
<p>实例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">var x = function(x, y) &#123;</span><br><span class="line">   return x * y;</span><br><span class="line">&#125;</span><br><span class="line">//多个参数，有返回值</span><br><span class="line">var  x = (x, y) =&gt; x * y;</span><br><span class="line">//或</span><br><span class="line">var x=(x,Y)=&gt;&#123;</span><br><span class="line">reruen x*y;</span><br><span class="line">&#125;</span><br><span class="line">--------------------</span><br><span class="line">function add(x)&#123;</span><br><span class="line">return x+10;</span><br><span class="line">&#125;</span><br><span class="line">//一个参数，有返回值</span><br><span class="line">var add=x=&gt;x+10;</span><br><span class="line">add(5);</span><br><span class="line">//或</span><br><span class="line">var add=x=&gt;&#123;</span><br><span class="line">return x+10;</span><br><span class="line">&#125;</span><br><span class="line">--------------------</span><br><span class="line">function show()&#123;</span><br><span class="line">alert(&quot;hello&quot;);</span><br><span class="line">&#125;</span><br><span class="line">//无参数，无返回值</span><br><span class="line">var show=()=&gt;&#123;</span><br><span class="line">alert(&quot;hello&quot;);</span><br><span class="line">&#125;</span><br><span class="line">--------------------</span><br><span class="line">function xxx(num)&#123;</span><br><span class="line">alert(num);</span><br><span class="line">&#125;</span><br><span class="line">//有一个参数，无返回值</span><br><span class="line">var xxx=num=&gt;&#123;</span><br><span class="line">alert(num);</span><br><span class="line">&#125;</span><br><span class="line">----------------</span><br><span class="line">function show()&#123;</span><br><span class="line">return &#123;name:&#x27;xxx&#x27;&#125;;</span><br><span class="line">&#125;</span><br><span class="line">//返回对象</span><br><span class="line">var show=()=&gt;(&#123;..&#125;);</span><br></pre></td></tr></table></figure>

<p>箭头功能没有自己的 this。它们不适合定义对象方法。<br>箭头功能未被提升。它们必须在使用前进行定义。</p>
<p>使用 const 比使用 var 更安全，因为函数表达式始终是常量值。<br>如果函数是单个语句，则只能省略 return 关键字和花括号。因此，保留它们可能是一个好习惯：</p>
<p>实例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const x = (x, y) =&gt; &#123; return x * y &#125;;</span><br></pre></td></tr></table></figure>

<h4 id="内置对象-如同内置函数）如-Math、-Date、-Array、-String、"><a href="#内置对象-如同内置函数）如-Math、-Date、-Array、-String、" class="headerlink" title="内置对象(如同内置函数）如:Math、 Date、 Array、 String、"></a>内置对象(如同内置函数）如:Math、 Date、 Array、 String、</h4><p>Math对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Math.PI  //圆周率</span><br><span class="line">Math.abs()	//求绝对值</span><br><span class="line">Math.max()	//求最大</span><br><span class="line">Math.min()	//求最小值</span><br><span class="line">Math.pow(x,y) 	//x的y次幂</span><br><span class="line">Math.round()	//四舍五入</span><br><span class="line">Math.random()	//获取随机数</span><br><span class="line">Math.ceil()	// 向上取整,有小数就整数部分加1</span><br><span class="line">Math.floor()	// 向下取整,丢弃小数部分</span><br></pre></td></tr></table></figure>

<ul>
<li>获取当前时间</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//时间对象是静态的</span><br><span class="line">//必须实例化</span><br><span class="line">var nowdate=new Date();</span><br><span class="line">console.log(nowdate);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//############</span><br><span class="line">//Date()构造函数的参数</span><br><span class="line">//自定义日期格式</span><br><span class="line">var nowdate=new Date(&quot;2020-2-22&quot;);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//日期格式化</span><br><span class="line">//getFUllYear()	//年</span><br><span class="line">//getMonth() 	//月</span><br><span class="line">//getDate()	//天</span><br><span class="line">//getDay()	//星期（周日0到周六6）</span><br><span class="line">//getHours()</span><br><span class="line">//getMinutes()</span><br><span class="line">//getSeconds()</span><br><span class="line">var date= new Date();</span><br><span class="line">console.log(date.getHours());</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//封装一个获取时间的方法</span><br><span class="line">function gettime()&#123;</span><br><span class="line">var time = new Date();</span><br><span class="line">var h=time.getHours();</span><br><span class="line">h= h&lt;10 ? &quot;0&quot;+h : h;		//小于10前面添加0</span><br><span class="line">var m=time.getMinutes();</span><br><span class="line">var s=getSeconds();</span><br><span class="line">return h +&#x27;:&#x27;+ m +&#x27;:&#x27;+ s;</span><br><span class="line">&#125;</span><br><span class="line">console.log(gettime());</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//######################</span><br><span class="line">//获取Date总毫秒数，距离1970.1.1的总毫秒数</span><br><span class="line">var date= new Date();</span><br><span class="line">console.log(date.valueOf());</span><br><span class="line">//或</span><br><span class="line">console.log(date.getTime());</span><br><span class="line">//或</span><br><span class="line">var date1= +new Date();		//常用</span><br><span class="line">console.log(date1);</span><br><span class="line">//或</span><br><span class="line">console.log(Date.now());	//H5新增</span><br></pre></td></tr></table></figure>

<ul>
<li>js 时分秒转化为秒</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var time = &#x27;00:02:10&#x27;;</span><br><span class="line">          var hour = time.split(&#x27;:&#x27;)[0];</span><br><span class="line">          var min = time.split(&#x27;:&#x27;)[1];</span><br><span class="line">          var sec = time.split(&#x27;:&#x27;)[2];</span><br><span class="line"></span><br><span class="line">          s = Number(hour*3600) + Number(min*60) + Number(sec);</span><br><span class="line">          console.log(s);//130</span><br></pre></td></tr></table></figure>

<ul>
<li> 设置日期对象的日期值</li>
</ul>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>setDate()</td>
<td>以数值（1-31）设置日</td>
</tr>
<tr>
<td>setFullYear()</td>
<td>设置年（可选月和日）</td>
</tr>
<tr>
<td>setHours()</td>
<td>设置小时（0-23）</td>
</tr>
<tr>
<td>setMilliseconds()</td>
<td>设置毫秒（0-999）</td>
</tr>
<tr>
<td>setMinutes()</td>
<td>设置分（0-59）</td>
</tr>
<tr>
<td>setMonth()</td>
<td>设置月（0-11）</td>
</tr>
<tr>
<td>setSeconds()</td>
<td>设置秒（0-59）</td>
</tr>
<tr>
<td>setTime()</td>
<td>设置时间（从 1970 年 1 月 1 日至今的毫秒数）</td>
</tr>
</tbody></table>
<p>setFullYear() 方法设置日期对象的年份。这个例子设置为 2020 年：</p>
<p>实例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">var d = new Date();</span><br><span class="line">d.setFullYear(2020);</span><br><span class="line">document.getElementById(&quot;demo&quot;).innerHTML = d;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>比较日期</li>
</ul>
<p>日期可以很容易地进行比较。</p>
<p>下面的例子把今日与 2049 年 1 月 16 日进行比较：</p>
<p>实例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var today, someday, text;</span><br><span class="line">today = new Date();</span><br><span class="line">someday = new Date();</span><br><span class="line">someday.setFullYear(2049, 0, 16);</span><br><span class="line">if (someday &gt; today) &#123;</span><br><span class="line">  text = &quot;今天在 2049 年 1 月 16 日之前&quot;;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  text = &quot;今天在 2049 年 1 月 16 日之后&quot;;</span><br><span class="line">&#125;</span><br><span class="line">document.getElementById(&quot;demo&quot;).innerHTML = text;</span><br></pre></td></tr></table></figure>
<h3 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h3><ul>
<li><p>setInterval(“函数”，毫秒数);<br>每隔对应的毫秒执行一次传入的函数;<br>返回值为：系统给启动定时器分配的编号；</p>
</li>
<li><p>clearInterval(定时器编号);<br>取消定时器</p>
</li>
</ul>
<h3 id="延时器"><a href="#延时器" class="headerlink" title="延时器"></a>延时器</h3><pre><code>只执行一次
</code></pre>
<ul>
<li>创建延时器<br>  <code>window.setTimeout(函数类型，延迟时间)</code><br>  返回值timeoutID是一个正整数，表示定时器的编号需要注意的是setTimeout()和setInterval()共用一个编号池，技术上，clearTimeout()和 clearInterval() 可以互换。但是，为了避免混淆，不要混用取消定时函数。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var timer1=window.setTimeout(function ()&#123;</span><br><span class="line">                console.log(&quot;你好啊！！！&quot;);</span><br><span class="line">            &#125;,3000);</span><br></pre></td></tr></table></figure>
<ul>
<li>清除延时器</li>
</ul>
<p><code>window.clearTimeout(延时器名称)</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function func()&#123;</span><br><span class="line">                //清除延时器</span><br><span class="line">                window.clearTimeout(timer1);</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

<h3 id="JS-this-关键词指的是它所属的对象。"><a href="#JS-this-关键词指的是它所属的对象。" class="headerlink" title="JS this 关键词指的是它所属的对象。"></a>JS this 关键词指的是它所属的对象。</h3><p>它拥有不同的值，具体取决于它的使用位置：</p>
<ul>
<li>在方法中，this 指的是所有者对象。</li>
</ul>
<p>在对象方法中，this 指的是此方法的“拥有者”。<br>在本页最上面的例子中，this 指的是 person 对象。<br>person 对象是 fullName 方法的拥有者。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var person = &#123;</span><br><span class="line">  firstName: &quot;Bill&quot;,</span><br><span class="line">  lastName : &quot;Gates&quot;,</span><br><span class="line">  id       : 678,</span><br><span class="line">fullName : function() &#123;</span><br><span class="line">  return this.firstName + &quot; &quot; + this.lastName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>单独的情况下，this 指的是全局对象。</li>
</ul>
<p>在单独使用时，拥有者是全局对象，因此 this 指的是全局对象。<br>在浏览器窗口中，全局对象是 [object Window]：</p>
<p>实例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var x = this;</span><br></pre></td></tr></table></figure>

<p>在严格模式中，如果单独使用，那么 this 指的是全局对象 [object Window]</p>
<ul>
<li>在函数中，this 指的是全局对象。</li>
</ul>
<p>在 JavaScript 函数中，函数的拥有者默认绑定 this。<br>因此，在函数中，this 指的是全局对象 [object Window]。</p>
<p>实例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function myFunction() &#123;</span><br><span class="line">  return this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>箭头函数没有自己的this，其中的this指的是window全局对象</p>
<p>在函数中使用时，在严格模式下，this 是未定义的（undefined）</p>
<ul>
<li>在事件中，this 指的是接收事件的元素。</li>
</ul>
<p>在 HTML 事件处理程序中，this 指的是接收此事件的 HTML 元素：</p>
<p>实例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onclick=&quot;this.style.display=&#x27;none&#x27;&quot;&gt;</span><br><span class="line">  点击来删除我！</span><br><span class="line">&lt;/button&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>像 call() 和 apply() 这样的方法可以将 this 引用到任何对象。</p>
<ul>
<li><p>call<br>格式：函数名.call();<br>参数：第一个参数：传入该函数this指向的对象，传入什么强制指向什么。<br> 第二参数开始：将原函数的参数往后顺延一位。</p>
</li>
<li><p>apply<br>格式：函数名.apply()<br>参数：第一个参数：传入该函数this指向的对象，传入什么强制指向什么。<br> 第二个参数：数组 其放入我们所有原来的参数。</p>
</li>
<li><p>bind预设this指向</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function show(x,y)&#123;</span><br><span class="line">console.log(this);</span><br><span class="line">console.log(x);</span><br><span class="line">console.log(y);</span><br><span class="line">&#125;</span><br><span class="line">var res=show.bind(&quot;bind&quot;);</span><br><span class="line">console.log(res);</span><br></pre></td></tr></table></figure>


<p>call() 和 apply() 方法是预定义的 JavaScript 方法。<br>它们都可以用于将另一个对象作为参数调用对象方法。<br>在下面的例子中，当使用 person2 作为参数调用 person1.fullName 时，this 将引用 person2，即使它是 person1 的方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var person1 = &#123;</span><br><span class="line">  fullName: function() &#123;</span><br><span class="line">    return this.firstName + &quot; &quot; + this.lastName;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">var person2 = &#123;</span><br><span class="line">  firstName:&quot;Bill&quot;,</span><br><span class="line">  lastName: &quot;Gates&quot;,</span><br><span class="line">&#125;</span><br><span class="line">person1.fullName.call(person2);  // 会返回 &quot;Bill Gates&quot;</span><br></pre></td></tr></table></figure>

<h2 id="js错误"><a href="#js错误" class="headerlink" title="js错误"></a>js错误</h2><ul>
<li><p>try 语句使您能够测试代码块中的错误。</p>
</li>
<li><p>catch 语句允许您处理错误。</p>
</li>
<li><p>throw 语句允许您创建自定义错误。</p>
</li>
<li><p>finally 使您能够执行代码，在 try 和 catch 之后，无论结果如何。</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">     供测试的代码块</span><br><span class="line">	throw new Error(&quot;直接允许&quot;);</span><br><span class="line">&#125;</span><br><span class="line"> catch(err) &#123;</span><br><span class="line">console.log(err);</span><br><span class="line">     处理错误的代码块</span><br><span class="line">//如果try中的代码无异常则不执行catch中的代码</span><br><span class="line">&#125; </span><br><span class="line">finally &#123;</span><br><span class="line">     无论 try / catch 结果如何都执行的代码块</span><br><span class="line">&#125;</span><br><span class="line">//----------------------------------</span><br><span class="line">function myFunction() &#123;</span><br><span class="line">    var message, x;</span><br><span class="line">    message = document.getElementById(&quot;message&quot;);</span><br><span class="line">    message.innerHTML = &quot;&quot;;</span><br><span class="line">    x = document.getElementById(&quot;demo&quot;).value;</span><br><span class="line">    try &#123; </span><br><span class="line">        if(x == &quot;&quot;) throw &quot;是空的&quot;;</span><br><span class="line">        if(isNaN(x)) throw &quot;不是数字&quot;;</span><br><span class="line">         x = Number(x);</span><br><span class="line">        if(x &gt;  10) throw &quot;太大&quot;;</span><br><span class="line">        if(x &lt;  5) throw &quot;太小&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    catch(err) &#123;</span><br><span class="line">        message.innerHTML = &quot;错误：&quot; + err + &quot;.&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    finally &#123;</span><br><span class="line">        document.getElementById(&quot;demo&quot;).value = &quot;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="JavaScript-闭包"><a href="#JavaScript-闭包" class="headerlink" title="JavaScript 闭包"></a>JavaScript 闭包</h3><ul>
<li><p>闭包特点：</p>
<ol>
<li>函数嵌套函数</li>
<li>内部函数使用外部函数的形参和变量</li>
<li>被引用的形参和变量不会被内存回收</li>
</ol>
</li>
<li><p>好处：</p>
<ol>
<li>变量能常驻内存当中</li>
<li>避免全局变量污染</li>
<li>可以声明私有成员</li>
</ol>
</li>
</ul>
<p>JavaScript 变量属于本地或全局作用域。</p>
<p>全局变量能够通过闭包实现局部（私有）。<br>闭包指的是有权访问父作用域的函数，即使在父函数关闭之后</p>
<blockquote>
<p>拥有相同名称的全局变量和局部变量是不同的变量。修改一个，不会改变其他。不通过关键词 var 创建的变量总是全局的，即使它们在函数中创建。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">var add = (function () &#123;</span><br><span class="line">    var counter = 0;</span><br><span class="line">    return function () &#123;return counter += 1;&#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">add();</span><br><span class="line">add();</span><br><span class="line">add();</span><br><span class="line"></span><br><span class="line">// 计数器目前是 3 </span><br><span class="line">/*</span><br><span class="line">第一次调用add()，相当于执行了function()&#123;return (++counter)&#125;一次；第二次调用add()，相当于又执行了function()&#123;return (++counter)&#125;一次；又由于function()&#123;return (++counter)&#125;是闭包，引用了其父函数的变量counter，所以在函数调用完毕counter依然存在，没有清零。</span><br><span class="line">    而且只在第一次给add赋值时，将counter设置为0。以后每次调用add()，counter都自增一次，没有重置。也就是前文说的，父函数只执行一次，每次调用都只执行了子函数。</span><br><span class="line">    这是为什么呢？因为只有执行下面这个函数，counter才重置。而这个函数只在第一次给add赋值时执行过一次。以后每次调用add()，都相当于调用function()&#123;return(++counter)&#125;。</span><br><span class="line">    function()&#123;</span><br><span class="line">       var counter = 0;</span><br><span class="line">       return function()&#123;</span><br><span class="line">          return (++counter);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">var moduleA=(function(mod)&#123;</span><br><span class="line">var conut=10;	//私有变量</span><br><span class="line">function showA()&#123;	//私有函数</span><br><span class="line">count+=20;</span><br><span class="line">console.log(count);</span><br><span class="line">&#125;</span><br><span class="line">function showB()&#123;</span><br><span class="line">count*=10;</span><br><span class="line">console.log(count);</span><br><span class="line">&#125;</span><br><span class="line">mod.outA=showA;</span><br><span class="line">mod.outB=showB;</span><br><span class="line">//对外暴露</span><br><span class="line">return mod;</span><br><span class="line">&#125;)(moduleA||&#123;&#125;);</span><br><span class="line"></span><br><span class="line">var moduleA=(function(mod)&#123;</span><br><span class="line">function showC()&#123;</span><br><span class="line">console.log(&quot;jjjj&quot;);</span><br><span class="line">&#125;</span><br><span class="line">mod.outC=showC;</span><br><span class="line">return mod;</span><br><span class="line">&#125;)(moduleA||&#123;&#125;);</span><br><span class="line"></span><br><span class="line">mouleA.outA();</span><br><span class="line">mouleA.outB();</span><br><span class="line">mouleA.outC();</span><br></pre></td></tr></table></figure>

<ul>
<li>立即执行函数写法</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var test=(function()&#123;</span><br><span class="line">var c=0;</span><br><span class="line">var m1=function()&#123;xxxx&#125;;</span><br><span class="line">var m2=function()&#123;xxxx&#125;;</span><br><span class="line">return&#123;</span><br><span class="line">m1:m1,</span><br><span class="line">m2:m2</span><br><span class="line">&#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<h4 id="模块化规范"><a href="#模块化规范" class="headerlink" title="模块化规范"></a>模块化规范</h4><ul>
<li>AMD规范：<ul>
<li>声明：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">define(function()&#123;</span><br><span class="line">//代码</span><br><span class="line">return&#123;</span><br><span class="line">outA:showA,</span><br><span class="line">outB:showB</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p>引用：（异步执行）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">require(&quot;moduleA.js&quot;,function(moduleA)&#123;</span><br><span class="line">moduleA.putA();</span><br><span class="line">moduleA.putB();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>ECMA6</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">export=&#123;</span><br><span class="line">outA:showA</span><br><span class="line">outB:showB</span><br><span class="line">&#125;</span><br><span class="line">import moduleA from &quot;moduleA.js&quot;</span><br><span class="line">moduleA.outA();</span><br><span class="line">moduleA.outB();</span><br></pre></td></tr></table></figure>
<ul>
<li><p>JavaScript 性能</p>
<ol>
<li>减少循环中的活动</li>
<li>减少 DOM 访问<br>与其他 JavaScript 相比，访问 HTML DOM 非常缓慢</li>
<li>缩减 DOM 规模<br>请尽量保持 HTML DOM 中较少的元素数量。</li>
<li>避免不必要的变量</li>
<li>延迟 JavaScript 加载<br>请把脚本放在页面底部，使浏览器首先加载页面。</li>
<li>避免使用 with<br>请避免使用 with 关键词。它对速度有负面影响。它也将混淆 JavaScript 作用域。</li>
</ol>
</li>
</ul>
<ul>
<li>JavaScript JSON</li>
</ul>
<p>JSON 是存储和传输数据的格式。<br>JSON 格式仅仅是文本，它能够轻松地在服务器浏览器之间传输，并用作任何编程语言的数据格式。<br>JSON 语法衍生于 JavaScript 对象标记法语法:</p>
<ul>
<li>数据在名称/值对中</li>
<li>数据由逗号分隔</li>
<li>花括号容纳对象</li>
<li>方括号容纳数组</li>
</ul>
<p>JSON 的值不可以是以下数据类型之一：函数;日期;undefined.</p>
<p>把 JSON 文本转换为 JavaScript 对象<br>首先，创建包含 JSON 语法的 JavaScript 字符串：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var text = &#x27;&#123; &quot;employees&quot; : [&#x27; +</span><br><span class="line">&#x27;&#123; &quot;firstName&quot;:&quot;Bill&quot; , &quot;lastName&quot;:&quot;Gates&quot; &#125;,&#x27; +</span><br><span class="line">&#x27;&#123; &quot;firstName&quot;:&quot;Steve&quot; , &quot;lastName&quot;:&quot;Jobs&quot; &#125;,&#x27; +</span><br><span class="line">&#x27;&#123; &quot;firstName&quot;:&quot;Alan&quot; , &quot;lastName&quot;:&quot;Turing&quot; &#125; ]&#125;&#x27;;</span><br></pre></td></tr></table></figure>

<p>然后，使用 JavaScript 的内建函数 JSON.parse() 来把这个字符串转换为 JavaScript 对象：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var obj = JSON.parse(text);</span><br></pre></td></tr></table></figure>

<p>最后，请在您的页面中使用这个新的 JavaScript 对象：</p>
<p>实例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;p id=&quot;demo&quot;&gt;\&lt;/p&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">document.getElementById(&quot;demo&quot;).innerHTML =</span><br><span class="line">obj.employees[1].firstName + &quot; &quot; + obj.employees[1].lastName;</span><br><span class="line">&lt;/script&gt; </span><br></pre></td></tr></table></figure>

<p>JSON 与 XML 的差异在于：</p>
<ul>
<li>JSON 不使用标签</li>
<li>JSON 更短</li>
<li>JSON 的读写速度更快</li>
<li>JSON 可使用数组</li>
</ul>
<p>最大的不同在于：</p>
<p>XML 必须使用 XML 解析器进行解析。而 JSON 可通过标准的 JavaScript 函数进行解析。</p>
<ul>
<li>JavaScript 表单验证<br>HTML 表单验证能够通过 JavaScript 来完成</li>
</ul>
<p>JavaScript 实例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function validateForm() &#123;</span><br><span class="line">    var x = document.forms[&quot;myForm&quot;][&quot;fname&quot;].value;</span><br><span class="line">    if (x == &quot;&quot;) &#123;</span><br><span class="line">        alert(&quot;必须填写姓名&quot;);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数能够在表单提交时被调用：</p>
<p>HTML 表单实例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;form name=&quot;myForm&quot; action=&quot;action\_page\_post.php&quot; onsubmit=&quot;return validateForm()&quot; method=&quot;post&quot;&gt;</span><br><span class="line">姓名：&lt;input type=&quot;text&quot; name=&quot;fname&quot;&gt;</span><br><span class="line">&lt;input type=&quot;submit&quot; value=&quot;Submit&quot;&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure>

<h2 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h2><p>浏览器对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">window:&#123;</span><br><span class="line">document:&#123;anchors,forms,images,links,location&#125;,</span><br><span class="line">frames,</span><br><span class="line">history,</span><br><span class="line">location,</span><br><span class="line">navigator,</span><br><span class="line">screen</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="window方法"><a href="#window方法" class="headerlink" title="window方法"></a>window方法</h3><ul>
<li>alert();弹出提示框</li>
<li>confirm();弹出带确认的提示框，点确认返回true，取消返回false</li>
<li>prompt(“tips”,”tips”);弹出带输入框的提示框，第一个参数为面板上的提示的内容，第二个为输入框里提示的内容</li>
<li>open();第一个参数的为跳转的url，第二个参数为新窗口的名字，第三个参数为设置打开窗口的属性；如width,height,top,left.</li>
</ul>
<p>history对象</p>
<p>window..history掌管的是当前窗口的历史记录（只要加载的url不一样就会产生不一样的历史记录）</p>
<p>属性：<br>history.length返回当前窗口的历史记录条数<br>方法：<br>history.back();返回上一条历史记录<br>history.forward()；前进下一条记录<br>history.go();跳转到（0为刷新，正整数为前进，负整数为后退）</p>
<h3 id="location"><a href="#location" class="headerlink" title="location"></a>location</h3><p>location—地址栏</p>
<p>方法：</p>
<ul>
<li><p>location.assign(url)<br>当前窗口跳转到该url</p>
</li>
<li><p>location.replace(url)</p>
</li>
</ul>
<p>在当前窗口替换成新的url</p>
<ul>
<li>location.reload()</li>
</ul>
<p>刷新当前窗口</p>
<ul>
<li>location.reload(true)</li>
</ul>
<p>不经过浏览器缓存，强制从服务器重载</p>
<hr>
<p><em>url:统一资源定位符</em><br><em>协议://IP（域名）//:端口号/路径/?查询字符串#锚点</em></p>
<ul>
<li>location.protocol</li>
</ul>
<p>查看协议<br>file:本地磁盘文件访问<br>http:<br>https:</p>
<ul>
<li>location.hostname</li>
</ul>
<p>查看主机名 IP</p>
<ul>
<li>location.port</li>
</ul>
<p>查看端口号(默认隐藏，无法查看)</p>
<p><code>hostname:port</code>可直接定位到当前使用的网络的程序</p>
<ul>
<li>location.pathname </li>
</ul>
<p>查看路径</p>
<ul>
<li>location.search </li>
</ul>
<p>查看字符串如<code>?name1=Tom&amp;name2=Tony</code></p>
<ul>
<li>location.hash</li>
</ul>
<p>查看锚点</p>
<ul>
<li>loaction.href</li>
</ul>
<p>查看整个url</p>
<p>##DOM</p>
<p>文档对象模型（document object model）<br>HTML DOM 方法是您能够（在 HTML 元素上）执行的动作。<br>HTML DOM 属性是您能够设置或改变的 HTML 元素的值。</p>
<ul>
<li><p>通过这个对象模型，JavaScript 获得创建动态 HTML 的所有力量：</p>
<ul>
<li>JavaScript 能改变页面中的所有 HTML 元素</li>
<li>JavaScript 能改变页面中的所有 HTML 属性</li>
<li>JavaScript 能改变页面中的所有 CSS 样式</li>
<li>JavaScript 能删除已有的 HTML 元素和属性</li>
<li>JavaScript 能添加新的 HTML 元素和属性</li>
<li>JavaScript 能对页面中所有已有的 HTML 事件作出反应</li>
<li>JavaScript 能在页面中创建新的 HTML 事件</li>
</ul>
</li>
<li><p>节点类型:</p>
<ul>
<li>元素节点：<div></div></li>
<li>属性节点：id=“div1”</li>
<li>文本节点： 文本</li>
</ul>
</li>
</ul>
<h3 id="结点的获取"><a href="#结点的获取" class="headerlink" title="结点的获取"></a>结点的获取</h3><ul>
<li><p>document.getElementById(id);</p>
</li>
<li><p>node.getElementsByTagName(标签名);<br>通过标签名获取符合条件的元素节点，返回：伪数组</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//获取ol下的li节点</span><br><span class="line">bar oOl=document.getElementById(&quot;ol1&quot;);</span><br><span class="line">var lis=oOl.getElementsByTagName(&quot;li&quot;);</span><br><span class="line">//返回的是数组</span><br></pre></td></tr></table></figure>

<ul>
<li><p>node.getElementsByClassName(class名);<br>通过class名字获取符合条件的元素节点；(IE8以下不兼容）</p>
</li>
<li><p>document.getElementByName(name属性的值);<br>通过name属性的值获取符合条件的元素节点，一般用于表单元素,因为其他元素使用name属性没用</p>
</li>
<li><p>document.querySelector(CSS选择器格式字符串);<br>返回一个元素节点，找到符合条件的第一个元素节点</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">window.onload=function()&#123;</span><br><span class="line">//id=ol1</span><br><span class="line">var node=document.querySelector(&quot;#ol1&quot;);</span><br><span class="line"></span><br><span class="line">//tagName=&#x27;li&#x27;</span><br><span class="line">var node=document.querySelector(&quot;li&quot;);</span><br><span class="line"></span><br><span class="line">//class=box</span><br><span class="line">var node =document.querySelector(&quot;.box&quot;);</span><br><span class="line">node.style.backgroundColor=&#x27;red&#x27;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">一、js获取子节点的方式</span><br><span class="line">1. 通过获取dom方式直接获取子节点</span><br><span class="line"></span><br><span class="line">其中test的父标签id的值，div为标签的名字。getElementsByTagName是一个方法。返回的是一个数组。在访问的时候要按数组的形式访问。</span><br><span class="line"></span><br><span class="line">1</span><br><span class="line">var a = document.getElementById(&quot;test&quot;).getElementsByTagName(&quot;div&quot;);</span><br><span class="line">2. 通过childNodes获取子节点</span><br><span class="line"></span><br><span class="line">使用childNodes获取子节点的时候，childNodes返回的是子节点的集合，是一个数组的格式。他会把换行和空格也当成是节点信息。</span><br><span class="line"></span><br><span class="line">1</span><br><span class="line">var b =document.getElementById(&quot;test&quot;).childNodes;</span><br><span class="line">为了不显示不必须的换行的空格，我们如果要使用childNodes就必须进行必要的过滤。通过正则表达式式取掉不必要的信息。下面是过滤掉</span><br><span class="line"></span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">//去掉换行的空格</span><br><span class="line">for(var i=0; i&lt;b.length;i++)&#123;</span><br><span class="line">  if(b[i].nodeName == &quot;#text&quot; &amp;&amp; !/\s/.test(b.nodeValue))&#123;</span><br><span class="line">    document.getElementById(&quot;test&quot;).removeChild(b[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">//打印测试</span><br><span class="line">for(var i=0;i&lt;b.length;i++)&#123;</span><br><span class="line">  console.log(i+&quot;---------&quot;)</span><br><span class="line">  console.log(b[i]);</span><br><span class="line">&#125;</span><br><span class="line">//补充 document.getElementById(&quot;test&quot;).childElementCount; 可以直接获取长度 同length</span><br><span class="line">4. 通过children来获取子节点</span><br><span class="line"></span><br><span class="line">利用children来获取子元素是最方便的，他也会返回出一个数组。对其获取子元素的访问只需按数组的访问形式即可。</span><br><span class="line"></span><br><span class="line">1</span><br><span class="line">var getFirstChild = document.getElementById(&quot;test&quot;).children[0];</span><br><span class="line">5. 获取第一个子节点</span><br><span class="line"></span><br><span class="line">firstChild来获取第一个子元素，但是在有些情况下我们打印的时候会显示undefined，这是什么情况呢？？其实firstChild和childNodes是一样的，在浏览器解析的时候会把他当换行和空格一起解析，其实你获取的是第一个子节点，只是这个子节点是一个换行或者是一个空格而已。那么不要忘记和childNodes一样处理呀。</span><br><span class="line"></span><br><span class="line">1</span><br><span class="line">var getFirstChild = document.getElementById(&quot;test&quot;).firstChild;</span><br><span class="line">6. firstElementChild获取第一个子节点</span><br><span class="line"></span><br><span class="line">使用firstElementChild来获取第一个子元素的时候，这就没有firstChild的那种情况了。会获取到父元素第一个子元素的节点 这样就能直接显示出来文本信息了。他并不会匹配换行和空格信息。</span><br><span class="line"></span><br><span class="line">1</span><br><span class="line">var getFirstChild = document.getElementById(&quot;test&quot;).firstElementChild;</span><br><span class="line">7. 获取最后一个子节点</span><br><span class="line"></span><br><span class="line">lastChild获取最后一个子节点的方式其实和firstChild是类似的。同样的lastElementChild和firstElementChild也是一样的。不再赘余。</span><br><span class="line"></span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">var getLastChildA = document.getElementById(&quot;test&quot;).lastChild;</span><br><span class="line">var getLastChildB = document.getElementById(&quot;test&quot;).lastElementChild;</span><br><span class="line">一个包解决你所有的JS问题,点击获取</span><br><span class="line"></span><br><span class="line">二、js获取父节点的方式</span><br><span class="line">1. parentNode获取父节点</span><br><span class="line"></span><br><span class="line">获取的是当前元素的直接父元素。parentNode是w3c的标准。</span><br><span class="line"></span><br><span class="line">1</span><br><span class="line">var p = document.getElementById(&quot;test&quot;).parentNode;</span><br><span class="line">2. parentElement获取父节点</span><br><span class="line"></span><br><span class="line">parentElement和parentNode一样，只是parentElement是ie的标准。</span><br><span class="line"></span><br><span class="line">1</span><br><span class="line">var p1 = document.getElementById(&quot;test&quot;).parentElement;</span><br><span class="line">3. offsetParent获取所有父节点</span><br><span class="line"></span><br><span class="line">一看offset我们就知道是偏移量 其实这个是于位置有关的上下级 ，直接能够获取到所有父亲节点， 这个对应的值是body下的所有节点信息。</span><br><span class="line"></span><br><span class="line">1</span><br><span class="line">var p2 = document.getElementById(&quot;test&quot;).offsetParent;</span><br><span class="line">三、js获取兄弟节点的方式</span><br><span class="line">1. 通过获取父亲节点再获取子节点来获取兄弟节点</span><br><span class="line"></span><br><span class="line">1</span><br><span class="line">var brother1 = document.getElementById(&quot;test&quot;).parentNode.children[1];</span><br><span class="line">2. 获取上一个兄弟节点</span><br><span class="line"></span><br><span class="line">在获取前一个兄弟节点的时候可以使用previousSibling和previousElementSibling。他们的区别是previousSibling会匹配字符，包括换行和空格，而不是节点。previousElementSibling则直接匹配节点。</span><br><span class="line"></span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">var brother2 = document.getElementById(&quot;test&quot;).previousElementSibling;</span><br><span class="line">var brother3 = document.getElementById(&quot;test&quot;).previousSibling;</span><br><span class="line">3. 获取下一个兄弟节点</span><br><span class="line"></span><br><span class="line">同previousSibling和previousElementSibling，nextSibling和nextElementSibling也是类似的。</span><br><span class="line"></span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">var brother4 = document.getElementById(&quot;test&quot;).nextElementSibling;</span><br><span class="line">var brother5 = document.getElementById(&quot;test&quot;).nextSibling;</span><br></pre></td></tr></table></figure>
<ul>
<li>document.querySelectorAll(CSS选择器格式字符串);<br>返回一个数组</li>
</ul>
<h3 id="获取样式"><a href="#获取样式" class="headerlink" title="获取样式"></a>获取样式</h3><ul>
<li>node.currentStyle[‘height’];    //IE兼容</li>
<li>getComputedStyle(node)[‘height’];    //火狐、谷歌</li>
</ul>
<p>获取的是当前有效的样式</p>
<ul>
<li>node.getAttribute(“class”);</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//增加属性,支持自定义</span><br><span class="line">node.setAttribute(&quot;class&quot;,&quot;box&quot;);</span><br><span class="line">node.setAttribute(&quot;jjj&quot;,&quot;aaa&quot;);</span><br><span class="line">//删除属性</span><br><span class="line">node.removeAttribute(&quot;class&quot;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="获取内容"><a href="#获取内容" class="headerlink" title="获取内容"></a>获取内容</h3><ul>
<li>innerHTML<br>获取标签内容，写入时会解析标签</li>
<li>innerText<br>获取标签间纯文本，不会解析标签</li>
<li>outerHTML<br>会替换整个标签</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">window.onload=function()&#123;</span><br><span class="line">var odiv=document.getElementById(&quot;div1&quot;);</span><br><span class="line"></span><br><span class="line">console.log(odiv.innerHTML);</span><br><span class="line">odiv.innerHTML=&quot;&lt;h1&gt;jjjjjjjj&lt;/h1&gt;&quot;;</span><br><span class="line"></span><br><span class="line">console.log(odiv.innerText);</span><br><span class="line">console.log(odiv.outerHTML);</span><br></pre></td></tr></table></figure>

<h3 id="获取子节点"><a href="#获取子节点" class="headerlink" title="获取子节点"></a>获取子节点</h3><ul>
<li><p>childNodes<br>访问当前节点下所有的子节点</p>
</li>
<li><p>firstChild<br>访问子节点中的首位</p>
</li>
<li><p>lastChild<br>访问子节点中的最后一位</p>
</li>
<li><p>nextSibling 访问当前节点兄弟节点中的下一个节点</p>
</li>
<li><p>previousSibling 访问当前节点兄弟节点中的上一个节点</p>
</li>
</ul>
<blockquote>
<p>上面这些属性都包含文本节点</p>
</blockquote>
<ul>
<li>children</li>
<li>firstElementChild</li>
<li>lastElementChild</li>
<li>nextElementSibling</li>
<li>previousElementSibling</li>
</ul>
<blockquote>
<p>上面这些属性只获取子节点中的元素节点，不包含文本。</p>
</blockquote>
<table>
<thead>
<tr>
<th></th>
<th>nodeType</th>
<th>nodeName</th>
<th>nodeValue</th>
</tr>
</thead>
<tbody><tr>
<td>元素节点</td>
<td>1</td>
<td>标签名</td>
<td>null</td>
</tr>
<tr>
<td>属性节点</td>
<td>2</td>
<td>属性名</td>
<td>属性值</td>
</tr>
<tr>
<td>文本节点</td>
<td>3</td>
<td>#text</td>
<td>文本内容</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">window.onload=function()&#123;</span><br><span class="line">var oDiv=document.getElementById(&quot;div1&quot;);</span><br><span class="line">console.log(oDiv.childNodes.length);	//返回数组，里面为全部子元素，包括换行，缩进</span><br><span class="line">console.log(oDiv.childNodes[0].nodeName);</span><br><span class="line">&#125;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div id=&quot;div1&quot; &gt; &lt;em&gt; text&lt;/em&gt; divtext &lt;strong&gt;text&lt;/strong&gt;&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>

<h3 id="获取当前元素节点上的所有的属性节点"><a href="#获取当前元素节点上的所有的属性节点" class="headerlink" title="获取当前元素节点上的所有的属性节点"></a>获取当前元素节点上的所有的属性节点</h3><ul>
<li>attrbutes</li>
</ul>
<p>获取当前元素节点上的所有的属性节点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var oDiv=document.getElementById(&quot;div1&quot;);</span><br><span class="line">console.log(oDiv.attributes);</span><br></pre></td></tr></table></figure>

<p>返回的是集合：</p>
<ol>
<li>无序</li>
<li>不重复</li>
</ol>
<h3 id="获取其中的某一个属性节点"><a href="#获取其中的某一个属性节点" class="headerlink" title="获取其中的某一个属性节点"></a>获取其中的某一个属性节点</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//div中title=&quot;hello&quot;</span><br><span class="line">console.log(oDiv.attributes.getNamedItem(&quot;title&quot;).nodeName);</span><br><span class="line">console.log(oDiv.attributes.getNamedItem(&quot;title&quot;).nodeType);</span><br><span class="line">console.log(oDiv.attributes.getNamedItem(&quot;title&quot;).nodeValue);</span><br><span class="line">//或</span><br><span class="line">console.log(oDiv.attributes[&quot;title&quot;].nodeName);</span><br><span class="line">console.log(oDiv.attributes[&quot;title&quot;].nodeType);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="节点操作"><a href="#节点操作" class="headerlink" title="节点操作"></a>节点操作</h3><blockquote>
<p>document.write()会覆盖页面上的所有内容</p>
</blockquote>
<ul>
<li>createElement()</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">document.createElement();</span><br><span class="line">参数：标签名</span><br><span class="line">返回值：创建好的节点</span><br></pre></td></tr></table></figure>

<ul>
<li>appendChild()</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node1.appendChild(node2);</span><br><span class="line">将node2节点插入到node1节点的子节点的末尾</span><br></pre></td></tr></table></figure>

<ul>
<li>createTextNode()</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">document.createTextNode(文本);</span><br><span class="line">创建文本节点（纯文本）</span><br></pre></td></tr></table></figure>

<ul>
<li>insertBefore()</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">box1的父节点.insertBefore(box2,box1);</span><br><span class="line">将box2添加到box1前面</span><br></pre></td></tr></table></figure>

<ul>
<li>replaceChild()</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">box1的父节点.replaceChild(box2,box1);</span><br><span class="line">用box2替换掉box1</span><br></pre></td></tr></table></figure>

<ul>
<li>cloneNode()</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">node.cloneNode();	//克隆自己</span><br><span class="line">node.cloneNode(true);	//克隆自己和本身下的所有子节点</span><br><span class="line">//返回克隆的新节点</span><br></pre></td></tr></table></figure>

<ul>
<li>removeChild()</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">box1的父节点.Child(box1);</span><br><span class="line">删掉box1节点</span><br></pre></td></tr></table></figure>



<p>实例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">window.onload=function()&#123;</span><br><span class="line">                var oDiv=document.getElementById(&quot;div1&quot;);	//div</span><br><span class="line">               var newP=document.createElement(&#x27;p&#x27;);		//创建一个新的p标签节点</span><br><span class="line">                var newText=document.createTextNode(&#x27;jjjj&#x27;);	//创建一个字符节点</span><br><span class="line">                newP.appendChild(newText);			//将字符节点插入到p节点中</span><br><span class="line">                oDiv.appendChild(newP);				//将p节点插入到div节点中</span><br><span class="line">		var newb=document.createElement(&#x27;input&#x27;);		//新建一个input节点</span><br><span class="line">                oDiv.insertBefore(newb,newP);			//将input节点添加到p节点前面</span><br><span class="line">		//doument.body.insertBefore(oP,oDiv);	//将oP节点插入到oDiv 前面</span><br><span class="line">        &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="offset"><a href="#offset" class="headerlink" title="offset"></a>offset</h3><ul>
<li>offsetWidth</li>
<li>offsetHeight</li>
</ul>
<ul>
<li><p>offsetLeft</p>
</li>
<li><p>offsetTop</p>
<ol>
<li><p>在父元素均不设置position属性时，在Chrome，opera和IE浏览器中offsetLeft是<em>元素边框外侧</em>到<em>浏览器窗口内侧</em>的距离且body.offsetLeft=0,在firefox浏览器中offsetLeft是元素边框外侧到body内侧的距离body.offsetLeft=-边框宽度</p>
</li>
<li><p>如果父元素是body且body设置了position属性，在Chrome和opera浏览器中offsetLeft是元素边框外侧到body边框外侧的距离，在IE和fireForx浏览器中offsetLeft是元素边框外侧到body边框内侧的距离</p>
</li>
<li><p>如果父元素不是body元素且设置了position属性时，offsetLeft为元素边框外侧到父元素边框内侧的距离（各浏览器情况一致）。</p>
</li>
</ol>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">window.onload=function()&#123;</span><br><span class="line">var oDiv=document.getElementById(&quot;div1&quot;);</span><br><span class="line">//alert(getStyle(ODiv,&quot;width&quot;));</span><br><span class="line">alert(oDiv.offsetWidth);	//眼睛能看到的实际宽度（width+border+padding）</span><br><span class="line"></span><br><span class="line">var oDiv2=document.getElementById(&quot;div2&quot;);</span><br><span class="line">alert(oDiv2.offsetLeft);//眼睛能看到实际距离第一个有定位的父节点的距离。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="HTML-事件"><a href="#HTML-事件" class="headerlink" title="HTML 事件"></a>HTML 事件</h2><p>HTML 事件可以是浏览器或用户做的某些事情。</p>
<p>写法：</p>
<ol>
<li>内联模式</li>
<li>脚本模式/外联模式</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onclick=&quot;btnClick()&quot;&gt; 内联模式&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">&lt;button id=&quot;btn&quot;&gt;外联模式&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">var oBtn=document.getElementById(&quot;btn&quot;);</span><br><span class="line">0Btn.onclick=function()&#123;</span><br><span class="line">console.log(&quot;click button&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>绑定事件格式：<code>元素节点.on+事件类型=匿名函数</code>；</p>
<blockquote>
<p>系统会在事件绑定完成时，生成一个事件对象。触发事件时，系统会自动去调用事件绑定的函数，将事件对象当做第一个参数传入。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">function show()&#123;</span><br><span class="line">console.log(argument.length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">window.onload=function()&#123;</span><br><span class="line">var oBtn=document.getElement(&quot;btn1&quot;);</span><br><span class="line">//oBtn.onclick=show;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">button属性：左键0；中键1；右键2；</span><br><span class="line"></span><br><span class="line">鼠标位置：(原点位置不同）</span><br><span class="line">clientX    clientY		//可视窗口的左上角</span><br><span class="line">pageX    pageY			//整个页面的左上角（滚动也包括）</span><br><span class="line">screenX    screenY		//电脑屏幕的左上角</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">oBtn.onclick=function(e)&#123;</span><br><span class="line">//事件对象获取的方式，固定写法</span><br><span class="line">var ev=e||window.event;</span><br><span class="line">console.log(ev);</span><br><span class="line">//console.log(ev.button);</span><br><span class="line">//console.log(ev.clientX);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>循环添加</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var Oblock=document.querySelectorAll(&#x27;div&#x27;);</span><br><span class="line">			//console.log(Oblock);</span><br><span class="line">			for (var i=0 ;i&lt; Oblock.length;i++)&#123;</span><br><span class="line">				Oblock[i].index=i;</span><br><span class="line">				Oblock[i].onmousedown=function(e)&#123;</span><br><span class="line">				console.log(this.index);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>window事件</p>
<ul>
<li>load 当页面加载完后会触发</li>
<li>unload 当页面解析的时候触发（如刷新界面、关闭当前界面）IE浏览器兼容</li>
<li>scroll 页面滚动</li>
<li>resize 窗口大小发生变化的时候触发</li>
</ul>
</li>
<li><p>表单事件</p>
<ul>
<li><p>blur 失去焦点</p>
</li>
<li><p>focus 获取焦点</p>
</li>
<li><p>select  在输入框内选中文本时触发</p>
</li>
<li><p>change 修改输入框内容并失去焦点时触发</p>
</li>
<li><p>sumit 只对sumit按钮有效</p>
</li>
<li><p>reset 只对reset按钮有效</p>
</li>
</ul>
</li>
</ul>
<p>下面是一些常见的 HTML 事件：</p>
<table>
<thead>
<tr>
<th>事件</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>onchange</td>
<td>HTML 元素已被改变</td>
</tr>
<tr>
<td>onclick</td>
<td>用户点击了 HTML 元素</td>
</tr>
<tr>
<td>ondblclick</td>
<td>双击</td>
</tr>
<tr>
<td>onmouseover</td>
<td>用户把鼠标移动到 HTML 元素上(经过子节点会重复触发)</td>
</tr>
<tr>
<td>onmouseout</td>
<td>用户把鼠标移开 HTML 元素(经过子节点会重复触发)</td>
</tr>
<tr>
<td>onmouseenter</td>
<td>用户把鼠标移动到 HTML 元素上(经过子节点不会重复触发,IE8不兼容)</td>
</tr>
<tr>
<td>onmouseleave</td>
<td>用户把鼠标移开 HTML 元素(经过子节点不会重复触发,IE8不兼容)</td>
</tr>
<tr>
<td>onmousedown</td>
<td>鼠标任一按钮被按下</td>
</tr>
<tr>
<td>onmousemove</td>
<td>鼠标被移动,会不停触发</td>
</tr>
<tr>
<td>onmouseup</td>
<td>鼠标按键被松开</td>
</tr>
<tr>
<td>onkeypress</td>
<td>用户按下键盘按键(只支持字符建，shift等没用)</td>
</tr>
<tr>
<td>onkeydown</td>
<td>用户按下键盘按键</td>
</tr>
<tr>
<td>onkeyup</td>
<td>用户抬起键盘按键</td>
</tr>
<tr>
<td>onload</td>
<td>浏览器已经完成页面加载</td>
</tr>
</tbody></table>
<p>键盘事件对象属性：</p>
<ul>
<li>shiftKey    //按下shift键为true，默认为false</li>
<li>altKey</li>
<li>ctrlKey</li>
<li>metaKey        //按下win键</li>
<li>keyCode    键码        //不区分大小写，只返回大写ASCII码，支持shift、ctrl等非字符键；只在keydown下支持,可用 which兼容</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">window.onload=function()&#123;</span><br><span class="line">window.onkeydown=function(ev)&#123;</span><br><span class="line">var e=ev||window.event;</span><br><span class="line">var w=e.which||e.keyCode;</span><br><span class="line">console.log(w);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>charCode        键码        //区分大小写，只支持字符键，只在keypress下支持,可用 which兼容</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">window.onload=function()&#123;</span><br><span class="line">window.onkeypress=function(ev)&#123;</span><br><span class="line">var e=ev||window.event;</span><br><span class="line">var w=e.which||e.keyCode;</span><br><span class="line">console.log(w);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ul>
<li>target<br>目标对象/触发对象</li>
</ul>
<p>IE8以下不兼容，可使用window.event.srcElement</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">window.onload=function()&#123;</span><br><span class="line">var oUl=document.getElementById(&quot;ul1&quot;);</span><br><span class="line"></span><br><span class="line">window.onkeypress=function(ev)&#123;</span><br><span class="line">var e=ev||window.event;</span><br><span class="line">var target=e.target||window.event.srcElement;</span><br><span class="line">console.log(this.tagName);</span><br><span class="line">console.log(target.innerHTML);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>事件冒泡：由里向外逐级触发</li>
</ul>
<p>事件对象的属性和方法:<br>cancelBubble=true;<br>stopPropagation();</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">window.onload=function()&#123;</span><br><span class="line">var oDiv=document.getElementById(&quot;div1&quot;);</span><br><span class="line">for(var i=0;i&lt;aDivs.length;i++)&#123;</span><br><span class="line">window.onkeypress=function(ev)&#123;</span><br><span class="line">var e=ev||window.event;</span><br><span class="line">console.log(this.tagName);</span><br><span class="line">e.cancelBubble=true;</span><br><span class="line">//e.stopProgagation();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="DOM事件监听器"><a href="#DOM事件监听器" class="headerlink" title="DOM事件监听器"></a>DOM事件监听器</h4><ul>
<li>addEventListerner();<br>语法<br>element.addEventListener(event, function, useCapture);<br>第一个参数是事件的类型（比如 “click” 或 “mousedown”）。第二个参数是当事件发生时我们需要调用的函数。第三个参数是布尔值，指定使用事件冒泡还是事件捕获,默认false事件冒泡,此参数是可选的。<blockquote>
<p>注意：请勿对事件使用 “on” 前缀；请使用 “click” 代替 “onclick”。</p>
</blockquote>
</li>
</ul>
<p>实例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//添加当用户点击按钮时触发的事件监听器：</span><br><span class="line">document.getElementById(&quot;myBtn&quot;).addEventListener(&quot;click&quot;, displayDate);</span><br></pre></td></tr></table></figure>
<p>addEventListener() 方法为指定元素指定事件处理程序。addEventListener() 方法为元素附加事件处理程序而不会覆盖已有的事件处理程序。您能够向一个元素添加多个事件处理程序。您能够向一个元素添加多个相同类型的事件处理程序，例如两个 “click” 事件。传统事件绑定重复添加会覆盖。您能够向任何 DOM 对象添加事件处理程序而非仅仅 HTML 元素，例如 window 对象。addEventListener() 方法使我们更容易控制事件如何对冒泡作出反应。当使用 addEventListener() 方法时，JavaScript 与 HTML 标记是分隔的，已达到更佳的可读性；即使在不控制 HTML 标记时也允许您添加事件监听器。</p>
<p>您能够通过使用 <code>removeEventListener()</code> 方法轻松地删除事件监听器。</p>
<p>格式：<code>node.removeEvenetListener()</code><br>参数：第一个为事件类型，第二个为删除函数的名字；</p>
<h4 id="IE事件处理函数"><a href="#IE事件处理函数" class="headerlink" title="IE事件处理函数"></a>IE事件处理函数</h4><ul>
<li>attachEvent();<br>参数：事件名称和函数<br>格式：node.attchEvent(onclink,fn);</li>
</ul>
<ul>
<li>detachEvent();<br>参数：事件名称和函数<br>格式：node.detachEvent(onclink,fn);</li>
</ul>
<ul>
<li>阻止超链接的默认行为</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">window.onload=function()&#123;</span><br><span class="line">var a1=document.getElementById(&quot;a1&quot;);</span><br><span class="line">a1.onclick=function()&#123;</span><br><span class="line">return confirm(&quot;are you sure?&quot;);</span><br><span class="line">&#125;</span><br><span class="line">//或</span><br><span class="line">a1.onclick=function(evt)&#123;</span><br><span class="line">evt.preventDefault();</span><br><span class="line">alert(&quot;done&quot;);</span><br><span class="line">&#125;</span><br><span class="line">//or</span><br><span class="line">a1.onclick=function(evt)&#123;</span><br><span class="line">window.event.returnValue=false;			//IE兼容</span><br><span class="line">alert(&quot;done&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;a id=&quot;a1&quot; href=&quot;...&quot;&gt;&lt;/a&gt;</span><br></pre></td></tr></table></figure>

<h3 id="委托"><a href="#委托" class="headerlink" title="委托"></a>委托</h3><p>事件委托</p>
<ol>
<li>找到当前节点的父节点或者祖先节点</li>
<li>将事件添加到你找到的这个父节点或者祖先节点上</li>
<li>找到触发对象，判断触发对象是否是想要的触发对象，进行后续操作</li>
</ol>
<p>li委托ul将li变成红色：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">window.onload=function()&#123;</span><br><span class="line">var oUl=document.getElementById(&quot;ul1&quot;);</span><br><span class="line">oUl.onclick=function(ev)&#123;</span><br><span class="line">var e=ev||winow.event;</span><br><span class="line">var target=e.target||winow.event.target;</span><br><span class="line">if(target.nodeName.toLowerCase()==&quot;li&quot;)&#123;</span><br><span class="line">target.style.backgroundColor=&quot;red&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="localStorage"><a href="#localStorage" class="headerlink" title="localStorage"></a>localStorage</h3><p>HTML5中年，加入了一个localStorage特性，用来作为本地存储使用的，解决了cookie存储空间不足的问题。localStorage中一般浏览器支持5M大小，cookie中每条cookie的存储空间为4k。</p>
<ul>
<li>本地存储技术：</li>
</ul>
<p><em>localStorage(IE8以下不兼容);</em></p>
<ul>
<li><p>永久存储</p>
</li>
<li><p>最大可存储5M，相当于客户端一个微型数据库</p>
</li>
<li><p>只能存储string</p>
</li>
<li><p>localStorage对象</p>
<ul>
<li>setItem(name,value);</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">if(!window.localStorage)&#123;</span><br><span class="line">alert(&quot;当前页面不支持localStorage&quot;);</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">localStorage.setItem(&quot;a&quot;,&quot;1&quot;);</span><br><span class="line">localStorage.b=&quot;2&quot;;</span><br><span class="line">localStorage[&quot;c&quot;]=&quot;3&quot;;</span><br><span class="line">console.log(localStorage.getItem(&quot;b&quot;);</span><br><span class="line">console.log(localStorage.b;</span><br><span class="line">console.log(localStorage[&quot;a&quot;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>getItem(name);</li>
<li>removeItem(name);</li>
</ul>
<p><em>cookie</em></p>
<p>会话跟踪技术,从一次会话开始到结束（浏览器的关闭），会全程跟踪记录客户端的状态，记录相关信息</p>
<ul>
<li>可设置过期时间</li>
<li>最大可存储4KB</li>
<li>每一个域名下最多可存储50条数据</li>
</ul>
<blockquote>
<p>只能存储字符串</p>
</blockquote>
<ul>
<li>cookie的语法</li>
</ul>
<p>name 键；value 值，都可自定义<br><code>name=value;expires=date;path=path;domain=url;secure，其中name=value必选，剩余的可选</code></p>
<ol>
<li>expires:过期时间，填写日期对象。系统会自动清理过期的cookie</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">funciton afterOffDate(n)&#123;</span><br><span class="line">var d=new Date();</span><br><span class="line">var day=d.getDate();</span><br><span class="line">d.setDate(n+day);</span><br><span class="line">return d;</span><br><span class="line">&#125;</span><br><span class="line">document.cookie=&quot;user=&#x27;xxx&#x27;;expires=&quot;+afterOffDate(7);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>path 限制访问路径，如果不设置默认加载当前.html文件的路径；</li>
<li>domain 限制访问域名，如果不设置默认加载当前文件.html文件的服务器域名</li>
<li>secure 加入这个字段后只能设置https协议加载cookie；<blockquote>
<p>火狐浏览器支持本地加载的文件缓存cookie，谷歌只支持服务器加载文件缓存cookie</p>
</blockquote>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//设置cookie</span><br><span class="line">document.cookie=&#x27;username=xxx&#x27;;</span><br><span class="line">//读取cookie</span><br><span class="line">console.log(document.cookie);</span><br></pre></td></tr></table></figure>
<ul>
<li>cookie编解码</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">document.cookie=&quot;name1=&quot;+encodeURIComponent(&quot;小明&quot;);	//编码写入</span><br><span class="line">console.log(decodeURIComponent(document.cookie);	//解码读取</span><br></pre></td></tr></table></figure>


<p><em>sessionStorage(结合后台使用)</em></p>
<h4 id="ES6-新特性"><a href="#ES6-新特性" class="headerlink" title="ES6 新特性"></a>ES6 新特性</h4><ul>
<li>中括号解析</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var [x,y,z]=[1,&quot;dd&quot;,false];</span><br><span class="line">//相当与</span><br><span class="line">var x=1,y=&quot;dd&quot;,z=fase;</span><br><span class="line">//还可以</span><br><span class="line">var [x,[a,b],y]=[10,[10,&quot;dd&quot;],&quot;a&quot;];</span><br><span class="line">//交换两数方便</span><br><span class="line">var [x,y]=[1,2];</span><br><span class="line">[x,y]=[y,x];</span><br><span class="line">//函数可一次性返回多个数据</span><br><span class="line">function xxx()&#123;</span><br><span class="line">return [&quot;jj&quot;,3,true];</span><br><span class="line">&#125;</span><br><span class="line">var [a,b,c]=xxx();</span><br></pre></td></tr></table></figure>

<ul>
<li>大括号解析</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//不用按循序赋值</span><br><span class="line">var &#123;name,age,sex&#125;=&#123;</span><br><span class="line">sex:&quot;男&quot;,</span><br><span class="line">name:&quot;xiaomi&quot;,</span><br><span class="line">age:11</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>反引号</p>
<ul>
<li>可用反引号代替单双引号括起字符串。其中的换行、代码缩进都会保留。</li>
<li>拼接字符串时可用<code>$&#123;变量/表达式/函数&#125;</code>代替<code>+&#39;&#39;+</code></li>
</ul>
</li>
<li><p>Array.from()</p>
</li>
</ul>
<p>将伪数组转换为真数组</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var aLid=document.getElementById(&quot;li1&quot;);</span><br><span class="line">aLis=Array.from(aLis);</span><br><span class="line">aLis.push(&quot;test&quot;);</span><br></pre></td></tr></table></figure>

<ul>
<li>Set();集合</li>
</ul>
<p>特点：</p>
<ol>
<li>不重复</li>
<li>无序</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let imgs= new Set();</span><br><span class="line">//添加元素</span><br><span class="line">imgs.add(100);</span><br><span class="line">imgs.add(100);</span><br><span class="line">imgs.add(&quot;ddd&quot;);</span><br><span class="line">imgs.add(new String(&quot;ddd&quot;));</span><br><span class="line">console.log(imgs);</span><br></pre></td></tr></table></figure>

<p>遍历集合<code>for....of</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">for(let item of imgs.keys())&#123;	//遍历键</span><br><span class="line">console.log(item);</span><br><span class="line">&#125;</span><br><span class="line">for(let item of imgs.values())&#123;		//只遍历值</span><br><span class="line">console.log(item);</span><br><span class="line">&#125;</span><br><span class="line">for(let item of imgs.entries())&#123;   	//遍历键与值</span><br><span class="line">console.log(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>数组与集合互转</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//数组变集合</span><br><span class="line">var set=new Set([3,2,4,5,6,1,3,4]);</span><br><span class="line">console.log(set);</span><br><span class="line">//集合变数组，将数据结构展开为数组</span><br><span class="line">var arr = [...set];</span><br><span class="line">console.log(arr);</span><br></pre></td></tr></table></figure>


<ul>
<li>Map();映射</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">let map=new Map();</span><br><span class="line">//添加数据</span><br><span class="line">map.set(&quot;Tom&quot;,&quot;fishman&quot;);</span><br><span class="line">map.set(&quot;Jack&quot;,&quot;woker&quot;);</span><br><span class="line">map.set(&quot;Sim&quot;,&quot;teacher&quot;);</span><br><span class="line">map.set(&quot;Jack&quot;,&quot;bussnessman&quot;);</span><br><span class="line">console.log(map);</span><br><span class="line">//取值</span><br><span class="line">console.log(map.get(&quot;Tom&quot;));</span><br><span class="line">//map遍历：for   of</span><br><span class="line">for(let [key,value] of map)&#123;</span><br><span class="line">console.log(key,value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>遍历：数组[for循环、for…in、foreach、for…of],对象[for…in]，set[for…of],map[for…pf];</p>
</blockquote>
<ul>
<li>构造函数</li>
</ul>
<p>我们某一个函数，使用new运算符去调用</p>
<ol>
<li>当前函数中的this指向新创建的对象</li>
<li>自动完成原料和出厂操作<br>这种通过new调用函数，叫做构造函数(首字母一般大写)，其可构造对象，</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function createPerson(name,sex)&#123;</span><br><span class="line">var obj=new Object();	//原料</span><br><span class="line">//加工</span><br><span class="line">0bj.name=name;</span><br><span class="line">obj.sex=sex;</span><br><span class="line">0bj.showName=function()&#123;</span><br><span class="line">console.log(this.name);</span><br><span class="line">&#125;</span><br><span class="line">obj.showSex=functin()&#123;</span><br><span class="line">console.log(this.sex);</span><br><span class="line">&#125;</span><br><span class="line">return obj;	//出厂</span><br><span class="line">&#125;</span><br><span class="line">var p1=createPerson(&quot;Tom&quot;,&quot;man&quot;);</span><br><span class="line">p1.showName();</span><br><span class="line">p1.showSex();</span><br></pre></td></tr></table></figure>

<ul>
<li>prototype 原型对象</li>
</ul>
<p>每一个函数上，都一个原型对象prototype</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function show()&#123;</span><br><span class="line">&#125;</span><br><span class="line">console.log(show.prototype);</span><br></pre></td></tr></table></figure>


<p>用在构造函数上，我们可以给构造函数的原型prototype，添加方法</p>
<ol>
<li>如果我们将方法添加到构造函数的原型prototype对象上</li>
<li>构造函数构造出来的对象共享原型上所有的方法</li>
</ol>
<p>构造函数构造出来的对象，有一个属性_proto_,指向构造除这个对象的构造函数的原型。</p>
<p>instanceof关键字，判断某一个对象是否是这个构造函数构造出来的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var arr1=[3,32,4,1,45];</span><br><span class="line">var arr2=[4,3,2,1];</span><br><span class="line">Array.prototype.sum=function()&#123;</span><br><span class="line">var res=0;</span><br><span class="line">for(var i=0;i&lt;this.length;i++)&#123;</span><br><span class="line">res+=this[i];</span><br><span class="line">&#125;</span><br><span class="line">return res;</span><br><span class="line">&#125;</span><br><span class="line">console.log(arr1.sum());</span><br><span class="line">console.log(arr2.sum());</span><br><span class="line">console.log(arr1.sum==arr2.sum);</span><br></pre></td></tr></table></figure>

<p>在子一级构造函数重写方法，只会在子一级生效，并不会影响父一级构造函数的方法。</p>
<p>继承和多态：<br>继承侧重是从父一级构造函数，继承到属性和方法；<br>多态侧重的是子一级自己重写和新增的属性和方法;</p>
<h4 id="ECMA6-class语法"><a href="#ECMA6-class语法" class="headerlink" title="ECMA6 class语法"></a>ECMA6 class语法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class preson&#123;</span><br><span class="line">//class属性添加。</span><br><span class="line">constructor(name,sex,age)&#123;</span><br><span class="line">this.name=xxx;</span><br><span class="line">this.sex=sex;</span><br><span class="line">this.age=age;</span><br><span class="line"></span><br><span class="line">showself()&#123;</span><br><span class="line">console.log(`$&#123;this.name&#125;,$&#123;this.age&#125;`);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var p1=new person(&quot;Tony&quot;,&quot;man&quot;,33);</span><br><span class="line">p1.showself();</span><br><span class="line"></span><br><span class="line">//extends继承</span><br><span class="line">class worker extends person&#123;</span><br><span class="line">constructor(name,sex,age,job)&#123;</span><br><span class="line">//继承到父一级的属性</span><br><span class="line">super(name,sex,age);</span><br><span class="line">this.job=job;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">function person(name,sex,age)&#123;</span><br><span class="line">this.name=name;</span><br><span class="line">this.sex=sex;</span><br><span class="line">this.age=age;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">person.prototype.showself=function()&#123;</span><br><span class="line">console.log(this.name,this.age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function woker(name,sex,age,job)&#123;</span><br><span class="line">//1.构造函数的伪装，继承父级的属性</span><br><span class="line">Person.call(this,name,sex,age);</span><br><span class="line">this.job=job;</span><br><span class="line">&#125;</span><br><span class="line">//2.原型链  继承父一级的方法</span><br><span class="line">//&lt;1&gt;通过for ...in 遍历继承</span><br><span class="line">for (var funcName in person.prototype)&#123;</span><br><span class="line">worker.prototype[funcName]=person.prototype[funcName];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//&lt;2&gt;Object.create()</span><br><span class="line">worker.prototype=Object.create(person.prototype);</span><br><span class="line">//&lt;3&gt;调用构造函数继承</span><br><span class="line">worker.prototype=new person();</span><br><span class="line"></span><br><span class="line">worker.prototype.showjob=function()&#123;</span><br><span class="line">console.log(this.job);</span><br><span class="line">&#125;</span><br><span class="line">var w1=new worker(&quot;Tom&quot;,&quot;man&quot;,22,&quot;driver&quot;);</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="触发input-file的click事件：document-querySelector-39-file-39-click"><a href="#触发input-file的click事件：document-querySelector-39-file-39-click" class="headerlink" title="触发input-file的click事件：document.querySelector(&#39;#file&#39;).click()"></a>触发input-file的click事件：<code>document.querySelector(&#39;#file&#39;).click()</code></h2><h2 id="清空input-file值"><a href="#清空input-file值" class="headerlink" title="清空input-file值:"></a>清空input-file值:</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//1.###</span><br><span class="line">var test = document.getElementById(&#x27;test&#x27;);</span><br><span class="line">test.value = &#x27;&#x27;;  //test的value不能设为有字符的值，但是可以设置为空值</span><br><span class="line"></span><br><span class="line">//2.###</span><br><span class="line">var test = document.getElementById(&#x27;test&#x27;);</span><br><span class="line">test.outerHTML = test.outerHTML; //重新初始化了test的html</span><br></pre></td></tr></table></figure>
<h2 id="switch-case语句"><a href="#switch-case语句" class="headerlink" title="switch case语句:"></a>switch case语句:</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">switch (value)&#123;</span><br><span class="line">    case value1:  xxxxx  // 当表达式的结果等于 value1 时，则执行该代码</span><br><span class="line">        break;</span><br><span class="line">    default :  xxxxxxxx // 如果没有与表达式相同的值，则执行该代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="js时间戳转换成日期的方法：-new-Date-parseInt-n-toLocaleDateString"><a href="#js时间戳转换成日期的方法：-new-Date-parseInt-n-toLocaleDateString" class="headerlink" title="js时间戳转换成日期的方法：(new Date(parseInt(n))).toLocaleDateString() "></a>js时间戳转换成日期的方法：<code>(new Date(parseInt(n))).toLocaleDateString() </code></h2><h2 id="获取地址栏地址：window-location-href。"><a href="#获取地址栏地址：window-location-href。" class="headerlink" title="获取地址栏地址：window.location.href。"></a>获取地址栏地址：window.location.href。</h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">KK</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">58</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/a913481180" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;a913481180" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:kangkanghuang@foxmail.com" title="E-Mail → mailto:kangkanghuang@foxmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="http://www.baidu.com/" title="http:&#x2F;&#x2F;www.baidu.com">百度</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">KK</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>

<script src="/js/utils.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
