<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/1.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/1.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.baidu.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":false,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="KK">
<meta property="og:url" content="http://www.baidu.com/index.html">
<meta property="og:site_name" content="KK">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="KK">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://www.baidu.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>KK</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">KK</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.baidu.com/2023/01/11/20-22-22/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="KK">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KK">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/01/11/20-22-22/" class="post-title-link" itemprop="url">PM2</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-01-11 20:22:22" itemprop="dateCreated datePublished" datetime="2023-01-11T20:22:22+08:00">2023-01-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-05-16 23:50:36" itemprop="dateModified" datetime="2023-05-16T23:50:36+08:00">2023-05-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>PM2 是常用的 node 进程管理工具，它可以提供 node.js 应用管理，如自动重载、性能监控、负载均衡等。同类工具有 Supervisor、Forever 等。</p>
<p>pm2 是一个进程管理工具,可以用它来管理你的 node 进程，并查看 node 进程的状态，当然也支持性能监控，进程守护，负载均衡等功能。pm2 基本是 Nodejs 应用程序不二的守护进程选择，事实上它并不仅仅可以启动 Nodejs 的程序，只要是一般的脚本的程序它同样可以胜任。</p>
<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul>
<li><p>内建负载均衡（使用 node cluster 集群模块，可以使用服务器上的所有 cpu）</p>
</li>
<li><p>后台运行（node app.js 这种命令是直接在前台运行的，不稳定，很容易断）</p>
</li>
<li><p>0 秒停机重载（应该是上线升级的时候 不需要停机）</p>
</li>
<li><p>停止不稳定的进程（避免无限循环）</p>
</li>
<li><p>控制台检测</p>
</li>
</ul>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><code>npm install -g pm2</code></p>
<h2 id="启动-PM2-项目"><a href="#启动-PM2-项目" class="headerlink" title="启动 PM2 项目"></a>启动 PM2 项目</h2><p>pm2 支持直接运行 server.js 启动项目，如下：<code>pm2 start server.js</code></p>
<ul>
<li><code>--watch</code>：监听应用目录的变化，一旦发生变化，自动重启。如果要精确监听、不见听的目录，最好通过配置文件。</li>
<li><code>-i --instances</code>：启用多少个实例，可用于负载均衡。如果-i 0 或者-i max，则根据当前机器核数确定实例数目。</li>
<li><code>--ignore-watch</code>：排除监听的目录/文件，可以是特定的文件名，也可以是正则。比如<code>--ignore-watch=&quot;test node_modules &quot;some scripts&quot;&quot;</code></li>
<li><code>-n --name</code>：应用的名称。查看应用信息的时候可以用到。</li>
<li><code>-o --output &lt;path&gt;</code>：标准输出日志文件的路径。</li>
<li><code>-e --error &lt;path&gt;</code>：错误输出日志文件的路径。</li>
<li><code>--interpreter &lt;interpreter&gt;</code>：the interpreter pm2 should use for executing app (bash, python…)。比如你用的 coffee script 来编写应用。</li>
</ul>
<h2 id="文件夹结构"><a href="#文件夹结构" class="headerlink" title="文件夹结构"></a>文件夹结构</h2><p>PM2 启动后，它将自动创建这些文件夹：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$HOME/.pm2：将包含所有PM2相关文件</span><br><span class="line"></span><br><span class="line">$HOME/.pm2/logs：将包含所有应用程序日志</span><br><span class="line"></span><br><span class="line">$HOME/.pm2/pids：将包含所有应用程序pids</span><br><span class="line"></span><br><span class="line">$HOME/.pm2/pm2.log：PM2 日志</span><br><span class="line"></span><br><span class="line">$HOME/.pm2/pm2.pid：PM2 pid</span><br><span class="line"></span><br><span class="line">$HOME/.pm2/rpc.sock：远程命令的套接字文件</span><br><span class="line"></span><br><span class="line">$HOME/.pm2/pub.sock：可发布事件的套接字文件</span><br><span class="line"></span><br><span class="line">$HOME/.pm2/conf.js：PM2配置</span><br></pre></td></tr></table></figure>

<p>在 Windows 中，$ HOME 环境变量可以是$ HOMEDRIVE + $ HOMEPATH</p>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><ul>
<li>查看应用列表（查看当前机器执行的所有进程）<br><code>pm2 list/ls/l</code></li>
<li>查看某个应用详情（查看某个进程信息）<br><code>pm2 show app_name|app_id</code>或者<code>pm2 describe app_name|app_id</code></li>
<li>重启<br><code>pm2 restart app.js</code>或<code>pm2 restart app_name|app_name</code></li>
<li>停止<br><code>pm2 stop app_name|app_id</code>或停止全部<code>pm2 stop all</code></li>
<li>删除<br>类似 pm2 stop，如下<br><code>pm2 delete app_name|app_id</code><br><code>pm2 delete all</code></li>
<li>日志查看<br>除了可以打开日志文件查看日志外，还可以通过<code>pm2 logs</code>来查看实时日志。这点对于线上问题排查非常重要。比如某个 node 服务突然异常重启了，那么可以通过 pm2 提供的日志工具来查看实时日志，看是不是脚本出错之类导致的异常重启。查看指定应用程序日志：<code>pm2 logs app_name|app_id</code>显示所有应用程序的日志：<code>pm2 logs</code></li>
</ul>
<h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><p>命令如下，表示开启三个进程。如果<code>-i 0</code>，则会根据机器当前核数自动开启尽可能多的进程。</p>
<p><code>pm2 start app.js -i 3</code> # 开启三个进程<br><code>pm2 start app.js -i max</code># 根据机器 CPU 核数，开启对应数目的进程</p>
<h2 id="开机自动启动"><a href="#开机自动启动" class="headerlink" title="开机自动启动"></a>开机自动启动</h2><p>可以通过<code>pm2 startup</code>来实现开机自启动。细节可参考。大致流程如下</p>
<p>通过<code>pm2 save</code>保存当前进程状态。</p>
<p>通过<code>pm2 startup [platform]</code>生成开机自启动的命令。（记得查看控制台输出）</p>
<p>将步骤 2 生成的命令，粘贴到控制台进行，搞定。</p>
<h2 id="监控-CPU-内存"><a href="#监控-CPU-内存" class="headerlink" title="监控 CPU/内存"></a>监控 CPU/内存</h2><p>运行如下命令，查看当前通过 pm2 运行的进程的状态。即可监控 CPU 和内存的使用情况，同时应用的报错信息也会打印在 Global Logs 窗口中，如下：</p>
<p><code>pm2 monit</code></p>
<h2 id="内存使用超过上限自动重启"><a href="#内存使用超过上限自动重启" class="headerlink" title="内存使用超过上限自动重启"></a>内存使用超过上限自动重启</h2><p>如果想要你的应用，在超过使用内存上限后自动重启，那么可以加上–max-memory-restart 参数。（有对应的配置项）</p>
<p><code>pm2 start big-array.js --max-memory-restart 20M</code></p>
<h2 id="pm2-编程接口"><a href="#pm2-编程接口" class="headerlink" title="pm2 编程接口"></a>pm2 编程接口</h2><p>如果想把 pm2 的进程监控，跟其他自动化流程整合起来，pm2 的编程接口就很有用了。细节可参考官方文档：<br><code>http://pm2.keymetrics.io/docs/usage/pm2-api/</code></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.baidu.com/2022/12/12/12-34-21/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="KK">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KK">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/12/12/12-34-21/" class="post-title-link" itemprop="url">Java</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-12-12 12:34:21" itemprop="dateCreated datePublished" datetime="2022-12-12T12:34:21+08:00">2022-12-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-05-16 23:50:36" itemprop="dateModified" datetime="2023-05-16T23:50:36+08:00">2023-05-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1><h2 id="编写-Java-程序时，应注意以下几点"><a href="#编写-Java-程序时，应注意以下几点" class="headerlink" title="编写 Java 程序时，应注意以下几点"></a>编写 Java 程序时，应注意以下几点</h2><ul>
<li>大小写敏感：Java 是大小写敏感的，这就意味着标识符 Hello 与 hello 是不同的。</li>
<li>类名：对于所有的类来说，类名的首字母应该大写。如果类名由若干单词组成，那么每个单词的首字母应该大写，例如 MyFirstJavaClass 。</li>
<li>方法名：所有的方法名都应该以小写字母开头。如果方法名含有若干单词，则后面的每个单词首字母大写。</li>
<li>源文件名：源文件名必须和类名相同。当保存文件的时候，你应该使用类名作为文件名保存（切记 Java 是大小写敏感的），文件名的后缀为 .java。（如果文件名和类名不相同则会导致编译错误）。</li>
<li>主方法入口：所有的 Java 程序由 public static void main(String[] args) 方法开始执行。</li>
</ul>
<h2 id="Java-标识符"><a href="#Java-标识符" class="headerlink" title="Java 标识符"></a>Java 标识符</h2><p>Java 所有的组成部分都需要名字。类名、变量名以及方法名都被称为标识符。</p>
<p>关于 Java 标识符，有以下几点需要注意：</p>
<ul>
<li>所有的标识符都应该以字母（A-Z 或者 a-z）,美元符（$）、或者下划线（_）开始</li>
<li>首字符之后可以是字母（A-Z 或者 a-z）,美元符（$）、下划线（_）或数字的任何字符组合</li>
<li>关键字不能用作标识符</li>
<li>标识符是大小写敏感的</li>
<li>合法标识符举例：age、$salary、_value、__1_value</li>
<li>非法标识符举例：123abc、-salary</li>
</ul>
<h2 id="Java-修饰符"><a href="#Java-修饰符" class="headerlink" title="Java 修饰符"></a>Java 修饰符</h2><p>像其他语言一样，Java 可以使用修饰符来修饰类中方法和属性。主要有两类修饰符：</p>
<ul>
<li>访问控制修饰符 : default, public , protected, private</li>
<li>非访问控制修饰符 : final, abstract, static, synchronized</li>
</ul>
<h2 id="Java-变量"><a href="#Java-变量" class="headerlink" title="Java 变量"></a>Java 变量</h2><p>Java 中主要有如下几种类型的变量</p>
<ul>
<li>局部变量</li>
<li>类变量（静态变量）</li>
<li>成员变量（非静态变量）</li>
</ul>
<h2 id="Java-关键字"><a href="#Java-关键字" class="headerlink" title="Java 关键字"></a>Java 关键字</h2><p>下面列出了 Java 关键字。这些保留字不能用于常量、变量、和任何标识符的名称。</p>
<ul>
<li>访问控制</li>
</ul>
<table>
<thead>
<tr>
<th align="center">关键字</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">private</td>
<td align="center">私有的</td>
</tr>
<tr>
<td align="center">protected</td>
<td align="center">受保护的</td>
</tr>
<tr>
<td align="center">public</td>
<td align="center">公共的</td>
</tr>
<tr>
<td align="center">default</td>
<td align="center">默认</td>
</tr>
</tbody></table>
<ul>
<li>类、方法和变量修饰符</li>
</ul>
<table>
<thead>
<tr>
<th align="center">关键字</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">abstract</td>
<td align="center">声明抽象</td>
</tr>
<tr>
<td align="center">class</td>
<td align="center">类</td>
</tr>
<tr>
<td align="center">extends</td>
<td align="center">扩充,继承</td>
</tr>
<tr>
<td align="center">final</td>
<td align="center">最终值,不可改变的</td>
</tr>
<tr>
<td align="center">implements</td>
<td align="center">实现（接口）</td>
</tr>
<tr>
<td align="center">interface</td>
<td align="center">接口</td>
</tr>
<tr>
<td align="center">native</td>
<td align="center">本地，原生方法（非 Java 实现）</td>
</tr>
<tr>
<td align="center">new</td>
<td align="center">新,创建</td>
</tr>
<tr>
<td align="center">static</td>
<td align="center">静态</td>
</tr>
<tr>
<td align="center">strictfp</td>
<td align="center">严格,精准</td>
</tr>
<tr>
<td align="center">synchronized</td>
<td align="center">线程,同步</td>
</tr>
<tr>
<td align="center">transient</td>
<td align="center">短暂</td>
</tr>
<tr>
<td align="center">volatile</td>
<td align="center">易失</td>
</tr>
</tbody></table>
<ul>
<li><p>程序控制语句</p>
<table>
<thead>
<tr>
<th align="center">关键字</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">break</td>
<td align="center">跳出循环</td>
</tr>
<tr>
<td align="center">case</td>
<td align="center">定义一个值以供 switch 选择</td>
</tr>
<tr>
<td align="center">continue</td>
<td align="center">继续</td>
</tr>
<tr>
<td align="center">do</td>
<td align="center">运行</td>
</tr>
<tr>
<td align="center">else</td>
<td align="center">否则</td>
</tr>
<tr>
<td align="center">for</td>
<td align="center">循环</td>
</tr>
<tr>
<td align="center">if</td>
<td align="center">如果</td>
</tr>
<tr>
<td align="center">instanceof</td>
<td align="center">实例</td>
</tr>
<tr>
<td align="center">return</td>
<td align="center">返回</td>
</tr>
<tr>
<td align="center">switch</td>
<td align="center">根据值选择执行</td>
</tr>
<tr>
<td align="center">while</td>
<td align="center">循环</td>
</tr>
</tbody></table>
</li>
<li><p>错误处理</p>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">关键字</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">assert</td>
<td align="center">断言表达式是否为真</td>
</tr>
<tr>
<td align="center">catch</td>
<td align="center">捕捉异常</td>
</tr>
<tr>
<td align="center">finally</td>
<td align="center">有没有异常都执行</td>
</tr>
<tr>
<td align="center">throw</td>
<td align="center">抛出一个异常对象</td>
</tr>
<tr>
<td align="center">throws</td>
<td align="center">声明一个异常可能被抛出</td>
</tr>
<tr>
<td align="center">try</td>
<td align="center">捕获异常</td>
</tr>
</tbody></table>
<ul>
<li><p>包相关</p>
<table>
<thead>
<tr>
<th align="center">关键字</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">import</td>
<td align="center">引入</td>
</tr>
<tr>
<td align="center">package</td>
<td align="center">包</td>
</tr>
</tbody></table>
</li>
<li><p>基本类型</p>
<table>
<thead>
<tr>
<th align="center">关键字</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">boolean</td>
<td align="center">布尔型</td>
</tr>
<tr>
<td align="center">byte</td>
<td align="center">字节型</td>
</tr>
<tr>
<td align="center">char</td>
<td align="center">字符型</td>
</tr>
<tr>
<td align="center">double</td>
<td align="center">双精度浮点</td>
</tr>
<tr>
<td align="center">float</td>
<td align="center">单精度浮点</td>
</tr>
<tr>
<td align="center">int</td>
<td align="center">整型</td>
</tr>
<tr>
<td align="center">long</td>
<td align="center">长整型</td>
</tr>
<tr>
<td align="center">short</td>
<td align="center">短整型</td>
</tr>
</tbody></table>
</li>
<li><p>变量引用</p>
<table>
<thead>
<tr>
<th align="center">关键字</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">super</td>
<td align="center">父类,超类</td>
</tr>
<tr>
<td align="center">this</td>
<td align="center">本类</td>
</tr>
<tr>
<td align="center">void</td>
<td align="center">无返回值</td>
</tr>
</tbody></table>
</li>
<li><p>保留关键字</p>
<table>
<thead>
<tr>
<th align="center">关键字</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">goto</td>
<td align="center">是关键字，但不能使用</td>
</tr>
<tr>
<td align="center">const</td>
<td align="center">是关键字，但不能使用</td>
</tr>
</tbody></table>
</li>
</ul>
<p>注意：Java 的 null 不是关键字，类似于 true 和 false，它是一个字面常量，不允许作为标识符使用。</p>
<h2 id="Java-对象和类"><a href="#Java-对象和类" class="headerlink" title="Java 对象和类"></a>Java 对象和类</h2><ul>
<li>对象：对象是类的一个实例（对象不是找个女朋友），有状态和行为。例如，一条狗是一个对象，它的状态有：颜色、名字、品种；行为有：摇尾巴、叫、吃等。</li>
<li>类：类是一个模板，它描述一类对象的行为和状态。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class Dog &#123;</span><br><span class="line">    String breed;</span><br><span class="line">    int size;</span><br><span class="line">    String colour;</span><br><span class="line">    int age;</span><br><span class="line"> </span><br><span class="line">    void eat() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    void run() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    void sleep()&#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    void name()&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个类可以包含以下类型变量：</p>
<ul>
<li>局部变量：在方法、构造方法或者语句块中定义的变量被称为局部变量。变量声明和初始化都是在方法中，方法结束后，变量就会自动销毁。</li>
<li>成员变量：成员变量是定义在类中，方法体之外的变量。这种变量在创建对象的时候实例化。成员变量可以被类中方法、构造方法和特定类的语句块访问。</li>
<li>类变量：类变量也声明在类中，方法体之外，但必须声明为 static 类型。<br>一个类可以拥有多个方法</li>
</ul>
<p>构造方法<br>每个类都有构造方法。如果没有显式地为类定义构造方法，Java 编译器将会为该类提供一个默认构造方法。</p>
<p>在创建一个对象的时候，至少要调用一个构造方法。构造方法的名称必须与类同名，一个类可以有多个构造方法。</p>
<p>下面是一个构造方法示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Puppy&#123;</span><br><span class="line">    public Puppy()&#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public Puppy(String name)&#123;</span><br><span class="line">        // 这个构造器仅有一个参数：name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建对象<br>对象是根据类创建的。在Java中，使用关键字 new 来创建一个新的对象。创建对象需要以下三步：</p>
<p>声明：声明一个对象，包括对象名称和对象类型。<br>实例化：使用关键字 new 来创建一个对象。<br>初始化：使用 new 创建对象时，会调用构造方法初始化对象。<br>下面是一个创建对象的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Puppy&#123;</span><br><span class="line">   public Puppy(String name)&#123;</span><br><span class="line">      //这个构造器仅有一个参数：name</span><br><span class="line">      System.out.println(&quot;小狗的名字是 : &quot; + name ); </span><br><span class="line">   &#125;</span><br><span class="line">   public static void main(String[] args)&#123;</span><br><span class="line">      // 下面的语句将创建一个Puppy对象</span><br><span class="line">      Puppy myPuppy = new Puppy( &quot;tommy&quot; );</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.baidu.com/2022/12/09/20-00-00/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="KK">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KK">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/12/09/20-00-00/" class="post-title-link" itemprop="url">react</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-12-09 20:00:00" itemprop="dateCreated datePublished" datetime="2022-12-09T20:00:00+08:00">2022-12-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-05-16 23:50:36" itemprop="dateModified" datetime="2023-05-16T23:50:36+08:00">2023-05-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="React"><a href="#React" class="headerlink" title="React"></a>React</h1><h2 id="浏览器中编写"><a href="#浏览器中编写" class="headerlink" title="浏览器中编写"></a>浏览器中编写</h2><ul>
<li>准备容器</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;test&quot;</span>&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>引入库</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--react核心库--&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;react.development.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;!--react-dom，用于支持react操纵dom--&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;react-dom.development.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;!--babel，用于将jsx转化为js--&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;babel.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>JSX</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;text/babel&gt;/*此处要写babel*/</span></span><br><span class="line"><span class="string">//创建虚拟dom</span></span><br><span class="line"><span class="string">const Vdom=(&lt;h1&gt;hello&lt;/h1&gt;)/*不用引号*/</span></span><br><span class="line"><span class="string">//渲染虚拟DOM到页面</span></span><br><span class="line"><span class="string">ReactDOM.render(Vdom,document.getElementById(&#x27;test&#x27;));</span></span><br><span class="line"><span class="string">&lt;/script&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>js<blockquote>
<p>jsx 最终会翻译成 js 写法</p>
</blockquote>
</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line"><span class="comment">//创建虚拟dom</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Vdom</span>=<span class="title class_">React</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;h1&#x27;</span>,&#123;<span class="attr">id</span>:<span class="string">&#x27;title&#x27;</span>&#125;,<span class="title class_">React</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;span&#x27;</span>,&#123;&#125;,<span class="string">&#x27;hello&#x27;</span>))</span><br><span class="line"><span class="comment">//渲染虚拟DOM到页面</span></span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(<span class="title class_">Vdom</span>,<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;test&#x27;</span>));</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>虚拟 DOM 本质是一个对象，虚拟 dom 比较轻量，真实 DOM 比较完整，虚拟 DOM 是 react 内部用，因此无需真实 DOM 那么多的属性。最终虚拟 DOM 会被 react 转化为真实 DOM 呈现在页面上。</p>
</blockquote>
<h2 id="JSX"><a href="#JSX" class="headerlink" title="JSX"></a>JSX</h2><blockquote>
<p>javascript XML,react 定义的类似与 XML 的 js 扩展语法，脚手架通过@babel/plugin-transform-react-jsx包解析成React.createElemnt(‘h1’,{className:’test’},’xx’)函数</p>
</blockquote>
<p>xml：早期用于存储和传输数据的格式</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">student</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>XIAOMI<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">age</span>&gt;</span>19<span class="tag">&lt;/<span class="name">age</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">student</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="jsx-语法规则"><a href="#jsx-语法规则" class="headerlink" title="jsx 语法规则"></a>jsx 语法规则</h3><ul>
<li>定义虚拟 dom，不要写引号</li>
<li>标签中混入 js 表达式要用｛｝，js 表达式会产生一个值(返回值)，可以放在任何需要值的地方，如<code>a</code>、<code>a+b</code>、<code>demo(1)</code>、<code>arr.map()</code>、<code>function test()&#123;&#125;</code>。js 语句：<code>if()&#123;&#125;</code>,<code>for()&#123;&#125;</code>,<code>switch()&#123;&#125;</code></li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Vdom</span> = <span class="language-xml"><span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&#123;a&#125;</span>&gt;</span>&#123;a.toString()&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>样式的类型指定不要用 class，要用 className</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Vdom</span> = <span class="language-xml"><span class="tag">&lt;<span class="name">span</span> <span class="attr">className</span>=<span class="string">&quot;test&quot;</span>&gt;</span>xxx<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>内联样式<br>要用<code>style=&#123;&#123;fontSize:"20px"&#125;&#125;</code>的写法</p>
</li>
<li><p>虚拟 dom 只有一个根标签</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const Vdom=(</span><br><span class="line">&lt;div&gt;</span><br><span class="line">&lt;span className=&quot;test&quot; &gt;xxx&lt;/span&gt;</span><br><span class="line">&lt;span className=&quot;test&quot; &gt;xxx&lt;/span&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<ul>
<li>标签首字符为小写则直接转为 html 中同名元素，若为大写则去渲染对应组件</li>
</ul>
<h3 id="列表渲染"><a href="#列表渲染" class="headerlink" title="列表渲染"></a>列表渲染</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> (</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  &#123;list.map(item=&gt;<span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;item.id&#125;</span>&gt;</span>item.name<span class="tag">&lt;/<span class="name">li</span>&gt;</span>)&#125;</span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h3><p>三元表达式，逻辑&amp;&amp;||运算，函数</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isTrue=<span class="literal">false</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">genSpan</span>=(<span class="params">i</span>)=&gt;&#123;</span><br><span class="line">  <span class="keyword">if</span>(i)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>x<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">b</span>&gt;</span>x<span class="tag">&lt;/<span class="name">b</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  &#123;isTrue&amp;&amp;<span class="tag">&lt;<span class="name">span</span>&gt;</span>xx<span class="tag">&lt;/<span class="name">span</span>&gt;</span>&#125;</span></span><br><span class="line"><span class="language-xml">  &#123;isTrue?<span class="tag">&lt;<span class="name">span</span>&gt;</span>xx<span class="tag">&lt;/<span class="name">span</span>&gt;</span>:<span class="tag">&lt;<span class="name">b</span>&gt;</span>xx<span class="tag">&lt;/<span class="name">b</span>&gt;</span>&#125;</span></span><br><span class="line"><span class="language-xml">  &#123;genSpan(isTrue)&#125;</span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="样式控制"><a href="#样式控制" class="headerlink" title="样式控制"></a>样式控制</h2><ul>
<li>内联</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> style=&#123;<span class="attr">color</span>:<span class="string">&#x27;red&#x27;</span>&#125;</span><br><span class="line"><span class="keyword">return</span> </span><br><span class="line"><span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;&#123;color:</span>&#x27;<span class="attr">red</span>&#x27;&#125;&#125;&gt;</span>xx<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;style&#125;</span>&gt;</span>xx<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/&gt;</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>类名<br>不能用对象和数组，只能是字符串</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> </span><br><span class="line"><span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#x27;test&#x27;</span>&gt;</span>xx<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;isTrue?</span>&#x27;<span class="attr">test</span>&#x27;<span class="attr">:</span>&#x27;&#x27;&#125;&gt;</span>xx<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/&gt;</span></span></span><br></pre></td></tr></table></figure>

<h2 id="组件和模块"><a href="#组件和模块" class="headerlink" title="组件和模块"></a>组件和模块</h2><p>模块：提供特定功能的 js 程序<br>组件：实现局部功能效果的代码和资源集合（html、js、css、img 等）</p>
<h3 id="函数式组件"><a href="#函数式组件" class="headerlink" title="函数式组件"></a>函数式组件</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Demo</span>(<span class="params"></span>)&#123;  <span class="comment">//组件必须首字母大写</span></span><br><span class="line"><span class="comment">//this 为undefind,经过babel编译后开启严格模式，this便指向undefind，不开启严格模式则是window</span></span><br><span class="line"><span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>test<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="comment">//必须有返回值，若没有内容返回null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">Demo</span>/&gt;</span></span>,<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;test&#x27;</span>))</span><br><span class="line"><span class="comment">//react解析组件标签,找到Demo组件，发现此组件是函数定义的，便调用该函数，将虚拟dom渲染成真实dom</span></span><br></pre></td></tr></table></figure>

<h3 id="类式组件"><a href="#类式组件" class="headerlink" title="类式组件"></a>类式组件</h3><h4 id="简单组件"><a href="#简单组件" class="headerlink" title="简单组件"></a>简单组件</h4><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在Demo的原型对象上</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>)&#123;<span class="comment">//必须提供render,极其返回值</span></span><br><span class="line">      <span class="comment">//this指向Demo的实例对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>test<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//react解析组件标签,找到Demo组件，发现此组件是类定义的，便new 出该类实例，通过该实例调用原型对象上的render方法。将虚拟dom渲染成真实dom</span></span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">Demo</span>/&gt;</span></span>,<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;test&#x27;</span>))</span><br></pre></td></tr></table></figure>

<h4 id="复杂组件"><a href="#复杂组件" class="headerlink" title="复杂组件"></a>复杂组件</h4><h5 id="state"><a href="#state" class="headerlink" title="state"></a>state</h5><blockquote>
<p>state 为组件的重要属性，值是对象，通过更新组件的 state 来更新对应的页面显示（重新渲染组件）</p>
</blockquote>
<h6 id="传统写法"><a href="#传统写法" class="headerlink" title="传统写法"></a>传统写法</h6><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Demo</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">prop</span>)&#123;</span><br><span class="line">    <span class="variable language_">super</span>(prop)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span>=&#123;</span><br><span class="line">      <span class="attr">a</span>:<span class="number">1</span>,</span><br><span class="line">      <span class="attr">b</span>:<span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="title function_">changValue</span>(<span class="params"></span>)&#123;</span><br><span class="line"> <span class="comment">//类中的方法默认开启局部严格模式</span></span><br><span class="line"> <span class="comment">//所以this为undefind</span></span><br><span class="line"> <span class="comment">//只有通过Demo实例调用此实例，this才为Demo的实例</span></span><br><span class="line"> <span class="comment">//changeValue作为onClick的回调，不是实例调用</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">onClick</span>=<span class="string">&#123;test&#125;</span>&gt;</span>test&#123;this.state.a&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">onClick</span>=<span class="string">&#123;this.changeValue&#125;</span>&gt;</span>test&#123;this.state.b&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">Demo</span>/&gt;</span></span>,<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;test&#x27;</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>解决 this 指向</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">prop</span>)&#123;</span><br><span class="line">    <span class="variable language_">super</span>(prop)<span class="comment">//构造器是否接受props，是否传给super取决于是否希望在构造器中通过this访问props</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span>=&#123;</span><br><span class="line">      <span class="attr">a</span>:<span class="number">1</span>,</span><br><span class="line">      <span class="attr">b</span>:<span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//改变this指向</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">changValue</span>=<span class="variable language_">this</span>.<span class="property">changValue</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">changValue</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">//state不能直接更改</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">a</span>=<span class="number">1</span></span><br><span class="line">    <span class="comment">//必须通过api</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;<span class="attr">a</span>:<span class="number">2</span>&#125;)<span class="comment">//更新为合并，不是替换</span></span><br><span class="line">   &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">onClick</span>=<span class="string">&#123;this.changeValue&#125;</span>&gt;</span>test&#123;this.state.b&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">Demo</span>/&gt;</span></span>,<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;test&#x27;</span>))</span><br></pre></td></tr></table></figure>

<h6 id="简写"><a href="#简写" class="headerlink" title="简写"></a>简写</h6><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Demo</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">  <span class="comment">//名称固定，就叫state</span></span><br><span class="line">  state=&#123;<span class="comment">//等于号，代表给该类的实例追加属性</span></span><br><span class="line">    <span class="attr">a</span>:<span class="number">1</span>,</span><br><span class="line">    <span class="attr">b</span>:<span class="number">2</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//必须用箭头函数,不需要通过constructor修改this指向</span></span><br><span class="line">  changValue=<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;<span class="attr">a</span>:<span class="number">2</span>&#125;)<span class="comment">//更新为合并，不是替换</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">onClick</span>=<span class="string">&#123;this.changeValue&#125;</span>&gt;</span>test&#123;this.state.b&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">Demo</span>/&gt;</span></span>,<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;test&#x27;</span>))</span><br></pre></td></tr></table></figure>

<h5 id="状态不可变"><a href="#状态不可变" class="headerlink" title="状态不可变"></a>状态不可变</h5><p>不要直接修改state状态的值，而是基于当前状态创建新的状态值</p>
<ul>
<li>错误修改</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">state=&#123;<span class="attr">count</span>:<span class="number">0</span>,<span class="attr">list</span>:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],<span class="attr">person</span>:&#123;<span class="attr">name</span>:<span class="string">&#x27;xx&#x27;</span>,<span class="attr">age</span>:<span class="number">18</span>&#125;&#125;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">count</span>++</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">count</span>+=<span class="number">1</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">count</span>=<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">list</span>.<span class="title function_">push</span>(<span class="number">1</span>)</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">list</span>.<span class="title function_">splice</span>(<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">person</span>.<span class="property">name</span>=<span class="string">&#x27;aaa&#x27;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>正确修改</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">  <span class="attr">count</span>:<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">count</span>+<span class="number">1</span>,</span><br><span class="line">  <span class="comment">//增加</span></span><br><span class="line">  <span class="attr">list</span>:[...<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">list</span>,<span class="number">4</span>]</span><br><span class="line">  <span class="comment">//删除</span></span><br><span class="line">  <span class="attr">list</span>:<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">list</span>.<span class="title function_">filter</span>(<span class="function"><span class="params">item</span>=&gt;</span>item!==<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">  <span class="attr">person</span>:&#123;</span><br><span class="line">    ...<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">person</span>,</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;aaa&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h5 id="props"><a href="#props" class="headerlink" title="props"></a>props</h5><blockquote>
<p>组件的所有属性都保存在 props 中，props 是只读的，不能修改。可以传递任何数据包括函数，jsx<br>类式组件通过this.props获取props对象<br>函数式组件通过参数获取props对象<br>可使用ts来配置</p>
</blockquote>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Demo</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line"><span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">h1</span> &gt;</span>test&#123;this.props.b&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">Demo</span> <span class="attr">a</span>=<span class="string">&#123;1&#125;</span> <span class="attr">b</span>=<span class="string">&#x27;ss&#x27;</span>/&gt;</span></span>,<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;test1&#x27;</span>))<span class="comment">//数据类型要用｛｝</span></span><br><span class="line"><span class="keyword">const</span> obj=&#123;<span class="attr">a</span>:<span class="number">1</span>,<span class="attr">b</span>:<span class="number">2</span>&#125;</span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">Demo</span> &#123;<span class="attr">...obj</span>&#125;/&gt;</span></span>,<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;test2&#x27;</span>))<span class="comment">//批量传属性</span></span><br></pre></td></tr></table></figure>

<ul>
<li>props 规则限制</li>
</ul>
<blockquote>
<p>常见规则：<br>必传：isRequired<br>基本类型：boolean , number,…<br>节点：element<br>指定对象：shape({})</p>
</blockquote>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//react16.x以上需引入prop-types.js</span></span><br><span class="line"><span class="comment">//导入prop-type包</span></span><br><span class="line"><span class="comment">//组件名.propTypes=&#123;&#125;给组件添加规则校验</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">PropTypes</span> <span class="keyword">from</span> <span class="string">&#x27;prop-types&#x27;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line"><span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">h1</span> &gt;</span>test&#123;this.props.b&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//限制类型</span></span><br><span class="line"><span class="title class_">Demo</span>.<span class="property">propTypes</span>=&#123;</span><br><span class="line"><span class="attr">a</span>:<span class="title class_">PropTypes</span>.<span class="property">number</span>.<span class="property">isRequied</span></span><br><span class="line"><span class="attr">test</span>:<span class="title class_">PropTypes</span>.<span class="property">func</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//默认值</span></span><br><span class="line"><span class="title class_">Demo</span>.<span class="property">defaultProps</span>=&#123;</span><br><span class="line"><span class="attr">b</span>:<span class="string">&#x27;xx&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">Demo</span> <span class="attr">a</span>=<span class="string">&#123;1&#125;</span> <span class="attr">b</span>=<span class="string">&#x27;ss&#x27;</span> <span class="attr">handle</span>=<span class="string">&quot;test&quot;</span>/&gt;</span></span>,<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;test1&#x27;</span>))<span class="comment">//数据类型要用｛｝</span></span><br><span class="line"><span class="keyword">const</span> obj=&#123;<span class="attr">a</span>:<span class="number">1</span>,<span class="attr">b</span>:<span class="number">2</span>&#125;</span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">Demo</span> &#123;<span class="attr">...obj</span>&#125;/&gt;</span></span>,<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;test2&#x27;</span>))<span class="comment">//批量传属性</span></span><br></pre></td></tr></table></figure>

<ul>
<li>简写</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">PropTypes</span> <span class="keyword">from</span> <span class="string">&#x27;prop-types&#x27;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line"><span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">h1</span> &gt;</span>test&#123;this.props.b&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> propTypes=&#123; <span class="comment">//加上static代表给类本身添加属性</span></span><br><span class="line"><span class="comment">//react16.x以上需引入prop-types.js</span></span><br><span class="line"><span class="attr">a</span>:<span class="title class_">PropTypes</span>.<span class="property">number</span>.<span class="property">isRequied</span></span><br><span class="line"><span class="attr">test</span>:<span class="title class_">PropTypes</span>.<span class="property">func</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> defaultProps=&#123;</span><br><span class="line"><span class="attr">b</span>:<span class="string">&#x27;xx&#x27;</span></span><br><span class="line">&#125;&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">Demo</span> <span class="attr">a</span>=<span class="string">&#123;1&#125;</span> <span class="attr">b</span>=<span class="string">&#x27;ss&#x27;</span> <span class="attr">handle</span>=<span class="string">&quot;test&quot;</span>/&gt;</span></span>,<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;test1&#x27;</span>))<span class="comment">//数据类型要用｛｝</span></span><br><span class="line"><span class="keyword">const</span> obj=&#123;<span class="attr">a</span>:<span class="number">1</span>,<span class="attr">b</span>:<span class="number">2</span>&#125;</span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">Demo</span> &#123;<span class="attr">...obj</span>&#125;/&gt;</span></span>,<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;test2&#x27;</span>))<span class="comment">//批量传属性</span></span><br></pre></td></tr></table></figure>

<ul>
<li>函数式组件使用 props</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> propTypes <span class="keyword">from</span> <span class="string">&#x27;prop-types&#x27;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Demo</span>(<span class="params">props</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">h1</span> &gt;</span>test&#123;props.b&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"> <span class="title class_">Demo</span>.<span class="property">propTypes</span>=&#123;</span><br><span class="line"><span class="comment">//react16.x以上需引入prop-types.js</span></span><br><span class="line"><span class="attr">a</span>:<span class="title class_">PropTypes</span>.<span class="property">number</span>.<span class="property">isRequied</span></span><br><span class="line"><span class="attr">test</span>:<span class="title class_">PropTypes</span>.<span class="property">func</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Demo</span>.<span class="property">defaultProps</span>=&#123;</span><br><span class="line"><span class="attr">b</span>:<span class="string">&#x27;xx&#x27;</span></span><br><span class="line">&#125;&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">Demo</span> <span class="attr">a</span>=<span class="string">&#123;1&#125;</span> <span class="attr">b</span>=<span class="string">&#x27;ss&#x27;</span> <span class="attr">handle</span>=<span class="string">&quot;test&quot;</span>/&gt;</span></span>,<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;test1&#x27;</span>))<span class="comment">//数据类型要用｛｝</span></span><br></pre></td></tr></table></figure>

<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> propTypes <span class="keyword">from</span> <span class="string">&#x27;prop-types&#x27;</span></span><br><span class="line"><span class="comment">//官方推荐</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Demo</span>(<span class="params">&#123;b:<span class="string">&#x27;xxx&#x27;</span>&#125;</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">h1</span> &gt;</span>test&#123;b&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"> <span class="title class_">Demo</span>.<span class="property">propTypes</span>=&#123;</span><br><span class="line"><span class="attr">a</span>:<span class="title class_">PropTypes</span>.<span class="property">number</span>.<span class="property">isRequied</span></span><br><span class="line"><span class="attr">test</span>:<span class="title class_">PropTypes</span>.<span class="property">func</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">Demo</span> <span class="attr">a</span>=<span class="string">&#123;1&#125;</span> <span class="attr">b</span>=<span class="string">&#x27;ss&#x27;</span> <span class="attr">handle</span>=<span class="string">&quot;test&quot;</span>/&gt;</span></span>,<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;test1&#x27;</span>))<span class="comment">//数据类型要用｛｝</span></span><br></pre></td></tr></table></figure>

<h5 id="refs"><a href="#refs" class="headerlink" title="refs"></a>refs</h5><blockquote>
<p>组件内的标签可使用 ref 属性标识自己类似 id=’test’</p>
</blockquote>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Demo</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line"><span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">ref</span>=<span class="string">&#x27;title1&#x27;</span> &gt;</span>官方不推荐String类型的ref写法，效率不高<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">ref</span>=<span class="string">&#123;(node)</span>=&gt;</span>&#123;this.title2=node&#125;&#125; &gt;ref的回调写法，内联写法在每次更新时会调用两次，第一次时为了清空旧的ref，所以为null，第二次才为DOM，可用类绑定函数替换<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">ref</span>=<span class="string">&#123;title3&#125;</span> &gt;</span>使用createRef<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">)</span><br><span class="line">&#125;</span><br><span class="line">title3=<span class="title function_">createRef</span>()<span class="comment">//调用后返回一个容器，用于存储ref标识的节点，只能存一个</span></span><br><span class="line">test=<span class="function">()=&gt;</span>&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">refs</span>.<span class="property">title1</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">title2</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">title3</span>.<span class="property">current</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="受控组件"><a href="#受控组件" class="headerlink" title="受控组件"></a>受控组件</h5><blockquote>
<p>input框的状态（value）被React组件状态（state）控制，就是可以被react状态控制的组件</p>
</blockquote>
<ul>
<li>在状态state中声明一个组件的状态数据</li>
<li>将状态数据设置为input标签元素的value属性的值</li>
<li>为input添加change时间</li>
<li>通过事件对象e获取文本框的值</li>
<li>调用setState方法，将文本框的值作为state状态的最新值</li>
</ul>
<h5 id="非受控组件"><a href="#非受控组件" class="headerlink" title="非受控组件"></a>非受控组件</h5><blockquote>
<p>就是手动操作dm的方式获取文本的值，文本框的状态不受react组件的state中的状态控制</p>
</blockquote>
<ul>
<li>导入createRef 函数</li>
<li>调用createRef函数，创建一个ref,存储到名为myref的实例属性中</li>
<li>为input添加ref属性</li>
<li>通过myref.current即可拿到input对应的dom元素</li>
</ul>
<h5 id="绑定事件"><a href="#绑定事件" class="headerlink" title="绑定事件"></a>绑定事件</h5><ol>
<li><p>通过 onXxx 属性指定事件处理函数（注意大小写）</p>
<ul>
<li>react 使用的自定义事件（原生小写-&gt;大写，原生大写-&gt;小写），而不是原生 DOM 事件</li>
<li>react 中的事件是通过事件委托方式处理的（委托给组件最外层的元素,事件冒泡）</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数式组件</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>)&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">onClick</span>=<span class="string">&#123;(event)</span>=&gt;</span>&#123;&#125;&#125;&gt;xx<span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">&#125;</span></span><br><span class="line"><span class="language-xml">//类式组件</span></span><br><span class="line"><span class="language-xml">class App extends React.Component&#123;</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">   /*避免this指向出现问题(undefined),使回调中的this指向当前组件实例对象*/</span></span><br><span class="line"><span class="language-xml">  handleClick=(event)=&gt;&#123;</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"> &#125;</span></span><br><span class="line"><span class="language-xml">   //this为undefined,需要在constructor中通过bind改变this指向</span></span><br><span class="line"><span class="language-xml">  handleClick2(event)&#123;</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"> &#125;</span></span><br><span class="line"><span class="language-xml"> </span></span><br><span class="line"><span class="language-xml"> render()&#123;</span></span><br><span class="line"><span class="language-xml">   //render函数中的 this已被react修正为当前组件实例对象</span></span><br><span class="line"><span class="language-xml">   return (</span></span><br><span class="line"><span class="language-xml">   <span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">   <span class="tag">&lt;<span class="name">div</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleClick&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">   &#123;/*不通过constuctor改变this指向，可用以下这种方法*/&#125;</span></span><br><span class="line"><span class="language-xml">   <span class="tag">&lt;<span class="name">div</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span>=&gt;</span>this.handleClick2()&#125;&gt;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">   <span class="tag">&lt;/&gt;</span>)</span></span><br><span class="line"><span class="language-xml"> &#125;</span></span><br><span class="line"><span class="language-xml">&#125;</span></span><br></pre></td></tr></table></figure></li>
<li><p>可通过 event.target 得到的发生事件的 DOM 元素对象</p>
</li>
<li><p>阻止默认行为event.preventDefault()</p>
</li>
</ol>
<h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><blockquote>
<p>类式组件才有生命周期,因为函数式组件不能实例化</p>
</blockquote>
<h5 id="旧-lt-16-4"><a href="#旧-lt-16-4" class="headerlink" title="旧(&lt;16.4)"></a>旧(&lt;16.4)</h5><ul>
<li>初始化阶段</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">constructor</span>(<span class="params"></span>)<span class="comment">//构造器</span></span><br><span class="line"><span class="title function_">componentWillMount</span>()<span class="comment">//组件将要挂载</span></span><br><span class="line"><span class="title function_">render</span>()</span><br><span class="line"><span class="title function_">componentDidMount</span>()<span class="comment">//组件挂载完毕</span></span><br></pre></td></tr></table></figure>

<ul>
<li>更新数据时</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">setState</span>()</span><br><span class="line"><span class="title function_">shouldComponentUpdate</span>()<span class="comment">//默认返回true，返回false时不执行更新</span></span><br><span class="line"><span class="title function_">componentWillUpdate</span>()<span class="comment">//组件将要更新</span></span><br><span class="line"><span class="title function_">render</span>()</span><br><span class="line"><span class="title function_">componentDidUpdate</span>()<span class="comment">//组件更新更新完毕</span></span><br></pre></td></tr></table></figure>

<ul>
<li>强制更新时</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">forceUpdate</span>()<span class="comment">//不想更改状态中的数据，更新页面</span></span><br><span class="line"><span class="title function_">componentWillUpdate</span>()<span class="comment">//组件将要更新</span></span><br><span class="line"><span class="title function_">render</span>()</span><br><span class="line"><span class="title function_">componentDidUpdate</span>()<span class="comment">//组件更新更新完毕</span></span><br></pre></td></tr></table></figure>

<ul>
<li>父组件渲染</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">componentWillReceiveProps</span>(props)<span class="comment">//第一次不调用，接受新的props才调用</span></span><br><span class="line"><span class="title function_">shouldComponentUpdate</span>()<span class="comment">//默认返回true，返回false时不执行更新</span></span><br><span class="line"><span class="title function_">componentWillUpdate</span>()<span class="comment">//组件将要更新</span></span><br><span class="line"><span class="title function_">render</span>()</span><br><span class="line"><span class="title function_">componentDidUpdate</span>()<span class="comment">//组件更新更新完毕</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>卸载组件</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//由React.unmountComponentAtNode()触发</span></span><br><span class="line"><span class="title function_">componentWillUnmount</span>()</span><br></pre></td></tr></table></figure>

<h5 id="新"><a href="#新" class="headerlink" title="新"></a>新</h5><blockquote>
<p>因为新版本的异步渲染，因此 componentWillUpdate，componentWillReceive，componentWillMount 即将废弃，所以要加上 UNSAFE_防止误解和滥用</p>
</blockquote>
<ul>
<li>初始化阶段</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">constructor</span>(<span class="params"></span>)<span class="comment">//构造器,初始化state,创建ref,bind解决this指向</span></span><br><span class="line"><span class="comment">//UNSAFE_componentWillMount()</span></span><br><span class="line"><span class="keyword">static</span> <span class="title function_">getDerivedStateFromProps</span>(<span class="params">props,state</span>)&#123;<span class="comment">//组件将要挂载，不能加到实例上，要加上static。</span></span><br><span class="line"><span class="comment">//必须返回状态对象，若包含state中的数据，将覆盖它。用于state的值任何时候取决于props</span></span><br><span class="line"><span class="keyword">return</span> &#123;<span class="attr">a</span>:<span class="number">1</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">render</span>()<span class="comment">//每次组件渲染都会触发，不要在里面调用setState()</span></span><br><span class="line"><span class="title function_">componentDidMount</span>()<span class="comment">//组件挂载完毕</span></span><br></pre></td></tr></table></figure>

<ul>
<li>更新数据时，调用 setState()、forceUpdate()或父组件新 Props</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="title function_">getDerivedStateFromProps</span>(props,state)<span class="comment">//组件将要挂载，不能加到实例上，要加上static。</span></span><br><span class="line"><span class="title function_">shouldComponentUpdate</span>()<span class="comment">//默认返回true，返回false时不执行更新</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">getSnapshotBeforeUpdate</span>(<span class="params">preProps,preState</span>)&#123;<span class="comment">//更新前,必须和componentDidupdate一起使用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//返回值会传入componentDidUpdate中</span></span><br><span class="line"><span class="keyword">return</span> <span class="string">&#x27;xxx&#x27;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">render</span>()</span><br><span class="line"><span class="title function_">componentDidUpdate</span>(preProps,preState,snapshotValue)<span class="comment">//之前的prop时和状态,不要在里面调用setState()</span></span><br></pre></td></tr></table></figure>

<ul>
<li>卸载组件</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//由React.unmountComponentAtNode()触发</span></span><br><span class="line"><span class="title function_">componentWillUnmount</span>()</span><br></pre></td></tr></table></figure>

<h4 id="react-中的-key-作用"><a href="#react-中的-key-作用" class="headerlink" title="react 中的 key 作用"></a>react 中的 key 作用</h4><p>key 是虚拟 Dom 对象的标识，当状态中的数据变化时，react 会根据新数据形成新的虚拟 DOM，<br>随后将新的虚拟 DOM 与旧的虚拟 DOM 进行 diff 比较。<br>若旧虚拟 dom 中到了与新虚拟 dom 中相同的 key：</p>
<ul>
<li>虚拟 dom 中内容没有变化，使用之前的真实 dom</li>
<li>虚拟 dom 中内容变化了，则生成新的真实 dom，随后替换掉页面中的真实 dom</li>
</ul>
<p>若旧虚拟 dom 未找到与新虚拟 dom 相同的 key，则创建新的真实 dom 渲染到页面中</p>
<p>用 index 做 key 引发的问题</p>
<ol>
<li>若对数据进行逆序添加，逆序删除等破坏顺序操作时，产生没必要的真实 dom 更新，虽然界面没有问题</li>
<li>若结构中包含输入类的 DOM，会产生错误 DOM 更新，界面会出现异常</li>
<li>若仅用于渲染列表展示，没有逆序添加，逆序删除等破坏顺序操作，则用 index 做 key 没有任何问题</li>
</ol>
<h4 id="脚手架"><a href="#脚手架" class="headerlink" title="脚手架"></a>脚手架</h4><p>安装：<code>npm i create-react-app -g</code></p>
<p>创建文件夹：<code>create-ract-app test</code></p>
<p>进入创建的文件夹：<code>npm start</code></p>
<ul>
<li>入口文件 index.js</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//核心库</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="comment">//渲染</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ReactDOM</span> <span class="keyword">from</span> <span class="string">&quot;react-dom&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&quot;./App&quot;</span>;</span><br><span class="line"><span class="comment">//react16.x</span></span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span>, <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;root&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//react 18.x</span></span><br><span class="line"><span class="comment">//const root=ReactDOM.createRoot(document.getElementById(&quot;root&quot;))</span></span><br><span class="line"><span class="comment">//root.render(</span></span><br><span class="line">  <span class="comment">//严格模式会影响useEffect的执行时机，为了检测额外的副作用，会让每一个useEffect执行两次</span></span><br><span class="line">  <span class="comment">// &lt;React.StrictMode&gt;</span></span><br><span class="line">  <span class="comment">// &lt;App/&gt;</span></span><br><span class="line">  <span class="comment">// &lt;/React.StrictMode&gt;</span></span><br><span class="line"><span class="comment">// )</span></span><br></pre></td></tr></table></figure>

<ul>
<li>App.js</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="title class_">Class</span> <span class="title class_">App</span> <span class="keyword">extends</span> <span class="title class_">React</span>.<span class="property">Component</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>xx<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span></span><br></pre></td></tr></table></figure>

<ul>
<li>样式模块化</li>
</ul>
<p>index.module.css</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.title</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hello form <span class="string">&#x27;./index.module.css&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> calss <span class="title class_">Test</span> <span class="keyword">extends</span> <span class="title class_">Compont</span>&#123;</span><br><span class="line"><span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;hello.title&#125;</span>&gt;</span>xx<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>代理</li>
</ul>
<p>setupProxy.js</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> proxy=<span class="built_in">require</span>(<span class="string">&#x27;http-proxy-middleware&#x27;</span>);</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>=<span class="keyword">function</span> (<span class="params">app</span>) &#123;</span><br><span class="line">app.<span class="title function_">use</span>(</span><br><span class="line">proxy.<span class="title function_">createProxyMiddleware</span>(<span class="string">&#x27;/apis&#x27;</span>,&#123;</span><br><span class="line"><span class="attr">target</span>:<span class="string">&#x27;http://xxx:xxx&#x27;</span>,</span><br><span class="line"><span class="attr">changeOrigin</span>:<span class="literal">true</span>,<span class="comment">//控制服务器收到的响应头中的Host字段值</span></span><br><span class="line"><span class="attr">pathRewrite</span>:&#123;<span class="string">&#x27;^/apis&#x27;</span>:<span class="string">&#x27;&#x27;</span>&#125;</span><br><span class="line">&#125;)，</span><br><span class="line">proxy.<span class="title function_">createProxyMiddleware</span>(<span class="string">&#x27;/api2&#x27;</span>,&#123;</span><br><span class="line"><span class="attr">target</span>:<span class="string">&#x27;http://xxx:xxx&#x27;</span>,</span><br><span class="line"><span class="attr">changeOrigin</span>:<span class="literal">true</span>,<span class="comment">//控制服务器收到的响应头中的Host字段值,true时为代理服务ip,false为当前ip，默认为false</span></span><br><span class="line"><span class="attr">pathRewrite</span>:&#123;<span class="string">&#x27;^/api2&#x27;</span>:<span class="string">&#x27;&#x27;</span>&#125;</span><br><span class="line">&#125;)，</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="组件间通信"><a href="#组件间通信" class="headerlink" title="组件间通信"></a>组件间通信</h4><ul>
<li><p>子-&gt;父<br>父给子组件间传入回调函数，子组件调用回调函数把数据传给父组件</p>
</li>
<li><p>消息订阅与发布<br>第三方库 pubsub.js</p>
</li>
</ul>
<h4 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h4><blockquote>
<p>依赖 H5 BOM 浏览器对象上的 history 或 hash 锚点，监听路由变化，匹配对应的组件<br>BrowserRouter 使用的 h5 的 histrory API,不兼容 IE9 以下版本<br>HashRouter 使用的 URL 的哈希值</p>
</blockquote>
<ul>
<li>react-router-dom</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//要统一由一个router管理，可包围在App外侧</span></span><br><span class="line">&lt;<span class="title class_">BrowserRouter</span>&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">&#x27;/test&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/test&quot;</span> <span class="attr">component</span>=<span class="string">&#123;Test&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">BrowserRouter</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">HashRouter</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">&#x27;/test&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/test&quot;</span> <span class="attr">component</span>=<span class="string">&#123;Test&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">HashRouter</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>路由组件<blockquote>
<p>接受的 props 默认有 history，location，match</p>
</blockquote>
</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Route</span> path=<span class="string">&quot;/test&quot;</span> component=&#123;<span class="title class_">Test</span>&#125;&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>一般组件<br>props 传什么有什么</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Test</span> /&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>NavLink<blockquote>
<p>可以通过 activeClassName 指定样式名,标签体内容是个特殊属性，通过 this.props.children 获取</p>
</blockquote>
</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">NavLink</span> activeClassName=<span class="string">&quot;active_color&quot;</span>&gt;test</span><br><span class="line">&lt;/<span class="title class_">NavLink</span>&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">NavLink</span> <span class="attr">activeClassName</span>=<span class="string">&quot;active_color&quot;</span> <span class="attr">children</span>=<span class="string">&#x27;test&#x27;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">NavLink</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>Switch<blockquote>
<p>路由默认会全部匹配完，加上 switch 可实现单一匹配，提高效率</p>
</blockquote>
</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Switch</span>&gt;</span><br><span class="line">&lt;Route path=&quot;/test&quot; component=&#123;Test&#125;&gt;</span><br><span class="line">&lt;Route path=&quot;/test&quot; component=&#123;Test&#125;&gt;</span><br><span class="line">//默认模糊匹配,exact严格匹配，开启后无法匹配二级路由</span><br><span class="line">&lt;Route exact path=&quot;/test&quot; component=&#123;Test&#125;&gt;</span><br><span class="line">&lt;/Switch&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>Redirect<blockquote>
<p>重定向，写在路由最下方，当路由都不匹配时，跳转到 redirect 指定的路由</p>
</blockquote>
</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Redirect</span> to=<span class="string">&quot;/test&quot;</span> &gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>二级路由</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Switch</span>&gt;</span><br><span class="line">&lt;Route path=&quot;/test&quot; component=&#123;Test&#125;&gt;</span><br><span class="line">&lt;Route path=&quot;/test/a&quot; component=&#123;Test&#125;&gt;</span><br><span class="line">&lt;Redirect to=&quot;/test&quot; &gt;</span><br><span class="line">&lt;/Switch&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>路由参数</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//params参数，this.props.match.params</span></span><br><span class="line">&lt;<span class="title class_">HashRouter</span>&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=`/<span class="attr">test</span>/$&#123;<span class="attr">123</span>&#125;/$&#123;<span class="attr">123</span>&#125;`&gt;</span><span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/test/:id/:count&quot;</span> <span class="attr">component</span>=<span class="string">&#123;Test&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">HashRouter</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//search参数(为urlencoded编码字符串，需借助querystring解析)，this.location.match.search</span></span><br><span class="line"><span class="keyword">import</span> qs <span class="keyword">from</span> <span class="string">&#x27;querystring&#x27;</span></span><br><span class="line">&lt;<span class="title class_">HashRouter</span>&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=`/<span class="attr">test</span>?<span class="attr">a</span>=<span class="string">$&#123;123&#125;&amp;b</span>=<span class="string">$&#123;123&#125;</span>`&gt;</span><span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/test&quot;</span> <span class="attr">component</span>=<span class="string">&#123;Test&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">//qs.parse(this.props.location.search)</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">HashRouter</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//state参数(不在地址栏显示，browser刷新页面不丢失，hashRouter刷新丢失)，this.props.location.state</span></span><br><span class="line">&lt;<span class="title class_">HashRouter</span>&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">&#123;&#123;pathname:</span>&#x27;/<span class="attr">test</span>&#x27;<span class="attr">state:</span>&#123;<span class="attr">a</span>=<span class="string">123,b</span>=<span class="string">123&#125;&#125;&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/test&quot;</span> <span class="attr">component</span>=<span class="string">&#123;Test&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">HashRouter</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>编程式路由</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">goto</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">history</span>.<span class="title function_">push</span>(<span class="string">&#x27;/test&#x27;</span>,&#123;</span><br><span class="line"><span class="attr">xx</span>:<span class="string">&#x27;xx&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">history</span>.<span class="title function_">replace</span>(<span class="string">&#x27;/test&#x27;</span>,&#123;</span><br><span class="line"><span class="attr">xx</span>:<span class="string">&#x27;xx&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>withRouter<blockquote>
<p>加工一般组件，让一般组件用上路由 api</p>
</blockquote>
</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; withRouter &#125; <span class="keyword">from</span> <span class="string">&quot;react-router-dom&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">withRouter</span>(<span class="title class_">Test</span>); <span class="comment">//返回的是全新的组件</span></span><br></pre></td></tr></table></figure>

<h4 id="React-Router-6"><a href="#React-Router-6" class="headerlink" title="React Router 6"></a>React Router 6</h4><blockquote>
<p>移除<code>&lt;Switch/&gt;</code> ，新增<code>&lt;Routers/&gt;</code><br>移除<code>&lt;Redirect/&gt;</code>，新增<code>&lt;Navigate/&gt;</code><br><code>component=&#123;About&#125;</code>变为 <code>element=&#123;&lt;About/&gt;&#125;</code><br>增加 hooks</p>
</blockquote>
<ul>
<li>Routers</li>
</ul>
<blockquote>
<p>提供路由出口，满足条件的路由组件会渲染到组件内部，相当与vue-router里的<router-view></router-view><br>必须用 Routers 包裹，不会匹配多个</p>
</blockquote>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;<span class="title class_">Routers</span>,<span class="title class_">Route</span>&#125; form <span class="string">&#x27;react-router-dom&#x27;</span></span><br><span class="line">&lt;<span class="title class_">Routers</span>&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/test&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">Test</span>/&gt;</span>&#125;&gt;</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/TEST&quot;</span> <span class="attr">caseSensitive</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">Test2</span>/&gt;</span>&#125;&gt;//区分大小写</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">Routers</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>Navigate<blockquote>
<p>重定向,只要被渲染，就会切换路由</p>
</blockquote>
</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;<span class="title class_">Routers</span>,<span class="title class_">Route</span>,<span class="title class_">Navigate</span>&#125; form <span class="string">&#x27;react-router-dom&#x27;</span></span><br><span class="line">&lt;<span class="title class_">Routers</span>&gt;</span><br><span class="line">&lt;Route path=&quot;/test&quot; element=&#123;&lt;Test/&gt;&#125;&gt;</span><br><span class="line">&lt;Route path=&quot;/&quot; element=&#123;&lt;Navigate to=&quot;/test&quot;  /&gt;&#125;&gt;</span><br><span class="line">&lt;Route path=&quot;/&quot; element=&#123;&lt;Navigate to=&quot;/test&quot; replace /&gt;&#125;&gt;</span><br><span class="line">&lt;/Routers&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>NavLink</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">NavLink</span> className=&#123;<span class="function">()=&gt;</span><span class="keyword">return</span> <span class="string">&#x27;activeColor&#x27;</span>&#125;&gt;&lt;/<span class="title class_">NavLink</span>&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>路由表</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;lazy&#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123;useRoutes,<span class="title class_">Navigate</span>&#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span></span><br><span class="line"><span class="comment">//生成路由</span></span><br><span class="line">cosnt <span class="title class_">About</span>=<span class="title function_">lazy</span>(<span class="function">()=&gt;</span><span class="keyword">import</span>(<span class="string">&#x27;../pages/About&#x27;</span>))</span><br><span class="line"><span class="keyword">const</span> element=<span class="title function_">useRoutes</span>([</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>:<span class="string">&#x27;/test&#x27;</span>,</span><br><span class="line">    <span class="attr">element</span>:<span class="language-xml"><span class="tag">&lt;<span class="name">Test</span>/&gt;</span></span></span><br><span class="line">    <span class="attr">children</span>:[</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">path</span>:<span class="string">&#x27;new&#x27;</span>,</span><br><span class="line">        <span class="attr">element</span>:<span class="language-xml"><span class="tag">&lt;<span class="name">New</span>/&gt;</span></span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>:<span class="string">&#x27;/about&#x27;</span>,</span><br><span class="line">    <span class="attr">element</span>:<span class="language-xml"><span class="tag">&lt;<span class="name">About</span>/&gt;</span></span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="attr">path</span>:<span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">      <span class="comment">//实现路由重定向</span></span><br><span class="line">      <span class="attr">element</span>:<span class="language-xml"><span class="tag">&lt;<span class="name">Navigate</span> <span class="attr">to</span>=<span class="string">&#x27;/main&#x27;</span>/&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">&#123;/*引用路由表*/&#125;</span></span><br><span class="line"><span class="language-xml">&#123;element&#125;</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">)&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Outlet</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">Routers</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">Router</span> <span class="attr">path</span>=<span class="string">&quot;/test&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">Test</span>/&gt;</span>&#125;&gt;</span></span><br><span class="line"><span class="language-xml">      &#123;/*二级路由嵌套*/&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Router</span> <span class="attr">path</span>=<span class="string">&quot;test1&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">Test1</span>/&gt;</span>&#125;&gt;<span class="tag">&lt;/<span class="name">Router</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Router</span> <span class="attr">path</span>=<span class="string">&quot;test2&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">Test2</span>/&gt;</span>&#125;&gt;<span class="tag">&lt;/<span class="name">Router</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">Router</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">Routers</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;<span class="title class_">Outlet</span>,<span class="title class_">NavLink</span>&#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Test</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="comment">// 若要显示子路由，需在父级路由组件中引入Outlet！！！</span></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">NavLink</span> <span class="attr">end</span> <span class="attr">to</span>=<span class="string">&quot;new&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">NavLink</span>&gt;</span>//end代表匹配子路由时，自己失去高亮</span></span><br><span class="line"><span class="language-xml">        &#123;/*指定路由组件呈现的位置*/&#125;</span></span><br><span class="line"><span class="language-xml">         <span class="tag">&lt;<span class="name">Outlet</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>路由参数</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//params参数，this.props.match.params</span></span><br><span class="line">&lt;<span class="title class_">Link</span> to=<span class="string">`/test/<span class="subst">$&#123;<span class="number">123</span>&#125;</span>/<span class="subst">$&#123;<span class="number">123</span>&#125;</span>`</span>&gt;&lt;/<span class="title class_">Link</span>&gt;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123;useParams,useMath&#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Demo</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="keyword">const</span> &#123;a,b&#125;=<span class="title function_">useParams</span>()</span><br><span class="line"><span class="keyword">const</span> &#123;a,b&#125;=<span class="title function_">useParams</span>(<span class="regexp">/test/</span>:a/:b&#125;)</span><br><span class="line"><span class="keyword">return</span> (&#123;a+b&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Link</span> to=<span class="string">`/test?a=<span class="subst">$&#123;<span class="number">123</span>&#125;</span>&amp;b=<span class="subst">$&#123;<span class="number">123</span>&#125;</span>`</span>&gt;&lt;/<span class="title class_">Link</span>&gt;</span><br><span class="line"><span class="keyword">import</span> &#123;useSearchParams,useLocation&#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Demo</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="keyword">const</span> [search,setSearch]=<span class="title function_">useSearchParams</span>()</span><br><span class="line"><span class="keyword">const</span> a=search.<span class="title function_">get</span>(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> <span class="title function_">setData</span>=(<span class="params"></span>)=&gt;&#123;<span class="title function_">setSearch</span>(<span class="number">1234</span>)&#125;<span class="comment">//更新a</span></span><br><span class="line"><span class="keyword">const</span> a1=<span class="title function_">useLocation</span>()</span><br><span class="line"><span class="keyword">return</span> (&#123;a&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Link</span> to=<span class="string">&#x27;/test&#x27;</span> state=&#123;&#123;a=<span class="number">123</span>,b=<span class="number">123</span>&#125;&#125;&gt;&lt;/<span class="title class_">Link</span>&gt;</span><br><span class="line"><span class="keyword">import</span> &#123;useLocation&#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Demo</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="keyword">const</span> obj=<span class="title function_">useLocation</span>()</span><br><span class="line"><span class="keyword">return</span> (&#123;obj.<span class="property">a</span>&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>编程式路由</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//导入useNavigate　函数</span></span><br><span class="line"><span class="keyword">import</span> &#123;useNavigate&#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span></span><br><span class="line"><span class="keyword">const</span> navigate=<span class="title function_">userNavigate</span>()</span><br><span class="line"><span class="title function_">goto</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="comment">//跳转</span></span><br><span class="line">  <span class="title function_">navigate</span>(<span class="string">&#x27;/test&#x27;</span>)</span><br><span class="line">  <span class="title function_">navigate</span>(<span class="string">&#x27;/test&#x27;</span>,&#123;</span><br><span class="line">    <span class="attr">replace</span>:<span class="literal">false</span>,</span><br><span class="line">    <span class="attr">state</span>:&#123;&#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="title function_">navigate</span>(<span class="number">1</span>)<span class="comment">//前进</span></span><br><span class="line">  <span class="title function_">navigate</span>(-<span class="number">1</span>)<span class="comment">//后退</span></span><br><span class="line"><span class="comment">//传参searchParams</span></span><br><span class="line">  <span class="title function_">navigate</span>(<span class="string">&#x27;/test?id=1&amp;name=xigua&#x27;</span>)</span><br><span class="line"><span class="comment">//params参数</span></span><br><span class="line"><span class="comment">//需配置路由/test/:id/:name</span></span><br><span class="line">  <span class="title function_">navigate</span>(<span class="string">&#x27;/test/1/xigua&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;useParams,useSearchParams&#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Test</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">const</span> [searchParams]=<span class="title function_">useSearchParams</span>()</span><br><span class="line">  <span class="keyword">const</span> id=searchParams.<span class="title function_">get</span>(<span class="string">&#x27;id&#x27;</span>)</span><br><span class="line">  <span class="keyword">const</span> &#123;name&#125;=searchParams.<span class="title function_">getAll</span>()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> [params]=<span class="title function_">useParams</span>()</span><br><span class="line">  <span class="keyword">const</span> id=params.<span class="property">id</span></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>通配符</li>
</ul>
<blockquote>
<p>不匹配时，显示的内容</p>
</blockquote>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;<span class="title class_">Routes</span>&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">Home</span>&gt;</span><span class="tag">&lt;/<span class="name">Home</span>&gt;</span>&#125;&gt;</span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;*&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">NotFount</span>&gt;</span><span class="tag">&lt;/<span class="name">NotFount</span>&gt;</span>&#125;&gt;</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">Routes</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<h4 id="集中式状态管理工具redux"><a href="#集中式状态管理工具redux" class="headerlink" title="集中式状态管理工具redux"></a>集中式状态管理工具redux</h4><blockquote>
<p>状态管理 js 库，集中式管理 react 应用中多个组件共享的状态</p>
</blockquote>
<h5 id="简单"><a href="#简单" class="headerlink" title="简单"></a>简单</h5><ul>
<li>store.js</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;createStore&#125;form <span class="string">&#x27;redux&#x27;</span></span><br><span class="line"><span class="keyword">import</span> countReducer <span class="keyword">from</span> <span class="string">&#x27;./countReducer&#x27;</span></span><br><span class="line"><span class="keyword">const</span> store=<span class="title function_">createStore</span>(countReducer)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store</span><br></pre></td></tr></table></figure>

<ul>
<li>countReducer.js</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个为count组件服务的reducer，reducer本质是一个函数</span></span><br><span class="line">第一次调用时是store自动触发的，传递的preState是undefin</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> (<span class="params">preState,action</span>)&#123;</span><br><span class="line"><span class="keyword">const</span> &#123;type,data&#125;=action</span><br><span class="line"><span class="keyword">return</span> preState</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>test.jsx</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&#x27;../store/store.js&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">componentDidMount</span>(<span class="params"></span>)&#123;</span><br><span class="line">store.<span class="title function_">subscribe</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line"><span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">increment</span>(<span class="params"></span>)&#123;</span><br><span class="line">store.<span class="title function_">dispatch</span>(&#123;<span class="attr">type</span>:<span class="string">&#x27;xx&quot;,data:123&#125;)</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">render()&#123;</span></span><br><span class="line"><span class="string">return （&lt;div&gt;&#123;&#123;store.getState()&#125;&#125;&lt;/div&gt;）</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<h5 id="完整"><a href="#完整" class="headerlink" title="完整"></a>完整</h5><ul>
<li>countAction.js</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个为count组件服务的action，</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">test</span>(<span class="params">data</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">type</span>: <span class="string">&quot;xxxx&quot;</span>, data &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>countReducer.js</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个为count组件服务的reducer，reducer本质是一个函数</span></span><br><span class="line"><span class="comment">//第一次调用时是store自动触发的，传递的preState是undefin</span></span><br><span class="line"><span class="comment">//必须是纯函数（同样输入必定得到同样输出）不要在reducer中发起网络请求、改写prestate、使用Date.now() , Math.random()</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> (<span class="params">preState, action</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; type, data &#125; = action;</span><br><span class="line">  <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">      <span class="keyword">return</span> preState; <span class="comment">//当preState没有变化时，不会引起页面刷新（浅比较）</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">      <span class="keyword">return</span> preState + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>constants.js</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="variable constant_">ADD</span> = <span class="string">&quot;add&quot;</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>test.jsx</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&#x27;../store/store.js&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123;test&#125; <span class="keyword">from</span> <span class="string">&#x27;../store/countAction.js&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">componentDidMount</span>(<span class="params"></span>)&#123;</span><br><span class="line">store.<span class="title function_">subscribe</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line"><span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">increment</span>(<span class="params"></span>)&#123;</span><br><span class="line">store.<span class="title function_">dispatch</span>(<span class="title function_">test</span>(<span class="number">123</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="keyword">return</span> （&lt;div&gt;&#123;&#123;store.<span class="title function_">getState</span>()&#125;&#125;&lt;/div&gt;）</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="异步-action"><a href="#异步-action" class="headerlink" title="异步 action"></a>异步 action</h5><blockquote>
<p>异步 action 指 action 返回值为函数，同步 action 指 action 返回值为对象</p>
</blockquote>
<ul>
<li>store.js</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;createStore,applyMiddleware&#125;form <span class="string">&#x27;redux&#x27;</span></span><br><span class="line"><span class="keyword">import</span> countReducer <span class="keyword">from</span> <span class="string">&#x27;./countReducer&#x27;</span></span><br><span class="line"><span class="comment">//引入异步action中间件</span></span><br><span class="line"><span class="comment">//yarn add redux-thunk</span></span><br><span class="line"><span class="keyword">import</span> thunk  <span class="keyword">from</span> <span class="string">&#x27;redux-thunk&#x27;</span></span><br><span class="line"><span class="keyword">const</span> store=<span class="title function_">createStore</span>(countReducer,<span class="title function_">applyMiddleware</span>(thunk))</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store</span><br></pre></td></tr></table></figure>

<ul>
<li>action.js</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&#x27;./store&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> add=data=(&#123;<span class="attr">type</span>:<span class="string">&#x27;add&#x27;</span>,data&#125;)<span class="comment">//同步action</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">addAsync</span>=(<span class="params">data,a,b,c</span>)=&gt;&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function">(<span class="params">dispatch</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line"><span class="title function_">dispatch</span>(<span class="title function_">add</span>(data)&#125;)</span><br><span class="line">&#125;,<span class="number">50000</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="react-redux"><a href="#react-redux" class="headerlink" title="react-redux"></a>react-redux</h5><blockquote>
<p>UI 组件应该包裹一个容器组件，它们为父子关系<br>UI 组件不能使用任何 redux api，容器组件可以<br>容器给 UI 组件通过 props 传递状态、操作方法<br>不用在写 store.subscribe()</p>
</blockquote>
<ul>
<li>容器组件<br>/containers/test/index.jsx</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//yran add react-redux</span></span><br><span class="line"><span class="keyword">import</span> testUI <span class="keyword">from</span> <span class="string">&quot;../../components/test.jsx&quot;</span>;</span><br><span class="line"><span class="comment">//引入connect用于连接UI组件与redux</span></span><br><span class="line"><span class="keyword">import</span> &#123; connect &#125; <span class="keyword">from</span> <span class="string">&quot;react-redux&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">mapStateToProps</span> = (<span class="params">state</span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">//通过props传给UI组件状态</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">b</span>: state,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">mapDisoatchToProps</span> = (<span class="params">dispatch</span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">//通过props传给UI操作方法</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">d</span>: <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">dispatch</span>(&#123; <span class="attr">type</span>: <span class="string">&quot;xxx&quot;</span>, data &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">c</span>: <span class="function">() =&gt;</span> &#123;&#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> testContainer = <span class="title function_">connect</span>(mapStateToProps, mapDisoatchToProps)(testUI);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> testContainer;</span><br></pre></td></tr></table></figure>

<p>App.jsx</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> store form <span class="string">&#x27;../../redux/store.js&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Test</span> <span class="keyword">from</span> <span class="string">&#x27;../../containers/test&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Test</span> <span class="attr">store</span>=<span class="string">&#123;store&#125;/</span>&gt;</span></span></span><br><span class="line">)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简写</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createIncreamentAction &#125; <span class="keyword">from</span> <span class="string">&quot;../store/action.js&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> testContainer = <span class="title function_">connect</span>(</span><br><span class="line">  <span class="function">(<span class="params">state</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="attr">a</span>: state;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">add</span>: createIncreamentAction,</span><br><span class="line">  &#125;</span><br><span class="line">)(testUI);</span><br></pre></td></tr></table></figure>

<h5 id="provide"><a href="#provide" class="headerlink" title="provide"></a>provide</h5><p>index.js</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&quot;./store&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Provider</span> &#125; <span class="keyword">from</span> <span class="string">&quot;react-redux&quot;</span>;</span><br><span class="line"><span class="comment">//自动匹配容器组件，添加上store</span></span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">ProVider</span> <span class="attr">store</span>=<span class="string">&#123;store&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">App</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">ProVider</span>&gt;</span></span>,</span><br><span class="line">  <span class="variable language_">document</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h5 id="整合容器和-UI-组件"><a href="#整合容器和-UI-组件" class="headerlink" title="整合容器和 UI 组件"></a>整合容器和 UI 组件</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;createIncreamentAction&#125; <span class="keyword">from</span> <span class="string">&#x27;../store/action.js&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> extend <span class="title class_">Componet</span>&#123;&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">connect</span>(</span><br><span class="line"><span class="function"><span class="params">state</span>=&gt;</span>&#123;<span class="attr">a</span>:state&#125;,</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">add</span>:createIncreamentAction</span><br><span class="line">&#125;</span><br><span class="line">)(<span class="title class_">Test</span>)</span><br></pre></td></tr></table></figure>

<h5 id="多个-reducer"><a href="#多个-reducer" class="headerlink" title="多个 reducer"></a>多个 reducer</h5><ul>
<li>store.js</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;createStore，applyMiddleware,combineReducers&#125;form <span class="string">&#x27;redux&#x27;</span></span><br><span class="line"><span class="keyword">import</span> countReducer1 <span class="keyword">from</span> <span class="string">&#x27;./reducer/count1&#x27;</span></span><br><span class="line"><span class="keyword">import</span> countReducer2 <span class="keyword">from</span> <span class="string">&#x27;./reducer/count2&#x27;</span></span><br><span class="line"><span class="keyword">let</span> allReducer=<span class="title function_">combineReducers</span>(&#123;</span><br><span class="line"><span class="attr">count1</span>:countReducer1</span><br><span class="line"><span class="attr">count2</span>:countReducer2</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">createStore</span>(allReducer)</span><br></pre></td></tr></table></figure>

<h5 id="使用-Redux-Toolkit-简化-Redux"><a href="#使用-Redux-Toolkit-简化-Redux" class="headerlink" title="使用 Redux Toolkit 简化 Redux"></a>使用 Redux Toolkit 简化 Redux</h5><p><code>npm install @reduxjs/toolkit react-redux</code><br>react-redux 也需要单独安装</p>
<ul>
<li>configureStore<br>configureStore 替代 createStore<br>配置简单,设置默认值也方便<br>src/store/index.js</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入</span></span><br><span class="line"><span class="keyword">import</span> &#123; configureStore &#125; <span class="keyword">from</span> <span class="string">&quot;@reduxjs/toolkit&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> counterSlice <span class="keyword">from</span> <span class="string">&quot;../pages/basic/counterSlice&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> mySlice <span class="keyword">from</span> <span class="string">&quot;../pages/mySlice&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">configureStore</span>(&#123;</span><br><span class="line">  <span class="attr">reducer</span>: &#123;</span><br><span class="line">    <span class="attr">rootCounter</span>: counterSlice,</span><br><span class="line">    <span class="attr">rootMy</span>: mySlice,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>这里 reduer 直接合并成一个唯一的 根 root 了<br>原有的 combineReducers 这个合并函数就用不到了<br>注意自己配置的 reducer 的 key 值 和 对应的 value 值<br>我这里把单独的 reducer 放到和页面同级了,这个根据自己的习惯,放到 store 下面新建目录存放所有的 reducer 也行</p>
<ul>
<li>根组件配置 store</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">入口index.<span class="property">js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ReactDOM</span> <span class="keyword">from</span> <span class="string">&#x27;react-dom/client&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&#x27;./store&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123;<span class="title class_">Provider</span>&#125; <span class="keyword">from</span> <span class="string">&#x27;react-redux&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> root = <span class="title class_">ReactDOM</span>.<span class="title function_">createRoot</span>(<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>));</span><br><span class="line">root.<span class="title function_">render</span>(</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">React.StrictMode</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">   <span class="tag">&lt;<span class="name">Provider</span> <span class="attr">store</span>=<span class="string">&#123;store&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">         <span class="tag">&lt;<span class="name">App</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">Provider</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">React.StrictMode</span>&gt;</span></span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>createAction<br>创建一个 action，传入动作类型字符串，返回动作函数。<br>createAction 语法： function createAction(type, prepareAction?)<br>1，type：Redux 中的 actionTypes<br>2，prepareAction：Redux 中的 actions</p>
</li>
<li><p>createReducer<br>创建一个 reducer，action type 映射到 case reducer 函数中，不用写 switch-case，并集成 immer。<br>Builder 提供了三个方法：<br>1，addCase： 根据 action 添加一个 reducer case 的操作。<br>2，addMatcher： 在调用 actions 前，使用 matcher function 过滤<br>3，addDefaultCase： 默认值，等价于 switch 的 default case;</p>
</li>
<li><p>createSlice reducer 编写</p>
<blockquote>
<p>createSlice 对 actions、Reducer 的一个封装。</p>
</blockquote>
<ol>
<li><p>创建 slice<br>使用 createSlice 方法创建一个 slice。每一个 slice 里面包含了 reducer 和 actions，可以实现模块化的封装。<br>所有的相关操作都独立在一个文件中完成。</p>
</li>
<li><p>关键属性:<br>name<br>命名空间，可以自动的把每一个 action 进行独立，解决了 action 的 type 出现同名的文件。在使用的时候默认会把使用 name/actionName<br>initialState<br>state 数据的初始值</p>
</li>
<li><p>reducers<br>定义的 action。由于内置了 immutable 插件，可以直接使用赋值的方式进行数据的改变，不需要每一次都返回一个新的 state 数据。</p>
</li>
<li><p>导出<br>counterSlice.actions 导出所有的修改函数方便页面使用<br>counterSlice.reducer 导出 reducer 在 store 里面使用<br>具体 reducer 函数的参数<br>参数 1: 当前 slice 的 state 数据<br>参数 2: 对象{type:””,payload:传参}</p>
</li>
</ol>
</li>
</ul>
<p>type:counterSpace/decrement<br>type 就是之前的 actions 用 switc/case 来匹配很麻烦,现在简洁了<br>type 构成 slice 的 name 命名空间/具体的修改函数</p>
<p>payload 要和传的时候保持一致</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createSlice &#125; <span class="keyword">from</span> <span class="string">&quot;@reduxjs/toolkit&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> initialState = &#123;</span><br><span class="line">  <span class="attr">counter</span>: <span class="number">100</span>,</span><br><span class="line">  <span class="attr">user</span>: &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;yzs&quot;</span>,</span><br><span class="line">    <span class="attr">job</span>: <span class="string">&quot;全栈&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">reducer切片</span></span><br><span class="line"><span class="comment">createSlice函数的作用：生成分片的reducer</span></span><br><span class="line"><span class="comment">内部调用的市createAction和createReducer</span></span><br><span class="line"><span class="comment">creatSlice可以帮助我们用更少的代码去生成配套的reducer和action,而且有很好的维护性</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> counterSlice = <span class="title function_">createSlice</span>(&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;counterSpace&quot;</span>, <span class="comment">// 命名空间，在调用action的时候会默认的设置为action的前缀,保证唯一.不重名</span></span><br><span class="line">  initialState,</span><br><span class="line">  <span class="attr">reducers</span>: &#123;</span><br><span class="line"><span class="comment">// reducer函数 state当前组件的数据</span></span><br><span class="line"><span class="comment">//第二个参数为&#123;payload:&#123;&#125;,type:&quot;&quot;&quot;&#125; 想想就写法或者vuex</span></span><br><span class="line">    <span class="title function_">increment</span>(<span class="params">state</span>) &#123;</span><br><span class="line">      state.<span class="property">counter</span> += <span class="number">100</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">decrement</span>(<span class="params">state, actions</span>) &#123;</span><br><span class="line">      <span class="comment">// actions == &#123;payload:&#123;&#125;,type:&quot;&quot;&quot;&#125;</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;decrement---actions&quot;</span>, actions);</span><br><span class="line">      state.<span class="property">counter</span> -= actions.<span class="property">payload</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">updateUser</span>(<span class="params">state, &#123; payload &#125;</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;updateUser-------payload&quot;</span>, payload);</span><br><span class="line"><span class="comment">// 引用类型 注意 赋值的写法</span></span><br><span class="line">      state.<span class="property">user</span> = &#123;</span><br><span class="line">        ...state.<span class="property">user</span>,</span><br><span class="line">        ...payload,</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">切片对象会自动地帮助我们生成action</span></span><br><span class="line"><span class="comment">切片对象会根据我们地reducers方法来自动地创建action对象，这些action对象会保存到切片对象的actions中</span></span><br><span class="line"><span class="comment">&#123;type:name/函数名，payload:函数的参数&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> &#123; increment, decrement, updateUser &#125; = counterSlice.<span class="property">actions</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">selectCount</span> = (<span class="params">state</span>) =&gt; state.<span class="property">rootCounter</span>.<span class="property">counter</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">selectUser</span> = (<span class="params">state</span>) =&gt; state.<span class="property">rootCounter</span>.<span class="property">user</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> counterSlice.<span class="property">reducer</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>页面使用<ol>
<li>useSelector()<br>返回指定的 state</li>
</ol>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这样写太长了 麻烦</span></span><br><span class="line"> <span class="keyword">const</span> counter = <span class="title function_">useSelector</span>(<span class="function"><span class="params">state</span>=&gt;</span>state.<span class="property">rootCouter</span>.<span class="property">counter</span>);</span><br></pre></td></tr></table></figure>

<p>rootCouter 这个 key 来源于 根 store 里面配置的 reducer，这样写太长了，麻烦。在这个 slice 里面我做了统一处理</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">selectCount</span> = (<span class="params">state</span>) =&gt; state.<span class="property">rootCounter</span>.<span class="property">counter</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">selectUser</span> = (<span class="params">state</span>) =&gt; state.<span class="property">rootCounter</span>.<span class="property">user</span>;</span><br></pre></td></tr></table></figure>

<p>页面使用</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useSelector, useDispatch &#125; <span class="keyword">from</span> <span class="string">&quot;react-redux&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  increment,</span><br><span class="line">  decrement,</span><br><span class="line">  updateUser,</span><br><span class="line">  selectCount,</span><br><span class="line">  selectUser,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">&quot;./normalSlice&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Counter</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> dispatch = <span class="title function_">useDispatch</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// let counter = useSelector(state=&gt;state.rootCouter.counter)</span></span><br><span class="line">  <span class="keyword">const</span> counter = <span class="title function_">useSelector</span>(selectCount);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;页面---counter:&quot;</span>, counter);</span><br><span class="line">  <span class="keyword">const</span> user = <span class="title function_">useSelector</span>(selectUser);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这样可以直接解构出当前 slice所有的 state</span></span><br><span class="line"><span class="comment">// 具体用哪种 看自己心情</span></span><br><span class="line"> <span class="keyword">const</span> &#123; counter &#125; = <span class="title function_">useSelector</span>(<span class="function">(<span class="params">state</span>) =&gt;</span> state.<span class="property">rootCouter</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ( <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span> 布局看下面 <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>useDispatch()<br>payload 传参和 reducer 保持一致<br>引用类型的 修改注意</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> dispatch = <span class="title function_">useDispatch</span>(); 修改函数</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>reduxjs/toolkit 基础用法<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">hr</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> dispatch(increment())&#125;&gt;+<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;counter&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> dispatch(decrement(666))&#125;&gt;-<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">hr</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>姓名:&#123;user.name&#125; ---职业:&#123;user.job&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span>=&gt;</span>&#123;dispatch(updateUser(&#123;name:&#x27;Michael&#x27;&#125;))&#125;&#125;&gt;改名<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span>=&gt;</span>&#123;</span></span><br><span class="line"><span class="language-xml">        dispatch(updateUser(&#123;job:&#x27;自由职业者&#x27;&#125;))&#125;</span></span><br><span class="line"><span class="language-xml">        &#125;&gt;转行<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>异步 createAsyncThunk()<br>内置了 redux-thunk 处理异步 , 足够解决绝大部分的问题. 还有其他中间件比如:redux-saga 、redux-observable。<br>异步请求处理三种状态的 action :pending\fulfilled\rejected；<br>这三种状态的 action 自动触发, 防止外部手动调用,则使用属性 extraReducers , 则不会生成对外的的 action creator .</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">接受一个动作类型字符串和一个返回<span class="title class_">Promise</span>函数，并生成一个pending/fulfilled/rejected基于该<span class="title class_">Promise</span>分派动作类型的 thunk</span><br><span class="line">用 fetch请求模拟一个异步</span><br><span class="line"><span class="number">3.</span><span class="title function_">createAsyncThunk</span>(<span class="string">&quot;counterSpace/getList&quot;</span>,<span class="function">()=&gt;</span>&#123;&#125;)</span><br><span class="line">参数<span class="number">1</span>: slice的name/命名空间/函数名</span><br><span class="line"></span><br><span class="line"><span class="comment">// return 不要忘记</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">getList</span> = (<span class="params"> </span>) =&gt; &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="title function_">fetch</span>(<span class="string">&quot;https://.XX.cn/api/news&quot;</span>).<span class="title function_">then</span>(<span class="function"><span class="params">res</span>=&gt;</span>res.<span class="title function_">json</span>());</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span>  getListAsync =  <span class="title function_">createAsyncThunk</span>(<span class="string">&quot;counterSpace/getList&quot;</span>,<span class="title function_">async</span>()=&gt;&#123;</span><br><span class="line">  <span class="keyword">const</span> res = <span class="keyword">await</span> <span class="title function_">getList</span>()</span><br><span class="line">  <span class="keyword">return</span> res<span class="comment">// 此处的返回结果会在 .fulfilled中作为payload的值</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>extraReducers<br>异步函数配置</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">createSlice</span>(&#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;counterSpace&quot;</span>,</span><br><span class="line">    initialState,</span><br><span class="line">    <span class="attr">reducers</span>:&#123;&#125;,</span><br><span class="line">    <span class="attr">extraReducers</span>: <span class="function">(<span class="params">builder</span>) =&gt;</span> &#123;</span><br><span class="line">    builder</span><br><span class="line">      .<span class="title function_">addCase</span>(getListAsync.<span class="property">pending</span>, <span class="function">(<span class="params">state</span>) =&gt;</span> &#123;</span><br><span class="line">         <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;pending&quot;</span>,state);</span><br><span class="line">      &#125;)</span><br><span class="line">      .<span class="title function_">addCase</span>(getListAsync.<span class="property">rejected</span>, <span class="function">(<span class="params">state, err</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;rejected 失败&quot;</span>,err);</span><br><span class="line"></span><br><span class="line">      &#125;)</span><br><span class="line">      .<span class="title function_">addCase</span>(getListAsync.<span class="property">fulfilled</span>, <span class="function">(<span class="params">state, action</span>) =&gt;</span> &#123;</span><br><span class="line">         <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;fulfilled 成功&quot;</span>,state);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;fulfilled action&quot;</span>,action);</span><br><span class="line"></span><br><span class="line">        state.<span class="property">list</span> = action.<span class="property">payload</span></span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line">这个配置基本就是套路</span><br><span class="line">只需要把函数名字改为通过<span class="title function_">createAsyncThunk</span>()创建的函数名</span><br><span class="line">根据自己的业务场景 写赋值逻辑就行</span><br></pre></td></tr></table></figure>

<p>页面使用异步函数</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onClick=&#123;<span class="function">()=&gt;</span><span class="title function_">dispatch</span>(<span class="title function_">getListAsync</span>(<span class="string">&#x27;异步模拟&#x27;</span>))&#125;&gt;异步&lt;/button&gt;</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;</span></span><br><span class="line"><span class="language-xml">          listData.map((news)=&gt;&#123;</span></span><br><span class="line"><span class="language-xml">            return <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;news.id&#125;</span>&gt;</span>&#123;news.title&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          &#125;)</span></span><br><span class="line"><span class="language-xml">        &#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<h5 id="集中式状态管理工具Mobx"><a href="#集中式状态管理工具Mobx" class="headerlink" title="集中式状态管理工具Mobx"></a>集中式状态管理工具Mobx</h5><blockquote>
<p>简单：编写无模板的极简代码<br>轻松实现最优渲染：依赖自动追踪最小渲染优化<br>自由：可移植，测试</p>
</blockquote>
<h6 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install mobx mobx-react</span><br></pre></td></tr></table></figure>

<h6 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h6><ul>
<li>stroe/counter.js</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;makeAutoObservable,computed&#125; <span class="keyword">from</span> <span class="string">&#x27;mobx&#x27;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CounterStore</span>&#123;</span><br><span class="line">  <span class="comment">//定义数据</span></span><br><span class="line">  count=<span class="number">0</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">//把数据弄成响应式</span></span><br><span class="line">    <span class="title function_">makeAutoObservable</span>(<span class="variable language_">this</span>,</span><br><span class="line">   &#123;</span><br><span class="line">  <span class="attr">count_2</span>:computed,<span class="comment">//标记为计算属性</span></span><br><span class="line">   &#125; </span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//修改数据</span></span><br><span class="line">  addCount=<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">conut</span>++</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">count_2</span>()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">count</span>*<span class="number">10</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实例化，导出</span></span><br><span class="line"><span class="keyword">const</span> counterStore=<span class="keyword">new</span> <span class="title class_">CounterStore</span>()</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> counterStore</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>App.js</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//导入store</span></span><br><span class="line"><span class="keyword">import</span> counterStore <span class="keyword">from</span> <span class="string">&#x27;./store/counter.js&#x27;</span></span><br><span class="line"><span class="comment">//导入中间件，链接mobx，react,完成响应式</span></span><br><span class="line"><span class="keyword">import</span> &#123;observer&#125; <span class="keyword">from</span> <span class="string">&#x27;mobx-react&#x27;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    &#123;counterSotre.count&#125;</span></span><br><span class="line"><span class="language-xml">    &#123;counterSotre.count_2&#125;</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;counterStore.addCount&#125;</span>&gt;</span>add<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">observer</span>(<span class="title class_">App</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h6 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h6><ul>
<li>store/index.js</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//组合模块</span></span><br><span class="line"><span class="keyword">import</span> &#123;<span class="title class_">CounterStore</span>&#125; <span class="keyword">from</span> <span class="string">&#x27;./counter.Store.js&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//声明rootStore</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RootStore</span>&#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">counterStore</span>=<span class="keyword">new</span> <span class="title class_">CounterSotre</span>()</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实例化根store</span></span><br><span class="line"><span class="keyword">const</span> rootStore=<span class="keyword">new</span> <span class="title class_">RootStore</span>()</span><br><span class="line"><span class="comment">//使用context进行透传．也可以直接导出包一层observer</span></span><br><span class="line"><span class="comment">//查找机制：优先从Provider标签中value,若找不到则找createContext()方法中的传递过来的默认参数</span></span><br><span class="line"><span class="keyword">const</span> context=<span class="title class_">React</span>.<span class="title function_">createContext</span>(rootStore)</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">useStore</span>=(<span class="params"></span>)=&gt;<span class="title class_">React</span>.<span class="title function_">useContext</span>(context)</span><br><span class="line"><span class="keyword">export</span> &#123;useStore&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>store/counter.Stroe.js</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;makeAutoObservable,computed&#125; <span class="keyword">from</span> <span class="string">&#x27;mobx&#x27;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CounterStore</span>&#123;</span><br><span class="line">  <span class="comment">//定义数据</span></span><br><span class="line">  count=<span class="number">0</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">//把数据弄成响应式</span></span><br><span class="line">    <span class="title function_">makeAutoObservable</span>(<span class="variable language_">this</span>,</span><br><span class="line">   &#123;</span><br><span class="line">  <span class="attr">count_2</span>:computed,<span class="comment">//标记为计算属性</span></span><br><span class="line">   &#125; </span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//修改数据</span></span><br><span class="line">  addCount=<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">conut</span>++</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">count_2</span>()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">count</span>*<span class="number">10</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实例化，导出</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">CounterStore</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> App.js</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//导入store</span></span><br><span class="line"><span class="keyword">import</span> &#123;useStore&#125; <span class="keyword">from</span> <span class="string">&#x27;./store/index.js&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123;observer&#125; <span class="keyword">from</span> <span class="string">&#x27;mobx-react&#x27;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">const</span> rootStore=<span class="title function_">useStore</span>()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    &#123;rootStore.counterSotre.count&#125;</span></span><br><span class="line"><span class="language-xml">    &#123;rootStore.counterSotre.count_2&#125;</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;rootStore.counterStore.addCount&#125;</span>&gt;</span>add<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">observer</span>(<span class="title class_">App</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj=&#123;<span class="attr">a</span>:&#123;<span class="attr">b</span>:<span class="number">1</span>&#125;&#125;</span><br><span class="line"><span class="keyword">const</span> &#123;a&#125;=obj;</span><br><span class="line"><span class="keyword">const</span> &#123;<span class="attr">a</span>:&#123;b&#125;&#125;=obj;<span class="comment">//连续解构赋值</span></span><br><span class="line"><span class="keyword">const</span> &#123;<span class="attr">a</span>:&#123;<span class="attr">b</span>:value&#125;&#125;=obj;<span class="comment">//连续解构赋值+重命名</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="高阶组件"><a href="#高阶组件" class="headerlink" title="高阶组件"></a>高阶组件</h5><blockquote>
<p>把一个组件当成另一个组件的参数传入，然后返回新的组件</p>
</blockquote>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">AuthComponent</span>(<span class="params">&#123;children&#125;</span>)&#123;</span><br><span class="line">  <span class="keyword">const</span> isToken=<span class="variable language_">localStorage</span>.<span class="title function_">get</span>(<span class="string">&#x27;token&#x27;</span>)</span><br><span class="line">  <span class="keyword">if</span>(isToken)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;&gt;</span>&#123;children&#125;<span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Navigate</span> <span class="attr">to</span>=<span class="string">&quot;/login&quot;</span> <span class="attr">replace</span> /&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line">&lt;<span class="title class_">AuthComponent</span>&gt;</span><br><span class="line">  &lt;<span class="title class_">Home</span>&gt;</span><br><span class="line">&lt;/<span class="title class_">AuthComponent</span>&gt;</span><br></pre></td></tr></table></figure>

<h5 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h5><ul>
<li>若 a 函数，接收的参数是一个函数，那么 a 就可以称为高阶函数</li>
<li>若 a 函数，调用的返回值依然是一个函数，那么 a 就可以称为高阶函数<br>如 promise setTimeOut arr.map()</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">test=(type)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function">(<span class="params">e</span>)=&gt;</span>&#123;</span><br><span class="line">arr.<span class="title function_">push</span>( &#123;[type]:e.<span class="property">target</span>.<span class="property">value</span>&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;input onChange=<span class="string">&quot;&#123;test(&#x27;1&#x27;)&#125;&quot;</span>/&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">onChange</span>=<span class="string">&quot;&#123;test(&#x27;2&#x27;)&#125;&quot;</span>/&gt;</span></span></span><br></pre></td></tr></table></figure>

<h5 id="函数的柯里化"><a href="#函数的柯里化" class="headerlink" title="函数的柯里化"></a>函数的柯里化</h5><p>通过函数调用继续返回函数的方式，实现多次接收参数最后统一处理的函数编码形式</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">test=(type)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function">(<span class="params">e</span>)=&gt;</span>&#123;</span><br><span class="line">arr.<span class="title function_">push</span>( &#123;[type]:e.<span class="property">target</span>.<span class="property">value</span>&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">a,b,c</span>)&#123;<span class="keyword">return</span> a+b+c&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sum2</span>(<span class="params">a</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function">(<span class="params">b</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function">(<span class="params">c</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="keyword">return</span> a+b+c</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">sum</span>(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<h4 id="前端发请求"><a href="#前端发请求" class="headerlink" title="前端发请求"></a>前端发请求</h4><h5 id="xhr"><a href="#xhr" class="headerlink" title="xhr"></a>xhr</h5><ul>
<li>jquery</li>
<li>axios（node 使用 axios 是封装 http 协议）</li>
</ul>
<h5 id="fetch"><a href="#fetch" class="headerlink" title="fetch"></a>fetch</h5><blockquote>
<p>原生函数,老版本兼容性差</p>
</blockquote>
<p>fetch(‘xxx’).then(res=&gt;{<br>//联系服务器成功<br>return res.json()<br>},err=&gt;{return new Promis(()=&gt;{})}).then(res=&gt;{},err=&gt;{})</p>
<h5 id="setState"><a href="#setState" class="headerlink" title="setState"></a>setState</h5><p>写法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">state=&#123;<span class="attr">a</span>:<span class="number">1</span>&#125;</span><br><span class="line"></span><br><span class="line">对象式setState</span><br><span class="line"><span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;<span class="attr">a</span>:<span class="number">2</span>&#125;)</span><br><span class="line"><span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;<span class="attr">a</span>:<span class="number">2</span>&#125;,<span class="function">()=&gt;</span>&#123;</span><br><span class="line"><span class="comment">//状态更新以及页面也更新后，才调用</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">函数式setState</span><br><span class="line"><span class="variable language_">this</span>.<span class="title function_">setState</span>(<span class="function">(<span class="params">state,props</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="keyword">return</span> &#123;<span class="attr">a</span>:<span class="number">1</span>&#125;&#125;,<span class="function">()=&gt;</span>&#123;&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="lazyLoad"><a href="#lazyLoad" class="headerlink" title="lazyLoad"></a>lazyLoad</h4><blockquote>
<p>路由组件懒加载</p>
</blockquote>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;lazy,<span class="title class_">Component</span>,<span class="title class_">Suspense</span>&#125; form <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Loading</span> <span class="keyword">from</span> <span class="string">&quot;./component/Loading.jsx&quot;</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Home</span>=<span class="title function_">lazy</span>(<span class="function">()=&gt;</span>&#123;<span class="keyword">import</span> (<span class="string">&#x27;./Home&#x27;</span>)&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">Demo</span> extend <span class="title class_">Component</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Suspense</span> <span class="attr">fallback</span>=<span class="string">&#123;</span>&lt;<span class="attr">Loading</span>/&gt;</span>&#125;&gt;</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Route</span>  <span class="attr">path</span>=<span class="string">&quot;/home&quot;</span> <span class="attr">component</span>=<span class="string">&#123;Home&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">Route</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">Suspense</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="Hooks"><a href="#Hooks" class="headerlink" title="Hooks"></a>Hooks</h4><blockquote>
<p>hook 是 16.8 的新特性，可以让你在函数组件中使用 state 以及其他 react 特性<br>hook 本质是一套能够使函数组件更强大，灵活的‘钩子’(某一时刻下自动执行的函数)<br>解决组件逻辑复用的问题：hook出现前，react先后尝试了mixins、HOC高阶组件、render-props等模式，但各自都有对应的问题。如mixin的数据来源不明，高阶组件的嵌套问题<br>解决了类式组件自身的问题：如属性过多，生命周期、this指向</p>
</blockquote>
<h5 id="state-1"><a href="#state-1" class="headerlink" title="state"></a>state</h5><p>useState返回的值是数组</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Test</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">const</span> [a,set]=<span class="title class_">React</span>.<span class="title function_">useState</span>(<span class="number">123</span>) <span class="comment">//初始化会调用一次，下次调用时，会缓存数据，不会覆盖</span></span><br><span class="line">  <span class="comment">//不能在if/for/函数体中写（react会按照hooks调用顺序识别每一个hook）</span></span><br><span class="line">  <span class="keyword">let</span> <span class="title function_">add1</span>=(<span class="params"></span>)=&gt;&#123;<span class="title function_">set</span>(<span class="number">456</span>)&#125;</span><br><span class="line">  <span class="keyword">let</span> <span class="title function_">add2</span>=(<span class="params"></span>)=&gt;&#123;<span class="title function_">set</span>(<span class="function">(<span class="params">a</span>)=&gt;</span>&#123;<span class="keyword">return</span> a+<span class="number">1</span>&#125;)&#125;</span><br><span class="line">  <span class="keyword">return</span> (<span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;a&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>)&#125;</span><br></pre></td></tr></table></figure>

<h5 id="effect"><a href="#effect" class="headerlink" title="effect"></a>effect</h5><blockquote>
<p>函数组件里使用生命周期</p>
</blockquote>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> form <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Test</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="keyword">const</span> [count,setCount]=<span class="title class_">React</span>.<span class="title function_">useState</span>(<span class="number">123</span>)</span><br><span class="line"></span><br><span class="line"><span class="title class_">React</span>.<span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;&#125;,[a])<span class="comment">//检测a,改变时调用------</span></span><br><span class="line"><span class="title class_">React</span>.<span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;&#125;,[])<span class="comment">//谁也不监测,仅在挂载和卸载的时候执行----</span></span><br><span class="line"><span class="title class_">React</span>.<span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;&#125;)<span class="comment">//检测所有,改变时调用----componentDidUpdate</span></span><br><span class="line"><span class="title class_">React</span>.<span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;<span class="keyword">return</span> <span class="function">()=&gt;</span>&#123;组件卸载前执行&#125;&#125;,[])<span class="comment">//componentWillUnmount</span></span><br><span class="line"><span class="comment">//不要在useEffectd 的回调函数外层直接包裹await,因为异步会导致清理函数无法立即返回</span></span><br><span class="line"><span class="title class_">React</span>.<span class="title function_">useEffect</span>(<span class="title function_">async</span>()=&gt;&#123;</span><br><span class="line">  <span class="keyword">const</span> res=<span class="keyword">await</span> axios.<span class="title function_">get</span>(<span class="string">&#x27;...&#x27;</span>)</span><br><span class="line">&#125;,[])</span><br><span class="line"><span class="comment">//正确写法</span></span><br><span class="line"><span class="title class_">React</span>.<span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">getData</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">const</span> res=<span class="keyword">await</span> axios.<span class="title function_">get</span>(<span class="string">&#x27;...&#x27;</span>)</span><br><span class="line">&#125;&#125;,[])</span><br><span class="line"><span class="keyword">return</span> (<span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>a<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在React通知到Renderer渲染器后，渲染器又分了三个子阶段来处理：</p>
<p>beforeMutation阶段（渲染视图前）<br>mutation阶段（渲染试图）<br>layout阶段（渲染视图后）<br>渲染器会在mutation阶段完成后， 在layout阶段同步的调用useLayoutEffect，在子组件嵌套中于是如此。在类组件中，调用的是componentDidMount生命周期函数。也就是说，在useLayoutEffect中，无论是否有重新触发setState，也不会在当前渲染里，重新更新界面。<br>而在整个渲染器渲染阶段（其实也叫commit）渲染完成后，react才会异步的执行useEffect。当在useEffect中如果有setState，则会重新触发渲染器，更新界面。</p>
<p>结论：</p>
<p>useLayoutEffect的是在渲染器执行当前渲染界面任务时，同步执行。<br>在当前一轮的Reconciler任务调度过程中，在渲染器执行完当前任务后，才会异步调用useEffect。<br>useLayoutEffect先于useEffect执行，并且子组件优先执行。<br>componentDidMount()完全等价于useLayoutEffect( fn , [ ] )，但是不等价于useEffect( fn , [ ] )。</p>
<h5 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h5><blockquote>
<p>获取dom元素获取组件对象</p>
</blockquote>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> form <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Test</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="keyword">const</span> myRef=<span class="title class_">React</span>.<span class="title function_">useRef</span>()</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">show</span>(<span class="params"></span>)&#123;myRef.<span class="property">style</span>.<span class="property">color</span>=<span class="string">&#x27;red&#x27;</span>&#125;</span><br><span class="line"><span class="keyword">return</span> (<span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">&#123;myRef&#125;</span>&gt;</span>a<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Fragment"><a href="#Fragment" class="headerlink" title="Fragment"></a>Fragment</h4><blockquote>
<p>可以不用必须有一个真实 DOM 根标签，编译后会移除</p>
</blockquote>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Fragment</span> <span class="attr">key</span>=<span class="string">&#123;&#125;</span>&gt;</span>//只能有一个属性：key</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;&gt;</span>//简写，但不能写任何属性</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/&gt;</span></span></span><br><span class="line">&lt;/<span class="title class_">Fragment</span>&gt;</span><br><span class="line">)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h4><blockquote>
<p>常用与祖组件和后代组件通信<br>一般不用 Context,而是它的封装 react-redux</p>
</blockquote>
<p>类式组件</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">CountContext</span>=<span class="title class_">React</span>.<span class="title function_">createContext</span>()<span class="comment">//创建一个上下文,必须所有组件都访问得到</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span>&#123;</span><br><span class="line">state=&#123;<span class="attr">a</span>:<span class="number">1</span>&#125;</span><br><span class="line"><span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="language-xml"><span class="tag">&lt;<span class="name">CountContext.Provider</span> <span class="attr">value</span>=<span class="string">&#123;this.state.a&#125;</span>&gt;</span><span class="tag">&lt;<span class="name">B</span>/&gt;</span><span class="tag">&lt;/<span class="name">CountContext.Provider</span>&gt;</span></span>)&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span>&#123;</span><br><span class="line"><span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="language-xml"><span class="tag">&lt;<span class="name">C</span>/&gt;</span></span>)&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span>&#123;</span><br><span class="line"><span class="keyword">static</span> contextType=<span class="title class_">CountContext</span><span class="comment">//声明接收context</span></span><br><span class="line"><span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="variable language_">this</span>.<span class="property">context</span>)&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>所有组件</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">CountContext</span>=<span class="title class_">React</span>.<span class="title function_">createContext</span>()<span class="comment">//创建一个上下文,必须所有组件都访问得到</span></span><br><span class="line"><span class="keyword">const</span> &#123;<span class="title class_">Consumer</span>,<span class="title class_">Provider</span>&#125;=<span class="title class_">CountContext</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span>&#123;</span><br><span class="line">state=&#123;<span class="attr">a</span>:<span class="number">1</span>&#125;</span><br><span class="line"><span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="language-xml"><span class="tag">&lt;<span class="name">Provider</span> <span class="attr">value</span>=<span class="string">&#123;this.state.a&#125;</span>&gt;</span><span class="tag">&lt;<span class="name">B</span>/&gt;</span><span class="tag">&lt;/<span class="name">Provider</span>&gt;</span></span>)&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span>&#123;</span><br><span class="line"><span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="language-xml"><span class="tag">&lt;<span class="name">C</span>/&gt;</span></span>)&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">C</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="keyword">static</span> contextType=<span class="title class_">CountContext</span><span class="comment">//声明接收context</span></span><br><span class="line"><span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">Consumer</span>&gt;</span>&#123;value=&gt;&#123;return (<span class="tag">&lt;<span class="name">span</span>&gt;</span>value<span class="tag">&lt;/<span class="name">span</span>&gt;</span>)&#125;<span class="tag">&lt;/<span class="name">Consumer</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>)&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="PureComponent"><a href="#PureComponent" class="headerlink" title="PureComponent"></a>PureComponent</h4><blockquote>
<p>只要执行 setState 即使不更新数据，组件也会重新 render9)<br>只要 render()调用，其子组件也会更新<br>原因：shouldComponentUpdate()默认总是为 true</p>
</blockquote>
<h5 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h5><ul>
<li>手动比较新旧值,不一样更新，否则禁止更新</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">shouldComponentUpdate</span>(<span class="params">nextProps,nextState</span>)&#123;<span class="comment">//新的</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">props</span>,<span class="variable language_">this</span>.<span class="property">state</span>)<span class="comment">//旧的</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;<span class="title class_">PureComponent</span>&#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> <span class="keyword">extends</span> <span class="title class_ inherited__">PureComponent</span> &#123;</span><br><span class="line"><span class="comment">//依赖的数据不更新时，不重新render</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj=<span class="variable language_">this</span>.<span class="property">state</span></span><br><span class="line">obj.<span class="property">name</span>=<span class="string">&#x27;xx&#x27;</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="title function_">setState</span>(obj)<span class="comment">//浅比较，数据不会更新</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="render-Props"><a href="#render-Props" class="headerlink" title="render Props"></a>render Props</h4><blockquote>
<p>组件标签内可以直接写多个文本，标签、函数、jsx,会传入到组件prpos中的chidren属性中<br>vue 中的插槽</p>
</blockquote>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span>&#123;</span><br><span class="line">state=&#123;<span class="attr">a</span>:<span class="number">1</span>&#125;</span><br><span class="line"><span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">B</span>&gt;</span>aaa<span class="tag">&lt;/<span class="name">B</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"> <span class="tag">&lt;<span class="name">B</span> <span class="attr">render</span>=<span class="string">&#123;(val)</span>=&gt;</span>&#123;<span class="tag">&lt;<span class="name">C</span> <span class="attr">b</span>=<span class="string">&#123;val&#125;</span> /&gt;</span>&#125;/&gt;</span></span><br><span class="line"><span class="language-xml"> <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">)&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span>&#123;</span><br><span class="line">state=&#123;<span class="attr">b</span>:<span class="number">1</span>&#125;</span><br><span class="line"><span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;this.props.children&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">this.props.render(this.state.b)</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/&gt;</span></span></span><br><span class="line">)&#125;<span class="comment">//aaa</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">C</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="keyword">static</span> contextType=<span class="title class_">CountContext</span><span class="comment">//声明接收context</span></span><br><span class="line"><span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">Consumer</span>&gt;</span>&#123;value=&gt;&#123;return (<span class="tag">&lt;<span class="name">span</span>&gt;</span>value<span class="tag">&lt;/<span class="name">span</span>&gt;</span>)&#125;<span class="tag">&lt;/<span class="name">Consumer</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>)&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ErrorBoundary-错误边界"><a href="#ErrorBoundary-错误边界" class="headerlink" title="ErrorBoundary 错误边界"></a>ErrorBoundary 错误边界</h4><blockquote>
<p>防止子组件出错导致整个页面出错,只能在生产环境使用<br>只能捕获后代组件生命周期产生的错误，不能捕获自己的</p>
</blockquote>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">state=&#123;<span class="attr">error</span>:<span class="string">&#x27;&#x27;</span>&#125;</span><br><span class="line"><span class="comment">//生命周期函数</span></span><br><span class="line"><span class="keyword">static</span> <span class="title function_">getDerivedStateFromError</span>(<span class="params">err</span>)&#123;<span class="comment">//它的子组件出现报错时会调用</span></span><br><span class="line"><span class="title function_">componentDidCath</span>(<span class="params">err,info</span>)&#123;&#125;<span class="comment">//发生错误时调用</span></span><br><span class="line"><span class="keyword">return</span> &#123;<span class="attr">error</span>:err&#125;<span class="comment">//返回新的state，在render前触发</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">&#123;error?error:&#x27;&#x27;&#125;</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="组件间通信-1"><a href="#组件间通信-1" class="headerlink" title="组件间通信"></a>组件间通信</h4><ul>
<li>props</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">children props</span><br><span class="line">render props</span><br></pre></td></tr></table></figure>

<ul>
<li>消息订阅-发布</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pubs-sub event</span><br></pre></td></tr></table></figure>

<ul>
<li>集中式管理</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redux、dva</span><br></pre></td></tr></table></figure>

<ul>
<li>conText</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">生产者-消费者模式</span><br></pre></td></tr></table></figure>

<ul>
<li>搭配<br>父子：props<br>兄弟: 集中式管理、消息订阅发布，借助父组件<br>祖孙: 集中式管理、消息订阅发布、context（开发用的少，封装插件用得多）</li>
</ul>
<h3 id="关闭eslint"><a href="#关闭eslint" class="headerlink" title="关闭eslint"></a>关闭eslint</h3><p>第一步：执行以下命令：</p>
<p><code>npm run eject</code></p>
<p>第二步：在package.json 中修改代码</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;eslintConfig&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;extends&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line"><span class="string">&quot;react-app&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="string">&quot;react-app/jest&quot;</span></span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;rules&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;no-undef&quot;</span><span class="punctuation">:</span><span class="string">&quot;off&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;no-restricted-globals&quot;</span><span class="punctuation">:</span> <span class="string">&quot;off&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;no-unused-vars&quot;</span><span class="punctuation">:</span> <span class="string">&quot;off&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>第三步：重启项目</p>
<h3 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h3><h4 id="并发模式下在-dev-时-render-phase-会执行两次"><a href="#并发模式下在-dev-时-render-phase-会执行两次" class="headerlink" title="并发模式下在 dev 时 render-phase 会执行两次"></a>并发模式下在 dev 时 render-phase 会执行两次</h4><p>这个是 react 的一个用来突出显示应用程序中潜在问题的工具（严格模式）</p>
<p>有一项检测意外的副作用，严格模式不能自动检测到你的副作用，但它可以帮助你发现它们，使它们更具确定性。通过故意重复调用以下函数来实现的该操作。</p>
<p>注意：这仅适用于开发模式。生产模式下生命周期不会被调用两次。strictMode，故意在开发环境中执行多次，暴雷出代码隐藏的 bug,把标签去掉即可</p>
<h4 id="antd-form，initialValue-值变化后不更新"><a href="#antd-form，initialValue-值变化后不更新" class="headerlink" title="antd+form，initialValue 值变化后不更新"></a>antd+form，initialValue 值变化后不更新</h4><p>当我们第一次点开 Modal 的时候， 会得到一个 initialValue,但是这个值只在组件挂载的时候执行了一次，后续数据的更新并不会造成重新渲染，所以当我们再次打开 Modal 窗口的时候并不会更新。</p>
<p>解决方案：<br>方法一：使用 form.resetFields()<br>使用 resetFields 方法会直接重置为 initialValue 的值，这样再次打开编辑表单就是我们想要的数据啦。</p>
<p>方法二：使用 form.setFieldsValue<br>对于 initialValue 不更新问题官方文档已经给出了解决方法</p>
<h4 id="react-获取上一轮的-props-和-state（接用-useEffect-useRef-实现）"><a href="#react-获取上一轮的-props-和-state（接用-useEffect-useRef-实现）" class="headerlink" title="react 获取上一轮的 props 和 state（接用 useEffect, useRef 实现）"></a>react 获取上一轮的 props 和 state（接用 useEffect, useRef 实现）</h4><p>如果只是 想实现 这个效果 下面的代码 也行 。就不用借助其它的了。 这个思路就是，在 改变 state 之前 就 备份一下 值 。</p>
<p>effect 的执行时机</p>
<p>与 componentDidMount、componentDidUpdate 不同的是，传给 useEffect 的函数会在浏览器完成布局与绘制之后，在一个延迟事件中被调用。这使得它适用于许多常见的副作用场景，比如设置订阅和事件处理等情况，因为绝大多数操作不应阻塞浏览器对屏幕的更新。</p>
<p>然而，并非所有 effect 都可以被延迟执行。例如，一个对用户可见的 DOM 变更就必须在浏览器执行下一次绘制前被同步执行，这样用户才不会感觉到视觉上的不一致。（概念上类似于被动监听事件和主动监听事件的区别。）React 为此提供了一个额外的 useLayoutEffect Hook 来处理这类 effect。它和 useEffect 的结构相同，区别只是调用时机不同。</p>
<p>此外，从 React 18 开始，当它是离散的用户输入（如点击）的结果时，或者当它是由 flushSync 包装的更新结果时，传递给 useEffect 的函数将在屏幕布局和绘制之前同步执行。这种行为便于事件系统或 flushSync 的调用者观察该效果的结果。</p>
<p>注意</p>
<p>这只影响传递给 useEffect 的函数被调用时 — 在这些 effect 中执行的更新仍会被推迟。这与 useLayoutEffect 不同，后者会立即启动该函数并处理其中的更新。</p>
<p>即使在 useEffect 被推迟到浏览器绘制之后的情况下，它也能保证在任何新的渲染前启动。React 在开始新的更新前，总会先刷新之前的渲染的 effect。<br>useRef</p>
<p>useRef 返回一个可变的 ref 对象，其 .current 属性被初始化为传入的参数（initialValue）。返回的 ref 对象在组件的整个生命周期内持续存在。<br>本质上，useRef 就像是可以在其 .current 属性中保存一个可变值的“盒子”。</p>
<p>你应该熟悉 ref 这一种访问 DOM 的主要方式。如果你将 ref 对象以 <code>&lt;div ref=&#123;myRef&#125; /&gt;</code> 形式传入组件，则无论该节点如何改变，React 都会将 ref 对象的 .current 属性设置为相应的 DOM 节点。</p>
<p>然而，useRef() 比 ref 属性更有用。它可以很方便地保存任何可变值，其类似于在 class 中使用实例字段的方式。</p>
<p>这是因为它创建的是一个普通 Javascript 对象。而 useRef() 和自建一个 {current: …} 对象的唯一区别是，useRef 会在每次渲染时返回同一个 ref 对象。</p>
<p>请记住，当 ref 对象内容发生变化时，useRef 并不会通知你。变更 .current 属性不会引发组件重新渲染。如果想要在 React 绑定或解绑 DOM 节点的 ref 时运行某些代码，则需要使用回调 ref 来实现。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Counter</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> prevCountRef = <span class="title function_">useRef</span>();</span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    prevCountRef.<span class="property">current</span> = count;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">const</span> prevCount = prevCountRef.<span class="property">current</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Now: &#123;count&#125;, before: &#123;prevCount&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.baidu.com/2022/10/01/10-12-33/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="KK">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KK">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/01/10-12-33/" class="post-title-link" itemprop="url">Three.js</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-10-01 10:12:33" itemprop="dateCreated datePublished" datetime="2022-10-01T10:12:33+08:00">2022-10-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-05-16 23:50:36" itemprop="dateModified" datetime="2023-05-16T23:50:36+08:00">2023-05-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/web/" itemprop="url" rel="index"><span itemprop="name">web</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><h3 id="创建一个场景"><a href="#创建一个场景" class="headerlink" title="创建一个场景"></a>创建一个场景</h3><p>场景、相机和渲染器</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> scene = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Scene</span>();</span><br><span class="line"><span class="keyword">const</span> camera = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">PerspectiveCamera</span>( <span class="number">75</span>, <span class="variable language_">window</span>.<span class="property">innerWidth</span> / <span class="variable language_">window</span>.<span class="property">innerHeight</span>, <span class="number">0.1</span>, <span class="number">1000</span> );</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> renderer = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">WebGLRenderer</span>();</span><br><span class="line">renderer.<span class="title function_">setSize</span>( <span class="variable language_">window</span>.<span class="property">innerWidth</span>, <span class="variable language_">window</span>.<span class="property">innerHeight</span> );</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>( renderer.<span class="property">domElement</span> );</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>相机：<br>three.js里有几种不同的相机，在这里，我们使用的是PerspectiveCamera（透视摄像机）。</li>
</ul>
<p>第一个参数是视野角度（FOV）。视野角度就是无论在什么时候，你所能在显示器上看到的场景的范围，它的单位是角度(与弧度区分开)。</p>
<p>第二个参数是长宽比（aspect ratio）。 也就是你用一个物体的宽除以它的高的值。比如说，当你在一个宽屏电视上播放老电影时，可以看到图像仿佛是被压扁的。</p>
<p>接下来的两个参数是近截面（near）和远截面（far）。 当物体某些部分比摄像机的远截面远或者比近截面近的时候，该这些部分将不会被渲染到场景中。或许现在你不用担心这个值的影响，但未来为了获得更好的渲染性能，你将可以在你的应用程序里去设置它。</p>
<ul>
<li>渲染器：<br>除了创建一个渲染器的实例之外，我们还需要在我们的应用程序里设置一个渲染器的尺寸。比如说，我们可以使用所需要的渲染区域的宽高，来让渲染器渲染出的场景填充满我们的应用程序。因此，我们可以将渲染器宽高设置为浏览器窗口宽高。对于性能比较敏感的应用程序来说，你可以使用setSize传入一个较小的值，例如window.innerWidth/2和window.innerHeight/2，这将使得应用程序在渲染时，以一半的长宽尺寸渲染场景。</li>
</ul>
<p>如果你希望保持你的应用程序的尺寸，但是以较低的分辨率来渲染，你可以在调用setSize时，将updateStyle（第三个参数）设为false。例如，假设你的<code>&lt;canvas&gt;</code> 标签现在已经具有了100%的宽和高，调用setSize(window.innerWidth/2, window.innerHeight/2, false)将使得你的应用程序以一半的分辨率来进行渲染。</p>
<h3 id="创建一个立方体"><a href="#创建一个立方体" class="headerlink" title="创建一个立方体"></a>创建一个立方体</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> geometry = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">BoxGeometry</span>();</span><br><span class="line"><span class="keyword">const</span> material = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">MeshBasicMaterial</span>( &#123; <span class="attr">color</span>: <span class="number">0x00ff00</span> &#125; );</span><br><span class="line"><span class="keyword">const</span> cube = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Mesh</span>( geometry, material );</span><br><span class="line">scene.<span class="title function_">add</span>( cube );</span><br><span class="line"></span><br><span class="line">camera.<span class="property">position</span>.<span class="property">z</span> = <span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<p>创建一个立方体，我们需要一个BoxGeometry（立方体）对象. 这个对象包含了一个立方体中所有的顶点（vertices）和面（faces）。接下来，对于这个立方体，我们需要给它一个材质，来让它有颜色。第三步，我们需要一个Mesh（网格）。 网格包含一个几何体以及作用在此几何体上的材质，我们可以直接将网格对象放入到我们的场景中，并让它在场景中自由移动。</p>
<h3 id="渲染场景"><a href="#渲染场景" class="headerlink" title="渲染场景"></a>渲染场景</h3><p>现在，如果将之前写好的代码复制到HTML文件中，你不会在页面中看到任何东西。这是因为我们还没有对它进行真正的渲染。为此，我们需要使用一个被叫做“渲染循环”（render loop）或者“动画循环”（animate loop）的东西。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">animate</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="title function_">requestAnimationFrame</span>( animate );</span><br><span class="line"> renderer.<span class="title function_">render</span>( scene, camera );</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">animate</span>();</span><br></pre></td></tr></table></figure>

<p>在这里我们创建了一个使渲染器能够在每次屏幕刷新时对场景进行绘制的循环（在大多数屏幕上，刷新率一般是60次/秒）。如果你是一个浏览器游戏开发的新手，你或许会说“为什么我们不直接用setInterval来实现刷新的功能呢？”当然啦，我们的确可以用setInterval，但是，requestAnimationFrame有很多的优点。最重要的一点或许就是当用户切换到其它的标签页时，它会暂停，因此不会浪费用户宝贵的处理器资源，也不会损耗电池的使用寿命。</p>
<h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h2><h3 id="相机"><a href="#相机" class="headerlink" title="相机"></a>相机</h3><h4 id="Camera"><a href="#Camera" class="headerlink" title="Camera"></a>Camera</h4><h5 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h5><p><code>Camera()</code><br>创建一个新的Camera（摄像机）。注意：这个类并不是被直接调用的；你所想要的或许是一个 PerspectiveCamera（透视摄像机）或者 OrthographicCamera（正交摄像机）。</p>
<h5 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h5><p>共有属性请参见其基类Object3D</p>
<p>.isCamera : Boolean<br>Read-only flag to check if a given object is of type Camera.</p>
<p>.layers : Layers<br>摄像机是一个layers的成员. 这是一个从Object3D继承而来的属性。</p>
<p>当摄像机的视点被渲染的时候，物体必须和当前被看到的摄像机共享至少一个层。</p>
<p>.matrixWorldInverse : Matrix4<br>这是matrixWorld矩阵的逆矩阵。 MatrixWorld包含了相机的世界变换矩阵。</p>
<p>.projectionMatrix : Matrix4<br>这是投影变换矩阵。</p>
<p>.projectionMatrixInverse : Matrix4<br>这是投影变换矩阵的逆矩阵。</p>
<h5 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h5><p>共有方法请参见其基类Object3D。</p>
<p>.clone ( ) : Camera<br>返回一个具有和当前相机的属性一样的新的相机。</p>
<p>.copy ( source : Camera, recursive : Boolean ) : this<br>将源摄像机的属性复制到新摄像机中。</p>
<p>.getWorldDirection ( target : Vector3 ) : Vector3<br>target — 调用该函数的结果将复制给该Vector3对象。</p>
<p>返回一个能够表示当前摄像机所正视的世界空间方向的Vector3对象。 （注意：摄像机俯视时，其Z轴坐标为负。）</p>
<h4 id="透视相机（PerspectiveCamera）"><a href="#透视相机（PerspectiveCamera）" class="headerlink" title="透视相机（PerspectiveCamera）"></a>透视相机（PerspectiveCamera）</h4><p>这一摄像机使用perspective projection（透视投影）来进行投影。</p>
<p>这一投影模式被用来模拟人眼所看到的景象，它是3D场景的渲染中使用得最普遍的投影模式。<br>透视投影相机的四个参数fov, aspect, near, far构成一个四棱台3D空间，被称为视锥体，只有视锥体之内的物体，才会渲染出来，视锥体范围之外的物体不会显示在Canvas画布上。<br>透视投影相机的投影规律是远小近大，通过相机观察阵列立方体大小变化，可以看到距离相机越远，立方体的渲染视觉效果越小。增加相机视角fov，视锥体范围更大，意味着可以看到渲染范围更大，远小近大的视觉效果更明显。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> camera = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">PerspectiveCamera</span>( <span class="number">45</span>, width / height, <span class="number">1</span>, <span class="number">1000</span> );</span><br><span class="line">scene.<span class="title function_">add</span>( camera );</span><br></pre></td></tr></table></figure>

<h5 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h5><p><code>PerspectiveCamera( fov : Number, aspect : Number, near : Number, far : Number )</code><br>fov — 摄像机视锥体垂直视野角度<br>aspect — 摄像机视锥体长宽比,一般设置为Canvas画布宽高比width / height<br>near — 摄像机视锥体近端面<br>far — 摄像机视锥体远端面</p>
<h5 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h5><blockquote>
<p>共有属性请参见其基类 Camera 。</p>
</blockquote>
<p>请注意，在大多数属性发生改变之后，你将需要调用.updateProjectionMatrix来使得这些改变生效。</p>
<p>.aspect : Float<br>摄像机视锥体的长宽比，通常是使用画布的宽/画布的高。默认值是1（正方形画布）。</p>
<p>.far : Float<br>摄像机的远端面，默认值是2000。</p>
<p>该值必须大于near plane（摄像机视锥体近端面）的值。</p>
<p>.filmGauge : Float<br>胶片尺寸，其默认值为35（毫米）。 这个参数不会影响摄像机的投影矩阵，除非.filmOffset被设置为了一个非零的值。</p>
<p>.filmOffset : Float<br>水平偏离中心偏移量，和.filmGauge单位相同。默认值为0。</p>
<p>.focus : Float<br>用于立体视觉和景深效果的物体的距离。 这个参数不会影响摄像机的投影矩阵，除非使用了StereoCamera。 默认值是10。</p>
<p>.fov : Float<br>摄像机视锥体垂直视野角度，从视图的底部到顶部，以角度来表示。默认值是50。</p>
<p>.isPerspectiveCamera : Boolean<br>Read-only flag to check if a given object is of type PerspectiveCamera.</p>
<p>.near : Float<br>摄像机的近端面，默认值是0.1。</p>
<p>其有效值范围是0到当前摄像机far plane（远端面）的值之间。 请注意，和OrthographicCamera不同，0对于PerspectiveCamera的近端面来说不是一个有效值。</p>
<p>.view : Object<br>Frustum window specification or null. 这个值使用.setViewOffset方法来进行设置，使用.clearViewOffset方法来进行清除。</p>
<p>.zoom : number<br>获取或者设置摄像机的缩放倍数，其默认值为1。</p>
<h5 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h5><blockquote>
<p>共有方法请参见其基类Camera。</p>
</blockquote>
<p>.clearViewOffset () : undefined<br>清除任何由.setViewOffset设置的偏移量。</p>
<p>.getEffectiveFOV () : Float<br>结合.zoom（缩放倍数），以角度返回当前垂直视野角度。</p>
<p>.getFilmHeight () : Float<br>返回当前胶片上图像的高，如果.aspect小于或等于1（肖像格式、纵向构图），则结果等于.filmGauge。</p>
<p>.getFilmWidth () : Float<br>返回当前胶片上图像的宽，如果.aspect大于或等于1（景观格式、横向构图），则结果等于.filmGauge。</p>
<p>.getFocalLength () : Float<br>返回当前.fov（视野角度）相对于.filmGauge（胶片尺寸）的焦距。</p>
<p>.setFocalLength ( focalLength : Float ) : undefined<br>通过相对于当前.filmGauge的焦距，设置FOV。</p>
<p>默认情况下，焦距是为35mm（全画幅）摄像机而指定的。</p>
<p>.setViewOffset ( fullWidth : Float, fullHeight : Float, x : Float, y : Float, width : Float, height : Float ) : undefined<br>fullWidth — 多视图的全宽设置<br>fullHeight — 多视图的全高设置<br>x — 副摄像机的水平偏移<br>y — 副摄像机的垂直偏移<br>width — 副摄像机的宽度<br>height — 副摄像机的高度</p>
<p>在较大的viewing frustum（视锥体）中设置偏移量，对于多窗口或者多显示器的设置是很有用的。</p>
<p>例如，如果你有一个3x2的显示器阵列，每个显示器分辨率都是1920x1080，且这些显示器排列成像这样的网格：<br>+—+—+—+<br>| A | B | C |<br>+—+—+—+<br>| D | E | F |<br>+—+—+—+</p>
<p>那对于每个显示器，你可以这样来设置、调用：<br>const w = 1920;<br>const h = 1080;<br>const fullWidth = w <em>3;<br>const fullHeight = h</em> 2;</p>
<p>// A<br>camera.setViewOffset( fullWidth, fullHeight, w <em>0, h</em> 0, w, h );<br>// B<br>camera.setViewOffset( fullWidth, fullHeight, w <em>1, h</em> 0, w, h );<br>// C<br>camera.setViewOffset( fullWidth, fullHeight, w <em>2, h</em> 0, w, h );<br>// D<br>camera.setViewOffset( fullWidth, fullHeight, w <em>0, h</em> 1, w, h );<br>// E<br>camera.setViewOffset( fullWidth, fullHeight, w <em>1, h</em> 1, w, h );<br>// F<br>camera.setViewOffset( fullWidth, fullHeight, w <em>2, h</em> 1, w, h );请注意，显示器的不必具有相同的大小，或者不必在网格中。<br>.updateProjectionMatrix () : undefined<br>更新摄像机投影矩阵。在任何参数被改变以后必须被调用。</p>
<p>.toJSON (meta : Object) : Object<br>meta – 包含有元数据的对象，例如对象后代中的纹理或图像<br>将摄像机转换为 three.js JSON Object/Scene format（three.js JSON 物体/场景格式）。</p>
<h5 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h5><ul>
<li>相机位置.position<br><code>camera.position.set(200, 200, 200);</code></li>
<li>相机观察目标.lookAt()</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//相机观察目标指向Threejs 3D空间中某个位置</span></span><br><span class="line">camera.<span class="title function_">lookAt</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>); <span class="comment">//坐标原点</span></span><br><span class="line">camera.<span class="title function_">lookAt</span>(<span class="number">0</span>, <span class="number">10</span>, <span class="number">0</span>);  <span class="comment">//y轴上位置10</span></span><br><span class="line">camera.<span class="title function_">lookAt</span>(mesh.<span class="property">position</span>);<span class="comment">//指向mesh对应的位置</span></span><br></pre></td></tr></table></figure>

<h4 id="正交相机（OrthographicCamera）"><a href="#正交相机（OrthographicCamera）" class="headerlink" title="正交相机（OrthographicCamera）"></a>正交相机（OrthographicCamera）</h4><p>这一摄像机使用orthographic projection（正交投影）来进行投影。</p>
<p>在这种投影模式下，无论物体距离相机距离远或者近，在最终渲染的图片中物体的大小都保持不变。</p>
<p>这对于渲染2D场景或者UI元素是非常有用的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> camera = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">OrthographicCamera</span>( width / - <span class="number">2</span>, width / <span class="number">2</span>, height / <span class="number">2</span>, height / - <span class="number">2</span>, <span class="number">1</span>, <span class="number">1000</span> );</span><br><span class="line">scene.<span class="title function_">add</span>( camera );</span><br></pre></td></tr></table></figure>

<h5 id="构造器-1"><a href="#构造器-1" class="headerlink" title="构造器"></a>构造器</h5><p>OrthographicCamera( left : Number, right : Number, top : Number, bottom : Number, near : Number, far : Number )<br>left — 摄像机视锥体左侧面。<br>right — 摄像机视锥体右侧面。<br>top — 摄像机视锥体上侧面。<br>bottom — 摄像机视锥体下侧面。<br>near — 摄像机视锥体近端面。<br>far — 摄像机视锥体远端面。</p>
<h5 id="属性-2"><a href="#属性-2" class="headerlink" title="属性"></a>属性</h5><p>共有属性请参见其基类Camera。<br>请注意，在大多数属性发生改变之后，你将需要调用.updateProjectionMatrix来使得这些改变生效。</p>
<p>.bottom : Float<br>摄像机视锥体下侧面。</p>
<p>.far : Float<br>摄像机视锥体远端面，其默认值为2000。</p>
<p>该值必须大于near plane（摄像机视锥体近端面）的值。</p>
<p>.isOrthographicCamera : Boolean<br>Read-only flag to check if a given object is of type OrthographicCamera.</p>
<p>.left : Float<br>摄像机视锥体左侧面。</p>
<p>.near : Float<br>摄像机视锥体近端面。其默认值为0.1.</p>
<p>其值的有效范围介于0和far（摄像机视锥体远端面）之间。<br>请注意，和PerspectiveCamera不同，0对于OrthographicCamera的近端面来说是一个有效值。</p>
<p>.right : Float<br>摄像机视锥体右侧面。</p>
<p>.top : Float<br>摄像机视锥体上侧面。</p>
<p>.view : Object<br>这个值是由setViewOffset来设置的，其默认值为null。</p>
<p>.zoom : number<br>获取或者设置摄像机的缩放倍数，其默认值为1。</p>
<h5 id="方法-2"><a href="#方法-2" class="headerlink" title="方法"></a>方法</h5><p>共有方法请参见其基类Camera。</p>
<p>.setViewOffset ( fullWidth : Float, fullHeight : Float, x : Float, y : Float, width : Float, height : Float ) : undefined<br>fullWidth — 多视图的全宽设置<br>fullHeight — 多视图的全高设置<br>x — 副摄像机的水平偏移<br>y — 副摄像机的垂直偏移<br>width — 副摄像机的宽度<br>height — 副摄像机的高度</p>
<p>在较大的viewing frustum（视锥体）中设置偏移量，对于多窗口或者多显示器的设置是很有用的。 对于如何使用它，请查看PerspectiveCamera中的示例。</p>
<p>.clearViewOffset () : undefined<br>清除任何由.setViewOffset设置的偏移量。</p>
<p>.updateProjectionMatrix () : undefined<br>更新摄像机投影矩阵。在任何参数被改变以后必须被调用。</p>
<p>.toJSON (meta : Object) : Object<br>meta – 包含有元数据的对象，例如对象后代中的纹理或图像<br>将摄像机转换为 three.js JSON Object/Scene format（three.js JSON 物体/场景格式）。</p>
<h4 id="摄像机阵列（ArrayCamera）"><a href="#摄像机阵列（ArrayCamera）" class="headerlink" title="摄像机阵列（ArrayCamera）"></a>摄像机阵列（ArrayCamera）</h4><p>ArrayCamera 用于更加高效地使用一组已经预定义的摄像机来渲染一个场景。这将能够更好地提升VR场景的渲染性能。<br>一个 ArrayCamera 的实例中总是包含着一组子摄像机，应当为每一个子摄像机定义viewport（视口）这个属性，这一属性决定了由该子摄像机所渲染的视口区域的大小。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cameras = [];</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">       <span class="keyword">const</span> subcamera = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">PerspectiveCamera</span>(<span class="number">40</span>, <span class="number">1</span>, <span class="number">0.1</span>, <span class="number">10</span>);</span><br><span class="line">       subcamera.<span class="property">viewport</span> = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Vector4</span>(</span><br><span class="line">         <span class="title class_">Math</span>.<span class="title function_">floor</span>(i * <span class="number">200</span>),</span><br><span class="line">         <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="number">1</span> * <span class="number">200</span>), <span class="comment">//视口高</span></span><br><span class="line">         <span class="title class_">Math</span>.<span class="title function_">ceil</span>(<span class="number">200</span>), <span class="comment">//宽</span></span><br><span class="line">         <span class="title class_">Math</span>.<span class="title function_">ceil</span>(<span class="number">200</span>) <span class="comment">//视口高</span></span><br><span class="line">       );</span><br><span class="line">       subcamera.<span class="property">position</span>.<span class="property">x</span> = i / <span class="number">3</span> - <span class="number">0.5</span>;</span><br><span class="line">       subcamera.<span class="property">position</span>.<span class="property">y</span> = <span class="number">0.5</span> + i;</span><br><span class="line">       subcamera.<span class="property">position</span>.<span class="property">z</span> = <span class="number">1.5</span>;</span><br><span class="line">       subcamera.<span class="property">position</span>.<span class="title function_">multiplyScalar</span>(<span class="number">2</span>);</span><br><span class="line">       subcamera.<span class="title function_">lookAt</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">       subcamera.<span class="title function_">updateMatrixWorld</span>();</span><br><span class="line">       cameras.<span class="title function_">push</span>(subcamera);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">let</span> camera = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">ArrayCamera</span>(cameras);</span><br></pre></td></tr></table></figure>

<h4 id="立方相机（CubeCamera）"><a href="#立方相机（CubeCamera）" class="headerlink" title="立方相机（CubeCamera）"></a>立方相机（CubeCamera）</h4><p>创建6个渲染到WebGLCubeRenderTarget的摄像机<br>构造器<br>CubeCamera( near : Number, far : Number, renderTarget : WebGLCubeRenderTarget )<br>near – 近剪切面的距离<br>far – 远剪切面的距离<br>renderTarget – The destination cube render target.</p>
<p>构造一个包含6个PerspectiveCameras（透视摄像机）的立方摄像机， 并将其拍摄的场景渲染到一个WebGLCubeRenderTarget上。</p>
<h4 id="立体相机（StereoCamera）"><a href="#立体相机（StereoCamera）" class="headerlink" title="立体相机（StereoCamera）"></a>立体相机（StereoCamera）</h4><p>双透视摄像机（立体相机）常被用于创建3D Anaglyph（3D立体影像） 或者Parallax Barrier（视差屏障）。</p>
<h3 id="几何体"><a href="#几何体" class="headerlink" title="几何体"></a>几何体</h3><h4 id="缓冲属性BufferAttribute"><a href="#缓冲属性BufferAttribute" class="headerlink" title="缓冲属性BufferAttribute"></a>缓冲属性BufferAttribute</h4><p>这个类用于存储与BufferGeometry相关联的 attribute（例如顶点位置向量，面片索引，法向量，颜色值，UV坐标以及任何自定义 attribute ）。 利用 BufferAttribute，可以更高效的向GPU传递数据。</p>
<blockquote>
<p>在 BufferAttribute 中，数据被存储为任意长度的矢量（通过itemSize进行定义），下列函数如无特别说明， 函数参数中的index会自动乘以矢量长度进行计算。 当想要处理类似向量的数据时， 可以使用在Vector2，Vector3， Vector4以及Color这些类中的.fromBufferAttribute( attribute, index ) 方法来更为便捷地处理。</p>
</blockquote>
<h5 id="构造函数-1"><a href="#构造函数-1" class="headerlink" title="构造函数"></a>构造函数</h5><p><code>BufferAttribute( array : TypedArray, itemSize : Integer, normalized : Boolean )</code><br>array – 必须是 TypedArray. 类型，用于实例化缓存。<br>该队列应该包含：<code>itemSize * numVertices</code>个元素，numVertices 是 BufferGeometry中的顶点数目</p>
<p>itemSize – 队列中与顶点相关的数据值的大小。举例，如果 attribute 存储的是三元组（例如顶点空间坐标、法向量或颜色值）则itemSize的值应该是3。</p>
<p>normalized – (可选) 指明缓存中的数据如何与GLSL代码中的数据对应。例如，如果array是 UInt16Array类型，且normalized的值是 true，则队列中的值将会从 0 - +65535 映射为 GLSL 中的 0.0f - +1.0f。 如果array是 Int16Array (有符号)，则值将会从 -32768 - +32767 映射为 -1.0f - +1.0f。若 normalized 的值为 false，则数据映射不会归一化，而会直接映射为 float 值，例如，32767 将会映射为 32767.0f.</p>
<h5 id="属性-3"><a href="#属性-3" class="headerlink" title="属性"></a>属性</h5><ul>
<li><p><code>.array</code> : TypedArray<br>在 array 中保存着缓存中的数据。</p>
</li>
<li><p><code>.count</code> : Integer<br>保存 array 除以 itemSize 之后的大小。若缓存存储三元组（例如顶点位置、法向量、颜色值），则该值应等于队列中三元组的个数。</p>
</li>
<li><p><code>.isBufferAttribute</code> : Boolean<br>用于判断对象是否为BufferAttribute类型的只读标记.</p>
</li>
</ul>
<p><code>.itemSize</code> : Integer<br>保存在 array 中矢量的长度。</p>
<ul>
<li><p><code>.name</code> : String<br>该 attribute 实例的别名，默认值为空字符串。</p>
</li>
<li><p><code>.needsUpdate</code> : Boolean<br>该标志位指明当前 attribute 已经被修改过，且需要再次送入 GPU 处理。当开发者改变了该队列的值，则标志位需要设置为 true。</p>
</li>
</ul>
<p>将标志位设为 true 同样会增加 version 的值。</p>
<ul>
<li><p><code>.normalized</code> : Boolean<br>指明缓存中数据在转化为GLSL着色器代码中数据时是否需要被归一化。详见构造函数中的说明。</p>
</li>
<li><p><code>.onUploadCallback</code> : Function<br>attribute 数据传输到GPU后的回调函数。</p>
</li>
<li><p><code>.updateRange</code> : Object<br>对象包含如下成员:<br>offset: 默认值为 0。 指明更新的起始位置。<br>count: 默认值为 -1，表示不指定更新范围。</p>
</li>
</ul>
<p>该值只可以被用于更新某些矢量数据（例如，颜色相关数据）。</p>
<ul>
<li><p><code>.usage</code> : Usage<br>为输入的数据定义最优的预估使用方式。等同于在WebGLRenderingContext.bufferData() 中的usage参数。默认为StaticDrawUsage。在usage constants中查看可用值。</p>
</li>
<li><p><code>.version</code> : Integer<br>版本号，当 needsUpdate 被设置为 true 时，该值会自增。</p>
</li>
</ul>
<h5 id="方法-3"><a href="#方法-3" class="headerlink" title="方法"></a>方法</h5><ul>
<li><p><code>.applyMatrix3 ( m : Matrix3 ) : this</code><br>将矩阵m应用此BufferAttribute中的每一个Vector3元素中。</p>
</li>
<li><p><code>.applyMatrix4 ( m : Matrix4 ) : this</code><br>将矩阵m应用到此BufferAttribute的每一个Vector3元素中</p>
</li>
<li><p><code>.applyNormalMatrix ( m : Matrix3 ) : this</code><br>将正规矩阵m应用到此BufferAttribute的每一个Vector3元素中</p>
</li>
<li><p><code>.transformDirection ( m : Matrix4 ) : this</code><br>将矩阵m应用到此BufferAttribute的每一个Vector3元素中，并将所有元素解释为方向向量。</p>
</li>
<li><p><code>.clone () : BufferAttribute</code><br>返回该 BufferAttribute 的拷贝。</p>
</li>
<li><p><code>.copyArray ( array ) : this</code><br>将参数中所给定的普通队列或 TypedArray 拷贝到 array 中。</p>
</li>
</ul>
<p>拷贝 TypedArray 相关注意事项详见 TypedArray.set。</p>
<ul>
<li><p><code>.copyAt ( index1 : Integer, bufferAttribute : BufferAttribute, index2 : Integer ) : this</code><br>将一个矢量从 <code>bufferAttribute[index2]</code> 拷贝到 <code>array[index1]</code> 中。</p>
</li>
<li><p><code>.getX ( index : Integer ) : Number</code><br>获取给定索引的矢量的第一维元素 （即 X 值）。</p>
</li>
<li><p><code>.getY ( index : Integer ) : Number</code><br>获取给定索引的矢量的第二维元素 （即 Y 值）。</p>
</li>
<li><p><code>.getZ ( index : Integer ) : Number</code><br>获取给定索引的矢量的第三维元素 （即 Z 值）。</p>
</li>
<li><p><code>.getW ( index : Integer ) : Number</code><br>获取给定索引的矢量的第四维元素 （即 W 值）。</p>
</li>
<li><p><code>.onUpload ( callback : Function ) : this</code><br>见 onUploadCallback 属性。</p>
</li>
</ul>
<p>在 WebGL / Buffergeometry 中，该方在缓存数据传递给 GPU 后，用于释放内存。</p>
<ul>
<li><code>.set ( value : Array, offset : Integer ) : this</code><br>value – 被拷贝的 Array 或 TypedArray 类型的数据。<br>offset – (可选) array 中开始拷贝的位置索引。</li>
</ul>
<p>对 array，调用 TypedArray.set( value, offset ) 方法。</p>
<p>特别的, 对将 value 转为 TypedArray 的要求详见上述链接。</p>
<ul>
<li><p><code>.setUsage ( value : Usage ) : this</code><br>Set usage to value. See usage constants for all possible input values.</p>
</li>
<li><p><code>.setX ( index : Integer, x : Float ) : this</code><br>设置给定索引的矢量的第一维数据（设置 X 值）。</p>
</li>
<li><p><code>.setY ( index : Integer, y : Float ) : this</code><br>设置给定索引的矢量的第二维数据（设置 Y 值）。</p>
</li>
<li><p><code>.setZ ( index : Integer, z : Float ) : this</code><br>设置给定索引的矢量的第三维数据（设置 Z 值）。</p>
</li>
<li><p><code>.setW ( index : Integer, w : Float ) : this</code><br>设置给定索引的矢量的第四维数据（设置 W 值）。</p>
</li>
<li><p><code>.setXY ( index : Integer, x : Float, y : Float ) : this</code><br>设置给定索引的矢量的第一、二维数据（设置 X 和 Y 值）。</p>
</li>
<li><p><code>.setXYZ ( index : Integer, x : Float, y : Float, z : Float ) : this</code><br>设置给定索引的矢量的第一、二、三维数据（设置 X、Y 和 Z 值）。</p>
</li>
<li><p><code>.setXYZW ( index : Integer, x : Float, y : Float, z : Float, w : Float ) : this</code><br>设置给定索引的矢量的第一、二、三、四维数据（设置 X、Y、Z 和 W 值）。</p>
</li>
</ul>
<h4 id="缓冲几何体BufferGeometry"><a href="#缓冲几何体BufferGeometry" class="headerlink" title="缓冲几何体BufferGeometry"></a>缓冲几何体BufferGeometry</h4><p>是面片、线或点几何体的有效表述。包括顶点位置，面片索引、法相量、颜色值、UV 坐标和自定义缓存属性值。使用 BufferGeometry 可以有效减少向 GPU 传输上述数据所需的开销。<br>BufferGeometry是一个没有任何形状的空几何体，你可以通过BufferGeometry自定义任何几何形状</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> geometry = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">BufferGeometry</span>();</span><br><span class="line"><span class="comment">// 创建一个简单的矩形. 在这里我们左上和右下顶点被复制了两次。</span></span><br><span class="line"><span class="comment">// 因为在两个三角面片里，这两个顶点都需要被用到。</span></span><br><span class="line"><span class="comment">//通过javascript类型化数组 Float32Array创建一组xyz坐标数据用来表示几何体的顶点坐标</span></span><br><span class="line"><span class="keyword">const</span> vertices = <span class="keyword">new</span> <span class="title class_">Float32Array</span>( [</span><br><span class="line"> -<span class="number">1.0</span>, -<span class="number">1.0</span>,  <span class="number">1.0</span>,</span><br><span class="line">  <span class="number">1.0</span>, -<span class="number">1.0</span>,  <span class="number">1.0</span>,</span><br><span class="line">  <span class="number">1.0</span>,  <span class="number">1.0</span>,  <span class="number">1.0</span>,</span><br><span class="line"></span><br><span class="line">  <span class="number">1.0</span>,  <span class="number">1.0</span>,  <span class="number">1.0</span>,</span><br><span class="line"> -<span class="number">1.0</span>,  <span class="number">1.0</span>,  <span class="number">1.0</span>,</span><br><span class="line"> -<span class="number">1.0</span>, -<span class="number">1.0</span>,  <span class="number">1.0</span></span><br><span class="line">] );</span><br><span class="line"><span class="comment">// 创建属性缓冲区对象</span></span><br><span class="line"><span class="comment">// itemSize = 3 因为每个顶点都是一个三元组。</span></span><br><span class="line"><span class="comment">//3个为一组，表示一个顶点的xyz坐标</span></span><br><span class="line">geometry.<span class="title function_">setAttribute</span>( <span class="string">&#x27;position&#x27;</span>, <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">BufferAttribute</span>( vertices, <span class="number">3</span> ) );<span class="comment">//设置几何体顶点</span></span><br><span class="line"><span class="keyword">const</span> material = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">MeshBasicMaterial</span>( &#123; <span class="attr">color</span>: <span class="number">0xff0000</span> &#125; );</span><br><span class="line"><span class="keyword">const</span> mesh = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Mesh</span>( geometry, material );</span><br></pre></td></tr></table></figure>

<h5 id="构造函数-2"><a href="#构造函数-2" class="headerlink" title="构造函数"></a>构造函数</h5><p><code>BufferGeometry()</code>创建一个新的 BufferGeometry. 同时将预置属性设置为默认值.</p>
<h5 id="属性-4"><a href="#属性-4" class="headerlink" title="属性"></a>属性</h5><ul>
<li><p><code>.attributes</code> : Object<br>通过 hashmap 存储该几何体相关的属性，hashmap 的 id 是当前 attribute 的名称，值是相应的 buffer。 你可以通过 <code>.setAttribute</code> 和 <code>.getAttribute</code> 添加和访问与当前几何体有关的 attribute。</p>
</li>
<li><p><code>.boundingBox</code> : Box3<br>当前 bufferGeometry 的外边界矩形。可以通过 .computeBoundingBox() 计算。默认值是 null。</p>
</li>
<li><p><code>.boundingSphere</code> : Sphere<br>当前 bufferGeometry 的外边界球形。可以通过 .computeBoundingSphere() 计算。默认值是 null。</p>
</li>
<li><p><code>.drawRange</code> : Object<br>用于判断几何体的哪个部分需要被渲染。该值不应该直接被设置，而需要通过 .setDrawRange 进行设置。默认值为<code>&#123; start: 0, count: Infinity &#125;</code></p>
</li>
<li><p><code>.groups</code> : Array<br>将当前几何体分割成组进行渲染，每个部分都会在单独的 WebGL 的 draw call 中进行绘制。该方法可以让当前的 bufferGeometry 可以使用一个材质队列进行描述。分割后的每个部分都是一个如下的表单：<code>&#123; start: Integer, count: Integer, materialIndex: Integer &#125;</code>start 表明当前 draw call 中的没有索引的几何体的几何体的第一个顶点；或者第一个三角面片的索引。 count 指明当前分割包含多少顶点（或 indices）。 materialIndex 指出当前用到的材质队列的索引。通过 <code>.addGroup</code> 来增加组，而不是直接更改当前队列。</p>
</li>
<li><p><code>.id</code> : Integer<br>当前 bufferGeometry 的唯一编号。</p>
</li>
<li><p><code>.index</code> : BufferAttribute<br>允许顶点在多个三角面片间可以重用。这样的顶点被称为”已索引的三角面片(indexed triangles)。 每个三角面片都和三个顶点的索引相关。该 attribute 因此所存储的是每个三角面片的三个顶点的索引。 如果该 attribute 没有设置过，则 renderer 假设每三个连续的位置代表一个三角面片。 默认值是 null。</p>
</li>
</ul>
<p><code>.isBufferGeometry</code> : Boolean<br>用于判断对象是否为BufferGeometry的只读标记.</p>
<p><code>.morphAttributes</code> : Object<br>存储 BufferAttribute 的 Hashmap，存储了几何体 morph targets 的细节信息。<br>注意：当这个geometry渲染之后，morph attribute 数据无法更改。你需要调用.dispose()，并重新创建一个新的BufferGeometry实例。</p>
<p><code>.morphTargetsRelative</code> : Boolean<br>用于控制morph target的行为，如果设置为 true，morph target数据作为相对的偏移量，而非绝对的位置/法向。 默认为false。</p>
<p><code>.name</code> : String<br>当前 bufferGeometry 实例的可选别名。默认值是空字符串。</p>
<p><code>.userData</code> : Object<br>存储 BufferGeometry 的自定义数据的对象。为保持对象在克隆时完整，该对象不应该包括任何函数的引用。</p>
<p><code>.uuid</code> : String<br>当前对象实例的 UUID，该值会自动被分配，且不应被修改。</p>
<h5 id="方法-4"><a href="#方法-4" class="headerlink" title="方法"></a>方法</h5><blockquote>
<p>EventDispatcher 在该类上可用的所有方法。</p>
</blockquote>
<ul>
<li><p><code>.setAttribute ( name : String, attribute : BufferAttribute ) : this</code><br>为当前几何体设置一个 attribute 属性。在类的内部，有一个存储 .attributes 的 hashmap， 通过该 hashmap，遍历 attributes 的速度会更快。而使用该方法，可以向 hashmap 内部增加 attribute。 所以，你需要使用该方法来添加 attributes。</p>
</li>
<li><p><code>.addGroup ( start : Integer, count : Integer, materialIndex : Integer ) : undefined</code><br>为当前几何体增加一个 group，详见 groups 属性。</p>
</li>
<li><p><code>.applyMatrix4 ( matrix : Matrix4 ) : this</code><br>用给定矩阵转换几何体的顶点坐标。</p>
</li>
<li><p><code>.center () : this</code><br>根据边界矩形将几何体居中。</p>
</li>
<li><p><code>.clone () : BufferGeometrya</code><br>克隆当前的 BufferGeometry。</p>
</li>
<li><p><code>.copy ( bufferGeometry : BufferGeometry ) : this</code><br>将参数指定的 BufferGeometry 的值拷贝到当前 BufferGeometry 中。</p>
</li>
<li><p><code>.clearGroups ( ) : undefined</code><br>清空所有的 groups。</p>
</li>
<li><p><code>.computeBoundingBox () : undefined</code><br>计算当前几何体的的边界矩形，该操作会更新已有 <code>[param:.boundingBox]</code>。<br>边界矩形不会默认计算，需要调用该接口指定计算边界矩形，否则保持默认值 null。</p>
</li>
<li><p><code>.computeBoundingSphere () : undefined</code><br>计算当前几何体的的边界球形，该操作会更新已有 <code>[param:.boundingSphere]</code>。<br>边界球形不会默认计算，需要调用该接口指定计算边界球形，否则保持默认值 null。</p>
</li>
<li><p><code>.computeTangents () : undefined</code><br>计算并向此geometry中添加tangent attribute。<br>只支持索引化的几何体对象，并且必须拥有position(位置)，normal(法向)和 uv attributes。如果使用了切线空间法向贴图，最好使用BufferGeometryUtils.computeMikkTSpaceTangents中的MikkTSpace算法。</p>
</li>
<li><p><code>.computeVertexNormals () : undefined</code><br>通过面片法向量的平均值计算每个顶点的法向量。</p>
</li>
</ul>
<p><code>.dispose () : undefined</code><br>从内存中销毁对象。<br>如果在运行时需要从内存中删除 BufferGeometry，则需要调用该函数。</p>
<p><code>.getAttribute ( name : String ) : BufferAttribute</code><br>返回指定名称的 attribute。</p>
<p><code>.getIndex () : BufferAttribute</code><br>返回缓存相关的 .index。</p>
<p><code>.hasAttribute ( name : String ) : Boolean</code><br>检查是否存在有指定名称的attribute，如果有返回true。</p>
<p><code>.lookAt ( vector : Vector3 ) : this</code><br>vector - 几何体所朝向的世界坐标。</p>
<p>旋转几何体朝向控件中的一点。该过程通常在一次处理中完成，不会循环处理。典型的用法是过通过调用 Object3D.lookAt 实时改变 mesh 朝向。</p>
<p><code>.normalizeNormals () : undefined</code><br>几何体中的每个法向量长度将会为 1。这样操作会更正光线在表面的效果。</p>
<p><code>.deleteAttribute ( name : String ) : BufferAttribute</code><br>删除具有指定名称的 attribute。</p>
<p><code>.rotateX ( radians : Float ) : this</code><br>在 X 轴上旋转几何体。该操作一般在一次处理中完成，不会循环处理。典型的用法是通过调用 Object3D.rotation 实时旋转几何体。</p>
<p><code>.rotateY ( radians : Float ) : this</code><br>在 Y 轴上旋转几何体。该操作一般在一次处理中完成，不会循环处理。典型的用法是通过调用 Object3D.rotation 实时旋转几何体。</p>
<p><code>.rotateZ ( radians : Float ) : this</code><br>在 Z 轴上旋转几何体。该操作一般在一次处理中完成，不会循环处理。典型的用法是通过调用 Object3D.rotation 实时旋转几何体。</p>
<p><code>.scale ( x : Float, y : Float, z : Float ) : this</code><br>缩放几何体。该操作一般在一次处理中完成，不会循环处理。典型的用法是通过调用 Object3D.scale 实时旋转几何体。</p>
<p><code>.setIndex ( index : BufferAttribute ) : this</code><br>设置缓存的 .index。</p>
<p><code>.setDrawRange ( start : Integer, count : Integer ) : undefined</code><br>设置缓存的 .drawRange。详见相关属性说明。</p>
<p><code>.setFromPoints ( points : Array ) : this</code><br>通过点队列设置该 BufferGeometry 的 attribute。</p>
<p><code>.toJSON () : Object</code><br>返回代表该 BufferGeometry 的 JSON 对象。</p>
<p><code>.toNonIndexed () : BufferGeometry</code><br>返回已索引的 BufferGeometry 的非索引版本。</p>
<p><code>.translate ( x : Float, y : Float, z : Float ) : this</code><br>移动几何体。该操作一般在一次处理中完成，不会循环处理。典型的用法是通过调用 Object3D.rotation 实时旋转几何体。</p>
<h4 id="立方体（BoxGeometry）"><a href="#立方体（BoxGeometry）" class="headerlink" title="立方体（BoxGeometry）"></a>立方体（BoxGeometry）</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> geometry = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">BoxGeometry</span>( <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span> );</span><br><span class="line"><span class="keyword">const</span> material = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">MeshBasicMaterial</span>( &#123;<span class="attr">color</span>: <span class="number">0x00ff00</span>&#125; );</span><br><span class="line"><span class="keyword">const</span> cube = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Mesh</span>( geometry, material );</span><br><span class="line">scene.<span class="title function_">add</span>( cube );</span><br></pre></td></tr></table></figure>

<h5 id="构造器-2"><a href="#构造器-2" class="headerlink" title="构造器"></a>构造器</h5><p><code>BoxGeometry(width : Float, height : Float, depth : Float, widthSegments : Integer, heightSegments : Integer, depthSegments : Integer)</code><br>width — X轴上面的宽度，默认值为1。<br>height — Y轴上面的高度，默认值为1。<br>depth — Z轴上面的深度，默认值为1。<br>widthSegments — （可选）宽度的分段数，默认值是1。<br>heightSegments — （可选）高度的分段数，默认值是1。<br>depthSegments — （可选）深度的分段数，默认值是1。</p>
<h5 id="属性-方法"><a href="#属性-方法" class="headerlink" title="属性|方法"></a>属性|方法</h5><blockquote>
<p>共有方法请参见其基类BufferGeometry。<br>共有属性请参见其基类BufferGeometry。</p>
</blockquote>
<p><code>.parameters</code> : Object<br>一个包含着构造函数中每个参数的对象。在对象实例化之后，对该属性的任何修改都不会改变这个几何体。</p>
<h4 id="圆形（CircleGeometry）"><a href="#圆形（CircleGeometry）" class="headerlink" title="圆形（CircleGeometry）"></a>圆形（CircleGeometry）</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> geometry = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">CircleGeometry</span>( <span class="number">5</span>, <span class="number">32</span> );</span><br><span class="line"><span class="keyword">const</span> material = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">MeshBasicMaterial</span>( &#123; <span class="attr">color</span>: <span class="number">0xffff00</span> &#125; );</span><br><span class="line"><span class="keyword">const</span> circle = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Mesh</span>( geometry, material );</span><br><span class="line">scene.<span class="title function_">add</span>( circle );</span><br></pre></td></tr></table></figure>

<h5 id="构造器-3"><a href="#构造器-3" class="headerlink" title="构造器"></a>构造器</h5><p><code>CircleGeometry(radius : Float, segments : Integer, thetaStart : Float, thetaLength : Float)</code><br>radius — 圆形的半径，默认值为1<br>segments — 分段（三角面）的数量，最小值为3，默认值为32。<br>thetaStart — 第一个分段的起始角度，默认为0。（three o’clock position）<br>thetaLength — 圆形扇区的中心角，通常被称为“θ”（西塔）。默认值是2*Pi，这使其成为一个完整的圆。</p>
<h5 id="属性-方法-1"><a href="#属性-方法-1" class="headerlink" title="属性|方法"></a>属性|方法</h5><blockquote>
<p>共有方法请参见其基类BufferGeometry。<br>共有属性请参见其基类BufferGeometry。</p>
</blockquote>
<p><code>.parameters</code> : Object<br>一个包含着构造函数中每个参数的对象。在对象实例化之后，对该属性的任何修改都不会改变这个几何体。</p>
<h4 id="平面（PlaneGeometry）"><a href="#平面（PlaneGeometry）" class="headerlink" title="平面（PlaneGeometry）"></a>平面（PlaneGeometry）</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> geometry = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">PlaneGeometry</span>( <span class="number">1</span>, <span class="number">1</span> );</span><br><span class="line"><span class="keyword">const</span> material = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">MeshBasicMaterial</span>( &#123;<span class="attr">color</span>: <span class="number">0xffff00</span>, <span class="attr">side</span>: <span class="variable constant_">THREE</span>.<span class="property">DoubleSide</span>&#125; );</span><br><span class="line"><span class="keyword">const</span> plane = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Mesh</span>( geometry, material );</span><br><span class="line">scene.<span class="title function_">add</span>( plane );</span><br></pre></td></tr></table></figure>

<h5 id="构造器-4"><a href="#构造器-4" class="headerlink" title="构造器"></a>构造器</h5><p><code>PlaneGeometry(width : Float, height : Float, widthSegments : Integer, heightSegments : Integer)</code><br>width — 平面沿着X轴的宽度。默认值是1。<br>height — 平面沿着Y轴的高度。默认值是1。<br>widthSegments — （可选）平面的宽度分段数，默认值是1。<br>heightSegments — （可选）平面的高度分段数，默认值是1。</p>
<h5 id="属性-方法-2"><a href="#属性-方法-2" class="headerlink" title="属性|方法"></a>属性|方法</h5><blockquote>
<p>共有方法请参见其基类BufferGeometry。<br>共有属性请参见其基类BufferGeometry。</p>
</blockquote>
<p><code>.parameters</code> : Object<br>一个包含着构造函数中每个参数的对象。在对象实例化之后，对该属性的任何修改都不会改变这个几何体。</p>
<h4 id="圆柱（CylinderGeometry）"><a href="#圆柱（CylinderGeometry）" class="headerlink" title="圆柱（CylinderGeometry）"></a>圆柱（CylinderGeometry）</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> geometry = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">CylinderGeometry</span>( <span class="number">5</span>, <span class="number">5</span>, <span class="number">20</span>, <span class="number">32</span> );</span><br><span class="line"><span class="keyword">const</span> material = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">MeshBasicMaterial</span>( &#123;<span class="attr">color</span>: <span class="number">0xffff00</span>&#125; );</span><br><span class="line"><span class="keyword">const</span> cylinder = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Mesh</span>( geometry, material );</span><br><span class="line">scene.<span class="title function_">add</span>( cylinder );</span><br></pre></td></tr></table></figure>

<h5 id="构造器-5"><a href="#构造器-5" class="headerlink" title="构造器"></a>构造器</h5><p><code>CylinderGeometry(radiusTop : Float, radiusBottom : Float, height : Float, radialSegments : Integer, heightSegments : Integer, openEnded : Boolean, thetaStart : Float, thetaLength : Float)</code><br>radiusTop — 圆柱的顶部半径，默认值是1。<br>radiusBottom — 圆柱的底部半径，默认值是1。<br>height — 圆柱的高度，默认值是1。<br>radialSegments — 圆柱侧面周围的分段数，默认为32。<br>heightSegments — 圆柱侧面沿着其高度的分段数，默认值为1。<br>openEnded — 一个Boolean值，指明该圆锥的底面是开放的还是封顶的。默认值为false，即其底面默认是封顶的。<br>thetaStart — 第一个分段的起始角度，默认为0。（three o’clock position）<br>thetaLength — 圆柱底面圆扇区的中心角，通常被称为“θ”（西塔）。默认值是2*Pi，这使其成为一个完整的圆柱。</p>
<h5 id="属性-方法-3"><a href="#属性-方法-3" class="headerlink" title="属性|方法"></a>属性|方法</h5><blockquote>
<p>共有方法请参见其基类BufferGeometry。<br>共有属性请参见其基类BufferGeometry。</p>
</blockquote>
<p><code>.parameters</code> : Object<br>一个包含着构造函数中每个参数的对象。在对象实例化之后，对该属性的任何修改都不会改变这个几何体。</p>
<h4 id="挤压（ExtrudeGeometry）"><a href="#挤压（ExtrudeGeometry）" class="headerlink" title="挤压（ExtrudeGeometry）"></a>挤压（ExtrudeGeometry）</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> length = <span class="number">12</span>, width = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> shape = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Shape</span>();</span><br><span class="line">shape.<span class="title function_">moveTo</span>( <span class="number">0</span>,<span class="number">0</span> );</span><br><span class="line">shape.<span class="title function_">lineTo</span>( <span class="number">0</span>, width );</span><br><span class="line">shape.<span class="title function_">lineTo</span>( length, width );</span><br><span class="line">shape.<span class="title function_">lineTo</span>( length, <span class="number">0</span> );</span><br><span class="line">shape.<span class="title function_">lineTo</span>( <span class="number">0</span>, <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> extrudeSettings = &#123;</span><br><span class="line"> <span class="attr">steps</span>: <span class="number">2</span>,</span><br><span class="line"> <span class="attr">depth</span>: <span class="number">16</span>,</span><br><span class="line"> <span class="attr">bevelEnabled</span>: <span class="literal">true</span>,</span><br><span class="line"> <span class="attr">bevelThickness</span>: <span class="number">1</span>,</span><br><span class="line"> <span class="attr">bevelSize</span>: <span class="number">1</span>,</span><br><span class="line"> <span class="attr">bevelOffset</span>: <span class="number">0</span>,</span><br><span class="line"> <span class="attr">bevelSegments</span>: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> geometry = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">ExtrudeGeometry</span>( shape, extrudeSettings );</span><br><span class="line"><span class="keyword">const</span> material = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">MeshBasicMaterial</span>( &#123; <span class="attr">color</span>: <span class="number">0x00ff00</span> &#125; );</span><br><span class="line"><span class="keyword">const</span> mesh = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Mesh</span>( geometry, material ) ;</span><br><span class="line">scene.<span class="title function_">add</span>( mesh );</span><br></pre></td></tr></table></figure>

<h5 id="构造器-6"><a href="#构造器-6" class="headerlink" title="构造器"></a>构造器</h5><p><code>ExtrudeGeometry(shapes : Array, options : Object)</code><br>shapes — 形状或者一个包含形状的数组。<br>options — 一个包含有下列参数的对象：</p>
<p>curveSegments — int，曲线上点的数量，默认值是12。<br>steps — int，用于沿着挤出样条的深度细分的点的数量，默认值为1。<br>depth — float，挤出的形状的深度，默认值为1。<br>bevelEnabled — bool，对挤出的形状应用是否斜角，默认值为true。<br>bevelThickness — float，设置原始形状上斜角的厚度。默认值为0.2。<br>bevelSize — float。斜角与原始形状轮廓之间的延伸距离，默认值为bevelThickness-0.1。<br>bevelOffset — float. Distance from the shape outline that the bevel starts. Default is 0.<br>bevelSegments — int。斜角的分段层数，默认值为3。<br>extrudePath — THREE.Curve对象。一条沿着被挤出形状的三维样条线。Bevels not supported for path extrusion.<br>UVGenerator — Object。提供了UV生成器函数的对象。<br>该对象将一个二维形状挤出为一个三维几何体。</p>
<p>当使用这个几何体创建Mesh的时候，如果你希望分别对它的表面和它挤出的侧面使用单独的材质，你可以使用一个材质数组。 第一个材质将用于其表面；第二个材质则将用于其挤压出的侧面。##### 属性|方法</p>
<blockquote>
<p>共有方法请参见其基类BufferGeometry。<br>共有属性请参见其基类BufferGeometry。</p>
</blockquote>
<p><code>.parameters</code> : Object<br>一个包含着构造函数中每个参数的对象。在对象实例化之后，对该属性的任何修改都不会改变这个几何体。</p>
<h4 id="形状（ShapeGeometry）"><a href="#形状（ShapeGeometry）" class="headerlink" title="形状（ShapeGeometry）"></a>形状（ShapeGeometry）</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> heartShape = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Shape</span>();</span><br><span class="line"></span><br><span class="line">heartShape.<span class="title function_">moveTo</span>( x + <span class="number">5</span>, y + <span class="number">5</span> );</span><br><span class="line">heartShape.<span class="title function_">bezierCurveTo</span>( x + <span class="number">5</span>, y + <span class="number">5</span>, x + <span class="number">4</span>, y, x, y );</span><br><span class="line">heartShape.<span class="title function_">bezierCurveTo</span>( x - <span class="number">6</span>, y, x - <span class="number">6</span>, y + <span class="number">7</span>,x - <span class="number">6</span>, y + <span class="number">7</span> );</span><br><span class="line">heartShape.<span class="title function_">bezierCurveTo</span>( x - <span class="number">6</span>, y + <span class="number">11</span>, x - <span class="number">3</span>, y + <span class="number">15.4</span>, x + <span class="number">5</span>, y + <span class="number">19</span> );</span><br><span class="line">heartShape.<span class="title function_">bezierCurveTo</span>( x + <span class="number">12</span>, y + <span class="number">15.4</span>, x + <span class="number">16</span>, y + <span class="number">11</span>, x + <span class="number">16</span>, y + <span class="number">7</span> );</span><br><span class="line">heartShape.<span class="title function_">bezierCurveTo</span>( x + <span class="number">16</span>, y + <span class="number">7</span>, x + <span class="number">16</span>, y, x + <span class="number">10</span>, y );</span><br><span class="line">heartShape.<span class="title function_">bezierCurveTo</span>( x + <span class="number">7</span>, y, x + <span class="number">5</span>, y + <span class="number">5</span>, x + <span class="number">5</span>, y + <span class="number">5</span> );</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> geometry = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">ShapeGeometry</span>( heartShape );</span><br><span class="line"><span class="keyword">const</span> material = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">MeshBasicMaterial</span>( &#123; <span class="attr">color</span>: <span class="number">0x00ff00</span> &#125; );</span><br><span class="line"><span class="keyword">const</span> mesh = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Mesh</span>( geometry, material ) ;</span><br><span class="line">scene.<span class="title function_">add</span>( mesh );</span><br></pre></td></tr></table></figure>

<h5 id="构造器-7"><a href="#构造器-7" class="headerlink" title="构造器"></a>构造器</h5><p><code>ShapeGeometry(shapes : Array, curveSegments : Integer)</code><br>shapes — 一个单独的shape，或者一个包含形状的Array。Default is a single triangle shape.<br>curveSegments - Integer - 每一个形状的分段数，默认值为12。</p>
<h5 id="属性-方法-4"><a href="#属性-方法-4" class="headerlink" title="属性|方法"></a>属性|方法</h5><blockquote>
<p>共有方法请参见其基类BufferGeometry。<br>共有属性请参见其基类BufferGeometry。</p>
</blockquote>
<p><code>.parameters</code> : Object<br>一个包含着构造函数中每个参数的对象。在对象实例化之后，对该属性的任何修改都不会改变这个几何体。</p>
<h4 id="圆环（RingGeometry）"><a href="#圆环（RingGeometry）" class="headerlink" title="圆环（RingGeometry）"></a>圆环（RingGeometry）</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> geometry = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">RingGeometry</span>( <span class="number">1</span>, <span class="number">5</span>, <span class="number">32</span> );</span><br><span class="line"><span class="keyword">const</span> material = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">MeshBasicMaterial</span>( &#123; <span class="attr">color</span>: <span class="number">0xffff00</span>, <span class="attr">side</span>: <span class="variable constant_">THREE</span>.<span class="property">DoubleSide</span> &#125; );</span><br><span class="line"><span class="keyword">const</span> mesh = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Mesh</span>( geometry, material );</span><br><span class="line">scene.<span class="title function_">add</span>( mesh );</span><br></pre></td></tr></table></figure>

<h5 id="构造器-8"><a href="#构造器-8" class="headerlink" title="构造器"></a>构造器</h5><p><code>RingGeometry(innerRadius : Float, outerRadius : Float, thetaSegments : Integer, phiSegments : Integer, thetaStart : Float, thetaLength : Float)</code><br>innerRadius — 内部半径，默认值为0.5。<br>outerRadius — 外部半径，默认值为1。<br>thetaSegments — 圆环的分段数。这个值越大，圆环就越圆。最小值为3，默认值为32。<br>phiSegments — 最小值为1，默认值为8。<br>thetaStart — 起始角度，默认值为0。<br>thetaLength — 圆心角，默认值为Math.PI * 2。</p>
<h5 id="属性-方法-5"><a href="#属性-方法-5" class="headerlink" title="属性|方法"></a>属性|方法</h5><blockquote>
<p>共有方法请参见其基类BufferGeometry。<br>共有属性请参见其基类BufferGeometry。</p>
</blockquote>
<p><code>.parameters</code> : Object<br>一个包含着构造函数中每个参数的对象。在对象实例化之后，对该属性的任何修改都不会改变这个几何体。</p>
<h4 id="圆锥（ConeGeometry）"><a href="#圆锥（ConeGeometry）" class="headerlink" title="圆锥（ConeGeometry）"></a>圆锥（ConeGeometry）</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> geometry = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">ConeGeometry</span>( <span class="number">5</span>, <span class="number">20</span>, <span class="number">32</span> );</span><br><span class="line"><span class="keyword">const</span> material = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">MeshBasicMaterial</span>( &#123;<span class="attr">color</span>: <span class="number">0xffff00</span>&#125; );</span><br><span class="line"><span class="keyword">const</span> cone = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Mesh</span>( geometry, material );</span><br><span class="line">scene.<span class="title function_">add</span>( cone );</span><br></pre></td></tr></table></figure>

<h5 id="构造器-9"><a href="#构造器-9" class="headerlink" title="构造器"></a>构造器</h5><p><code>ConeGeometry(radius : Float, height : Float, radialSegments : Integer, heightSegments : Integer, openEnded : Boolean, thetaStart : Float, thetaLength : Float)</code><br>radius — 圆锥底部的半径，默认值为1。<br>height — 圆锥的高度，默认值为1。<br>radialSegments — 圆锥侧面周围的分段数，默认为32。<br>heightSegments — 圆锥侧面沿着其高度的分段数，默认值为1。<br>openEnded — 一个Boolean值，指明该圆锥的底面是开放的还是封顶的。默认值为false，即其底面默认是封顶的。<br>thetaStart — 第一个分段的起始角度，默认为0。（three o’clock position）<br>thetaLength — 圆锥底面圆扇区的中心角，通常被称为“θ”（西塔）。默认值是2*Pi，这使其成为一个完整的圆锥。</p>
<h5 id="属性-方法-6"><a href="#属性-方法-6" class="headerlink" title="属性|方法"></a>属性|方法</h5><blockquote>
<p>共有方法请参见其基类BufferGeometry。<br>共有属性请参见其基类BufferGeometry。</p>
</blockquote>
<p><code>.parameters</code> : Object<br>一个包含着构造函数中每个参数的对象。在对象实例化之后，对该属性的任何修改都不会改变这个几何体。</p>
<h4 id="球（SphereGeometry）"><a href="#球（SphereGeometry）" class="headerlink" title="球（SphereGeometry）"></a>球（SphereGeometry）</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> geometry = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">SphereGeometry</span>( <span class="number">15</span>, <span class="number">32</span>, <span class="number">16</span> );</span><br><span class="line"><span class="keyword">const</span> material = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">MeshBasicMaterial</span>( &#123; <span class="attr">color</span>: <span class="number">0xffff00</span> &#125; );</span><br><span class="line"><span class="keyword">const</span> sphere = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Mesh</span>( geometry, material );</span><br><span class="line">scene.<span class="title function_">add</span>( sphere );</span><br></pre></td></tr></table></figure>

<h5 id="构造器-10"><a href="#构造器-10" class="headerlink" title="构造器"></a>构造器</h5><p><code>SphereGeometry(radius : Float, widthSegments : Integer, heightSegments : Integer, phiStart : Float, phiLength : Float, thetaStart : Float, thetaLength : Float)</code><br>radius — 球体半径，默认为1。<br>widthSegments — 水平分段数（沿着经线分段），最小值为3，默认值为32。<br>heightSegments — 垂直分段数（沿着纬线分段），最小值为2，默认值为16。<br>phiStart — 指定水平（经线）起始角度，默认值为0。。<br>phiLength — 指定水平（经线）扫描角度的大小，默认值为 Math.PI * 2。<br>thetaStart — 指定垂直（纬线）起始角度，默认值为0。<br>thetaLength — 指定垂直（纬线）扫描角度大小，默认值为 Math.PI。<br>该几何体是通过扫描并计算围绕着Y轴（水平扫描）和X轴（垂直扫描）的顶点来创建的。 因此，不完整的球体（类似球形切片）可以通过为phiStart，phiLength，thetaStart和thetaLength设置不同的值来创建， 以定义我们开始（或结束）计算这些顶点的起点（或终点）。</p>
<h5 id="属性-方法-7"><a href="#属性-方法-7" class="headerlink" title="属性|方法"></a>属性|方法</h5><blockquote>
<p>共有方法请参见其基类BufferGeometry。<br>共有属性请参见其基类BufferGeometry。</p>
</blockquote>
<p><code>.parameters</code> : Object<br>一个包含着构造函数中每个参数的对象。在对象实例化之后，对该属性的任何修改都不会改变这个几何体。</p>
<h4 id="圆环（TorusGeometry）"><a href="#圆环（TorusGeometry）" class="headerlink" title="圆环（TorusGeometry）"></a>圆环（TorusGeometry）</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> geometry = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">TorusGeometry</span>( <span class="number">10</span>, <span class="number">3</span>, <span class="number">16</span>, <span class="number">100</span> );</span><br><span class="line"><span class="keyword">const</span> material = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">MeshBasicMaterial</span>( &#123; <span class="attr">color</span>: <span class="number">0xffff00</span> &#125; );</span><br><span class="line"><span class="keyword">const</span> torus = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Mesh</span>( geometry, material );</span><br><span class="line">scene.<span class="title function_">add</span>( torus );</span><br></pre></td></tr></table></figure>

<h5 id="构造器-11"><a href="#构造器-11" class="headerlink" title="构造器"></a>构造器</h5><p><code>TorusGeometry(radius : Float, tube : Float, radialSegments : Integer, tubularSegments : Integer, arc : Float)</code><br>radius - 环面的半径，从环面的中心到管道横截面的中心。默认值是1。<br>tube — 管道的半径，默认值为0.4。<br>radialSegments — 管道横截面的分段数，默认值为12。<br>tubularSegments — 管道的分段数，默认值为48。<br>arc — 圆环的圆心角（单位是弧度），默认值为Math.PI * 2。</p>
<h5 id="属性-方法-8"><a href="#属性-方法-8" class="headerlink" title="属性|方法"></a>属性|方法</h5><blockquote>
<p>共有方法请参见其基类BufferGeometry。<br>共有属性请参见其基类BufferGeometry。</p>
</blockquote>
<p><code>.parameters</code> : Object<br>一个包含着构造函数中每个参数的对象。在对象实例化之后，对该属性的任何修改都不会改变这个几何体。</p>
<h4 id="管道（TubeGeometry）"><a href="#管道（TubeGeometry）" class="headerlink" title="管道（TubeGeometry）"></a>管道（TubeGeometry）</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CustomSinCurve</span> <span class="keyword">extends</span> <span class="title class_ inherited__">THREE.Curve</span> &#123;</span><br><span class="line"></span><br><span class="line"> <span class="title function_">constructor</span>(<span class="params"> scale = <span class="number">1</span> </span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">super</span>();</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">scale</span> = scale;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="title function_">getPoint</span>(<span class="params"> t, optionalTarget = <span class="keyword">new</span> THREE.Vector3() </span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> tx = t * <span class="number">3</span> - <span class="number">1.5</span>;</span><br><span class="line">  <span class="keyword">const</span> ty = <span class="title class_">Math</span>.<span class="title function_">sin</span>( <span class="number">2</span> * <span class="title class_">Math</span>.<span class="property">PI</span> * t );</span><br><span class="line">  <span class="keyword">const</span> tz = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> optionalTarget.<span class="title function_">set</span>( tx, ty, tz ).<span class="title function_">multiplyScalar</span>( <span class="variable language_">this</span>.<span class="property">scale</span> );</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> path = <span class="keyword">new</span> <span class="title class_">CustomSinCurve</span>( <span class="number">10</span> );</span><br><span class="line"><span class="keyword">const</span> geometry = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">TubeGeometry</span>( path, <span class="number">20</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="literal">false</span> );</span><br><span class="line"><span class="keyword">const</span> material = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">MeshBasicMaterial</span>( &#123; <span class="attr">color</span>: <span class="number">0x00ff00</span> &#125; );</span><br><span class="line"><span class="keyword">const</span> mesh = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Mesh</span>( geometry, material );</span><br><span class="line">scene.<span class="title function_">add</span>( mesh );</span><br></pre></td></tr></table></figure>

<h5 id="构造器-12"><a href="#构造器-12" class="headerlink" title="构造器"></a>构造器</h5><p><code>TubeGeometry(path : Curve, tubularSegments : Integer, radius : Float, radialSegments : Integer, closed : Boolean)</code><br>path — Curve - 一个由基类Curve继承而来的3D路径。 Default is a quadratic bezier curve.<br>tubularSegments — Integer - 组成这一管道的分段数，默认值为64。<br>radius — Float - 管道的半径，默认值为1。<br>radialSegments — Integer - 管道横截面的分段数目，默认值为8。<br>closed — Boolean 管道的两端是否闭合，默认值为false。</p>
<h5 id="属性-方法-9"><a href="#属性-方法-9" class="headerlink" title="属性|方法"></a>属性|方法</h5><blockquote>
<p>共有方法请参见其基类BufferGeometry。<br>共有属性请参见其基类BufferGeometry。</p>
</blockquote>
<p><code>.parameters</code> : Object<br>一个包含着构造函数中每个参数的对象。在对象实例化之后，对该属性的任何修改都不会改变这个几何体。<br><code>.tangents</code> : Array<br>一个Vector3切线数组。</p>
<p><code>.normals</code> : Array<br>一个Vector3法线数组。</p>
<p><code>.binormals</code> : Array<br>一个Vector3次法线数组。</p>
<h4 id="多面缓冲几何体（PolyhedronGeometry）"><a href="#多面缓冲几何体（PolyhedronGeometry）" class="headerlink" title="多面缓冲几何体（PolyhedronGeometry）"></a>多面缓冲几何体（PolyhedronGeometry）</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> verticesOfCube = [</span><br><span class="line">    -<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,    <span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,    <span class="number">1</span>, <span class="number">1</span>,-<span class="number">1</span>,    -<span class="number">1</span>, <span class="number">1</span>,-<span class="number">1</span>,</span><br><span class="line">    -<span class="number">1</span>,-<span class="number">1</span>, <span class="number">1</span>,    <span class="number">1</span>,-<span class="number">1</span>, <span class="number">1</span>,    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,    -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> indicesOfFaces = [</span><br><span class="line">    <span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>,    <span class="number">0</span>,<span class="number">3</span>,<span class="number">2</span>,</span><br><span class="line">    <span class="number">0</span>,<span class="number">4</span>,<span class="number">7</span>,    <span class="number">7</span>,<span class="number">3</span>,<span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>,<span class="number">1</span>,<span class="number">5</span>,    <span class="number">5</span>,<span class="number">4</span>,<span class="number">0</span>,</span><br><span class="line">    <span class="number">1</span>,<span class="number">2</span>,<span class="number">6</span>,    <span class="number">6</span>,<span class="number">5</span>,<span class="number">1</span>,</span><br><span class="line">    <span class="number">2</span>,<span class="number">3</span>,<span class="number">7</span>,    <span class="number">7</span>,<span class="number">6</span>,<span class="number">2</span>,</span><br><span class="line">    <span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,    <span class="number">6</span>,<span class="number">7</span>,<span class="number">4</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> geometry = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">PolyhedronGeometry</span>( verticesOfCube, indicesOfFaces, <span class="number">6</span>, <span class="number">2</span> );</span><br></pre></td></tr></table></figure>

<h5 id="构造器-13"><a href="#构造器-13" class="headerlink" title="构造器"></a>构造器</h5><p><code>PolyhedronGeometry(vertices : Array, indices : Array, radius : Float, detail : Integer)</code><br>vertices — 一个顶点Array（数组）：[1,1,1, -1,-1,-1, … ]。<br>indices — 一个构成面的索引Array（数组）， [0,1,2, 2,3,0, … ]。<br>radius — Float - 最终形状的半径。<br>detail — Integer - 将对这个几何体细分多少个级别。细节越多，形状就越平滑。</p>
<h5 id="属性-方法-10"><a href="#属性-方法-10" class="headerlink" title="属性|方法"></a>属性|方法</h5><blockquote>
<p>共有方法请参见其基类BufferGeometry。<br>共有属性请参见其基类BufferGeometry。</p>
</blockquote>
<p><code>.parameters</code> : Object<br>一个包含着构造函数中每个参数的对象。在对象实例化之后，对该属性的任何修改都不会改变这个几何体。</p>
<h4 id="边缘几何体（EdgesGeometry）"><a href="#边缘几何体（EdgesGeometry）" class="headerlink" title="边缘几何体（EdgesGeometry）"></a>边缘几何体（EdgesGeometry）</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> geometry = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">BoxGeometry</span>( <span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span> );</span><br><span class="line"><span class="keyword">const</span> edges = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">EdgesGeometry</span>( geometry );</span><br><span class="line"><span class="keyword">const</span> line = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">LineSegments</span>( edges, <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">LineBasicMaterial</span>( &#123; <span class="attr">color</span>: <span class="number">0xffffff</span> &#125; ) );</span><br><span class="line">scene.<span class="title function_">add</span>( line );</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="构造器-14"><a href="#构造器-14" class="headerlink" title="构造器"></a>构造器</h5><p><code>EdgesGeometry( geometry : BufferGeometry, thresholdAngle : Integer )</code><br>geometry — 任何一个几何体对象。<br>thresholdAngle — 仅当相邻面的法线之间的角度（单位为角度）超过这个值时，才会渲染边缘。默认值为1。</p>
<h5 id="属性-方法-11"><a href="#属性-方法-11" class="headerlink" title="属性|方法"></a>属性|方法</h5><blockquote>
<p>共有方法请参见其基类BufferGeometry。<br>共有属性请参见其基类BufferGeometry。<br><code>.parameters</code> : Object<br>一个包含着构造函数中每个参数的对象。在对象实例化之后，对该属性的任何修改都不会改变这个几何体。</p>
</blockquote>
<h4 id="网格几何体（WireframeGeometry）"><a href="#网格几何体（WireframeGeometry）" class="headerlink" title="网格几何体（WireframeGeometry）"></a>网格几何体（WireframeGeometry）</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> geometry = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">SphereGeometry</span>( <span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span> );</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> wireframe = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">WireframeGeometry</span>( geometry );</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> line = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">LineSegments</span>( wireframe );</span><br><span class="line">line.<span class="property">material</span>.<span class="property">depthTest</span> = <span class="literal">false</span>;</span><br><span class="line">line.<span class="property">material</span>.<span class="property">opacity</span> = <span class="number">0.25</span>;</span><br><span class="line">line.<span class="property">material</span>.<span class="property">transparent</span> = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">scene.<span class="title function_">add</span>( line );</span><br></pre></td></tr></table></figure>

<h5 id="构造器-15"><a href="#构造器-15" class="headerlink" title="构造器"></a>构造器</h5><p><code>WireframeGeometry( geometry : BufferGeometry )</code><br>geometry — 任意几何体对象。</p>
<h5 id="属性-方法-12"><a href="#属性-方法-12" class="headerlink" title="属性|方法"></a>属性|方法</h5><blockquote>
<p>共有方法请参见其基类BufferGeometry。<br>共有属性请参见其基类BufferGeometry。</p>
</blockquote>
<h3 id="材质"><a href="#材质" class="headerlink" title="材质"></a>材质</h3><h4 id="Material"><a href="#Material" class="headerlink" title="Material"></a>Material</h4><p>材质描述了对象objects的外观。它们的定义方式与渲染器无关， 因此，如果您决定使用不同的渲染器，不必重写材质。</p>
<h5 id="构造器-16"><a href="#构造器-16" class="headerlink" title="构造器"></a>构造器</h5><p><code>Material()</code>该方法创建一个通用材质。</p>
<h4 id="属性-5"><a href="#属性-5" class="headerlink" title="属性"></a>属性</h4><ul>
<li><p><code>.alphaTest</code> : Float<br>设置运行alphaTest时要使用的alpha值。如果不透明度低于此值，则不会渲染材质。默认值为0。</p>
</li>
<li><p><code>.alphaToCoverage</code> : Boolean<br>启用alpha to coverage. 只能在开启了MSAA的渲染环境中使用 (当渲染器创建的时候antialias 属性要true才能使用). 默认为 false.</p>
</li>
<li><p><code>.blendDst</code> : Integer<br>混合目标。默认值为OneMinusSrcAlphaFactor。 目标因子所有可能的取值请参阅constants。 必须将材质的blending设置为CustomBlending才能生效。</p>
</li>
<li><p><code>.blendDstAlpha</code> : Integer<br>.blendDst的透明度。 默认值为 null.</p>
</li>
<li><p><code>.blendEquation</code> : Integer<br>使用混合时所采用的混合方程式。默认值为AddEquation。 混合方程式所有可能的取值请参阅constants。 必须将材质的blending设置为CustomBlending才能生效。<br>.blendEquationAlpha : Integer<br>.blendEquation 的透明度. 默认值为 null.</p>
</li>
<li><p><code>.blending</code> : Blending<br>在使用此材质显示对象时要使用何种混合。<br>必须将其设置为CustomBlending才能使用自定义blendSrc, blendDst 或者 [page:Constant blendEquation]。 混合模式所有可能的取值请参阅constants。默认值为NormalBlending。</p>
</li>
<li><p><code>.blendSrc</code> : Integer<br>混合源。默认值为SrcAlphaFactor。 源因子所有可能的取值请参阅constants。<br>必须将材质的blending设置为CustomBlending才能生效。</p>
</li>
<li><p><code>.blendSrcAlpha</code> : Integer<br>.blendSrc的透明度。 默认值为 null.</p>
</li>
<li><p><code>.clipIntersection</code> : Boolean<br>更改剪裁平面的行为，以便仅剪切其交叉点，而不是它们的并集。默认值为 false。</p>
</li>
<li><p><code>.clippingPlanes</code> : Array<br>用户定义的剪裁平面，在世界空间中指定为THREE.Plane对象。这些平面适用于所有使用此材质的对象。空间中与平面的有符号距离为负的点被剪裁（未渲染）。 这需要WebGLRenderer.localClippingEnabled为true。 示例请参阅WebGL / clipping /intersection。默认值为 null。</p>
</li>
<li><p><code>.clipShadows</code> : Boolean<br>定义是否根据此材质上指定的剪裁平面剪切阴影。默认值为 false。</p>
</li>
<li><p><code>.colorWrite</code> : Boolean<br>是否渲染材质的颜色。 这可以与网格的renderOrder属性结合使用，以创建遮挡其他对象的不可见对象。默认值为true。</p>
</li>
<li><p><code>.defines</code> : Object<br>注入shader的自定义对象。 以键值对形式的对象传递，{ MY_CUSTOM_DEFINE: ‘’ , PI2: Math.PI * 2 }。 这些键值对在顶点和片元着色器中定义。默认值为undefined。</p>
</li>
<li><p><code>.depthFunc</code> : Integer<br>使用何种深度函数。默认为LessEqualDepth。 深度模式所有可能的取值请查阅constants。</p>
</li>
<li><p><code>.depthTest</code> : Boolean<br>是否在渲染此材质时启用深度测试。默认为 true。</p>
</li>
<li><p><code>.depthWrite</code> : Boolean<br>渲染此材质是否对深度缓冲区有任何影响。默认为true。</p>
</li>
</ul>
<p>在绘制2D叠加时，将多个事物分层在一起而不创建z-index时，禁用深度写入会很有用。</p>
<ul>
<li><code>.forceSinglePass</code> : Boolean<br>决定双面透明的东西是否强制使用单通道渲染，默认为false。</li>
</ul>
<p>为了减少一些半透明物体的渲染错误，此引擎调用两次绘制来渲染渲染双面透明的东西。 但是此方案可能会导致在某些情况下使绘制调用次数翻倍，例如渲染一些平面的植物例如草精灵之类的。 在这些情况下，将forceSinglePass设置为true来使用单通道渲染来避免性能问题。</p>
<ul>
<li><p><code>.isMaterial</code> : Boolean<br>检查这个对象是否为材质Material的只读标记.</p>
</li>
<li><p><code>.stencilWrite</code> : Boolean<br>是否对模板缓冲执行模板操作，如果执行写入或者与模板缓冲进行比较，这个值需要设置为true。默认为false。</p>
</li>
<li><p><code>.stencilWriteMask</code> : Integer<br>写入模板缓冲区时所用的位元遮罩，默认为0xFF。</p>
</li>
<li><p><code>.stencilFunc</code> : Integer<br>使用模板比较时所用的方法，默认为AlwaysStencilFunc。在模板函数 constants 中查看可用的值</p>
</li>
<li><p><code>.stencilRef</code> : Integer<br>在进行模板比较或者模板操作的时候所用的基准值，默认为0。</p>
</li>
<li><p><code>.stencilFuncMask</code> : Integer<br>与模板缓冲进行比较时所使用的位元遮罩，默认为0xFF</p>
</li>
<li><p><code>.stencilFail</code> : Integer<br>当比较函数没有通过的时候要执行的模板操作，默认为KeepStencilOp，在模板操作 constants 查看可用值。</p>
</li>
<li><p><code>.stencilZFail</code> : Integer<br>当比较函数通过了但是深度检测没有通过的时候要执行的模板操作， 默认为KeepStencilOp，在模板操作 constants 查看可用值。</p>
</li>
<li><p><code>.stencilZPass</code> : Integer<br>当比较函数和深度检测都通过时要执行的模板操作，默认为KeepStencilOp，在模板操作constants 中查看可用值。</p>
</li>
<li><p><code>.id</code> : Integer<br>此材质实例的唯一编号。</p>
</li>
<li><p><code>.name</code> : String<br>对象的可选名称（不必是唯一的）。默认值为空字符串。</p>
</li>
<li><p><code>.needsUpdate</code> : Boolean<br>指定需要重新编译材质。</p>
</li>
<li><p><code>.opacity</code> : Float<br>在0.0 - 1.0的范围内的浮点数，表明材质的透明度。值0.0表示完全透明，1.0表示完全不透明。<br>如果材质的transparent属性未设置为true，则材质将保持完全不透明，此值仅影响其颜色。 默认值为1.0。</p>
</li>
<li><p><code>.polygonOffset</code> : Boolean<br>是否使用多边形偏移。默认值为false。这对应于WebGL的GL_POLYGON_OFFSET_FILL功能。</p>
</li>
<li><p><code>.polygonOffsetFactor</code> : Integer<br>设置多边形偏移系数。默认值为0。</p>
</li>
<li><p><code>.polygonOffsetUnits</code> : Integer<br>设置多边形偏移单位。默认值为0。</p>
</li>
<li><p><code>.precision</code> : String<br>重写此材质渲染器的默认精度。可以是”highp”, “mediump” 或 “lowp”。默认值为null。</p>
</li>
<li><p><code>.premultipliedAlpha</code> : Boolean<br>是否预乘alpha（透明度）值。有关差异的示例，请参阅WebGL / Materials / Physical / Transmission。 默认值为false。</p>
</li>
<li><p><code>.dithering</code> : Boolean<br>是否对颜色应用抖动以消除条带的外观。默认值为 false。</p>
</li>
<li><p><code>.shadowSide</code> : Integer<br>定义投影的面。设置时，可以是THREE.FrontSide, THREE.BackSide, 或Materials。默认值为 null。<br>如果为null， 则面投射阴影确定如下：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>THREE.FrontSide</td>
<td>背面</td>
</tr>
<tr>
<td>THREE.BackSide</td>
<td>前面</td>
</tr>
<tr>
<td>THREE.DoubleSide</td>
<td>双面</td>
</tr>
</tbody></table>
</li>
<li><p><code>.side</code> : Integer<br>定义将要渲染哪一面 - 正面，背面或两者。 默认为THREE.FrontSide。其他选项有THREE.BackSide 和 THREE.DoubleSide。</p>
</li>
<li><p><code>.toneMapped</code> : Boolean<br>定义这个材质是否会被渲染器的toneMapping设置所影响，默认为 true 。</p>
</li>
<li><p><code>.transparent</code> : Boolean<br>定义此材质是否透明。这对渲染有影响，因为透明对象需要特殊处理，并在非透明对象之后渲染。<br>设置为true时，通过设置材质的opacity属性来控制材质透明的程度。<br>默认值为false。</p>
</li>
<li><p><code>.type</code> : String<br>值是字符串’Material’。不应该被更改，并且可以用于在场景中查找此类型的所有对象。</p>
</li>
<li><p><code>.uuid</code> : String<br>此材质实例的UUID，会自动分配，不应该被更改。</p>
</li>
<li><p><code>.version</code> : Integer<br>开始为0，会记录 .needsUpdate : Boolean设置为true的次数。</p>
</li>
<li><p><code>.vertexColors</code> : Boolean<br>是否使用顶点着色。默认值为false。 此引擎支持RGB或者RGBA两种顶点颜色，取决于缓冲 attribute 使用的是三分量（RGB）还是四分量（RGBA）。</p>
</li>
<li><p><code>.visible</code> : Boolean<br>此材质是否可见。默认为true。</p>
</li>
<li><p><code>.userData</code> : Object<br>一个对象，可用于存储有关Material的自定义数据。它不应该包含对函数的引用，因为这些函数不会被克隆。</p>
</li>
</ul>
<h5 id="方法-5"><a href="#方法-5" class="headerlink" title="方法"></a>方法</h5><blockquote>
<p>EventDispatcher 方法在此类中可用。</p>
</blockquote>
<ul>
<li><p><code>.clone ( ) : Material</code><br>返回与此材质具有相同参数的新材质。</p>
</li>
<li><p><code>.copy ( material : material ) : this</code><br>将被传入材质中的参数复制到此材质中。</p>
</li>
<li><p><code>.dispose () : undefined</code><br>处理材质。材质的纹理不会被处理。需要通过Texture处理。</p>
</li>
<li><p><code>.onBeforeCompile ( shader : Shader, renderer : WebGLRenderer ) : undefined</code><br>在编译shader程序之前立即执行的可选回调。此函数使用shader源码作为参数。用于修改内置材质。</p>
</li>
</ul>
<p>和其他属性不一样的是，这个回调在.clone()，.copy() 和 .toJSON() 中不支持。</p>
<ul>
<li><code>.customProgramCacheKey () : String</code><br>当用到onBeforeCompile回调的时候，这个回调函数可以用来定义在onBeforeCompile中使用的配置项，这样three.js就可以根据这个回调返回的字符串来判定使用一个缓存的编译好的着色器代码还是根据需求重新编译一段新的着色器代码。</li>
</ul>
<p>例如一个onBeforeCompile回调函数包含了下面的条件语句:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( black ) &#123;</span><br><span class="line"> shader.<span class="property">fragmentShader</span> = shader.<span class="property">fragmentShader</span>.<span class="title function_">replace</span>(<span class="string">&#x27;gl_FragColor = vec4(1)&#x27;</span>, <span class="string">&#x27;gl_FragColor = vec4(0)&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么 customProgramCacheKey 就可以设置为:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">material.<span class="property">customProgramCacheKey</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> black ? <span class="string">&#x27;1&#x27;</span> : <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和其他属性不一样的是，这个回调在.clone()，.copy() 和 .toJSON() 中不支持。</p>
<ul>
<li><code>.setValues ( values : Object ) : undefined</code><br>values – 具有参数的容器。 根据values设置属性。</li>
<li><code>.toJSON ( meta : Object ) : Object</code><br>meta – 包含有元数据的对象，例如该对象的纹理或图片。 将material对象转换为 three.js JSON Object/Scene format（three.js JSON 物体/场景格式）。</li>
</ul>
<h4 id="基础网格材质-MeshBasicMaterial"><a href="#基础网格材质-MeshBasicMaterial" class="headerlink" title="基础网格材质(MeshBasicMaterial)"></a>基础网格材质(MeshBasicMaterial)</h4><h5 id="构造器-17"><a href="#构造器-17" class="headerlink" title="构造器"></a>构造器</h5><p><code>MeshBasicMaterial( parameters : Object )</code><br>parameters - (可选)用于定义材质外观的对象，具有一个或多个属性。材质的任何属性都可以从此处传入(包括从Material继承的任何属性)。</p>
<p>属性color例外，其可以作为十六进制字符串传递，默认情况下为 0xffffff（白色），内部调用Color.set(color)。</p>
<h5 id="属性-方法-13"><a href="#属性-方法-13" class="headerlink" title="属性|方法"></a>属性|方法</h5><blockquote>
<p>共有方法请参见其基类Material。<br>共有属性请参见其基类Material。</p>
</blockquote>
<p><code>.alphaMap</code> : Texture<br>alpha贴图是一张灰度纹理，用于控制整个表面的不透明度。（黑色：完全透明；白色：完全不透明）。 默认值为null。</p>
<p>仅使用纹理的颜色，忽略alpha通道（如果存在）。 对于RGB和RGBA纹理，WebGL渲染器在采样此纹理时将使用绿色通道， 因为在DXT压缩和未压缩RGB 565格式中为绿色提供了额外的精度。 Luminance-only以及luminance/alpha纹理也仍然有效。</p>
<p><code>.aoMap</code> : Texture<br>该纹理的红色通道用作环境遮挡贴图。默认值为null。aoMap需要第二组UV。</p>
<p><code>.aoMapIntensity</code> : Float<br>环境遮挡效果的强度。默认值为1。零是不遮挡效果。</p>
<p><code>.color</code> : Color<br>材质的颜色(Color)，默认值为白色 (0xffffff)。</p>
<p><code>.combine</code> : Integer<br>如何将表面颜色的结果与环境贴图（如果有）结合起来。</p>
<p>选项为THREE.MultiplyOperation（默认值），THREE.MixOperation， THREE.AddOperation。如果选择多个，则使用.reflectivity在两种颜色之间进行混合。</p>
<p><code>.envMap</code> : Texture<br>环境贴图。默认值为null。</p>
<p><code>.fog</code> : Boolean<br>材质是否受雾影响。默认为true。</p>
<p><code>.lightMap</code> : Texture<br>光照贴图。默认值为null。lightMap需要第二组UV。</p>
<p><code>.lightMapIntensity</code> : Float<br>烘焙光的强度。默认值为1。</p>
<p><code>.map</code> : Texture<br>颜色贴图。可以选择包括一个alpha通道，通常与.transparent 或.alphaTest。默认为null。</p>
<p><code>.reflectivity</code> : Float<br>环境贴图对表面的影响程度; 见.combine。默认值为1，有效范围介于0（无反射）和1（完全反射）之间。</p>
<p><code>.refractionRatio</code> : Float<br>空气的折射率（IOR）（约为1）除以材质的折射率。它与环境映射模式THREE.CubeRefractionMapping 和THREE.EquirectangularRefractionMapping一起使用。 The index of refraction (IOR) of air (approximately 1) divided by the index of refraction of the material. It is used with environment mapping mode THREE.CubeRefractionMapping. 折射率不应超过1。默认值为0.98。</p>
<p><code>.specularMap</code> : Texture<br>材质使用的高光贴图。默认值为null。</p>
<p><code>.wireframe</code> : Boolean<br>将几何体渲染为线框。默认值为false（即渲染为平面多边形）。</p>
<p><code>.wireframeLinecap</code> : String<br>定义线两端的外观。可选值为 ‘butt’，’round’ 和 ‘square’。默认为’round’。</p>
<p>该属性对应2D Canvas lineJoin属性， 并且会被WebGL渲染器忽略。</p>
<p><code>.wireframeLinejoin</code> : String<br>定义线连接节点的样式。可选值为 ‘round’, ‘bevel’ 和 ‘miter’。默认值为 ‘round’。</p>
<p>该属性对应2D Canvas lineJoin属性， 并且会被WebGL渲染器忽略。</p>
<p><code>.wireframeLinewidth</code> : Float<br>控制线框宽度。默认值为1。</p>
<p>由于OpenGL Core Profile与大多数平台上WebGL渲染器的限制， 无论如何设置该值，线宽始终为1。</p>
<h4 id="Lambert网格材质-MeshLambertMaterial"><a href="#Lambert网格材质-MeshLambertMaterial" class="headerlink" title="Lambert网格材质(MeshLambertMaterial)"></a>Lambert网格材质(MeshLambertMaterial)</h4><p>一种非光泽表面的材质，没有镜面高光。<br>由于反射率和光照模型的简单性，MeshPhongMaterial，MeshStandardMaterial或者MeshPhysicalMaterial 上使用这种材质时会以一些图形精度为代价，得到更高的性能。</p>
<h5 id="构造器-18"><a href="#构造器-18" class="headerlink" title="构造器"></a>构造器</h5><p><code>MeshLambertMaterial( parameters : Object )</code><br>parameters - (可选)用于定义材质外观的对象，具有一个或多个属性。 材质的任何属性都可以从此处传入(包括从Material继承的任何属性)。</p>
<p>属性color例外，其可以作为十六进制字符串传递，默认情况下为 0xffffff（白色），内部调用Color.set(color)。</p>
<h5 id="属性-方法-14"><a href="#属性-方法-14" class="headerlink" title="属性|方法"></a>属性|方法</h5><blockquote>
<p>共有方法请参见其基类Material。<br>共有属性请参见其基类Material。</p>
</blockquote>
<p>.alphaMap : Texture<br>alpha贴图是一张灰度纹理，用于控制整个表面的不透明度。（黑色：完全透明；白色：完全不透明）。 默认值为null。</p>
<p>仅使用纹理的颜色，忽略alpha通道（如果存在）。 对于RGB和RGBA纹理，WebGL渲染器在采样此纹理时将使用绿色通道， 因为在DXT压缩和未压缩RGB 565格式中为绿色提供了额外的精度。 Luminance-only以及luminance/alpha纹理也仍然有效。</p>
<p>.aoMap : Texture<br>该纹理的红色通道用作环境遮挡贴图。默认值为null。aoMap需要第二组UV。</p>
<p>.aoMapIntensity : Float<br>环境遮挡效果的强度。默认值为1。零是不遮挡效果。</p>
<p>.bumpMap : Texture<br>用于创建凹凸贴图的纹理。黑色和白色值映射到与光照相关的感知深度。凹凸实际上不会影响对象的几何形状，只影响光照。如果定义了法线贴图，则将忽略该贴图。</p>
<p>.bumpScale : Float<br>凹凸贴图会对材质产生多大影响。典型范围是0-1。默认值为1。</p>
<p>.color : Color<br>材质的颜色(Color)，默认值为白色 (0xffffff)。</p>
<p>.combine : Integer<br>如何将表面颜色的结果与环境贴图（如果有）结合起来。</p>
<p>选项为THREE.MultiplyOperation（默认值），THREE.MixOperation， THREE.AddOperation。如果选择多个，则使用.reflectivity在两种颜色之间进行混合。</p>
<p>.displacementMap : Texture<br>位移贴图会影响网格顶点的位置，与仅影响材质的光照和阴影的其他贴图不同，移位的顶点可以投射阴影，阻挡其他对象， 以及充当真实的几何体。位移纹理是指：网格的所有顶点被映射为图像中每个像素的值（白色是最高的），并且被重定位。</p>
<p>.displacementScale : Float<br>位移贴图对网格的影响程度（黑色是无位移，白色是最大位移）。如果没有设置位移贴图，则不会应用此值。默认值为1。</p>
<p>.displacementBias : Float<br>位移贴图在网格顶点上的偏移量。如果没有设置位移贴图，则不会应用此值。默认值为0。</p>
<p>.emissive : Color<br>材质的放射（光）颜色，基本上是不受其他光照影响的固有颜色。默认为黑色。</p>
<p>.emissiveMap : Texture<br>设置放射（发光）贴图。默认值为null。放射贴图颜色由放射颜色和强度所调节。 如果你有一个放射贴图，请务必将放射颜色设置为黑色以外的其他颜色。</p>
<p>.emissiveIntensity : Float<br>放射光强度。调节发光颜色。默认为1。</p>
<p>.envMap : Texture<br>环境贴图。默认值为null。</p>
<p>.flatShading : Boolean<br>定义材质是否使用平面着色进行渲染。默认值为false。</p>
<p>.fog : Boolean<br>材质是否受雾影响。默认为true。</p>
<p>.lightMap : Texture<br>光照贴图。默认值为null。lightMap需要第二组UV。</p>
<p>.lightMapIntensity : Float<br>烘焙光的强度。默认值为1。</p>
<p>.map : Texture<br>颜色贴图。可以选择包括一个alpha通道，通常与.transparent 或.alphaTest。默认为null。</p>
<p>.normalMap : Texture<br>用于创建法线贴图的纹理。RGB值会影响每个像素片段的曲面法线，并更改颜色照亮的方式。法线贴图不会改变曲面的实际形状，只会改变光照。 In case the material has a normal map authored using the left handed convention, the y component of normalScale should be negated to compensate for the different handedness.</p>
<p>.normalMapType : Integer<br>法线贴图的类型。</p>
<p>选项为THREE.TangentSpaceNormalMap（默认）和THREE.ObjectSpaceNormalMap。</p>
<p>.normalScale : Vector2<br>法线贴图对材质的影响程度。典型范围是0-1。默认值是Vector2设置为（1,1）。</p>
<p>.reflectivity : Float<br>环境贴图对表面的影响程度; 见.combine。默认值为1，有效范围介于0（无反射）和1（完全反射）之间。</p>
<p>.refractionRatio : Float<br>空气的折射率（IOR）（约为1）除以材质的折射率。它与环境映射模式THREE.CubeRefractionMapping 和THREE.EquirectangularRefractionMapping一起使用。 The index of refraction (IOR) of air (approximately 1) divided by the index of refraction of the material. It is used with environment mapping mode THREE.CubeRefractionMapping. 折射率不应超过1。默认值为0.98。</p>
<p>.specularMap : Texture<br>材质使用的高光贴图。默认值为null。</p>
<p>.wireframe : Boolean<br>将几何体渲染为线框。默认值为false（即渲染为平面多边形）。</p>
<p>.wireframeLinecap : String<br>定义线两端的外观。可选值为 ‘butt’，’round’ 和 ‘square’。默认为’round’。</p>
<p>该属性对应2D Canvas lineJoin属性， 并且会被WebGL渲染器忽略。</p>
<p>.wireframeLinejoin : String<br>定义线连接节点的样式。可选值为 ‘round’, ‘bevel’ 和 ‘miter’。默认值为 ‘round’。</p>
<p>该属性对应2D Canvas lineJoin属性， 并且会被WebGL渲染器忽略。</p>
<p>.wireframeLinewidth : Float<br>控制线框宽度。默认值为1。</p>
<p>由于OpenGL Core Profile与 大多数平台上WebGL渲染器的限制，无论如何设置该值，线宽始终为1。</p>
<h4 id="Phong网格材质-MeshPhongMaterial"><a href="#Phong网格材质-MeshPhongMaterial" class="headerlink" title="Phong网格材质(MeshPhongMaterial)"></a>Phong网格材质(MeshPhongMaterial)</h4><p>一种用于具有镜面高光的光泽表面的材质。</p>
<p>在MeshStandardMaterial或MeshPhysicalMaterial上使用此材质时，性能通常会更高 ，但会牺牲一些图形精度。</p>
<h5 id="构造器-19"><a href="#构造器-19" class="headerlink" title="构造器"></a>构造器</h5><p><code>MeshPhongMaterial( parameters : Object )</code></p>
<p>parameters - (可选)用于定义材质外观的对象，具有一个或多个属性。 材质的任何属性都可以从此处传入(包括从Material继承的任何属性)。</p>
<p>属性color例外，其可以作为十六进制字符串传递，默认情况下为 0xffffff（白色），内部调用Color.set(color)。</p>
<h5 id="属性-方法-15"><a href="#属性-方法-15" class="headerlink" title="属性|方法"></a>属性|方法</h5><blockquote>
<p>共有方法请参见其基类Material。<br>共有属性请参见其基类Material。</p>
</blockquote>
<p>.alphaMap : Texture<br>alpha贴图是一张灰度纹理，用于控制整个表面的不透明度。（黑色：完全透明；白色：完全不透明）。 默认值为null。</p>
<p>仅使用纹理的颜色，忽略alpha通道（如果存在）。 对于RGB和RGBA纹理，WebGL渲染器在采样此纹理时将使用绿色通道， 因为在DXT压缩和未压缩RGB 565格式中为绿色提供了额外的精度。 Luminance-only以及luminance/alpha纹理也仍然有效。</p>
<p>.aoMap : Texture<br>该纹理的红色通道用作环境遮挡贴图。默认值为null。aoMap需要第二组UV。</p>
<p>.aoMapIntensity : Float<br>环境遮挡效果的强度。默认值为1。零是不遮挡效果。</p>
<p>.bumpMap : Texture<br>用于创建凹凸贴图的纹理。黑色和白色值映射到与光照相关的感知深度。凹凸实际上不会影响对象的几何形状，只影响光照。如果定义了法线贴图，则将忽略该贴图。</p>
<p>.bumpScale : Float<br>凹凸贴图会对材质产生多大影响。典型范围是0-1。默认值为1。</p>
<p>.color : Color<br>材质的颜色(Color)，默认值为白色 (0xffffff)。</p>
<p>.combine : Integer<br>如何将表面颜色的结果与环境贴图（如果有）结合起来。</p>
<p>选项为THREE.MultiplyOperation（默认值），THREE.MixOperation， THREE.AddOperation。如果选择多个，则使用.reflectivity在两种颜色之间进行混合。</p>
<p>.displacementMap : Texture<br>位移贴图会影响网格顶点的位置，与仅影响材质的光照和阴影的其他贴图不同，移位的顶点可以投射阴影，阻挡其他对象， 以及充当真实的几何体。位移纹理是指：网格的所有顶点被映射为图像中每个像素的值（白色是最高的），并且被重定位。</p>
<p>.displacementScale : Float<br>位移贴图对网格的影响程度（黑色是无位移，白色是最大位移）。如果没有设置位移贴图，则不会应用此值。默认值为1。</p>
<p>.displacementBias : Float<br>位移贴图在网格顶点上的偏移量。如果没有设置位移贴图，则不会应用此值。默认值为0。</p>
<p>.emissive : Color<br>材质的放射（光）颜色，基本上是不受其他光照影响的固有颜色。默认为黑色。</p>
<p>.emissiveMap : Texture<br>设置放射（发光）贴图。默认值为null。放射贴图颜色由放射颜色和强度所调节。 如果你有一个放射贴图，请务必将放射颜色设置为黑色以外的其他颜色。</p>
<p>.emissiveIntensity : Float<br>放射光强度。调节发光颜色。默认为1。</p>
<p>.envMap : Texture<br>环境贴图。默认值为null。</p>
<p>.flatShading : Boolean<br>定义材质是否使用平面着色进行渲染。默认值为false。</p>
<p>.fog : Boolean<br>材质是否受雾影响。默认为true。</p>
<p>.lightMap : Texture<br>光照贴图。默认值为null。lightMap需要第二组UV。</p>
<p>.lightMapIntensity : Float<br>烘焙光的强度。默认值为1。</p>
<p>.map : Texture<br>颜色贴图。可以选择包括一个alpha通道，通常与.transparent 或.alphaTest。默认为null。 纹理贴图颜色由漫反射颜色.color调节。</p>
<p>.normalMap : Texture<br>用于创建法线贴图的纹理。RGB值会影响每个像素片段的曲面法线，并更改颜色照亮的方式。法线贴图不会改变曲面的实际形状，只会改变光照。 In case the material has a normal map authored using the left handed convention, the y component of normalScale should be negated to compensate for the different handedness.</p>
<p>.normalMapType : Integer<br>法线贴图的类型。</p>
<p>选项为THREE.TangentSpaceNormalMap（默认）和THREE.ObjectSpaceNormalMap。</p>
<p>.normalScale : Vector2<br>法线贴图对材质的影响程度。典型范围是0-1。默认值是Vector2设置为（1,1）。</p>
<p>.reflectivity : Float<br>环境贴图对表面的影响程度; 见.combine。默认值为1，有效范围介于0（无反射）和1（完全反射）之间。</p>
<p>.refractionRatio : Float<br>空气的折射率（IOR）（约为1）除以材质的折射率。它与环境映射模式THREE.CubeRefractionMapping 和THREE.EquirectangularRefractionMapping一起使用。 The index of refraction (IOR) of air (approximately 1) divided by the index of refraction of the material. It is used with environment mapping mode THREE.CubeRefractionMapping. 折射率不应超过1。默认值为0.98。</p>
<p>.shininess : Float<br>.specular高亮的程度，越高的值越闪亮。默认值为 30。</p>
<p>.specular : Color<br>材质的高光颜色。默认值为0x111111（深灰色）的颜色Color。</p>
<p>这定义了材质的光泽度和光泽的颜色。</p>
<p>.specularMap : Texture<br>镜面反射贴图值会影响镜面高光以及环境贴图对表面的影响程度。默认值为null。</p>
<p>.wireframe : Boolean<br>将几何体渲染为线框。默认值为false（即渲染为平面多边形）。</p>
<p>.wireframeLinecap : String<br>定义线两端的外观。可选值为 ‘butt’，’round’ 和 ‘square’。默认为’round’。</p>
<p>该属性对应2D Canvas lineJoin属性， 并且会被WebGL渲染器忽略。</p>
<p>.wireframeLinejoin : String<br>定义线连接节点的样式。可选值为 ‘round’, ‘bevel’ 和 ‘miter’。默认值为 ‘round’。</p>
<p>该属性对应2D Canvas lineJoin属性， 并且会被WebGL渲染器忽略。</p>
<p>.wireframeLinewidth : Float<br>控制线框宽度。默认值为1。</p>
<p>由于OpenGL Core Profile与 大多数平台上WebGL渲染器的限制，无论如何设置该值，线宽始终为1。</p>
<h4 id="标准网格材质-MeshStandardMaterial"><a href="#标准网格材质-MeshStandardMaterial" class="headerlink" title="标准网格材质(MeshStandardMaterial)"></a>标准网格材质(MeshStandardMaterial)</h4><p>一种基于物理的标准材质，使用Metallic-Roughness工作流程。</p>
<p>该材质提供了比MeshLambertMaterial 或MeshPhongMaterial 更精确和逼真的结果，代价是计算成本更高</p>
<h5 id="构造器-20"><a href="#构造器-20" class="headerlink" title="构造器"></a>构造器</h5><p><code>MeshStandardMaterial( parameters : Object )</code></p>
<p>parameters - (可选)用于定义材质外观的对象，具有一个或多个属性。 材质的任何属性都可以从此处传入(包括从Material继承的任何属性)。</p>
<p>属性color例外，其可以作为十六进制字符串传递，默认情况下为 0xffffff（白色），内部调用Color.set(color)。</p>
<h5 id="属性-方法-16"><a href="#属性-方法-16" class="headerlink" title="属性|方法"></a>属性|方法</h5><blockquote>
<p>共有方法请参见其基类Material。<br>共有属性请参见其基类Material。</p>
</blockquote>
<p>.alphaMap : Texture<br>alpha贴图是一张灰度纹理，用于控制整个表面的不透明度。（黑色：完全透明；白色：完全不透明）。 默认值为null。</p>
<p>仅使用纹理的颜色，忽略alpha通道（如果存在）。 对于RGB和RGBA纹理，WebGL渲染器在采样此纹理时将使用绿色通道， 因为在DXT压缩和未压缩RGB 565格式中为绿色提供了额外的精度。 Luminance-only以及luminance/alpha纹理也仍然有效。</p>
<p>.aoMap : Texture<br>该纹理的红色通道用作环境遮挡贴图。默认值为null。aoMap需要第二组UV。</p>
<p>.aoMapIntensity : Float<br>环境遮挡效果的强度。默认值为1。零是不遮挡效果。</p>
<p>.bumpMap : Texture<br>用于创建凹凸贴图的纹理。黑色和白色值映射到与光照相关的感知深度。凹凸实际上不会影响对象的几何形状，只影响光照。如果定义了法线贴图，则将忽略该贴图。</p>
<p>.bumpScale : Float<br>凹凸贴图会对材质产生多大影响。典型范围是0-1。默认值为1。</p>
<p>.color : Color<br>材质的颜色(Color)，默认值为白色 (0xffffff)。</p>
<p>.defines : Object<br>如下形式的对象:<code>&#123; &#39;STANDARD&#39;: &#39;&#39; &#125;</code>;WebGLRenderer使用它来选择shaders。</p>
<p>.displacementMap : Texture<br>位移贴图会影响网格顶点的位置，与仅影响材质的光照和阴影的其他贴图不同，移位的顶点可以投射阴影，阻挡其他对象， 以及充当真实的几何体。位移纹理是指：网格的所有顶点被映射为图像中每个像素的值（白色是最高的），并且被重定位。</p>
<p>.displacementScale : Float<br>位移贴图对网格的影响程度（黑色是无位移，白色是最大位移）。如果没有设置位移贴图，则不会应用此值。默认值为1。</p>
<p>.displacementBias : Float<br>位移贴图在网格顶点上的偏移量。如果没有设置位移贴图，则不会应用此值。默认值为0。</p>
<p>.emissive : Color<br>材质的放射（光）颜色，基本上是不受其他光照影响的固有颜色。默认为黑色。</p>
<p>.emissiveMap : Texture<br>设置放射（发光）贴图。默认值为null。放射贴图颜色由放射颜色和强度所调节。 如果你有一个放射贴图，请务必将放射颜色设置为黑色以外的其他颜色。</p>
<p>.emissiveIntensity : Float<br>放射光强度。调节发光颜色。默认为1。</p>
<p>.envMap : Texture<br>环境贴图，为了能够保证物理渲染准确，您应该添加由PMREMGenerator预处理过的环境贴图，默认为null。</p>
<p>.envMapIntensity : Float<br>通过乘以环境贴图的颜色来缩放环境贴图的效果。</p>
<p>.flatShading : Boolean<br>定义材质是否使用平面着色进行渲染。默认值为false。</p>
<p>.fog : Boolean<br>材质是否受雾影响。默认为true。</p>
<p>.isMeshStandardMaterial : Boolean<br>检查当前对象是否为标准网格材质的标记。</p>
<p>.lightMap : Texture<br>光照贴图。默认值为null。lightMap需要第二组UV。</p>
<p>.lightMapIntensity : Float<br>烘焙光的强度。默认值为1。</p>
<p>.map : Texture<br>颜色贴图。可以选择包括一个alpha通道，通常与.transparent 或.alphaTest。默认为null。 纹理贴图颜色由漫反射颜色.color调节。</p>
<p>.metalness : Float<br>材质与金属的相似度。非金属材质，如木材或石材，使用0.0，金属使用1.0，通常没有中间值。 默认值为0.0。0.0到1.0之间的值可用于生锈金属的外观。如果还提供了metalnessMap，则两个值相乘。</p>
<p>.metalnessMap : Texture<br>该纹理的蓝色通道用于改变材质的金属度。</p>
<p>.normalMap : Texture<br>用于创建法线贴图的纹理。RGB值会影响每个像素片段的曲面法线，并更改颜色照亮的方式。法线贴图不会改变曲面的实际形状，只会改变光照。 In case the material has a normal map authored using the left handed convention, the y component of normalScale should be negated to compensate for the different handedness.</p>
<p>.normalMapType : Integer<br>法线贴图的类型。</p>
<p>选项为THREE.TangentSpaceNormalMap（默认）和THREE.ObjectSpaceNormalMap。</p>
<p>.normalScale : Vector2<br>法线贴图对材质的影响程度。典型范围是0-1。默认值是Vector2设置为（1,1）。</p>
<p>.refractionRatio : Float<br>空气的折射率（IOR）（约为1）除以材质的折射率。它与环境映射模式THREE.CubeRefractionMapping 和THREE.EquirectangularRefractionMapping一起使用。 The index of refraction (IOR) of air (approximately 1) divided by the index of refraction of the material. It is used with environment mapping mode THREE.CubeRefractionMapping. 折射率不应超过1。默认值为0.98。</p>
<p>.roughness : Float<br>材质的粗糙程度。0.0表示平滑的镜面反射，1.0表示完全漫反射。默认值为1.0。如果还提供roughnessMap，则两个值相乘。</p>
<p>.roughnessMap : Texture<br>该纹理的绿色通道用于改变材质的粗糙度。</p>
<p>.wireframe : Boolean<br>将几何体渲染为线框。默认值为false（即渲染为平面多边形）。</p>
<p>.wireframeLinecap : String<br>定义线两端的外观。可选值为 ‘butt’，’round’ 和 ‘square’。默认为’round’。</p>
<p>该属性对应2D Canvas lineJoin属性， 并且会被WebGL渲染器忽略。</p>
<p>.wireframeLinejoin : String<br>定义线连接节点的样式。可选值为 ‘round’, ‘bevel’ 和 ‘miter’。默认值为 ‘round’。</p>
<p>该属性对应2D Canvas lineJoin属性， 并且会被WebGL渲染器忽略。</p>
<p>.wireframeLinewidth : Float<br>控制线框宽度。默认值为1。<br>由于OpenGL Core Profile与 大多数平台上WebGL渲染器的限制，无论如何设置该值，线宽始终为1。</p>
<h4 id="物理网格材质-MeshPhysicalMaterial"><a href="#物理网格材质-MeshPhysicalMaterial" class="headerlink" title="物理网格材质(MeshPhysicalMaterial)"></a>物理网格材质(MeshPhysicalMaterial)</h4><p>提供了更高级的基于物理的渲染属性<br>物理网格材质使用了更复杂的着色器功能，所以在每个像素的渲染都要比three.js中的其他材质更费性能，大部分的特性是默认关闭的，需要手动开启，每开启一项功能在开启的时候才会更耗性能。请注意，为获得最佳效果，您在使用此材质时应始终指定environment map。</p>
<h5 id="构造器-21"><a href="#构造器-21" class="headerlink" title="构造器"></a>构造器</h5><p><code>MeshPhysicalMaterial( parameters : Object )</code><br>parameters - (可选)用于定义材质外观的对象，具有一个或多个属性。 材质的任何属性都可以从此处传入(包括从Material和MeshStandardMaterial继承的任何属性)</p>
<p>属性color例外，其可以作为十六进制字符串传递，默认情况下为 0xffffff（白色），内部调用Color.set(color)。</p>
<h4 id="基础线条材质（LineBasicMaterial）"><a href="#基础线条材质（LineBasicMaterial）" class="headerlink" title="基础线条材质（LineBasicMaterial）"></a>基础线条材质（LineBasicMaterial）</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> material = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">LineBasicMaterial</span>( &#123;</span><br><span class="line"> <span class="attr">color</span>: <span class="number">0xffffff</span>,</span><br><span class="line"> <span class="attr">linewidth</span>: <span class="number">1</span>,</span><br><span class="line"> <span class="attr">linecap</span>: <span class="string">&#x27;round&#x27;</span>, <span class="comment">//ignored by WebGLRenderer</span></span><br><span class="line"> <span class="attr">linejoin</span>:  <span class="string">&#x27;round&#x27;</span> <span class="comment">//ignored by WebGLRenderer</span></span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure>

<h5 id="构造器-22"><a href="#构造器-22" class="headerlink" title="构造器"></a>构造器</h5><p><code>LineBasicMaterial( parameters : Object )</code><br>parameters - (可选)用于定义材质外观的对象，具有一个或多个属性。材质的任何属性都可以从此处传入(包括从Material继承的任何属性)。</p>
<p>属性color例外，其可以作为十六进制字符串传递，默认情况下为 0xffffff（白色），内部调用Color.set(color)。</p>
<h5 id="属性-方法-17"><a href="#属性-方法-17" class="headerlink" title="属性|方法"></a>属性|方法</h5><blockquote>
<p>共有方法请参见其基类Material。<br>共有属性请参见其基类Material。</p>
</blockquote>
<ul>
<li><p><code>.color : Color</code><br>材质的颜色(Color)，默认值为白色 (0xffffff)。</p>
</li>
<li><p><code>.fog : Boolean</code><br>材质是否受雾影响。默认为true。</p>
</li>
<li><p><code>.linewidth : Float</code><br>控制线宽。默认值为 1。</p>
</li>
</ul>
<p>由于OpenGL Core Profile与 大多数平台上WebGL渲染器的限制，无论如何设置该值，线宽始终为1。</p>
<ul>
<li><code>.linecap : String</code><br>定义线两端的样式。可选值为 ‘butt’, ‘round’ 和 ‘square’。默认值为 ‘round’。</li>
</ul>
<p>该属性对应2D Canvas lineCap属性， 并且会被WebGL渲染器忽略。</p>
<ul>
<li><code>.linejoin : String</code><br>定义线连接节点的样式。可选值为 ‘round’, ‘bevel’ 和 ‘miter’。默认值为 ‘round’。</li>
</ul>
<p>该属性对应2D Canvas lineJoin属性， 并且会被WebGL渲染器忽略。</p>
<ul>
<li><code>.map : Texture</code><br>Sets the color of the lines using data from a Texture.</li>
</ul>
<h4 id="虚线材质-LineDashedMaterial"><a href="#虚线材质-LineDashedMaterial" class="headerlink" title="虚线材质(LineDashedMaterial)"></a>虚线材质(LineDashedMaterial)</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> material = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">LineDashedMaterial</span>( &#123;</span><br><span class="line"> <span class="attr">color</span>: <span class="number">0xffffff</span>,</span><br><span class="line"> <span class="attr">linewidth</span>: <span class="number">1</span>,</span><br><span class="line"> <span class="attr">scale</span>: <span class="number">1</span>,</span><br><span class="line"> <span class="attr">dashSize</span>: <span class="number">3</span>,</span><br><span class="line"> <span class="attr">gapSize</span>: <span class="number">1</span>,</span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure>

<h5 id="构造器-23"><a href="#构造器-23" class="headerlink" title="构造器"></a>构造器</h5><p><code>LineDashedMaterial( parameters : Object )</code><br>parameters - (可选)用于定义材质外观的对象，具有一个或多个属性。材质的任何属性都可以从此处传入(包括从LineBasicMaterial继承的任何属性)。</p>
<h5 id="属性-方法-18"><a href="#属性-方法-18" class="headerlink" title="属性|方法"></a>属性|方法</h5><blockquote>
<p>共有方法请参见其基类Material。<br>共有属性请参见其基类Material。</p>
</blockquote>
<ul>
<li><p><code>.dashSize</code> : number<br>虚线的大小，是指破折号和间隙之和。默认值为 3。</p>
</li>
<li><p><code>.gapSize</code> : number<br>间隙的大小，默认值为 1。</p>
</li>
<li><p><code>.isLineDashedMaterial</code> : Boolean<br>Read-only flag to check if a given object is of type LineDashedMaterial.</p>
</li>
<li><p><code>.scale</code> : number<br>线条中虚线部分的占比。默认值为 1。</p>
</li>
</ul>
<h4 id="卡通着色的材质（MeshToonMaterial）"><a href="#卡通着色的材质（MeshToonMaterial）" class="headerlink" title="卡通着色的材质（MeshToonMaterial）"></a>卡通着色的材质（MeshToonMaterial）</h4><h5 id="构造器-24"><a href="#构造器-24" class="headerlink" title="构造器"></a>构造器</h5><p><code>MeshToonMaterial( parameters : Object )</code><br>parameters - (可选)用于定义材质外观的对象，具有一个或多个属性。材质的任何属性都可以从此处传入(包括从LineBasicMaterial继承的任何属性)。</p>
<h4 id="阴影材质-ShadowMaterial"><a href="#阴影材质-ShadowMaterial" class="headerlink" title="阴影材质(ShadowMaterial)"></a>阴影材质(ShadowMaterial)</h4><p>此材质可以接收阴影，但在其他方面完全透明。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> geometry = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">PlaneGeometry</span>( <span class="number">2000</span>, <span class="number">2000</span> );</span><br><span class="line">geometry.<span class="title function_">rotateX</span>( - <span class="title class_">Math</span>.<span class="property">PI</span> / <span class="number">2</span> );</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> material = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">ShadowMaterial</span>();</span><br><span class="line">material.<span class="property">opacity</span> = <span class="number">0.2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> plane = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Mesh</span>( geometry, material );</span><br><span class="line">plane.<span class="property">position</span>.<span class="property">y</span> = -<span class="number">200</span>;</span><br><span class="line">plane.<span class="property">receiveShadow</span> = <span class="literal">true</span>;</span><br><span class="line">scene.<span class="title function_">add</span>( plane );</span><br></pre></td></tr></table></figure>

<h5 id="构造器-25"><a href="#构造器-25" class="headerlink" title="构造器"></a>构造器</h5><p><code>ShadowMaterial( parameters : Object )</code><br>parameters - (可选)用于定义材质外观的对象，具有一个或多个属性。材质的任何属性都可以从此处传入(包括从LineBasicMaterial继承的任何属性)。</p>
<h5 id="属性-方法-19"><a href="#属性-方法-19" class="headerlink" title="属性|方法"></a>属性|方法</h5><blockquote>
<p>共有方法请参见其基类Material。<br>共有属性请参见其基类Material。<br>.color : Color<br>Color of the material, by default set to black (0x000000).</p>
</blockquote>
<p>.fog : Boolean<br>材质是否受雾影响。默认为true。</p>
<p>.transparent : Boolean<br>定义此材质是否透明。默认值为 true。</p>
<h4 id="点材质-PointsMaterial"><a href="#点材质-PointsMaterial" class="headerlink" title="点材质(PointsMaterial)"></a>点材质(PointsMaterial)</h4><h5 id="构造器-26"><a href="#构造器-26" class="headerlink" title="构造器"></a>构造器</h5><p><code>PointsMaterial( parameters : Object )</code><br>parameters - (可选)用于定义材质外观的对象，具有一个或多个属性。材质的任何属性都可以从此处传入(包括从LineBasicMaterial继承的任何属性)。<br>属性color例外，其可以作为十六进制字符串传递，默认情况下为 0xffffff（白色），内部调用Color.set(color)。</p>
<h4 id="点精灵材质-SpriteMaterial"><a href="#点精灵材质-SpriteMaterial" class="headerlink" title="点精灵材质(SpriteMaterial)"></a>点精灵材质(SpriteMaterial)</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">TextureLoader</span>().<span class="title function_">load</span>( <span class="string">&#x27;textures/sprite.png&#x27;</span> );</span><br><span class="line"><span class="keyword">const</span> material = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">SpriteMaterial</span>( &#123; <span class="attr">map</span>: map, <span class="attr">color</span>: <span class="number">0xffffff</span> &#125; );</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sprite = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Sprite</span>( material );</span><br><span class="line">sprite.<span class="property">scale</span>.<span class="title function_">set</span>(<span class="number">200</span>, <span class="number">200</span>, <span class="number">1</span>)</span><br><span class="line">scene.<span class="title function_">add</span>( sprite );</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="构造器-27"><a href="#构造器-27" class="headerlink" title="构造器"></a>构造器</h5><p><code>SpriteMaterial( parameters : Object )</code><br>parameters - (可选)用于定义材质外观的对象，具有一个或多个属性。 材质的任何属性都可以从此处传入(包括从Material 和 ShaderMaterial继承的任何属性)。</p>
<p>属性color例外，其可以作为十六进制字符串传递，默认情况下为 0xffffff（白色）， 内部调用Color.set(color)。 SpriteMaterials不会被Material.clippingPlanes裁剪。</p>
<h5 id="属性-方法-20"><a href="#属性-方法-20" class="headerlink" title="属性|方法"></a>属性|方法</h5><p>.alphaMap : Texture<br>alpha贴图是一张灰度纹理，用于控制整个表面的不透明度。（黑色：完全透明；白色：完全不透明）。 默认值为null。</p>
<p>仅使用纹理的颜色，忽略alpha通道（如果存在）。 对于RGB和RGBA纹理，WebGL渲染器在采样此纹理时将使用绿色通道， 因为在DXT压缩和未压缩RGB 565格式中为绿色提供了额外的精度。 Luminance-only以及luminance/alpha纹理也仍然有效。</p>
<p>.color : Color<br>材质的颜色(Color)，默认值为白色 (0xffffff)。 .map会和 color 相乘。</p>
<p>.fog : Boolean<br>材质是否受雾影响。默认为true。</p>
<p>.isSpriteMaterial : Boolean<br>Read-only flag to check if a given object is of type SpriteMaterial.</p>
<p>.map : Texture<br>颜色贴图。可以选择包括一个alpha通道，通常与.transparent 或.alphaTest。默认为null。</p>
<p>.rotation : Radians<br>sprite的转动，以弧度为单位。默认值为0。</p>
<p>.sizeAttenuation : Boolean<br>精灵的大小是否会被相机深度衰减。（仅限透视摄像头。）默认为true。</p>
<p>.transparent : Boolean<br>定义此材质是否透明。默认值为 true。</p>
<h3 id="物体"><a href="#物体" class="headerlink" title="物体"></a>物体</h3><h4 id="三维物体（Object3D）"><a href="#三维物体（Object3D）" class="headerlink" title="三维物体（Object3D）"></a>三维物体（Object3D）</h4><p>这是Three.js中大部分对象的基类，提供了一系列的属性和方法来对三维空间中的物体进行操纵。</p>
<p>请注意，可以通过.add( object )方法来将对象进行组合，该方法将对象添加为子对象，但为此最好使用Group（来作为父对象）</p>
<h5 id="构造器-28"><a href="#构造器-28" class="headerlink" title="构造器"></a>构造器</h5><p><code>Object3D()</code><br>构造器中不带有参数。</p>
<h5 id="属性-6"><a href="#属性-6" class="headerlink" title="属性"></a>属性</h5><ul>
<li><p><code>.animations</code> : AnimationClip<br>三维物体所属的动画剪辑数组.</p>
</li>
<li><p><code>.castShadow</code> : Boolean<br>对象是否被渲染到阴影贴图中。默认值为false。</p>
</li>
<li><p><code>.children</code> : Array<br>含有对象的子级的数组。请参阅Group来了解将手动对象进行分组的相关信息。</p>
</li>
<li><p><code>.customDepthMaterial</code> : Material<br>在渲染到深度图的时候所用的自定义深度材质。 只能在网格中使用。 当使用DirectionalLight（平行光）或者SpotLight（聚光灯光）生成影子的时候, 如果你调整过顶点着色器中的顶点位置，就需要定义一个自定义深度材质来生成正确的影子。默认为undefined.</p>
</li>
<li><p><code>.customDistanceMaterial</code> : Material<br>与customDepthMaterial相同，但与PointLight(点光源）一起使用。默认值为undefined。</p>
</li>
<li><p><code>.frustumCulled</code> : Boolean<br>当这个设置了的时候，每一帧渲染前都会检测这个物体是不是在相机的视椎体范围内。 如果设置为false 物体不管是不是在相机的视椎体范围内都会渲染。默认为true。</p>
</li>
<li><p><code>.id</code> : Integer<br>只读 —— 表示该对象实例ID的唯一数字。</p>
</li>
<li><p><code>.isObject3D</code> : Boolean<br>查看所给对象是不是Object3D类型的只读标记.</p>
</li>
<li><p><code>.layers</code> : Layers<br>物体的层级关系。 物体只有和一个正在使用的Camera至少在同一个层时才可见。当使用Raycaster进行射线检测的时候此项属性可以用于过滤不参与检测的物体.</p>
</li>
<li><p><code>.matrix</code> : Matrix4<br>局部变换矩阵。</p>
</li>
<li><p><code>.matrixAutoUpdate</code> : Boolean<br>当这个属性设置了之后，它将计算每一帧的位移、旋转（四元变换）和缩放矩阵，并重新计算matrixWorld属性。默认值是Object3D.DEFAULT_MATRIX_AUTO_UPDATE (true)。</p>
</li>
<li><p><code>.matrixWorld</code> : Matrix4<br>物体的世界变换。若这个Object3D没有父级，则它将和local transform .matrix（局部变换矩阵）相同。</p>
</li>
<li><p><code>.matrixWorldAutoUpdate</code> : Boolean<br>默认为 true. 当设置的时候，渲染器在每一帧都会检查物体自身以及它的自带是否需要更新世界变换矩阵。 如果不需要的话它自身以及它的子代的所有世界变换矩阵都需要你来维护。</p>
</li>
<li><p><code>.matrixWorldNeedsUpdate</code> : Boolean<br>当这个属性设置了之后，它将计算在那一帧中的matrixWorld，并将这个值重置为false。默认值为false。</p>
</li>
<li><p><code>.modelViewMatrix</code> : Matrix4<br>这个值传递给着色器，用于计算物体的位置。</p>
</li>
<li><p><code>.name</code> : String<br>对象的名称，可选、不必唯一。默认值是一个空字符串。</p>
</li>
<li><p><code>.normalMatrix</code> : Matrix3<br>这个值传递给着色器，用于计算物体的光照。 它是物体的modelViewMatrix矩阵中，左上角3x3子矩阵的逆的转置矩阵。</p>
</li>
</ul>
<p>使用这个特殊矩阵的原因，是只需使用modelViewMatrix就可以得出一个法线（缩放时）的非单位长度或者非垂直的方向（不规则缩放时）。</p>
<p>另一方面，modelViewMatrix矩阵中的位移部分和法线的计算无关，因此Matrix3就已经足够了。</p>
<ul>
<li><code>.onAfterRender</code> : Function<br>一个可选的回调函数，在Object3D渲染之后直接执行。 使用以下参数来调用此函数：renderer，scene，camera，geometry，material，group。</li>
</ul>
<p>注意此回调函数只会在<em>可渲染</em>的3D物体上执行。可渲染的3D物体指的是那种拥有视觉表现的、定义了几何体与材质的物体，例如像是Mesh、Line、Points 或者Sprite。 Object3D、 Group 或者 Bone 这些是不可渲染的物体，因此此回调函数不会在这样的物体上执行。</p>
<ul>
<li><code>.onBeforeRender</code> : Function<br>一个可选的回调函数，在Object3D渲染之前直接执行。 使用以下参数来调用此函数：renderer，scene，camera，geometry，material，group。</li>
</ul>
<p>注意此回调函数只会在<em>可渲染</em>的3D物体上执行。可渲染的3D物体指的是那种拥有视觉表现的、定义了几何体与材质的物体，例如像是Mesh、Line、Points 或者Sprite。 Object3D、 Group 或者 Bone 这些是不可渲染的物体，因此此回调函数不会在这样的物体上执行。</p>
<ul>
<li><p><code>.parent</code> : Object3D<br>在scene graph（场景图）中，一个对象的父级对象。 一个对象最多仅能有一个父级对象。</p>
</li>
<li><p><code>.position</code> : Vector3<br>表示对象局部位置的Vector3。默认值为(0, 0, 0)。</p>
</li>
<li><p><code>.quaternion</code> : Quaternion<br>表示对象局部旋转的Quaternion（四元数）。</p>
</li>
<li><p><code>.receiveShadow</code> : Boolean<br>材质是否接收阴影。默认值为false。</p>
</li>
<li><p><code>.renderOrder</code> : Number<br>这个值将使得scene graph（场景图）中默认的的渲染顺序被覆盖， 即使不透明对象和透明对象保持独立顺序。 渲染顺序是由低到高来排序的，默认值为0。</p>
</li>
<li><p><code>.rotation</code> : Euler<br>物体的局部旋转，以弧度来表示。（请参阅Euler angles-欧拉角）</p>
</li>
<li><p><code>.scale</code> : Vector3<br>物体的局部缩放。默认值是Vector3( 1, 1, 1 )。</p>
</li>
<li><p><code>.up</code> : Vector3<br>这个属性由lookAt方法所使用，例如，来决定结果的朝向。 默认值是Object3D.DEFAULT_UP，即( 0, 1, 0 )。</p>
</li>
<li><p><code>.userData</code> : Object<br>一个用于存储Object3D自定义数据的对象。 它不应当包含对函数的引用，因为这些函数将不会被克隆。</p>
</li>
<li><p><code>.uuid</code> : String<br>该对象实例的UUID。 这是一个自动生成的值，不应当对其进行修改。</p>
</li>
<li><p><code>.visible</code> : Boolean<br>可见性。这个值为true时，物体将被渲染。默认值为true。</p>
</li>
</ul>
<p>静态属性<br>静态属性和方法由每个类所定义，并非由每个类的实例所定义。 也就是说，改变Object3D.DEFAULT_UP或Object3D.DEFAULT_MATRIX_AUTO_UPDATE的值， 将改变每个在此之后由Object3D类（或派生类）创建的实例中的up和matrixAutoUpdate的值。（已经创建好的Object3D不会受到影响）。</p>
<ul>
<li><p><code>.DEFAULT_UP</code> : Vector3<br>默认的物体的up方向，同时也作为DirectionalLight、HemisphereLight和Spotlight（自顶向下创建的灯光）的默认方向。 默认设为( 0, 1, 0 )。</p>
</li>
<li><p><code>.DEFAULT_MATRIX_AUTO_UPDATE</code> : Boolean<br>matrixAutoUpdate的默认设置，用于新创建的Object3D。<br>.DEFAULT_MATRIX_WORLD_AUTO_UPDATE : Boolean<br>matrixWorldAutoUpdate的默认设置，用于新创建的Object3D。</p>
</li>
</ul>
<h5 id="方法-6"><a href="#方法-6" class="headerlink" title="方法"></a>方法</h5><p>EventDispatcher 在该类上可用的所有方法。</p>
<ul>
<li><code>.add ( object : Object3D, ... ) : this</code><br>添加对象到这个对象的子级，可以添加任意数量的对象。 当前传入的对象中的父级将在这里被移除，因为一个对象仅能有一个父级。</li>
</ul>
<p>请参阅Group来查看手动编组对象的相关信息。</p>
<ul>
<li><p><code>.applyMatrix4 ( matrix : Matrix4 ) : undefined</code><br>对当前物体应用这个变换矩阵，并更新物体的位置、旋转和缩放。</p>
</li>
<li><p><code>.applyQuaternion ( quaternion : Quaternion ) : this</code><br>对当前物体应用由四元数所表示的变换。</p>
</li>
<li><p><code>.attach ( object : Object3D ) : this</code><br>将object作为子级来添加到该对象中，同时保持该object的世界变换。</p>
</li>
<li><p><code>.clone ( recursive : Boolean ) : Object3D</code><br>recursive —— 如果值为true，则该物体的后代也会被克隆。默认值为true。</p>
</li>
</ul>
<p>返回对象前物体的克隆（以及可选的所有后代）。</p>
<ul>
<li><code>.copy ( object : Object3D, recursive : Boolean ) : this</code><br>recursive —— 如果值为true，则该物体的后代也会被复制。默认值为true。</li>
</ul>
<p>复制给定的对象到这个对象中。 请注意，事件监听器和用户定义的回调函数（.onAfterRender 和 .onBeforeRender）不会被复制。</p>
<ul>
<li><code>.getObjectById ( id : Integer ) : Object3D</code><br>id —— 标识该对象实例的唯一数字。</li>
</ul>
<p>从该对象开始，搜索一个对象及其子级，返回第一个带有匹配id的子对象。<br>请注意，id是按照时间顺序来分配的：1、2、3、……，每增加一个新的对象就自增1。</p>
<ul>
<li><code>.getObjectByName ( name : String ) : Object3D</code><br>name —— 用于来匹配子物体中Object3D.name属性的字符串。</li>
</ul>
<p>从该对象开始，搜索一个对象及其子级，返回第一个带有匹配name的子对象。<br>请注意，大多数的对象中name默认是一个空字符串，要使用这个方法，你将需要手动地设置name属性。</p>
<ul>
<li><code>.getObjectByProperty ( name : String, value : Any ) : Object3D</code><br>name —— 将要用于查找的属性的名称。<br>value —— 给定的属性的值。</li>
</ul>
<p>从该对象开始，搜索一个对象及其子级，返回第一个给定的属性中包含有匹配的值的子对象。</p>
<ul>
<li><code>.getObjectsByProperty ( name : String, value : Any ) : Object3D</code><br>name —— 将要用于查找的属性的名称。<br>value —— 给定的属性的值。</li>
</ul>
<p>从此对象开始，搜索一个对象及其子对象，返回包含给定属性的匹配值的所有子对象。</p>
<ul>
<li><code>.getWorldPosition ( target : Vector3 ) : Vector3</code><br>target — 结果将被复制到这个Vector3中。</li>
</ul>
<p>返回一个表示该物体在世界空间中位置的矢量。</p>
<ul>
<li><code>.getWorldQuaternion ( target : Quaternion ) : Quaternion</code><br>target — 结果将被复制到这个Quaternion中。</li>
</ul>
<p>返回一个表示该物体在世界空间中旋转的四元数。</p>
<ul>
<li><code>.getWorldScale ( target : Vector3 ) : Vector3</code><br>target — 结果将被复制到这个Vector3中。</li>
</ul>
<p>返回一个包含着该物体在世界空间中各个轴向上所应用的缩放因数的矢量。</p>
<ul>
<li><code>.getWorldDirection ( target : Vector3 ) : Vector3</code><br>target — 结果将被复制到这个Vector3中。</li>
</ul>
<p>返回一个表示该物体在世界空间中Z轴正方向的矢量。</p>
<ul>
<li><code>.localToWorld ( vector : Vector3 ) : Vector3</code><br>vector - 一个表示在该物体局部空间中位置的向量。</li>
</ul>
<p>将该向量从物体的局部空间转换到世界空间。</p>
<ul>
<li><code>.lookAt ( vector : Vector3 ) : undefined</code><br>.lookAt ( x : Float, y : Float, z : Float ) : undefined<br>vector - 一个表示世界空间中位置的向量。</li>
</ul>
<p>也可以使用世界空间中x、y和z的位置分量。</p>
<p>旋转物体使其在世界空间中面朝一个点。</p>
<p>这一方法不支持其父级被旋转过或者被位移过的物体。</p>
<ul>
<li><p><code>.raycast ( raycaster : Raycaster, intersects : Array ) : undefined</code><br>抽象（空方法），在一条被投射出的射线与这个物体之间获得交点。 在一些子类，例如Mesh, Line, and Points实现了这个方法，以用于光线投射。</p>
</li>
<li><p><code>.remove ( object : Object3D, ... ) : this</code><br>从当前对象的子级中移除对象。可以移除任意数量的对象。</p>
</li>
<li><p><code>.removeFromParent () : this</code><br>Removes this object from its current parent.</p>
</li>
<li><p><code>.rotateOnAxis ( axis : Vector3, angle : Float ) : this</code><br>axis —— 一个在局部空间中的标准化向量。<br>angle —— 角度，以弧度来表示。</p>
</li>
</ul>
<p>在局部空间中绕着该物体的轴来旋转一个物体，假设这个轴已被标准化。</p>
<ul>
<li><code>.rotateOnWorldAxis ( axis : Vector3, angle : Float ) : this</code><br>axis – 一个在世界空间中的标准化向量。<br>angle – 角度，以弧度来表示。</li>
</ul>
<p>在世界空间中绕着该物体的轴来旋转一个物体，假设这个轴已被标准化。 方法假设该物体没有旋转过的父级。</p>
<ul>
<li><code>.rotateX ( rad : Float ) : this</code><br>rad - 将要旋转的角度（以弧度来表示）。</li>
</ul>
<p>绕局部空间的X轴旋转这个物体。</p>
<ul>
<li><code>.rotateY ( rad : Float ) : this</code><br>rad - 将要旋转的角度（以弧度来表示）。</li>
</ul>
<p>绕局部空间的Y轴旋转这个物体。</p>
<ul>
<li><code>.rotateZ ( rad : Float ) : this</code><br>rad - 将要旋转的角度（以弧度来表示）。</li>
</ul>
<p>绕局部空间的Z轴旋转这个物体。</p>
<ul>
<li><code>.setRotationFromAxisAngle ( axis : Vector3, angle : Float ) : undefined</code><br>axis – 一个在局部空间中的标准化向量。<br>angle – 角度（以弧度来表示）。</li>
</ul>
<p>调用.quaternion中的setFromAxisAngle( axis, angle )。</p>
<ul>
<li><p><code>.setRotationFromEuler ( euler : Euler ) : undefined</code><br>euler – 指定了旋转量的欧拉角。<br>调用.quaternion中的setRotationFromEuler( euler)。</p>
</li>
<li><p><code>.setRotationFromMatrix ( m : Matrix4 ) : undefined</code><br>m – 通过该矩阵中的旋转分量来旋转四元数。<br>调用.quaternion中的setFromRotationMatrix( m)。</p>
</li>
</ul>
<p>请注意，这里假设m上的3x3矩阵是一个纯旋转矩阵（即未缩放的矩阵）。</p>
<ul>
<li><code>.setRotationFromQuaternion ( q : Quaternion ) : undefined</code><br>q – 标准化的四元数。</li>
</ul>
<p>将所给的四元数复制到.quaternion中。</p>
<ul>
<li><p><code>.toJSON ( meta : Object ) : Object</code><br>meta – 包含有元数据的对象，例如该对象的材质、纹理或图片。 将对象转换为 three.js JSON Object/Scene format（three.js JSON 物体/场景格式）。</p>
</li>
<li><p><code>.translateOnAxis ( axis : Vector3, distance : Float ) : this</code><br>axis – 一个在局部空间中的标准化向量。<br>distance – 将要平移的距离。</p>
</li>
</ul>
<p>在局部空间中沿着一条轴来平移物体，假设轴已被标准化。</p>
<ul>
<li><p><code>.translateX ( distance : Float ) : this</code><br>沿着X轴将平移distance个单位。</p>
</li>
<li><p><code>.translateY ( distance : Float ) : this</code><br>沿着Y轴将平移distance个单位。</p>
</li>
<li><p><code>.translateZ ( distance : Float ) : this</code><br>沿着Z轴将平移distance个单位。</p>
</li>
<li><p><code>.traverse ( callback : Function ) : undefined</code><br>callback - 以一个object3D对象作为第一个参数的函数。</p>
</li>
</ul>
<p>在对象以及后代中执行的回调函数。</p>
<ul>
<li><code>.traverseVisible ( callback : Function ) : undefined</code><br>callback - 以一个object3D对象作为第一个参数的函数。</li>
</ul>
<p>类似traverse函数，但在这里，回调函数仅对可见的对象执行，不可见对象的后代将不遍历。</p>
<ul>
<li><code>.traverseAncestors ( callback : Function ) : undefined</code><br>callback - 以一个object3D对象作为第一个参数的函数。</li>
</ul>
<p>在所有的祖先中执行回调函数。</p>
<ul>
<li><p><code>.updateMatrix () : undefined</code><br>更新局部变换。</p>
</li>
<li><p><code>.updateMatrixWorld ( force : Boolean ) : undefined</code><br>更新物体及其后代的全局变换。</p>
</li>
<li><p><code>.updateWorldMatrix ( updateParents : Boolean, updateChildren : Boolean ) : undefined</code><br>updateParents - 递归更新物体的所有祖先的全局变换.<br>updateChildren - 递归更新物体的所有后代的全局变换.</p>
</li>
</ul>
<p>更新物体的全局变换。</p>
<ul>
<li><code>.worldToLocal ( vector : Vector3 ) : Vector3</code><br>vector - 一个表示在世界空间中位置的向量。</li>
</ul>
<p>将该向量从世界空间转换到物体的局部空间。</p>
<h4 id="网格模型（Mesh）"><a href="#网格模型（Mesh）" class="headerlink" title="网格模型（Mesh）"></a>网格模型（Mesh）</h4><p>表示基于以三角形为polygon mesh（多边形网格）的物体的类。 同时也作为其他类的基类<br>网格模型Mesh其实就一个一个三角形(面)拼接构成。使用使用网格模型Mesh渲染几何体geometry，就是几何体所有顶点坐标三个为一组，构成一个三角形，多组顶点构成多个三角形，就可以用来模拟表示物体的表面。<br>空间中一个三角形有正反两面，相机对着三角形的一个面，如果三个顶点的顺序是逆时针方向，该面视为正面，如果三个顶点的顺序是顺时针方向，该面视为反面。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> geometry = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">BoxGeometry</span>( <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span> );</span><br><span class="line"><span class="keyword">const</span> material = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">MeshBasicMaterial</span>( &#123; <span class="attr">color</span>: <span class="number">0xffff00</span> &#125; );</span><br><span class="line"><span class="keyword">const</span> mesh = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Mesh</span>( geometry, material );</span><br><span class="line">scene.<span class="title function_">add</span>( mesh );</span><br></pre></td></tr></table></figure>

<p>网格模型Mesh对应的几何体BufferGeometry，拆分为多个三角后，很多三角形重合的顶点位置坐标是相同的，这时候如果你想减少顶点坐标数据量，可以借助几何体顶点索引geometry.index来实现。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//每个三角形3个顶点坐标，矩形平面可以拆分为两个三角形，也就是6个顶点坐标。</span></span><br><span class="line"><span class="keyword">const</span> vertices = <span class="keyword">new</span> <span class="title class_">Float32Array</span>([</span><br><span class="line">    <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="comment">//顶点1坐标</span></span><br><span class="line">    <span class="number">80</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="comment">//顶点2坐标</span></span><br><span class="line">    <span class="number">80</span>, <span class="number">80</span>, <span class="number">0</span>, <span class="comment">//顶点3坐标</span></span><br><span class="line">    <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="comment">//顶点4坐标   和顶点1位置相同</span></span><br><span class="line">    <span class="number">80</span>, <span class="number">80</span>, <span class="number">0</span>, <span class="comment">//顶点5坐标  和顶点3位置相同</span></span><br><span class="line">    <span class="number">0</span>, <span class="number">80</span>, <span class="number">0</span>, <span class="comment">//顶点6坐标</span></span><br><span class="line">]);</span><br><span class="line"><span class="comment">//如果几何体有顶点索引geometry.index，那么你可以吧三角形重复的顶点位置坐标删除。</span></span><br><span class="line"><span class="keyword">const</span> vertices = <span class="keyword">new</span> <span class="title class_">Float32Array</span>([</span><br><span class="line">    <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="comment">//顶点1坐标</span></span><br><span class="line">    <span class="number">80</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="comment">//顶点2坐标</span></span><br><span class="line">    <span class="number">80</span>, <span class="number">80</span>, <span class="number">0</span>, <span class="comment">//顶点3坐标</span></span><br><span class="line">    <span class="number">0</span>, <span class="number">80</span>, <span class="number">0</span>, <span class="comment">//顶点4坐标</span></span><br><span class="line">]);</span><br></pre></td></tr></table></figure>

<p>BufferAttribute定义顶点索引.index数据<br>通过javascript类型化数组Uint16Array创建顶点索引.index数据。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Uint16Array类型数组创建顶点索引数据</span></span><br><span class="line"><span class="keyword">const</span> indexes = <span class="keyword">new</span> <span class="title class_">Uint16Array</span>([</span><br><span class="line">    <span class="comment">// 下面索引值对应顶点位置数据中的顶点坐标</span></span><br><span class="line">    <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>,</span><br><span class="line">])</span><br></pre></td></tr></table></figure>

<p>通过threejs的属性缓冲区对象BufferAttribute表示几何体顶点索引.index数据。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 索引数据赋值给几何体的index属性</span></span><br><span class="line">geometry.<span class="property">index</span> = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">BufferAttribute</span>(indexes, <span class="number">1</span>); <span class="comment">//1个为一组</span></span><br></pre></td></tr></table></figure>

<h4 id="构造器-29"><a href="#构造器-29" class="headerlink" title="构造器"></a>构造器</h4><p><code>Mesh( geometry : BufferGeometry, material : Material )</code><br>geometry —— （可选）BufferGeometry的实例，默认值是一个新的BufferGeometry。<br>material —— （可选）一个Material，或是一个包含有Material的数组，默认是一个新的MeshBasicMa`terial。</p>
<h5 id="属性-7"><a href="#属性-7" class="headerlink" title="属性"></a>属性</h5><p>共有属性请参见其基类Object3D。</p>
<p>.geometry : BufferGeometry<br>BufferGeometry 的实例或者派生类，定义了物体的结构。</p>
<p>.isMesh : Boolean<br>Read-only flag to check if a given object is of type Mesh.</p>
<p>.material : Material<br>由Material基类或者一个包含材质的数组派生而来的材质实例，定义了物体的外观。默认值是一个MeshBasicMaterial。</p>
<p>.morphTargetInfluences : Array<br>一个包含有权重（值一般在0-1范围内）的数组，指定应用了多少变形。 默认情况下是未定义的，但是会被updateMorphTargets重置为一个空数组。</p>
<p>.morphTargetDictionary : Object<br>基于morphTarget.name属性的morphTargets字典。 默认情况下是未定义的，但是会被updateMorphTargets重建。</p>
<h5 id="方法-7"><a href="#方法-7" class="headerlink" title="方法"></a>方法</h5><p>共有方法请参见其基类Object3D。</p>
<p>.clone () : Mesh<br>返回这个Mesh对象及其子级的克隆。</p>
<p>.raycast ( raycaster : Raycaster, intersects : Array ) : undefined<br>在一条投射出去的Ray（射线）和这个网格之间产生交互。 Raycaster.intersectObject将会调用这个方法。</p>
<p>.updateMorphTargets () : undefined<br>更新morphTargets，使其不对对象产生影响，重置morphTargetInfluences and morphTargetDictionary属性。</p>
<h4 id="点（Points）"><a href="#点（Points）" class="headerlink" title="点（Points）"></a>点（Points）</h4><p>一个用于显示点的类。 由WebGLRenderer渲染的点使用 gl.POINTS。</p>
<h5 id="构造器-30"><a href="#构造器-30" class="headerlink" title="构造器"></a>构造器</h5><p><code>Points( geometry : BufferGeometry, material : Material )</code><br>geometry —— （可选）是一个BufferGeometry的实例，默认值是一个新的BufferGeometry。几何体geometry作为点模型Points参数，会把几何体渲染为点<br>material —— （可选） 是一个对象，默认值是一个PointsMaterial。</p>
<h5 id="属性-8"><a href="#属性-8" class="headerlink" title="属性"></a>属性</h5><p>共有属性请参见其基类Object3D。</p>
<p>.geometry : BufferGeometry<br>一个BufferGeometry的实例（或者派生类），定义了物体的结构。</p>
<p>.isPoints : Boolean<br>Read-only flag to check if a given object is of type Points.</p>
<p>.material : Material<br>Material的实例。定义了物体的外观。默认值是一个的PointsMaterial。</p>
<p>.morphTargetInfluences : Array<br>一个包含有权重（值一般在0-1范围内）的数组，指定应用了多少变形。 默认情况下是未定义的，但是会被updateMorphTargets重置为一个空数组。</p>
<p>.morphTargetDictionary : Object<br>基于morphTarget.name属性的morphTargets字典。 默认情况下是未定义的，但是会被updateMorphTargets重建。</p>
<h5 id="方法-8"><a href="#方法-8" class="headerlink" title="方法"></a>方法</h5><p>共有方法请参见其基类Object3D。</p>
<p>.clone () : Mesh<br>返回这个Mesh对象及其子级的克隆。</p>
<p>.raycast ( raycaster : Raycaster, intersects : Array ) : undefined<br>在一条投射出去的Ray（射线）和这个网格之间产生交互。 Raycaster.intersectObject将会调用这个方法。</p>
<p>.updateMorphTargets () : undefined<br>更新morphTargets，使其不对对象产生影响，重置morphTargetInfluences and morphTargetDictionary属性。</p>
<h4 id="精灵（Sprite）"><a href="#精灵（Sprite）" class="headerlink" title="精灵（Sprite）"></a>精灵（Sprite）</h4><p>精灵是一个总是面朝着摄像机的平面，通常含有使用一个半透明的纹理。精灵不会投射任何阴影</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">TextureLoader</span>().<span class="title function_">load</span>( <span class="string">&quot;sprite.png&quot;</span> );</span><br><span class="line"><span class="keyword">const</span> material = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">SpriteMaterial</span>( &#123; <span class="attr">map</span>: map &#125; );</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sprite = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Sprite</span>( material );</span><br><span class="line">scene.<span class="title function_">add</span>( sprite );</span><br></pre></td></tr></table></figure>

<h5 id="构造器-31"><a href="#构造器-31" class="headerlink" title="构造器"></a>构造器</h5><p>Sprite( material : Material )<br>material - （可选值）是SpriteMaterial的一个实例。 默认值是一个白色的SpriteMaterial。</p>
<p>创建一个新的Sprite。</p>
<h5 id="属性-9"><a href="#属性-9" class="headerlink" title="属性"></a>属性</h5><p>共有属性请参见其基类Object3D。</p>
<p>.isSprite : Boolean<br>Read-only flag to check if a given object is of type Sprite.</p>
<p>.material : SpriteMaterial<br>SpriteMaterial的一个实例，定义了这个对象的外观。默认值是一个白色的SpriteMaterial。</p>
<p>.center : Vector2<br>这个精灵的锚点，也就是精灵旋转时，围绕着旋转的点。当值为(0.5,0.5)时，对应着这个精灵的中心点；当值为(0,0)时，对应着这个精灵左下角的点。<br>其默认值是(0.5,0.5)。</p>
<h5 id="方法-9"><a href="#方法-9" class="headerlink" title="方法"></a>方法</h5><p>共有方法请参见其基类Object3D。</p>
<p>.clone () : Sprite<br>返回当前Sprite对象的一个克隆及其任何后代。</p>
<p>.copy ( sprite : Sprite ) : this<br>将前一个Sprite对象的属性复制给当前的这个对象。</p>
<p>.raycast ( raycaster : Raycaster, intersects : Array ) : undefined<br>在投射的光线和精灵之前产生交互。Raycaster.intersectObject将会调用这个方法。 在对sprite进行射线投射之前，射线投射必须通过调用Raycaster.setFromCamera()来初始化。</p>
<h4 id="线（Line）"><a href="#线（Line）" class="headerlink" title="线（Line）"></a>线（Line）</h4><p>它几乎和LineSegments是一样的，唯一的区别是它在渲染时使用的是gl.LINE_STRIP， 而不是gl.LINES。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> material = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">LineBasicMaterial</span>(&#123;</span><br><span class="line"> <span class="attr">color</span>: <span class="number">0x0000ff</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> points = [];</span><br><span class="line">points.<span class="title function_">push</span>( <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Vector3</span>( - <span class="number">10</span>, <span class="number">0</span>, <span class="number">0</span> ) );</span><br><span class="line">points.<span class="title function_">push</span>( <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Vector3</span>( <span class="number">0</span>, <span class="number">10</span>, <span class="number">0</span> ) );</span><br><span class="line">points.<span class="title function_">push</span>( <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Vector3</span>( <span class="number">10</span>, <span class="number">0</span>, <span class="number">0</span> ) );</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> geometry = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">BufferGeometry</span>().<span class="title function_">setFromPoints</span>( points );</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> line = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Line</span>( geometry, material );</span><br><span class="line">scene.<span class="title function_">add</span>( line );</span><br></pre></td></tr></table></figure>

<h5 id="构造器-32"><a href="#构造器-32" class="headerlink" title="构造器"></a>构造器</h5><p><code>Line( geometry : BufferGeometry, material : Material )</code><br>geometry —— 表示线段的顶点，默认值是一个新的BufferGeometry。几何体作为线模型Line (opens new window)的参数，你会发现渲染效果是从第一个点开始到最后一个点，依次连成线。<br>material —— 线的材质，默认值是一个新的具有随机颜色的LineBasicMaterial。</p>
<h5 id="属性-10"><a href="#属性-10" class="headerlink" title="属性"></a>属性</h5><p>共有属性请参见其基类Object3D。</p>
<p>.geometry : BufferGeometry<br>表示线段的顶点。</p>
<p>.isLine : Boolean<br>Read-only flag to check if a given object is of type Line.</p>
<p>.material : Material<br>线的材质。</p>
<p>.morphTargetInfluences : Array<br>An array of weights typically from 0-1 that specify how much of the morph is applied. Undefined by default, but reset to a blank array by .updateMorphTargets().</p>
<p>.morphTargetDictionary : Object<br>A dictionary of morphTargets based on the morphTarget.name property. Undefined by default, but rebuilt .updateMorphTargets().</p>
<h5 id="方法-10"><a href="#方法-10" class="headerlink" title="方法"></a>方法</h5><p>共有方法请参见其基类Object3D。</p>
<p>.computeLineDistances () : this<br>计算LineDashedMaterial所需的距离的值的数组。 对于几何体中的每一个顶点，这个方法计算出了当前点到线的起始点的累积长度。</p>
<p>.raycast ( raycaster : Raycaster, intersects : Array ) : undefined<br>在一条投射出去的Ray（射线）和这条线之间产生交互。 Raycaster.intersectObject将会调用这个方法。</p>
<p>.clone () : Line<br>返回这条线及其子集的一个克隆对象。</p>
<p>.updateMorphTargets () : undefined<br>Updates the morphTargets to have no influence on the object. Resets the .morphTargetInfluences and .morphTargetDictionary properties.</p>
<h4 id="组（Group）"><a href="#组（Group）" class="headerlink" title="组（Group）"></a>组（Group）</h4><p>它几乎和Object3D是相同的，其目的是使得组中对象在语法上的结构更加清晰。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> geometry = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">BoxGeometry</span>( <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span> );</span><br><span class="line"><span class="keyword">const</span> material = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">MeshBasicMaterial</span>( &#123;<span class="attr">color</span>: <span class="number">0x00ff00</span>&#125; );</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cubeA = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Mesh</span>( geometry, material );</span><br><span class="line">cubeA.<span class="property">position</span>.<span class="title function_">set</span>( <span class="number">100</span>, <span class="number">100</span>, <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cubeB = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Mesh</span>( geometry, material );</span><br><span class="line">cubeB.<span class="property">position</span>.<span class="title function_">set</span>( -<span class="number">100</span>, -<span class="number">100</span>, <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">//create a group and add the two cubes</span></span><br><span class="line"><span class="comment">//These cubes can now be rotated / scaled etc as a group</span></span><br><span class="line"><span class="keyword">const</span> group = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Group</span>();</span><br><span class="line">group.<span class="title function_">add</span>( cubeA );</span><br><span class="line">group.<span class="title function_">add</span>( cubeB );</span><br><span class="line"></span><br><span class="line">scene.<span class="title function_">add</span>( group );</span><br></pre></td></tr></table></figure>

<h5 id="构造器-33"><a href="#构造器-33" class="headerlink" title="构造器"></a>构造器</h5><p><code>Group( )</code></p>
<h5 id="属性-方法-21"><a href="#属性-方法-21" class="headerlink" title="属性|方法"></a>属性|方法</h5><blockquote>
<p>共有属性请参见其基类Object3D。<br>共有方法请参见其基类Object3D。</p>
</blockquote>
<p>.isGroup : Boolean<br>Read-only flag to check if a given object is of type Group.</p>
<p>.type : String<br>一个字符串：“Group”。这个属性不应当被改变。</p>
<h4 id="实例化网格（InstancedMesh）"><a href="#实例化网格（InstancedMesh）" class="headerlink" title="实例化网格（InstancedMesh）"></a>实例化网格（InstancedMesh）</h4><p>一种具有实例化渲染支持的特殊版本的Mesh。你可以使用 InstancedMesh 来渲染大量具有相同几何体与材质、但具有不同世界变换的物体。 使用 InstancedMesh 将帮助你减少 draw call 的数量，从而提升你应用程序的整体渲染性能。</p>
<h5 id="构造器-34"><a href="#构造器-34" class="headerlink" title="构造器"></a>构造器</h5><p><code>InstancedMesh( geometry : BufferGeometry, material : Material, count : Integer )</code><br>geometry - 一个 BufferGeometry 的实例。<br>material - 一个 Material 的实例。默认为一个新的 MeshBasicMaterial 。<br>count - 实例的数量</p>
<h3 id="渲染器"><a href="#渲染器" class="headerlink" title="渲染器"></a>渲染器</h3><h4 id="WebGLRenderer"><a href="#WebGLRenderer" class="headerlink" title="WebGLRenderer"></a>WebGLRenderer</h4><p>构造器<br><code>WebGLRenderer( parameters : Object )</code><br>parameters - (可选) 该对象的属性定义了渲染器的行为。也可以完全不传参数。在所有情况下，当缺少参数时，它将采用合理的默认值。 以下是合法参数：</p>
<p><code>canvas</code> - 一个供渲染器绘制其输出的canvas 它和下面的domElement属性对应。 如果没有传这个参数，会创建一个新canvas<br><code>context</code> - 可用于将渲染器附加到已有的渲染环境(RenderingContext)中。默认值是null<br><code>precision</code> - 着色器精度. 可以是 “highp”, “mediump” 或者 “lowp”. 如果设备支持，默认为”highp” .<br><code>alpha</code> - controls the default clear alpha value. When set to true, the value is 0. Otherwise it’s 1. Default is false.<br><code>premultipliedAlpha</code> - renderer是否假设颜色有 premultiplied alpha. 默认为true<br><code>antialias</code> - 是否执行抗锯齿。默认为false.<br><code>stencil</code> - 绘图缓存是否有一个至少8位的模板缓存(stencil buffer)。默认为true<br><code>preserveDrawingBuffer</code> -是否保留缓直到手动清除或被覆盖。 默认false.<br><code>powerPreference</code> - 提示用户代理怎样的配置更适用于当前WebGL环境。 可能是”high-performance”, “low-power” 或 “default”。默认是”default”. 详见WebGL spec<br><code>failIfMajorPerformanceCaveat</code> - 检测渲染器是否会因性能过差而创建失败。默认为false。详见 WebGL spec for details.<br><code>depth</code> - 绘图缓存是否有一个至少6位的深度缓存(depth buffer )。 默认是true.<br><code>logarithmicDepthBuffer</code> - 是否使用对数深度缓存。如果要在单个场景中处理巨大的比例差异，就有必要使用。 Note that this setting uses gl_FragDepth if available which disables the Early Fragment Test optimization and can cause a decrease in performance. 默认是false。 示例：camera / logarithmicdepthbuffer</p>
<h5 id="属性-11"><a href="#属性-11" class="headerlink" title="属性"></a>属性</h5><ul>
<li><p><code>.autoClear</code> : Boolean<br>定义渲染器是否在渲染每一帧之前自动清除其输出。</p>
</li>
<li><p><code>.autoClearColor</code> : Boolean<br>如果autoClear为true, 定义renderer是否清除颜色缓存。 默认是true</p>
</li>
<li><p><code>.autoClearDepth</code> : Boolean<br>如果autoClear是true, 定义renderer是否清除深度缓存。 默认是true</p>
</li>
<li><p><code>.autoClearStencil</code> : Boolean<br>如果autoClear是true, 定义renderer是否清除模板缓存. 默认是true</p>
</li>
<li><p><code>.debug</code> : Object</p>
<ul>
<li>checkShaderErrors: 如果为true，定义是否检查材质着色器程序 编译和链接过程中的错误。 禁用此检查生产以获得性能增益可能很有用。 强烈建议在开发期间保持启用这些检查。 如果着色器没有编译和链接 - 它将无法工作，并且相关材料将不会呈现。 默认是true</li>
<li>onShaderError( gl, program, glVertexShader, glFragmentShader ): A callback function that can be used for custom error reporting. The callback receives the WebGL context, an instance of WebGLProgram as well two instances of WebGLShader representing the vertex and fragment shader. Assigning a custom function disables the default error reporting. Default is null.</li>
</ul>
</li>
<li><p><code>.capabilities</code> : Object<br>一个包含当前渲染环境(RenderingContext)的功能细节的对象。</p>
<ul>
<li>floatFragmentTextures: 环境是否支持OES_texture_float扩展</li>
<li>floatVertexTextures: 如果floatFragmentTextures和vertexTextures都是true， 则此值为true</li>
<li>getMaxAnisotropy(): 返回最大可用各向异性。</li>
<li>getMaxPrecision(): 返回顶点着色器和片元着色器的最大可用精度。</li>
<li>isWebGL2: true if the context in use is a WebGL2RenderingContext object.</li>
<li>logarithmicDepthBuffer: 如果logarithmicDepthBuffer在构造器中被设为true且 环境支持EXT_frag_depth扩展，则此值为true</li>
<li>maxAttributes: gl.MAX_VERTEX_ATTRIBS的值</li>
<li>maxCubemapSize: gl.MAX_CUBE_MAP_TEXTURE_SIZE 的值，着色器可使用的立方体贴图纹理的最大宽度*高度</li>
<li>maxFragmentUniforms: gl.MAX_FRAGMENT_UNIFORM_VECTORS的值，片元着色器可使用的全局变量(uniforms)数量</li>
<li>maxSamples: The value of gl.MAX_SAMPLES. Maximum number of samples in context of Multisample anti-aliasing (MSAA).</li>
<li>maxTextureSize: gl.MAX_TEXTURE_SIZE的值，着色器可使用纹理的最大宽度*高度</li>
<li>maxTextures: *gl.MAX_TEXTURE_IMAGE_UNITS的值，着色器可使用的纹理数量</li>
<li>maxVaryings: gl.MAX_VARYING_VECTORS的值，着色器可使用矢量的数量</li>
<li>maxVertexTextures: gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS的值，顶点着色器可使用的纹理数量。</li>
<li>maxVertexUniforms: gl.MAX_VERTEX_UNIFORM_VECTORS的值，顶点着色器可使用的全局变量(uniforms)数量</li>
<li>precision: 渲染器当前使用的着色器的精度</li>
<li>vertexTextures: 如果 .maxVertexTextures : Integer大于0，此值为true (即可以使用顶点纹理)</li>
</ul>
</li>
<li><p><code>.clippingPlanes</code> : Array<br>用户自定义的剪裁平面，在世界空间中被指定为THREE.Plane对象。 这些平面全局使用。空间中与该平面点积为负的点将被切掉。 默认值是[]</p>
</li>
<li><p><code>.domElement</code> : DOMElement<br>一个canvas，渲染器在其上绘制输出。<br>渲染器的构造函数会自动创建(如果没有传入canvas参数);你需要做的仅仅是像下面这样将它加页面里去:<code>document.body.appendChild( renderer.domElement );</code></p>
</li>
<li><p><code>.extensions</code> : Object</p>
<ul>
<li>get( extensionName : String ): 用于检查是否支持各种扩展，并返回一个对象，其中包含扩展的详细信息。 该方法检查以下扩展：<br>WEBGL_depth_texture<br>EXT_texture_filter_anisotropic<br>WEBGL_compressed_texture_s3tc<br>WEBGL_compressed_texture_pvrtc<br>WEBGL_compressed_texture_etc1<br>.outputColorSpace : string<br>定义渲染器的输出编码。默认为THREE.SRGBColorSpace</li>
</ul>
</li>
</ul>
<p>如果渲染目标已经使用 .setRenderTarget、之后将直接使用renderTarget.texture.colorSpace</p>
<p>查看texture constants页面以获取其他格式细节</p>
<ul>
<li><code>.info</code> : Object<br>一个对象，包含有关图形板内存和渲染过程的一系列统计信息。这些信息可用于调试或仅仅满足下好奇心。该对象包含以下字段:</li>
</ul>
<p>memory:<br>geometries<br>textures<br>render:<br>calls<br>triangles<br>points<br>lines<br>frame<br>programs<br>默认情况下，这些字段在每次渲染调用时都会重置，但是当每帧有多个渲染通道时（例如，使用后处理时），最好使用自定义模式重置。先将 autoReset 设置为 false.<br>renderer.info.autoReset = false;然后在单个帧时渲染完成后调用 reset().<br>renderer.info.reset();</p>
<ul>
<li><p><code>.localClippingEnabled</code> : Boolean<br>定义渲染器是否考虑对象级剪切平面。 默认为false.</p>
</li>
<li><p><code>.useLegacyLights</code> : Boolean<br>Whether to use the legacy lighting mode or not. 默认是true。</p>
</li>
<li><p><code>.properties</code> : Object<br>渲染器内部使用，以跟踪各种子对象属性。</p>
</li>
<li><p><code>.renderLists</code> : WebGLRenderLists<br>在内部用于处理场景渲染对象的排序。</p>
</li>
<li><p><code>.shadowMap</code> : WebGLShadowMap<br>如果使用，它包含阴影贴图的引用。</p>
<ul>
<li>enabled: 如果设置开启，允许在场景中使用阴影贴图。默认是 false。</li>
<li>autoUpdate: 启用场景中的阴影自动更新。默认是true<br>如果不需要动态光照/阴影, 则可以在实例化渲染器时将之设为false</li>
<li>needsUpdate: 当被设为true, 场景中的阴影贴图会在下次render调用时刷新。默认是false<br>如果你已经禁用了阴影贴图的自动更新(shadowMap.autoUpdate = false), 那么想要在下一次渲染时更新阴影的话就需要将此值设为true</li>
<li>type: 定义阴影贴图类型 (未过滤, 关闭部分过滤, 关闭部分双线性过滤), 可选值有:</li>
</ul>
</li>
</ul>
<p>THREE.BasicShadowMap<br>THREE.PCFShadowMap (默认)<br>THREE.PCFSoftShadowMap<br>THREE.VSMShadowMap<br>详见Renderer constants</p>
<ul>
<li><code>.sortObjects</code> : Boolean<br>定义渲染器是否应对对象进行排序。默认是true.</li>
</ul>
<p>说明: 排序用于尝试正确渲染出具有一定透明度的对象。根据定义，排序可能不总是有用。根据应用的需求，可能需要关闭排序并使其他方法来处理透明度的渲染，例如， 手动确定每个对象的渲染顺序。</p>
<ul>
<li><p><code>.state</code> : Object<br>包含设置WebGLRenderer.context状态的各种属性的函数。</p>
</li>
<li><p><code>.toneMapping</code> : Constant<br>默认是NoToneMapping。查看Renderer constants以获取其它备选项</p>
</li>
<li><p><code>.toneMappingExposure</code> : Number<br>色调映射的曝光级别。默认是1</p>
</li>
</ul>
<p>-<code>.xr</code> : WebXRManager<br>Provides access to the WebXR related interface of the renderer.</p>
<h5 id="方法-11"><a href="#方法-11" class="headerlink" title="方法"></a>方法</h5><ul>
<li><p><code>.render ( scene : Object3D, camera : Camera ) : undefined</code><br>用相机(camera)渲染一个场景(scene)或是其它类型的object。<br>渲染一般是在canvas上完成的，或者是renderTarget(如果有指定)<br>如果forceClear值是true，那么颜色、深度及模板缓存将会在渲染之前清除，即使渲染器的autoClear属性值是false<br>即便forceClear设为true, 也可以通过将autoClearColor、autoClearStencil或autoClearDepth属性的值设为false来阻止对应缓存被清除。</p>
</li>
<li><p><code>.setSize ( width : Integer, height : Integer, updateStyle : Boolean ) : undefined</code><br>将输出canvas的大小调整为(width, height)并考虑设备像素比，且将视口从(0, 0)开始调整到适合大小 将updateStyle设置为false以阻止对canvas的样式做任何改变。</p>
</li>
<li><p><code>.setViewport ( x : Integer, y : Integer, width : Integer, height : Integer ) : undefined</code><br>将视口大小设置为(x, y)到 (x + width, y + height).</p>
</li>
<li><p><code>.clear ( color : Boolean, depth : Boolean, stencil : Boolean ) : undefined</code><br>告诉渲染器清除颜色、深度或模板缓存. 此方法将颜色缓存初始化为当前颜色。参数们默认都是true</p>
</li>
<li><p><code>.clearColor ( ) : undefined</code><br>清除颜色缓存。 相当于调用.clear( true, false, false )</p>
</li>
<li><p><code>.clearDepth ( ) : undefined</code><br>清除深度缓存。相当于调用.clear( false, true, false )</p>
</li>
<li><p><code>.clearStencil ( ) : undefined</code><br>清除模板缓存。相当于调用.clear( false, false, true )</p>
</li>
<li><p><code>.compile ( scene : Object3D, camera : Camera ) : undefined</code><br>使用相机编译场景中的所有材质。这对于在首次渲染之前预编译着色器很有用。</p>
</li>
<li><p><code>.copyFramebufferToTexture ( position : Vector2, texture : FramebufferTexture, level : Number ) : undefined</code><br>将当前WebGLFramebuffer中的像素复制到2D纹理中。可访问WebGLRenderingContext.copyTexImage2D.</p>
</li>
<li><p><code>.copyTextureToTexture ( position : Vector2, srcTexture : Texture, dstTexture : Texture, level : Number ) : undefined</code><br>将纹理的所有像素复制到一个已有的从给定位置开始的纹理中。可访问WebGLRenderingContext.texSubImage2D.</p>
</li>
<li><p><code>.dispose ( ) : undefined</code><br>处理当前的渲染环境</p>
</li>
<li><p><code>.forceContextLoss () : undefined</code><br>模拟WebGL环境的丢失。需要支持 WEBGL_lose_context 扩展才能用。</p>
</li>
<li><p><code>.forceContextRestore ( ) : undefined</code><br>模拟WebGL环境的恢复。需要支持 WEBGL_lose_context 扩展才能用。</p>
</li>
<li><p><code>.getClearAlpha () : Float</code><br>返回一个表示当前alpha值的float，范围0到1</p>
</li>
<li><p><code>.getClearColor ( target : Color ) : Color</code><br>返回一个表示当前颜色值的THREE.Color实例</p>
</li>
<li><p><code>.getContext () : WebGL2RenderingContext</code><br>返回当前WebGL环境</p>
</li>
<li><p><code>.getContextAttributes () : WebGLContextAttributes</code><br>返回一个对象，这个对象中存有在WebGL环境在创建的时候所设置的属性</p>
</li>
<li><p><code>.getActiveCubeFace () : Integer</code><br>Returns the current active cube face.</p>
</li>
<li><p><code>.getActiveMipmapLevel () : Integer</code><br>Returns the current active mipmap level.</p>
</li>
<li><p><code>.getRenderTarget () : RenderTarget</code><br>如果当前存在RenderTarget，则返回该值；否则返回null。</p>
</li>
<li><p><code>.getCurrentViewport () : RenderTarget</code><br>返回当前视口</p>
</li>
<li><p><code>.getDrawingBufferSize () : Object</code><br>返回一个包含渲染器绘图缓存宽度和高度(单位像素)的对象。</p>
</li>
<li><p><code>.getPixelRatio () : number</code><br>返回当前使用设备像素比</p>
</li>
<li><p><code>.getSize ( target : Vector2 ) : Vector2</code><br>返回包含渲染器输出canvas的宽度和高度(单位像素)的对象。</p>
</li>
<li><p><code>.initTexture ( texture : Texture ) : undefined</code><br>初始化给定的纹理。用于预加载纹理而不是等到第一次渲染（可能会由于解码和 GPU 上传的开销而导致明显的延迟）.</p>
</li>
<li><p><code>.resetGLState ( ) : undefined</code><br>将GL状态重置为默认值。WebGL环境丢失时会内部调用</p>
</li>
<li><p><code>.readRenderTargetPixels ( renderTarget : WebGLRenderTarget, x : Float, y : Float, width : Float, height : Float, buffer : TypedArray, activeCubeFaceIndex : Integer ) : undefined</code><br>buffer - Uint8Array is the only destination type supported in all cases, other types are renderTarget and platform dependent. See WebGL spec for details.</p>
</li>
</ul>
<p>将renderTarget中的像素数据读取到传入的缓冲区中。这是WebGLRenderingContext.readPixels()的包装器<br>示例：interactive / cubes / gpu</p>
<p>For reading out a WebGLCubeRenderTarget use the optional parameter activeCubeFaceIndex to determine which face should be read.</p>
<ul>
<li><p><code>.resetState () : undefined</code><br>可用于重置内部 WebGL 状态。此方法主要与跨多个 WebGL 库共享单个 WebGL 上下文的应用程序相关。</p>
</li>
<li><p><code>.setAnimationLoop ( callback : Function ) : undefined</code><br>callback — 每个可用帧都会调用的函数。 如果传入‘null’,所有正在进行的动画都会停止。</p>
</li>
</ul>
<p>可用来代替requestAnimationFrame的内置函数. 对于WebXR项目，必须使用此函数。</p>
<ul>
<li><p><code>.setClearAlpha ( alpha : Float ) : undefined</code><br>设置alpha。合法参数是一个0.0到 1.0之间的浮点数</p>
</li>
<li><p><code>.setClearColor ( color : Color, alpha : Float ) : undefined</code><br>设置颜色及其透明度</p>
</li>
<li><p><code>.setPixelRatio ( value : number ) : undefined</code><br>设置设备像素比。通常用于避免HiDPI设备上绘图模糊</p>
</li>
<li><p><code>.setRenderTarget ( renderTarget : WebGLRenderTarget, activeCubeFace : Integer, activeMipmapLevel : Integer ) : undefined</code><br>renderTarget – 需要被激活的renderTarget(可选)。若此参数为空，则将canvas设置成活跃render target。<br>activeCubeFace – Specifies the active cube side (PX 0, NX 1, PY 2, NY 3, PZ 4, NZ 5) of WebGLCubeRenderTarget. When passing a WebGLArrayRenderTarget or WebGL3DRenderTarget this indicates the z layer to render in to (optional).<br>activeMipmapLevel – Specifies the active mipmap level (optional).</p>
</li>
</ul>
<p>该方法设置活跃rendertarget。</p>
<ul>
<li><p><code>.setScissor ( x : Integer, y : Integer, width : Integer, height : Integer ) : undefined</code><br>将剪裁区域设为(x, y)到(x + width, y + height) Sets the scissor area from</p>
</li>
<li><p><code>.setScissorTest ( boolean : Boolean ) : undefined</code><br>启用或禁用剪裁检测. 若启用，则只有在所定义的裁剪区域内的像素才会受之后的渲染器影响。</p>
</li>
</ul>
<h4 id="WebGL1Renderer"><a href="#WebGL1Renderer" class="headerlink" title="WebGL1Renderer"></a>WebGL1Renderer</h4><p>自r118起，WebGLRenderer会自动使用 WebGL 2 渲染上下文。当升级一个已存在的项目到 =&gt; r118 ， 应用程序可能会因为下列两种原因而损坏：</p>
<p>自定义着色器代码必须符合GLSL 3.0。<br>WebGL 1扩展检查到被更改<br>如果你不能够花时间来升级你的代码，但仍然想要使用最新版本，那你就可以使用WebGL1Renderer。 这一版本的渲染器会强制使用 WebGL 1 渲染上下文。<br>构造函数<br>WebGL1Renderer( parameters : Object )<br>Creates a new WebGL1Renderer.</p>
<h4 id="SVG渲染器（SVGRenderer）"><a href="#SVG渲染器（SVGRenderer）" class="headerlink" title="SVG渲染器（SVGRenderer）"></a>SVG渲染器（SVGRenderer）</h4><p>SVGRenderer被用于使用SVG来渲染几何数据，所产生的矢量图形在以下几个方面十分有用：</p>
<p>动画标志（logo）或者图标（icon）<br>可交互的2D或3D图表或图形<br>交互式地图<br>复杂的或包含动画的用户界面<br>SVGRenderer具有很多优势。它产生清晰并且锐利的图像输出，它和实际视口分辨率无关。<br>SVG元素可以通过CSS来控制样式；并且由于它可以添加诸如标题或者描述文字之类的元数据（对于搜索引擎或者屏幕阅读器十分有用），因此它具有十分良好的可访问性。</p>
<p>然而，SVG也有一些十分重要的限制：</p>
<p>没有高级的着色器<br>不支持纹理<br>不支持阴影</p>
<p>SVGRenderer 是一个附加组件，必须显式导入。 See Installation / Addons.</p>
<p><code>import &#123; SVGRenderer &#125; from &#39;three/addons/renderers/SVGRenderer.js&#39;;</code></p>
<h4 id="CSS-3D渲染器（CSS3DRenderer）"><a href="#CSS-3D渲染器（CSS3DRenderer）" class="headerlink" title="CSS 3D渲染器（CSS3DRenderer）"></a>CSS 3D渲染器（CSS3DRenderer）</h4><p>CSS3DRenderer用于通过CSS3的transform属性， 将层级的3D变换应用到DOM元素上。 如果你希望不借助基于canvas的渲染来在你的网站上应用3D变换，那么这一渲染器十分有趣。 同时，它也可以将DOM元素与WebGL的内容相结合。</p>
<p>然而，这一渲染器也有一些十分重要的限制：</p>
<p>它不可能使用three.js中的材质系统。<br>同时也不可能使用几何体。<br>CSS3DRenderer 仅支持100%的浏览器和显示缩放。<br>因此，CSS3DRenderer仅仅关注普通的DOM元素，这些元素被包含到了特殊的对象中（CSS3DObject或者CSS3DSprite），然后被加入到场景图中。<br>进口<br>CSS3DRenderer 是一个附加组件，必须显式导入。 See Installation / Addons.</p>
<p><code>import &#123; CSS3DRenderer &#125; from &#39;three/addons/renderers/CSS3DRenderer.js&#39;;</code></p>
<h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><h4 id="Scene"><a href="#Scene" class="headerlink" title="Scene"></a>Scene</h4><p>场景能够让你在什么地方、摆放什么东西来交给three.js来渲染，这是你放置物体、灯光和摄像机的地方。</p>
<h5 id="构造器-35"><a href="#构造器-35" class="headerlink" title="构造器"></a>构造器</h5><p>Scene()<br>创建一个新的场景对象。</p>
<h5 id="属性-12"><a href="#属性-12" class="headerlink" title="属性"></a>属性</h5><p>.background : Object<br>若不为空，在渲染场景的时候将设置背景，且背景总是首先被渲染的。 可以设置一个用于的“clear”的Color（颜色）、一个覆盖canvas的Texture（纹理）， 或是 a cubemap as a CubeTexture or an equirectangular as a Texture。默认值为null。</p>
<p>.backgroundBlurriness : Float<br>Sets the blurriness of the background. Only influences environment maps assigned to Scene.background. Valid input is a float between 0 and 1. Default is 0.</p>
<p>.environment : Texture<br>若该值不为null，则该纹理贴图将会被设为场景中所有物理材质的环境贴图。 然而，该属性不能够覆盖已存在的、已分配给 MeshStandardMaterial.envMap 的贴图。默认为null。</p>
<p>.fog : Fog<br>一个fog实例定义了影响场景中的每个物体的雾的类型。默认值为null。</p>
<p>.isScene : Boolean</p>
<p>.overrideMaterial : Material<br>如果不为空，它将强制场景中的每个物体使用这里的材质来渲染。默认值为null。</p>
<h5 id="方法-12"><a href="#方法-12" class="headerlink" title="方法"></a>方法</h5><p>.toJSON : Object<br>meta – 包含有元数据的对象，例如场景中的的纹理或图片。 将scene对象转换为 three.js JSON Object/Scene format（three.js JSON 物体/场景格式）。</p>
<h4 id="雾（Fog）"><a href="#雾（Fog）" class="headerlink" title="雾（Fog）"></a>雾（Fog）</h4><p>这个类中的参数定义了线性雾。也就是说，雾的密度是随着距离线性增大的。</p>
<h5 id="构造器-36"><a href="#构造器-36" class="headerlink" title="构造器"></a>构造器</h5><p>Fog( color : Integer, near : Float, far : Float )<br>颜色参数传入Color构造函数中，来设置颜色属性。颜色可以是一个十六进制的整型数，或者是CSS风格的字符串。</p>
<h5 id="属性-13"><a href="#属性-13" class="headerlink" title="属性"></a>属性</h5><p>.isFog : Boolean<br>Read-only flag to check if a given object is of type Fog.</p>
<p>.name : String<br>对象的名称，可选、不必唯一。默认值是一个空字符串。</p>
<p>.color : Color<br>雾的颜色。比如说，如果将其设置为黑色，远处的物体将被渲染成黑色。</p>
<p>.near : Float<br>开始应用雾的最小距离。距离小于活动摄像机“near”个单位的物体将不会被雾所影响。</p>
<p>默认值是1。</p>
<p>.far : Float<br>结束计算、应用雾的最大距离，距离大于活动摄像机“far”个单位的物体将不会被雾所影响。</p>
<p>默认值是1000。</p>
<h5 id="方法-13"><a href="#方法-13" class="headerlink" title="方法"></a>方法</h5><p>.clone () : Fog<br>返回一个具有和当前雾参数相同的新的Fog实例。</p>
<p>.toJSON () : Object<br>以JSON格式返回Fog的数据。</p>
<h4 id="雾-指数（FogExp2）"><a href="#雾-指数（FogExp2）" class="headerlink" title="雾-指数（FogExp2）"></a>雾-指数（FogExp2）</h4><p>该类所包含的参数定义了指数雾，它可以在相机附近提供清晰的视野，且距离相机越远，雾的浓度随着指数增长越快。</p>
<h5 id="构造器-37"><a href="#构造器-37" class="headerlink" title="构造器"></a>构造器</h5><p>FogExp2( color : Integer, density : Float )<br>颜色参数传入Color构造函数中，来设置颜色属性。颜色可以是一个十六进制的整型数，或者是CSS风格的字符串。</p>
<h5 id="属性-14"><a href="#属性-14" class="headerlink" title="属性"></a>属性</h5><p>.isFogExp2 : Boolean<br>Read-only flag to check if a given object is of type FogExp2.</p>
<p>.name : String<br>对象的名称，可选、不必唯一。默认值是一个空字符串。</p>
<p>.color : Color<br>雾的颜色。比如说，如果将其设置为黑色，远处的物体将被渲染成黑色。</p>
<p>.density : Float<br>定义雾的密度将会增长多块。</p>
<p>默认值是0.00025.</p>
<h5 id="方法-14"><a href="#方法-14" class="headerlink" title="方法"></a>方法</h5><p>.clone () : FogExp2<br>返回一个具有和当前雾参数相同的新的FogExp2实例。</p>
<p>.toJSON () : Object<br>以JSON格式返回FogExp2的数据。</p>
<h3 id="光源"><a href="#光源" class="headerlink" title="光源"></a>光源</h3><h4 id="Light"><a href="#Light" class="headerlink" title="Light"></a>Light</h4><h5 id="构造器（Constructor）"><a href="#构造器（Constructor）" class="headerlink" title="构造器（Constructor）"></a>构造器（Constructor）</h5><p><code>Light( color : Integer, intensity : Float )</code><br>color - (可选参数) 16进制表示光的颜色。 缺省值 0xffffff (白色)。<br>intensity - (可选参数) 光照强度。 缺省值 1。</p>
<p>创造一个新的光源。注意，这并不是直接调用的（而是使用派生类之一）。</p>
<h5 id="属性（Properties）"><a href="#属性（Properties）" class="headerlink" title="属性（Properties）"></a>属性（Properties）</h5><p>公共属性请查看基类Object3D。</p>
<p>.color : Color<br>光源的颜色。如果构造的时候没有传递，默认会创建一个新的 Color 并设置为白色。</p>
<p>.intensity : Float<br>光照的强度，或者说能量。 在 physically correct 模式下, color 和强度 的乘积被解析为以坎德拉（candela）为单位的发光强度。 默认值 - 1.0<br>.isLight : Boolean<br>Read-only flag to check if a given object is of type Light.</p>
<h5 id="Methods"><a href="#Methods" class="headerlink" title="Methods"></a>Methods</h5><p>公共方法请查看基类 Object3D。</p>
<p>.copy ( source : Light ) : this<br>从source复制 color, intensity 的值到当前光源对象中。</p>
<p>.toJSON ( meta : Object ) : Object<br>以JSON格式返回光数据。</p>
<p>meta – 包含有元数据的对象，例如该对象的材质、纹理或图片。 将该light对象转换为 three.js JSON Object/Scene format（three.js JSON 物体/场景格式）。</p>
<h4 id="环境光AmbientLight"><a href="#环境光AmbientLight" class="headerlink" title="环境光AmbientLight"></a>环境光AmbientLight</h4><p>环境光会均匀的照亮场景中的所有物体。环境光不能用来投射阴影，因为它没有方向。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> light = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">AmbientLight</span>( <span class="number">0x404040</span> ); <span class="comment">// soft white light</span></span><br><span class="line">scene.<span class="title function_">add</span>( light );</span><br></pre></td></tr></table></figure>

<p>构造函数<br><code>AmbientLight( color : Integer, intensity : Float )</code><br>color - （参数可选）颜色的rgb数值。缺省值为 0xffffff。<br>intensity - (参数可选)光照的强度。缺省值为 1。</p>
<p>创建一个环境光对象。</p>
<h5 id="属性-方法-22"><a href="#属性-方法-22" class="headerlink" title="属性|方法"></a>属性|方法</h5><blockquote>
<p>公共属性请查看基类 Light。<br>公共方法请查看基类Light。</p>
</blockquote>
<p>.castShadow : Boolean<br>这个参数在对象构造的时候就被设置成了 undefined 。因为环境光不能投射阴影。</p>
<p>.isAmbientLight : Boolean<br>Read-only flag to check if a given object is of type AmbientLight.</p>
<h4 id="平行光（DirectionalLight）"><a href="#平行光（DirectionalLight）" class="headerlink" title="平行光（DirectionalLight）"></a>平行光（DirectionalLight）</h4><p>平行光是沿着特定方向发射的光。这种光的表现像是无限远,从它发出的光线都是平行的。常常用平行光来模拟太阳光 的效果;</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> directionalLight = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">DirectionalLight</span>( <span class="number">0xffffff</span>, <span class="number">0.5</span> );</span><br><span class="line">scene.<span class="title function_">add</span>( directionalLight );</span><br></pre></td></tr></table></figure>

<h5 id="构造函数-3"><a href="#构造函数-3" class="headerlink" title="构造函数"></a>构造函数</h5><p><code>DirectionalLight( color : Integer, intensity : Float )</code><br>color - (可选参数) 16进制表示光的颜色。 缺省值为 0xffffff (白色)。<br>intensity - (可选参数) 光照的强度。缺省值为1。</p>
<h5 id="属性-方法-23"><a href="#属性-方法-23" class="headerlink" title="属性|方法"></a>属性|方法</h5><blockquote>
<p>公共属性请查看基类 Light。<br>公共方法请查看基类Light。</p>
</blockquote>
<p>.castShadow : Boolean<br>如果设置为 true 该平行光会产生动态阴影。 警告: 这样做的代价比较高而且需要一直调整到阴影看起来正确. 查看 DirectionalLightShadow 了解详细信息。该属性默认为 false。</p>
<p>.isDirectionalLight : Boolean<br>Read-only flag to check if a given object is of type DirectionalLight.</p>
<p>.position : Vector3<br>假如这个值设置等于 Object3D.DEFAULT_UP (0, 1, 0),那么光线将会从上往下照射。</p>
<p>.shadow : DirectionalLightShadow<br>这个 DirectionalLightShadow 对象用来计算该平行光产生的阴影。</p>
<p>.target : Object3D<br>平行光的方向是从它的位置到目标位置。默认的目标位置为原点 (0,0,0)。<br>注意: 对于目标的位置，要将其更改为除缺省值之外的任何位置,它必须被添加到 scene 场景中去。<code>scene.add( light.target );</code><br>这使得属性target中的 matrixWorld 会每帧自动更新。</p>
<p>它也可以设置target为场景中的其他对象(任意拥有 position 属性的对象), 示例如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> targetObject = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Object3D</span>();</span><br><span class="line">scene.<span class="title function_">add</span>(targetObject);</span><br><span class="line"></span><br><span class="line">light.<span class="property">target</span> = targetObject;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>完成上述操作后，平行光现在就可以追踪到目标对像了。</p>
<h5 id="方法-15"><a href="#方法-15" class="headerlink" title="方法"></a>方法</h5><p><code>.copy ( source : DirectionalLight ) : this</code><br>复制 source 的值到这个平行光源对象。</p>
<h4 id="点光源（PointLight）"><a href="#点光源（PointLight）" class="headerlink" title="点光源（PointLight）"></a>点光源（PointLight）</h4><p>从一个点向各个方向发射的光源。一个常见的例子是模拟一个灯泡发出的光。该光源可以投射阴影</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> light = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">PointLight</span>( <span class="number">0xff0000</span>, <span class="number">1</span>, <span class="number">100</span> );</span><br><span class="line">light.<span class="property">position</span>.<span class="title function_">set</span>( <span class="number">50</span>, <span class="number">50</span>, <span class="number">50</span> );</span><br><span class="line">scene.<span class="title function_">add</span>( light );</span><br></pre></td></tr></table></figure>

<h5 id="构造函数-4"><a href="#构造函数-4" class="headerlink" title="构造函数"></a>构造函数</h5><p><code>PointLight( color : Integer, intensity : Float, distance : Number, decay : Float )</code><br>color - (可选参数)) 十六进制光照颜色。 缺省值 0xffffff (白色)。<br>intensity - (可选参数) 光照强度。 缺省值 1。<br>distance - 这个距离表示从光源到光照强度为0的位置。 当设置为0时，光永远不会消失(距离无穷大)。缺省值 0.<br>decay - 沿着光照距离的衰退量。缺省值 2。</p>
<h5 id="属性-方法-24"><a href="#属性-方法-24" class="headerlink" title="属性|方法"></a>属性|方法</h5><blockquote>
<p>公共属性请查看基类 Light。<br>公共方法请查看基类Light。</p>
</blockquote>
<p>.castShadow : Boolean<br>如果设置为 true 该平行光会产生动态阴影。 警告: 这样做的代价比较高而且需要一直调整到阴影看起来正确. 查看 DirectionalLightShadow 了解详细信息。该属性默认为 false。<br>.distance : Float<br>如果非零，那么光强度将会从最大值当前灯光位置处按照距离线性衰减到0。 缺省值为 0.0。</p>
<p>.power : Float<br>光功率<br>在 physically correct 模式中, 表示以”流明（光通量单位）”为单位的光功率。 缺省值 - 4Math.PI。</p>
<p>该值与 intensity 直接关联<br><code>power = intensity * 4π</code>修改该值也会导致光强度的改变。</p>
<p>.shadow : PointLightShadow<br>PointLightShadow用与计算此光照的阴影。</p>
<p>此对象的摄像机被设置为 fov 为90度，aspect为1， 近裁剪面 near 为0，远裁剪面far 为500的透视摄像机 PerspectiveCamera。</p>
<p>.decay : Float<br>The amount the light dims along the distance of the light. Default is 2.<br>In context of physically-correct rendering the default value should not be changed.</p>
<h5 id="方法-16"><a href="#方法-16" class="headerlink" title="方法"></a>方法</h5><p><code>.copy ( source : PointLight ) : this</code><br>将所有属性的值从源 source 复制到此点光源对象。</p>
<h4 id="聚光灯（SpotLight）"><a href="#聚光灯（SpotLight）" class="headerlink" title="聚光灯（SpotLight）"></a>聚光灯（SpotLight）</h4><p>光线从一个点沿一个方向射出，随着光线照射的变远，光线圆锥体的尺寸也逐渐增大。该光源可以投射阴影</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> spotLight = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">SpotLight</span>( <span class="number">0xffffff</span> );</span><br><span class="line">spotLight.<span class="property">position</span>.<span class="title function_">set</span>( <span class="number">100</span>, <span class="number">1000</span>, <span class="number">100</span> );</span><br><span class="line">spotLight.<span class="property">map</span> = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">TextureLoader</span>().<span class="title function_">load</span>( url );</span><br><span class="line"></span><br><span class="line">spotLight.<span class="property">castShadow</span> = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">spotLight.<span class="property">shadow</span>.<span class="property">mapSize</span>.<span class="property">width</span> = <span class="number">1024</span>;</span><br><span class="line">spotLight.<span class="property">shadow</span>.<span class="property">mapSize</span>.<span class="property">height</span> = <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">spotLight.<span class="property">shadow</span>.<span class="property">camera</span>.<span class="property">near</span> = <span class="number">500</span>;</span><br><span class="line">spotLight.<span class="property">shadow</span>.<span class="property">camera</span>.<span class="property">far</span> = <span class="number">4000</span>;</span><br><span class="line">spotLight.<span class="property">shadow</span>.<span class="property">camera</span>.<span class="property">fov</span> = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">scene.<span class="title function_">add</span>( spotLight );</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="构造函数-5"><a href="#构造函数-5" class="headerlink" title="构造函数"></a>构造函数</h5><p><code>SpotLight( color : Integer, intensity : Float, distance : Float, angle : Radians, penumbra : Float, decay : Float )</code><br>color - (可选参数) 十六进制光照颜色。 缺省值 0xffffff (白色)。<br>intensity - (可选参数) 光照强度。 缺省值 1。<br>distance - 从光源发出光的最大距离，其强度根据光源的距离线性衰减。<br>angle - 光线散射角度，最大为Math.PI/2。<br>penumbra - 聚光锥的半影衰减百分比。在0和1之间的值。默认为0。<br>decay - 沿着光照距离的衰减量。</p>
<h5 id="属性-方法-25"><a href="#属性-方法-25" class="headerlink" title="属性|方法"></a>属性|方法</h5><blockquote>
<p>公共属性请查看基类 Light。<br>公共方法请查看基类Light。</p>
</blockquote>
<p>.angle : Float<br>从聚光灯的位置以弧度表示聚光灯的最大范围。应该不超过 Math.PI/2。默认值为 Math.PI/3。</p>
<p>.castShadow : Boolean<br>此属性设置为 true 聚光灯将投射阴影。警告: 这样做的代价比较高而且需要一直调整到阴影看起来正确。 查看 SpotLightShadow 了解详细信息。 默认值为 false</p>
<p>.decay : Float<br>The amount the light dims along the distance of the light. Default is 2.<br>In context of physically-correct rendering the default value should not be changed.</p>
<p>.distance : Float<br>如果非零，那么光强度将会从最大值当前灯光位置处按照距离线性衰减到0。 缺省值为 0.0。</p>
<p>.isSpotLight : Boolean<br>Read-only flag to check if a given object is of type SpotLight.</p>
<p>.penumbra : Float<br>聚光锥的半影衰减百分比。在0和1之间的值。 默认值 — 0.0。</p>
<p>.position : Vector3<br>假如这个值设置等于 Object3D.DEFAULT_UP (0, 1, 0)，那么光线将会从上往下照射。</p>
<p>.power : Float<br>光功率<br>在 physically correct 模式中， 表示以”流明（光通量单位）”为单位的光功率。 缺省值 - 4Math.PI。</p>
<p>该值与 intensity 直接关联<br>power = intensity * 4π修改该值也会导致光强度的改变。</p>
<p>.shadow : SpotLightShadow<br>SpotLightShadow用与计算此光照的阴影。</p>
<p>.target : Object3D<br>聚光灯的方向是从它的位置到目标位置.默认的目标位置为原点 (0,0,0)。<br>注意: 对于目标的位置，要将其更改为除缺省值之外的任何位置，它必须被添加到 scene 场景中去。<br>scene.add( light.target );这使得属性target中的 matrixWorld 会每帧自动更新。</p>
<p>它也可以设置target为场景中的其他对象(任意拥有 position 属性的对象), 示例如下:<br>const targetObject = new THREE.Object3D();<br>scene.add(targetObject);</p>
<p>light.target = targetObject;完成上述操作后，聚光灯现在就可以追踪到目标对像了。</p>
<p>.map : Texture<br>A Texture used to modulate the color of the light. The spot light color is mixed with the RGB value of this texture, with a ratio corresponding to its alpha value. The cookie-like masking effect is reproduced using pixel values (0, 0, 0, 1-cookie_value). Warning: map : SpotLight is disabled if castShadow : SpotLight is false.</p>
<h5 id="方法（Methods）"><a href="#方法（Methods）" class="headerlink" title="方法（Methods）"></a>方法（Methods）</h5><p>公共方法请查看基类 Light。</p>
<p>.copy ( source : SpotLight ) : this<br>将所有属性的值从源 source 复制到此聚光灯光源对象。</p>
<h4 id="平面光光源（RectAreaLight）"><a href="#平面光光源（RectAreaLight）" class="headerlink" title="平面光光源（RectAreaLight）"></a>平面光光源（RectAreaLight）</h4><p>平面光光源从一个矩形平面上均匀地发射光线。这种光源可以用来模拟像明亮的窗户或者条状灯光光源。</p>
<p>注意事项:</p>
<p>不支持阴影。<br>只支持 MeshStandardMaterial 和 MeshPhysicalMaterial 两种材质。<br>你必须在你的场景中加入 RectAreaLightUniformsLib ，并调用init()。</p>
<h3 id="三维坐标系"><a href="#三维坐标系" class="headerlink" title="三维坐标系"></a>三维坐标系</h3><p>AxesHelper的xyz轴<br>three.js坐标轴颜色红R、绿G、蓝B分别对应坐标系的x、y、z轴，对于three.js的3D坐标系默认y轴朝上。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AxesHelper：辅助观察的坐标系</span></span><br><span class="line"><span class="keyword">const</span> axesHelper = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">AxesHelper</span>(<span class="number">150</span>);</span><br><span class="line">scene.<span class="title function_">add</span>(axesHelper);</span><br></pre></td></tr></table></figure>

<h2 id="全屏"><a href="#全屏" class="headerlink" title="全屏"></a>全屏</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;dblclick&#x27;</span>,<span class="function">()=&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> isFull=<span class="variable language_">document</span>.<span class="property">fullscreenElement</span>;</span><br><span class="line">  <span class="keyword">if</span>(!isFull)&#123;</span><br><span class="line">    renderer.<span class="property">domElement</span>.<span class="title function_">requestFullscreen</span>(); </span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">exitFullscreen</span>(); </span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="自适应屏幕"><a href="#自适应屏幕" class="headerlink" title="自适应屏幕"></a>自适应屏幕</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;resize&#x27;</span>,<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  <span class="comment">//更新摄像头</span></span><br><span class="line">  camera.<span class="property">aspect</span>=<span class="variable language_">window</span>.<span class="property">innerWidth</span>/<span class="variable language_">window</span>.<span class="property">innerHeight</span></span><br><span class="line">   <span class="comment">// 渲染器执行render方法的时候会读取相机对象的投影矩阵属性projectionMatrix</span></span><br><span class="line">    <span class="comment">// 但是不会每渲染一帧，就通过相机的属性计算投影矩阵(节约计算资源)</span></span><br><span class="line">  <span class="comment">//更新摄像机投影矩阵</span></span><br><span class="line">  camera.<span class="title function_">updateProjectionMatrix</span>();</span><br><span class="line">  <span class="comment">//更新渲染器</span></span><br><span class="line">  renderer.<span class="title function_">setSize</span>(<span class="variable language_">window</span>.<span class="property">innerWidth</span>,<span class="variable language_">window</span>.<span class="property">innerHeight</span>)</span><br><span class="line">  <span class="comment">//设置渲染器的像素比</span></span><br><span class="line">  renderer.<span class="title function_">setPixelRatio</span>(<span class="variable language_">window</span>.<span class="property">devicePixelRatio</span>)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.baidu.com/2022/08/11/20-22-22/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="KK">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KK">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/11/20-22-22/" class="post-title-link" itemprop="url">nginx</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-08-11 20:22:22" itemprop="dateCreated datePublished" datetime="2022-08-11T20:22:22+08:00">2022-08-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-05-16 23:50:36" itemprop="dateModified" datetime="2023-05-16T23:50:36+08:00">2023-05-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h1><blockquote>
<p>负载均衡、反向代理、动静结合</p>
</blockquote>
<h2 id="配置文件匹配顺序"><a href="#配置文件匹配顺序" class="headerlink" title="配置文件匹配顺序"></a>配置文件匹配顺序</h2><p><code>/etc/nginx/conf.d/</code>多个配置文件时，会优先匹配配置了<code>server_name</code>且值不是<code>localhost</code>，接着是<code>localhost</code>，再接着是没有配置的。若端口号和<code>server_name</code>都一样则优先选择该目录下的第一个配置文件。</p>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">nginx -v</span><br><span class="line">nginx -V</span><br><span class="line">nginx -t //查看配置是否有问题</span><br><span class="line">nginx -s reload //重新加载配置</span><br><span class="line">nginx -s stop //强行停止</span><br><span class="line">nginx -s quit //安全退出</span><br><span class="line">ps -ef|grep nginx //查看进程</span><br><span class="line">systemctl <span class="built_in">enable</span> nginx //开机自动启动</span><br><span class="line">//防火墙</span><br><span class="line">systemctl status firewalld.service</span><br><span class="line">systemctl stop firewalld.service</span><br><span class="line">systemctl <span class="built_in">disable</span> firewalld.service</span><br><span class="line">systemctl status firewalld.service</span><br></pre></td></tr></table></figure>

<h2 id="开启-GZIP-压缩"><a href="#开启-GZIP-压缩" class="headerlink" title="开启 GZIP 压缩"></a>开启 GZIP 压缩</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">    gzip on;</span><br><span class="line">    gzip_type application/javascript;<span class="comment">#压缩类型，文本文件压缩效果最好,图片视频资源压缩作用不大，大文件资源会消耗大量cpu资源不推荐</span></span><br><span class="line">    gzip_min_length 1k;<span class="comment">#最小压缩单位，小于1k压缩意义不大</span></span><br><span class="line">    gzip_comp_level 5;<span class="comment">#压缩级别，1-9，数字越大压缩效果越好，但会加大cpu压力，高并发场景不建议调太高,建议5左右</span></span><br><span class="line">    gzip_very on;<span class="comment">#在响应头添加very:accept-encoding,让代理服务器根据请求头识别是否启用了gzip压缩</span></span><br><span class="line">    gzip_http_version 1.1;<span class="comment">#启用gzip压缩的最低http版本，默认1.1</span></span><br><span class="line">    gzip_buffers 4 4k;<span class="comment">#设置压缩所需的缓冲区大小和申请内存的倍率，如4 4k代表以4k为单位，按照原始数据大小以4k为单位的4倍申请内存。默认是申请跟原始数据相同大小的内存空间。</span></span><br><span class="line">    gzip_static on;<span class="comment">#静态压缩，若提前已准备好了压缩文件.gz的压缩包或者提供静态文件服务，可以启用。它可避免动态压缩，提高性能</span></span><br><span class="line">    gzip_proxied off;<span class="comment">#nginx作为反向代理时，开启或关闭后端服务器返回的结果（前提是后端必须返回包含Via的请求头）。off-关闭所有代理结果数据的压缩。expired-若请求头包含‘Expires’信息，则启用。no-cache-若请求头包含‘Cache-Control:no-cache’信息，则启用。no-store-若请求头包含‘Cache-Control:no-store’信息，则启用。private-&gt;若请求头包含‘Cache-Control:private’信息，则启用。no_last_modified-&gt;若请求头不包含‘Last-Modified’信息，则启用。no_etag-&gt;若请求头不包含‘Etag’信息，则启用。auth-&gt;若请求头包含“Authorization&quot;信息，则启用。any-&gt;无条件启用压缩</span></span><br><span class="line">    gzip_disable MSIE[1-6]\.;<span class="comment">#设置禁用浏览器进行Gzip压缩，ie6对gzip压缩支持不好，会造成假死。</span></span><br><span class="line">    listen 8080;</span><br><span class="line">    server_name localhost;</span><br><span class="line">    location / &#123;</span><br><span class="line">        root /opt/test/;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="开启-Brotli"><a href="#开启-Brotli" class="headerlink" title="开启 Brotli"></a>开启 Brotli</h2><blockquote>
<p>比 gzip 性能高，ie 浏览器不支持，仅支持 https，无法使用时，会降级为 gzip</p>
</blockquote>
<ol>
<li>下载源码</li>
<li>下载算法</li>
<li>重新编译，<code>./configure --prefix=安装目录 --with-http_ssl_module --add-module=brotli的安装目录</code></li>
<li>安装好后，将 objs 文件夹中 nginx 执行文件替换掉 sbin 中的执行文件</li>
<li>编辑文件</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">    ...</span><br><span class="line">brotli on；</span><br><span class="line">brotli_type application/javascript;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="请求限流"><a href="#请求限流" class="headerlink" title="请求限流"></a>请求限流</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">语法：limit_req zone=name [burst=number][nodelay|delay=number];</span><br><span class="line">上下文：http,server,location</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">http:&#123;</span><br><span class="line">limit_req_zone <span class="variable">$binary_remote_addr</span> zone=ip_limit:10m rate=1r/s;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>$binary_remote_addr</code>-&gt;通过 remote_addr 这个标识来做限制，限制的是同一客户端的 ip 地址，在这里，客户端 ip 地址作为关键。注意，不是<code>$ remote_addr</code>,<code>$ remote_addr</code>变量的大小可以从 7 到 15 个字节不等，存储状态在 32 位平台上占用 32 或 64 字节，在 64 位平台上总是 64 字节。对于 ipv4 地址，<code>$binary_remote_addr</code>变量始终是 4 个字节，对于 ipv6 地址则为 16 个字节，<br><code>zone=ip_limit:10m</code>-&gt;生成一个 10MB 大小，名字为 ip_limitd 的内存区域，主要用来存储访问频次信息。<br><code>rate=1r/s</code>-&gt;标识允许相同标识客户端的一个访问频次，1r 即 1 次</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">    ...</span><br><span class="line">location / &#123;</span><br><span class="line">limit_req zone=ip_limit burst=5 nodelay;</span><br><span class="line">...</span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure>

<p><code>zone</code>-&gt;表示使用哪个区域来做限制<br><code>burst</code>-&gt;设置了一个大小为 5 的缓存区，当有大量请求即 burst 时，超过访问频次限制的请求可以先放到此缓存区。<br><code>nodelay</code>-&gt;超过访问频次且缓存区也满了的时候，直接返回 503，若无设置，则请求会等待排队。</p>
<h2 id="连接限流"><a href="#连接限流" class="headerlink" title="连接限流"></a>连接限流</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">语法：limit_conn zone number;</span><br><span class="line">上下文：http,server,location</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">http:&#123;</span><br><span class="line">limit_conn_zone <span class="variable">$binary_remote_addr</span> zone=addr:10m;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>$binary_remote_addr</code>-&gt;通过 remote_addr 这个标识来做限制，限制的是同一客户端的 ip 地址.<br><code>zone=addr:10m</code>-&gt;生成一个 10MB 大小，名字为 addr 的内存区域，主要用来存储访问频次信息。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">...</span><br><span class="line">location / &#123;</span><br><span class="line">limit_conn addr 1;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>zone</code>-&gt;表示使用哪个区域来做限制<br><code>1</code>-&gt;允许相同标识客户端的一个访问频次，1 代表只允许每个 ip 地址 1 个连接。</p>
<h2 id="防盗链"><a href="#防盗链" class="headerlink" title="防盗链"></a>防盗链</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">server&#123;</span><br><span class="line">listen 8080;</span><br><span class="line">server_name localhost;</span><br><span class="line">location / &#123;</span><br><span class="line">root /opt/test/;</span><br><span class="line">&#125;</span><br><span class="line">location ~_ ._\.(gif|jpg|png)<span class="variable">$&#123;</span></span><br><span class="line"><span class="variable">        root /opt/test/img/;</span></span><br><span class="line"><span class="variable">        valid_referers none blocked xxx.com;</span></span><br><span class="line"><span class="variable">        if($invalid_referer)&#123;</span></span><br><span class="line"><span class="variable">#return 403;返回错误页面</span></span><br><span class="line"><span class="variable">rewrite ^/ http://xxxx/error;</span></span><br><span class="line"><span class="variable">break;</span></span><br><span class="line"><span class="variable">&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>破解方法</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">header</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;referrer&quot;</span> <span class="attr">content</span>=<span class="string">&quot;no-referrer&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="如何利用-Nginx-代理获取真实-IP"><a href="#如何利用-Nginx-代理获取真实-IP" class="headerlink" title="如何利用 Nginx 代理获取真实 IP"></a>如何利用 Nginx 代理获取真实 IP</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">listen 80;</span><br><span class="line">server_name xxx.xxxx.com;</span><br><span class="line"></span><br><span class="line">location / &#123; <span class="comment">#保留代理之前的 host 包含客户端真实的域名和端口号</span></span><br><span class="line">proxy_set_header Host <span class="variable">$host</span>; <span class="comment">#保留代理之前的真实客户端 ip</span></span><br><span class="line">proxy_set_header X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line"> <span class="comment">#这个 Header 和 X-Real-IP 类似，但它在多级代理时会包含真实客户端及中间每个代理服务器的 IP</span></span><br><span class="line">proxy_set_header X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>; <span class="comment">#表示客户端真实的协议（http 还是 https）</span></span><br><span class="line">proxy_set_header X-Forwarded-Proto <span class="variable">$scheme</span>; <span class="comment">#指定修改被代理服务器返回的响应头中的 location 头域跟 refresh 头域数值 #如果使用&quot;default&quot;参数，将根据 location 和 proxy_pass 参数的设置来决定。</span></span><br><span class="line"><span class="comment">#proxy_redirect [ default|off|redirect replacement ];</span></span><br><span class="line">proxy_redirect off;</span><br><span class="line">proxy_pass http://IP:PORT;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>经过反向代理后，由于在客户端和 web 服务器之间增加了中间层，因此 web 服务器无法直接拿到客户端的 ip，通过<code>$remote_addr</code>变量拿到的将是反向代理服务器的 ip 地址。</p>
<p>这句话的意思是说，当你使用了 nginx 反向服务器后，在 web 端使用 <code>request.getRemoteAddr()</code>（本质上就是获取<code>$remote_addr</code>），取得的是 nginx 的地址，即<code>$remote_addr</code>变量中封装的是 nginx 的地址，当然是没法获得用户的真实 ip 的。但是，nginx 是可以获得用户的真实 ip 的，也就是说 nginx 使用<code>$remote_addr</code>变量时获得的是用户的真实 ip，如果我们想要在 web 端获得用户的真实 ip，就必须在 nginx 里作一个赋值操作，即我在上面的配置：</p>
<p><code>proxy_set_header X-Real-IP $remote_addr;</code>。</p>
<p><code>$remote_addr</code> 只能获取到与服务器本身直连的上层请求 ip，所以设置<code>$remote_addr</code> 一般都是设置第一个代理上面;</p>
<p>但是问题是，有时候是通过 cdn 访问过来的，那么后面 web 服务器获取到的，永远都是 cdn 的 ip 而非真是用户 ip,那么这个时候就要用到<code>X-Forwarded-For</code>了，这个变量的意思，其实就像是链路反追踪，从客户的真实 ip 为起点，穿过多层级的 proxy ，最终到达 web 服务器，都会记录下来，所以在获取用户真实 ip 的时候，一般就可以设置成下面的配置：</p>
<p><code>proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</code>。</p>
<p><code>X-Forwarded-For</code>变量，这是一个 squid 开发的，用于识别通过 HTTP 代理或负载平衡器原始 IP 一个连接到 Web 服务器的客户机地址的非 rfc 标准，如果有做<code>X-Forwarded-For</code>设置的话,每次经过 proxy 转发都会有记录,格式就是<code>client1,proxy1,proxy2</code>以逗号隔开各个地址，由于它是非 rfc 标准，所以默认是没有的，需要强制添加。在默认情况下经过 proxy 转发的请求，在后端看来远程地址都是 proxy 端的 ip 。也就是说在默认情况下我们使用<code>request.getAttribute(“X-Forwarded-For”)</code>获取不到用户的 ip，如果我们想要通过这个变量获得用户的 ip，我们需要自己在 nginx 添加配置：</p>
<p><code>proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</code></p>
<p>它意思是增加一个<code>$proxy_add_x_forwarded_for</code>到<code>X-Forwarded-For</code>里去，注意是增加，而不是覆盖，当然由于默认的<code>X-Forwarded-For</code>值是空的，所以我们总感觉<code>X-Forwarded-For</code>的值就等于<code>$proxy_add_x_forwarded_for</code>的值，实际上当你搭建两台 nginx 在不同的 ip 上，并且都使用了这段配置，那你会发现在 web 服务器端通过 <code>request.getAttribute(“X-Forwarded-For”)</code>获得的将会是客户端 ip 和第一台 nginx 的 ip。</p>
<p>那么<code>$proxy_add_x_forwarded_for</code>又是什么？</p>
<p><code>$proxy_add_x_forwarded_for</code>变量包含客户端请求头中的<code>X-Forwarded-For</code>与<code>$remote_addr</code>两部分，他们之间用逗号分开。</p>
<p>举个例子，有一个 web 应用，在它之前通过了两个 nginx 转发，<a target="_blank" rel="noopener" href="http://www.linuxidc.com即用户访问该web通过两台nginx./">www.linuxidc.com即用户访问该web通过两台nginx。</a></p>
<p>在第一台 nginx 中,使用：</p>
<p><code>proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</code></p>
<p>现在的<code>$proxy_add_x_forwarded_for</code>变量的<code>X-Forwarded-For</code>部分是空的，所以只有<code>$remote_addr</code>，而<code>$remote_addr</code>的值是用户的 ip，于是赋值以后，<code>X-Forwarded-For</code>变量的值就是用户的真实的 ip 地址了。</p>
<p>到了第二台 nginx，使用：</p>
<p><code>proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</code></p>
<p>现在的<code>$proxy_add_x_forwarded_for</code>变量，<code>X-Forwarded-For</code>部分包含的是用户的真实 ip，<code>$remote_addr</code>部分的值是上一台 nginx 的 ip 地址，于是通过这个赋值以后现在的<code>X-Forwarded-For</code>的值就变成了“用户的真实 ip，第一台 nginx 的 ip”，这样就清楚了吧。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.baidu.com/2022/06/11/20-22-22/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="KK">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KK">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/11/20-22-22/" class="post-title-link" itemprop="url">前端包管理工具</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-11 20:22:22" itemprop="dateCreated datePublished" datetime="2022-06-11T20:22:22+08:00">2022-06-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-05-16 23:50:36" itemprop="dateModified" datetime="2023-05-16T23:50:36+08:00">2023-05-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="NPM"><a href="#NPM" class="headerlink" title="NPM"></a>NPM</h2><h3 id="一，包的安装-更新-卸载"><a href="#一，包的安装-更新-卸载" class="headerlink" title="一，包的安装/更新/卸载"></a>一，包的安装/更新/卸载</h3><p><code>npm i</code> 或者<code>npm install</code>装包,默认安装最新版本，直接<code>npm i</code>会安装<code>package.json</code>中 dependencies 的所有包</p>
<p><code>npm i xx@1.0</code>安装指定版本</p>
<p><code>npm i -S</code> 或者 <code>npm i --save</code>装包到生产环境（也就是上线后需要的依赖），在<code>package.json</code>的 dependencies 中生成版本信息</p>
<p><code>npm i -D</code> 或者 <code>npm i --save-dev</code>装包到开发环境（也就是开发时需要的依赖），在<code>package.json</code>的 devDependencies 中生成版本信息</p>
<p><code>npm i xx@1.0 --save-exact</code>精确安装指定版本的包到生产环境。精确的意思就是，什么版本就是什么版本，版本号前面的<code>^</code>会消失掉。有<code>^</code> 代表是补丁版本</p>
<p><code>npm uninstall xx</code>卸载包</p>
<p><code>npm update xx@1.0</code>更新包，默认更新到最新</p>
<p><code>npm outdated</code>检查包是否过时，默认列出所有过时的包</p>
<p><code>npm i xx1@npm:xx@1</code><br><code>npm i xx2@npm:xx@2</code><br>安装同一个包的不同版本，如要引入 1 版本，则<code>import ‘xx1’</code>。<code>npm 6.9</code>及以后的版本可用</p>
<h3 id="二，信息查看"><a href="#二，信息查看" class="headerlink" title="二，信息查看"></a>二，信息查看</h3><p><code>npm ls</code>查看安装过的包，加<code>-g</code>就是查看全局安装过的包， <code>--depth 0</code>就是查看第一层，不再深入递归查询出子文件夹</p>
<p><code>npm ls 包名 -g</code>查看某个包，有则显示版本，没有则是 empty</p>
<p><code>npm root xx</code>查看包的安装路径</p>
<p><code>npm view xx versions</code>查看某个包在线上的所有版本</p>
<p>三，配置向<br><code>npm config set proxy=&quot;http://xx.com:8080&quot;</code>因为公司的防火墙原因，无法完成任何模块的安装，这个时候设置代理可以解决</p>
<p><code>npm config set registry=&quot;https://registry.npm.taobao.org&quot;</code>设置安装源，如上就是设置源为国内的淘宝镜像</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://npm.taobao.org/">https://npm.taobao.org</a> 和 <a target="_blank" rel="noopener" href="https://registry.npm.taobao.org/">https://registry.npm.taobao.org</a> 将在 2022.06.30 号正式下线和停止 DNS 解析。<br>新域名：<a target="_blank" rel="noopener" href="https://registry.npmmirror.com/">https://registry.npmmirror.com</a></p>
</blockquote>
<p>注意 npm 更换国内镜像源之后，将无法再使用 npm search 命令，需要恢复为官方源才可以使用，如果恢复官方源后还不可使用，运行删除注册表命令后重试即可。</p>
<p><code>npm config delete registry</code>// 删除注册表</p>
<p><code>npm config list -l</code>查看所有配置</p>
<h3 id="三-其它"><a href="#三-其它" class="headerlink" title="三, 其它"></a>三, 其它</h3><p><code>npm cache clean</code>清除 npm 本地缓存</p>
<p><code>npm init</code>初始化 package.json</p>
<p><code>npm start</code>启动指令,npm start 指令会匹配到 package 的 scripts 里的配置，然后启动对应脚本。start 此类的支持自定义，常见的自定义为 dev</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;start&quot;</span><span class="punctuation">:</span> <span class="string">&quot;xxx&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="四，发布自己的包"><a href="#四，发布自己的包" class="headerlink" title="四，发布自己的包"></a>四，发布自己的包</h3><h4 id="第一步：进入要发布的项目根目录，初始化为-npm-包"><a href="#第一步：进入要发布的项目根目录，初始化为-npm-包" class="headerlink" title="第一步：进入要发布的项目根目录，初始化为 npm 包"></a>第一步：进入要发布的项目根目录，初始化为 npm 包</h4><p><code>npm init</code></p>
<p>依次按提示填入包名、版本、描述、github 地址、关键字、license 等<br>这步完成之后会生成一个 package.json 文件，上面输入的这些信息可以在该文件中修改<br>name 是名字，不能和别人的一样，否则发布失败<br>version 是版本号，每次发布自己手动修改，版本号需递增，否则发布失败<br>main 设置入口文件，入口文件需和 package 同级，如不同级，则应该写/xx/yy 这样的相对路径，</p>
<p>注意：如果你的包引用了第三方包，则需要在 package.json 文件种增加 dependencies 节点，写入依赖的包及版本</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;dependencies&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;colors&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^1.3.2&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;on-finished&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^2.3.0&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="第二步、注册-npm-用户，有两种方法-注册-npm-用户，有两种方法"><a href="#第二步、注册-npm-用户，有两种方法-注册-npm-用户，有两种方法" class="headerlink" title="第二步、注册 npm 用户，有两种方法 注册 npm 用户，有两种方法"></a>第二步、注册 npm 用户，有两种方法 注册 npm 用户，有两种方法</h4><p>方法一、npm 官网注册：npm</p>
<p>方法二、使用 npm 命令注册：npm adduser</p>
<h4 id="第三步、账号登录"><a href="#第三步、账号登录" class="headerlink" title="第三步、账号登录"></a>第三步、账号登录</h4><p><code>npm login</code></p>
<p>依次输入第二步中第一种方法注册的用户名、密码和邮箱</p>
<h4 id="第四步、发布包，上传到-npm-包服务器"><a href="#第四步、发布包，上传到-npm-包服务器" class="headerlink" title="第四步、发布包，上传到 npm 包服务器"></a>第四步、发布包，上传到 npm 包服务器</h4><p><code>npm publish</code></p>
<p>注意：如果报错：<code>&#39;You do not have permission to publish &quot;mypackage1&quot;. Are you logged in as the correct user?&#39;</code></p>
<p>表示包<code>mypackage1</code>已经在包管理器已经存在被别人用了，需要更该包名称</p>
<h3 id="五，更新一个已经发布的包"><a href="#五，更新一个已经发布的包" class="headerlink" title="五，更新一个已经发布的包"></a>五，更新一个已经发布的包</h3><h4 id="第一步、修改包的版本"><a href="#第一步、修改包的版本" class="headerlink" title="第一步、修改包的版本"></a>第一步、修改包的版本</h4><p>这次我在包根目录下新加了一个 index.js 文件</p>
<p><code>npm version patch</code> 该命令在原来的版本上自动加 1,实际上是将 package.json 文件中的 version 值修改了。</p>
<h4 id="第二步、重新发布包"><a href="#第二步、重新发布包" class="headerlink" title="第二步、重新发布包"></a>第二步、重新发布包</h4><p><code>npm publish</code></p>
<h3 id="六、删除包"><a href="#六、删除包" class="headerlink" title="六、删除包"></a>六、删除包</h3><p>1、删除指定的版本</p>
<p><code>npm unpublish 包名@版本号</code></p>
<p>2、删除整个包</p>
<p><code>npm unpublish 包名 --force</code></p>
<h2 id="YARN"><a href="#YARN" class="headerlink" title="YARN"></a>YARN</h2><blockquote>
<p>Yarn 是由 Facebook、Google、Exponent 和 Tilde 联合推出了一个新的 JS 包管理工具 。</p>
</blockquote>
<p>安装：<code>npm install -g yarn</code></p>
<p>执行 <code>yarn xxx</code> 命令报以下错误时：</p>
<p>操作以下步骤进行策略更改：</p>
<blockquote>
<p>1.使用管理员身份运行 <code>cmd</code> 或 <code>Power shell</code> 2.输入：<code>set-executionpolicy remotesigned</code> 3.输入<code>Y</code>，回车保存</p>
</blockquote>
<p>yarn 配置源：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 查询源</span><br><span class="line">yarn config get registry</span><br><span class="line"></span><br><span class="line">// 更换国内源</span><br><span class="line">yarn config <span class="built_in">set</span> registry https://registry.npmmirror.com</span><br><span class="line"></span><br><span class="line">// 恢复官方源</span><br><span class="line">yarn config <span class="built_in">set</span> registry https://registry.yarnpkg.com</span><br><span class="line"></span><br><span class="line">// 删除注册表</span><br><span class="line">yarn config delete registry</span><br></pre></td></tr></table></figure>

<p>npm 与 yarn 命令对比：</p>
<table>
<thead>
<tr>
<th>npm 命令</th>
<th>yarn 命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>npm install</td>
<td>yarn install</td>
<td>安装依赖,安装时，如果 node_modules 中有相应的包则不会重新下载 –force 可以强制</td>
</tr>
<tr>
<td>npm install [package@版本号]</td>
<td>yarn add [package@版本号]</td>
<td>指定版本安装一个包</td>
</tr>
<tr>
<td>npm install [package] –save</td>
<td>yarn add [package]</td>
<td>安装一个包,–save 是 yarn 默认的</td>
</tr>
<tr>
<td>npm install -g [package]</td>
<td>yarn global add [package@版本号]</td>
<td>指定版本安装一个包</td>
</tr>
<tr>
<td>npm install –save-dev [package]</td>
<td>yarn add –dev [package]</td>
<td>安装包作为开发依赖项，简写<code>-D</code></td>
</tr>
<tr>
<td>npm uninstall [package]</td>
<td>yarn remove [package]</td>
<td>卸载一个包</td>
</tr>
<tr>
<td>npm uninstall –save-dev [package]</td>
<td>yarn remove [package]</td>
<td>卸载开发依赖包</td>
</tr>
<tr>
<td>npm update</td>
<td>yarn upgrade</td>
<td>更新的依赖关系</td>
</tr>
<tr>
<td>npm update [package]</td>
<td>yarn upgrade [package]</td>
<td>更新包，npm 可以通过 ‘–save</td>
</tr>
</tbody></table>
<h2 id="PNPM"><a href="#PNPM" class="headerlink" title="PNPM"></a>PNPM</h2><blockquote>
<p>pnpm(Performance npm，简称高性能 npm)的作者 Zoltan Kochan 发现 yarn 并没有打算去解决上述的这些问题，于是另起炉灶，写了全新的包管理器。</p>
</blockquote>
<p>pnpm 复刻了 npm 所有的命令，所以使用方法和 npm 一样，并且在安装目录结构上做了优化，特点是善用链接，且由于链接的优势，大多数情况下 pnpm 的安装速度比 yarn 和 npm 更快。</p>
<p>安装：<code>npm i pnpm -g</code></p>
<p>升级版本<code>pnpm add -g pnpm to update</code></p>
<p>设置源：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pnpm config get registry //查看源</span><br><span class="line">pnpm config <span class="built_in">set</span> registry https://registry.npmmirror.com //切换淘宝源</span><br></pre></td></tr></table></figure>

<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>在项目根目录安装依赖包 bar，而 bar 依赖了 foo。点开项目根目录的 node_modules，可以看到我们在项目中安装的 bar，以及.pnpm 文件夹。<br>那么 pnpm 是如何维护依赖的嵌套关系的呢？</p>
<p>首先在<code>.pnpm</code>文件夹以平铺的方式存储了项目中所有的依赖包，建立硬链接。命名的方式如下：</p>
<p><code>.pnpm/&lt;organization-name&gt;+&lt;package-name&gt;@&lt;version&gt;/node_modules/&lt;name&gt;// 组织名(若无会省略)+包名@版本号/node_modules/名称(项目名称)</code><br>其中.pnpm 中的包中的 node_modules 下面的包中的每个文件都是内容可寻址存储的硬链接。将 foo 和 bar 都放到 node_modules 文件夹，可以保证包能自行导入自己。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">node_modules</span><br><span class="line">└── .pnpm</span><br><span class="line"> ├── foo@1.0.0</span><br><span class="line"> │   └── node_modules</span><br><span class="line"> │       └── foo -&gt; &lt;store&gt;/bar 硬链接</span><br><span class="line"> │           ├── index.js</span><br><span class="line"> │           └── package.json</span><br><span class="line"> └── bar@1.0.0</span><br><span class="line">     └── node_modules</span><br><span class="line">         └── bar -&gt; &lt;store&gt;/bar 硬链接</span><br><span class="line">             ├── index.js</span><br><span class="line">             └── package.json</span><br></pre></td></tr></table></figure>

<p>建立符号链接，由于 bar 依赖了 foo，因此 foo 被符号链接到<a href="mailto:&#x62;&#x61;&#x72;&#64;&#49;&#46;&#48;&#x2e;&#x30;">&#x62;&#x61;&#x72;&#64;&#49;&#46;&#48;&#x2e;&#x30;</a>/node_modules 文件夹下，</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">node_modules</span><br><span class="line">└── .pnpm</span><br><span class="line"> ├── foo@1.0.0</span><br><span class="line"> │   └── node_modules</span><br><span class="line"> │       └── foo -&gt; &lt;store&gt;/bar 硬链接</span><br><span class="line"> │           ├── index.js</span><br><span class="line"> │           └── package.json</span><br><span class="line"> └── bar@1.0.0</span><br><span class="line">     └── node_modules</span><br><span class="line">         └── bar -&gt; &lt;store&gt;/bar 硬链接</span><br><span class="line">         │    ├── index.js</span><br><span class="line">         │    └── package.json</span><br><span class="line">         └── foo -&gt; ../../bar@1.0.0/node_modules/bar 符号链接</span><br></pre></td></tr></table></figure>

<p>处理直接依赖，bar 被符号链接到根目录的 node_modules 文件夹</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">node_modules</span><br><span class="line">├── bar -&gt; ./.pnpm/bar@1.0.0/node_modules/bar 符号链接</span><br><span class="line">└── .pnpm</span><br><span class="line"> ├── foo@1.0.0</span><br><span class="line"> │   └── node_modules</span><br><span class="line"> │       └── foo -&gt; &lt;store&gt;/bar 硬链接</span><br><span class="line"> │           ├── index.js</span><br><span class="line"> │           └── package.json</span><br><span class="line"> └── bar@1.0.0</span><br><span class="line">     └── node_modules</span><br><span class="line">         └── bar -&gt; &lt;store&gt;/bar 硬链接</span><br><span class="line">         │    ├── index.js</span><br><span class="line">         │    └── package.json</span><br><span class="line">         └── foo -&gt; ../../bar@1.0.0/node_modules/bar 符号链接</span><br></pre></td></tr></table></figure>

<p>在项目中我们引入 bar 的时候，会在当前项目根目录的 node_modules 找 bar，从 projectRoot/node_modules/bar 这个符号链接找到 bar 的真实文件 projectRoot/node_modules/.pnpm/<a href="mailto:&#98;&#x61;&#x72;&#64;&#x31;&#x2e;&#48;&#46;&#x30;">&#98;&#x61;&#x72;&#64;&#x31;&#x2e;&#48;&#46;&#x30;</a>/node_modules/bar（硬链接即可看做真实存在的文件）。<br>接着 bar 依赖了 foo，根据 node 的寻址机制，会从里到外找 foo，最后在这个路径 projectRoot/node_modules/.pnpm/<a href="mailto:&#x62;&#97;&#x72;&#x40;&#49;&#x2e;&#48;&#46;&#48;">&#x62;&#97;&#x72;&#x40;&#49;&#x2e;&#48;&#46;&#48;</a>/node_modules/foo 找到了，这个是一个符号链接，会定位到 projectRoot/node_modules/.pnpm/<a href="mailto:&#102;&#x6f;&#111;&#64;&#x31;&#x2e;&#48;&#x2e;&#48;">&#102;&#x6f;&#111;&#64;&#x31;&#x2e;&#48;&#x2e;&#48;</a></p>
<h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ul>
<li><p>解决了幽灵依赖的问题<br>yarn 和 npm 中的幽灵依赖：由于在 yarn 或 npm 中采用扁平化的安装包的方式，即所有的包（包ffff依赖）都被提升到了项目根目录中的 node_modules 中，那么项目中可以直接引用到不在 package.json 中声明的包，那么在包更新的时候，可能会导致问题。<br>而 pnmp 中的项目根目录的 node_modules 中只有项目直接依赖的包，所以不会有这个问题。</p>
</li>
<li><p>路径过长的问题<br>在 npm@3 之前，npm 采用的嵌套结构管理包，node_modules 结构是干净、可预测的，因为 node_modules 中的每个依赖项都有自己的 node_modules 文件夹。但是这样的管理方式会导致路径过程超出 window 的限制。<br>在 npm@3 和 yarn 中，采用了扁平化结构管理包（解决了路径过长的问题，导致了幽灵依赖的问题）。<br>pnpm 利用符号链接解决了这个问题。<br>继续上面的<br>添加<a href="mailto:&#113;&#x61;&#114;&#64;&#x32;&#x2e;&#x30;&#46;&#x30;">&#113;&#x61;&#114;&#64;&#x32;&#x2e;&#x30;&#46;&#x30;</a>作为 foo 和 bar 的依赖项,可以看到我们目录深度没有改变，但却表达了嵌套的包依赖关系。</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">node_modules</span><br><span class="line">├── bar -&gt; ./.pnpm/bar@1.0.0/node_modules/bar 符号链接</span><br><span class="line">└── .pnpm</span><br><span class="line">    ├── foo@1.0.0</span><br><span class="line">    │   └── node_modules</span><br><span class="line">    │       └── foo -&gt; &lt;store&gt;/bar 硬链接</span><br><span class="line">    │           ├── index.js</span><br><span class="line">    │           └── package.json</span><br><span class="line">    │       └── qar -&gt; ../../qar@2.0.0/node_modules/qar 符号链接</span><br><span class="line">    └── bar@1.0.0</span><br><span class="line">    │   └── node_modules</span><br><span class="line">    │       └── bar -&gt; &lt;store&gt;/bar 硬链接</span><br><span class="line">    │       │    ├── index.js</span><br><span class="line">    │       │    └── package.json</span><br><span class="line">    │        └── foo -&gt; ../../bar@1.0.0/node_modules/bar 符号链接</span><br><span class="line">    │       └── qar -&gt; ../../qar@2.0.0/node_modules/qar 符号链接</span><br><span class="line">    └── qar@2.0.0</span><br><span class="line">            └── node_modules</span><br><span class="line">                └── qar -&gt; &lt;store&gt;/qar</span><br></pre></td></tr></table></figure>

<ul>
<li>占用更小的内存，下载速度更快<br>使用 npm 时，依赖每次被不同的项目使用，都会重复安装一次。 而在使用 pnpm 时，依赖会被存储在内容可寻址的存储中，所以：</li>
</ul>
<p>如果你用到了某依赖项的不同版本，只会将不同版本间有差异的文件添加到仓库。 例如，如果某个包有 100 个文件，而它的新版本只改变了其中 1 个文件。那么 pnpm update 时只会向存储中心额外添加 1 个新文件，而不会因为仅仅一个文件的改变复制整新版本包的内容。<br>所有文件都会存储在硬盘上的某一位置。 当软件包被被安装时，包里的文件会硬链接到这一位置，而不会占用额外的磁盘空间。 这允许你跨项目地共享同一版本的依赖。<br>因此，您在磁盘上节省了大量空间，这与项目和依赖项的数量成正比，并且安装速度要快得多！</p>
<h2 id="CNPM"><a href="#CNPM" class="headerlink" title="CNPM"></a>CNPM</h2><p>cnpm 是个中国版的 npm，是淘宝定制的 cnpm (gzip 压缩支持) 命令行工具代替默认的 npm</p>
<h2 id="npm-vs-yarn-vs-pnpm"><a href="#npm-vs-yarn-vs-pnpm" class="headerlink" title="npm vs yarn vs pnpm"></a>npm vs yarn vs pnpm</h2><h3 id="npm-v1-v2"><a href="#npm-v1-v2" class="headerlink" title="npm v1-v2"></a>npm v1-v2</h3><p>初代 npm(Node.js Package Manager)随着 Node.js 的发布出现了。</p>
<p>它的文件结构是嵌套的,这会导致 3 个问题：</p>
<p>1、node_modules 体积过大(大量重复的包被安装)</p>
<p>2、node_modules 嵌套层级过深(会导致文件路径过长的问题)</p>
<p>3、模块实例不能共享</p>
<h3 id="yarn-amp-npm-v3"><a href="#yarn-amp-npm-v3" class="headerlink" title="yarn &amp; npm v3"></a>yarn &amp; npm v3</h3><p>这个版本 yarn 和 npm v3 带来了扁平化依赖管理：<br>扁平化处理时，比如安装 A，A 依赖 B 和 C，C 依赖 D 和 E，就把 A~E 全部放到 node_modules 目录下，从而解决上个版本中 node_modules 嵌套层级过深的问题。</p>
<p>在 install 安装时，会不停的往上级 node_modules 中寻找，如果找到同样的包，就不再重复安装，从而解决了大量包被重复安装的问题。但是扁平化带来了新的问题：</p>
<ol>
<li>依赖结构的不确定性</li>
<li>扁平化算法本身复杂性很高，耗时较长</li>
<li>项目中仍然可以非法访问没有声明过依赖的包</li>
</ol>
<p> 对于问题 1，比如 B 和 C 都依赖了 F，但是依赖的 F 版本不一样,依赖结构的不确定性表现是扁平化的结果不确定，以下 2 种情况都有可能，取决于 package.json 中 B 和 C 的位置。于是出现 yarn.lock(npm5 才有 package-lock.json)，来保证 install 后产生确定的依赖结构。但这并不能完全解决问题，node_modules 中依然存在各种不同版本的 F，而这可能导致各种情况的编译报错，以及安装满，占磁盘空间。</p>
<p>对于问题 3，package.json 中我们只声明了 A，B<del>F 都是因为扁平化处理才放到和 A 同级的 node_modules 下，理论上在项目中写代码时只可以使用 A，但实际上 B</del>F 也可以使用，由于扁平化将没有直接依赖的包提升到 node_modules 一级目录，Node.js 没有校验是否有直接依赖，所以项目中可以非法访问没有声明过依赖的包。这会产生两个问题：B~F 中的包升级后，项目可能出问题和额外的管理成本(比如协作时别人运行一次 npm install 后项目依旧跑不起来)</p>
<h3 id="pnpm"><a href="#pnpm" class="headerlink" title="pnpm"></a>pnpm</h3><p>pnpm 复刻了 npm 所有的命令，所以使用方法和 npm 一样，并且在安装目录结构上做了优化，特点是善用链接，且由于链接的优势，大多数情况下 pnpm 的安装速度比 yarn 和 npm 更快。</p>
<p>比如安装 A，A 依赖了 B：</p>
<ol>
<li><p>安装依赖<br>A 和 B 一起放到.pnpm 中(和上面相比，这里没有耗时的扁平化算法)。<br>另外<a href="mailto:&#65;&#x40;&#49;&#46;&#x30;&#46;&#x30;">&#65;&#x40;&#49;&#46;&#x30;&#46;&#x30;</a>下面是 node_modules，然后才是 A，这样做有两点好处：</p>
<ul>
<li>允许包引用自身</li>
<li>把包和它的依赖摊平，避免循环结构</li>
</ul>
</li>
<li><p>处理间接依赖<br>A 平级目录创建 B，B 指向<a href="mailto:&#x42;&#64;&#x31;&#x2e;&#x30;&#x2e;&#x30;">&#x42;&#64;&#x31;&#x2e;&#x30;&#x2e;&#x30;</a>下面的 B。</p>
</li>
<li><p>处理直接依赖<br>顶层 node_modules 目录下创建 A，指向<a href="mailto:&#x41;&#64;&#49;&#46;&#48;&#x2e;&#48;">&#x41;&#64;&#49;&#46;&#48;&#x2e;&#48;</a>下的 A。</p>
</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><p>如果你想更快的速度，更小的空间，你应该选择 pnpm;</p>
</li>
<li><p>如果你要用 Monorepo(monolithic repository)是一种项目架构,简单的来说:一个仓库内包含多个开发项目(模块,包)，你可以用 yarn 或 pnpm;</p>
</li>
<li><p>如果是 node 项目，你应该用 npm，因为这是 node 官方推荐的，而且 yarn 不支持 node5+;</p>
</li>
<li><p>对于 npm 项目，如果你担心项目的安全性，你可以考虑用 yarn 替换 npm。</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.baidu.com/2022/06/01/20-00-00/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="KK">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KK">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/01/20-00-00/" class="post-title-link" itemprop="url">TypeScript</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-01 20:00:00" itemprop="dateCreated datePublished" datetime="2022-06-01T20:00:00+08:00">2022-06-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-05-16 23:50:36" itemprop="dateModified" datetime="2023-05-16T23:50:36+08:00">2023-05-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/web/" itemprop="url" rel="index"><span itemprop="name">web</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h1><blockquote>
<p>TypeScript 是一种由微软开发的开源、跨平台的编程语言。它是 JavaScript 的超集，主要提供了类型系统和对 ES6+ 的支持,最终会被编译为 JavaScript 代码。</p>
</blockquote>
<h2 id="安装-TypeScript-npm-包"><a href="#安装-TypeScript-npm-包" class="headerlink" title="安装 TypeScript npm 包"></a>安装 TypeScript npm 包</h2><ul>
<li>安装<br><code>npm install -g typescript</code><br>安装完成后我们就可以使用 TypeScript 编译器，名称叫 tsc，可将编译结果生成 js 文件。</li>
<li>使用<br><code>tsc hello.ts</code></li>
</ul>
<h2 id="基础类型"><a href="#基础类型" class="headerlink" title="基础类型"></a>基础类型</h2><ul>
<li>布尔值</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">isDone</span>: <span class="built_in">boolean</span> = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>数字<blockquote>
<p>和 JavaScript 一样，TypeScript 里的所有数字都是浮点数。 这些浮点数的类型是 number。 除了支持十进制和十六进制字面量，TypeScript 还支持 ECMAScript 2015 中引入的二进制和八进制字面量。</p>
</blockquote>
</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">decLiteral</span>: <span class="built_in">number</span> = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">hexLiteral</span>: <span class="built_in">number</span> = <span class="number">0xf00d</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">binaryLiteral</span>: <span class="built_in">number</span> = <span class="number">0b1010</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">octalLiteral</span>: <span class="built_in">number</span> = <span class="number">0o744</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>字符串</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">name</span>: <span class="built_in">string</span> = <span class="string">&quot;bob&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">name</span>: <span class="built_in">string</span> = <span class="string">&#x27;bob&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">name</span>: <span class="built_in">string</span> = <span class="string">`bob`</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>数组</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">list</span>: <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="attr">list</span>: <span class="title class_">Array</span>&lt;<span class="built_in">number</span>&gt; = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];<span class="comment">//使用数组泛型Array&lt;元素类型&gt;</span></span><br></pre></td></tr></table></figure>

<p>-元组 Tuple</p>
<blockquote>
<p>元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。 比如，你可以定义一对值分别为 string 和 number 类型的元组。</p>
</blockquote>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">x</span>: [<span class="built_in">string</span>, <span class="built_in">number</span>];</span><br><span class="line">x = [<span class="string">&#x27;hello&#x27;</span>, <span class="number">10</span>]; <span class="comment">// OK</span></span><br><span class="line">x = [<span class="number">10</span>, <span class="string">&#x27;hello&#x27;</span>]; <span class="comment">// Error</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>当访问一个越界的元素，会使用联合类型替代：</p>
</blockquote>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x[<span class="number">3</span>] = <span class="string">&#x27;world&#x27;</span>; <span class="comment">// OK, 字符串可以赋值给(string | number)类型</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x[<span class="number">5</span>].<span class="title function_">toString</span>()); <span class="comment">// OK, &#x27;string&#x27; 和 &#x27;number&#x27; 都有 toString</span></span><br><span class="line">x[<span class="number">6</span>] = <span class="literal">true</span>; <span class="comment">// Error, 布尔不是(string | number)类型</span></span><br></pre></td></tr></table></figure>

<ul>
<li>枚举<blockquote>
<p>enum 类型是对 JavaScript 标准数据类型的一个补充。 像 C#等其它语言一样，使用枚举类型可以为一组数值赋予友好的名字。</p>
</blockquote>
</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123;<span class="title class_">Red</span>, <span class="title class_">Green</span>, <span class="title class_">Blue</span>&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">c</span>: <span class="title class_">Color</span> = <span class="title class_">Color</span>.<span class="property">Green</span>;</span><br><span class="line"><span class="comment">//默认情况下，从0开始为元素编号。 你也可以手动的指定成员的数值。 例如，我们将上面的例子改成从 1开始编号：</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123;<span class="title class_">Red</span> = <span class="number">1</span>, <span class="title class_">Green</span>, <span class="title class_">Blue</span>&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">c</span>: <span class="title class_">Color</span> = <span class="title class_">Color</span>.<span class="property">Green</span>;</span><br><span class="line"><span class="comment">//或者，全部都采用手动赋值：</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123;<span class="title class_">Red</span> = <span class="number">1</span>, <span class="title class_">Green</span> = <span class="number">2</span>, <span class="title class_">Blue</span> = <span class="number">4</span>&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">c</span>: <span class="title class_">Color</span> = <span class="title class_">Color</span>.<span class="property">Green</span>;</span><br><span class="line"><span class="comment">//枚举类型提供的一个便利是你可以由枚举的值得到它的名字。 例如，我们知道数值为2，但是不确定它映射到Color里的哪个名字，我们可以查找相应的名字：</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123;<span class="title class_">Red</span> = <span class="number">1</span>, <span class="title class_">Green</span>, <span class="title class_">Blue</span>&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">colorName</span>: <span class="built_in">string</span> = <span class="title class_">Color</span>[<span class="number">2</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(colorName);  <span class="comment">// 显示&#x27;Green&#x27;因为上面代码里它的值是2</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Any<br>不希望类型检查器对这些值进行检查而是直接让它们通过编译阶段的检查。 那么我们可以使用 any 类型来标记这些变量：</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">notSure</span>: <span class="built_in">any</span> = <span class="number">4</span>;</span><br><span class="line">notSure = <span class="string">&quot;maybe a string instead&quot;</span>;</span><br><span class="line">notSure = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">list</span>: <span class="built_in">any</span>[] = [<span class="number">1</span>, <span class="literal">true</span>, <span class="string">&quot;free&quot;</span>];</span><br><span class="line">list[<span class="number">1</span>] = <span class="number">100</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>Void<br>某种程度上来说，void 类型像是与 any 类型相反，它表示没有任何类型。 当一个函数没有返回值时，你通常会见到其返回值类型是 void：</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">warnUser</span>(<span class="params"></span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;This is my warning message&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//声明一个void类型的变量没有什么大用，因为你只能为它赋予undefined和null：</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">unusable</span>: <span class="built_in">void</span> = <span class="literal">undefined</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>Null 和 Undefined<blockquote>
<p>TypeScript 里，undefined 和 null 两者各自有自己的类型分别叫做 undefined 和 null。 和 void 相似，它们的本身的类型用处不是很大：</p>
</blockquote>
</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">u</span>: <span class="literal">undefined</span> = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">n</span>: <span class="literal">null</span> = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<p>默认情况下 null 和 undefined 是所有类型的子类型。 就是说你可以把 null 和 undefined 赋值给 number 类型的变量。然而，当你指定了–strictNullChecks 标记，null 和 undefined 只能赋值给 void 和它们各自。 这能避免 很多常见的问题。 也许在某处你想传入一个 string 或 null 或 undefined，你可以使用联合类型 string | null | undefined。</p>
<ul>
<li>Never<br>never 类型表示的是那些永不存在的值的类型。 例如， never 类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型； 变量也可能是 never 类型，当它们被永不为真的类型保护所约束时。never 类型是任何类型的子类型，也可以赋值给任何类型；然而，没有类型是 never 的子类型或可以赋值给 never 类型（除了 never 本身之外）。 即使 any 也不可以赋值给 never。</li>
</ul>
<p>下面是一些返回 never 类型的函数：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回never的函数必须存在无法达到的终点</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">error</span>(<span class="params">message: <span class="built_in">string</span></span>): <span class="built_in">never</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推断的返回值类型为never</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fail</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">error</span>(<span class="string">&quot;Something failed&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回never的函数必须存在无法达到的终点</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">infiniteLoop</span>(<span class="params"></span>): <span class="built_in">never</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Object<br>object 表示非原始类型，也就是除 number，string，boolean，symbol，null 或 undefined 之外的类型。</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">function</span> <span class="title function_">create</span>(<span class="params">o: <span class="built_in">object</span> | <span class="literal">null</span></span>): <span class="built_in">void</span>;</span><br><span class="line"><span class="title function_">create</span>(&#123; <span class="attr">prop</span>: <span class="number">0</span> &#125;); <span class="comment">// OK</span></span><br><span class="line"><span class="title function_">create</span>(<span class="literal">null</span>); <span class="comment">// OK</span></span><br><span class="line"><span class="title function_">create</span>(<span class="number">42</span>); <span class="comment">// Error</span></span><br><span class="line"><span class="title function_">create</span>(<span class="string">&quot;string&quot;</span>); <span class="comment">// Error</span></span><br><span class="line"><span class="title function_">create</span>(<span class="literal">false</span>); <span class="comment">// Error</span></span><br><span class="line"><span class="title function_">create</span>(<span class="literal">undefined</span>); <span class="comment">// Error</span></span><br></pre></td></tr></table></figure>

<ul>
<li>类型断言<br>类型断言好比其它语言里的类型转换，但是不进行特殊的数据检查和解构。 它没有运行时的影响，只是在编译阶段起作用。 TypeScript 会假设你，程序员，已经进行了必须的检查。</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类型断言有两种形式。 其一是“尖括号”语法：</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">someValue</span>: <span class="built_in">any</span> = <span class="string">&quot;this is a string&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">strLength</span>: <span class="built_in">number</span> = (&lt;<span class="built_in">string</span>&gt;someValue).<span class="property">length</span>;</span><br><span class="line"><span class="comment">//另一个为as语法：</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">someValue</span>: <span class="built_in">any</span> = <span class="string">&quot;this is a string&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">strLength</span>: <span class="built_in">number</span> = (someValue <span class="keyword">as</span> <span class="built_in">string</span>).<span class="property">length</span>;</span><br><span class="line"><span class="comment">//两种形式是等价的。 至于使用哪个大多数情况下是凭个人喜好；然而，当你在TypeScript里使用JSX时，只有 as语法断言是被允许的。</span></span><br></pre></td></tr></table></figure>

<ul>
<li>解构<br>解构数组</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> input = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">let</span> [first, second] = input;</span><br><span class="line">[first, second] = [second, first];</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">[first, second]: [<span class="built_in">number</span>, <span class="built_in">number</span>]</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(first);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(second);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//你可以在数组里使用...语法创建剩余变量</span></span><br><span class="line"><span class="keyword">let</span> [first, ...rest] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(first); <span class="comment">// outputs 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(rest); <span class="comment">// outputs [ 2, 3, 4 ]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [first] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(first); <span class="comment">// outputs 1</span></span><br><span class="line"><span class="keyword">let</span> [, second, , fourth] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br></pre></td></tr></table></figure>

<p>对象解构</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> o = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="string">&quot;foo&quot;</span>,</span><br><span class="line">    <span class="attr">b</span>: <span class="number">12</span>,</span><br><span class="line">    <span class="attr">c</span>: <span class="string">&quot;bar&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> &#123; a, b &#125; = o;</span><br><span class="line"><span class="comment">//可以用没有声明的赋值,注意，我们需要用括号将它括起来，因为Javascript通常会将以 &#123; 起始的语句解析为一个块。</span></span><br><span class="line">(&#123; a, b &#125; = &#123; <span class="attr">a</span>: <span class="string">&quot;baz&quot;</span>, <span class="attr">b</span>: <span class="number">101</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以在对象里使用...语法创建剩余变量：</span></span><br><span class="line"><span class="keyword">let</span> &#123; a, ...passthrough &#125; = o;</span><br><span class="line"><span class="keyword">let</span> total = passthrough.<span class="property">b</span> + passthrough.<span class="property">c</span>.<span class="property">length</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>属性重命名</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; <span class="attr">a</span>: newName1, <span class="attr">b</span>: newName2 &#125; = o;</span><br><span class="line"><span class="comment">//好像你写成了以下样子：</span></span><br><span class="line"><span class="keyword">let</span> newName1 = o.<span class="property">a</span>;</span><br><span class="line"><span class="keyword">let</span> newName2 = o.<span class="property">b</span>;</span><br><span class="line"><span class="comment">//这里的冒号不是指示类型的。 如果你想指定它的类型， 仍然需要在其后写上完整的模式。</span></span><br><span class="line"><span class="keyword">let</span> &#123;a, b&#125;: &#123;<span class="attr">a</span>: <span class="built_in">string</span>, <span class="attr">b</span>: <span class="built_in">number</span>&#125; = o;</span><br></pre></td></tr></table></figure>

<p>默认值</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">默认值可以让你在属性为 <span class="literal">undefined</span> 时使用缺省值：</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">keepWholeObject</span>(<span class="params">wholeObject: &#123; a: <span class="built_in">string</span>, b?: <span class="built_in">number</span> &#125;</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> &#123; a, b = <span class="number">1001</span> &#125; = wholeObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数声明<br>解构也能用于函数声明。 看以下简单的情况：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> C = &#123; <span class="attr">a</span>: <span class="built_in">string</span>, b?: <span class="built_in">number</span> &#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">&#123; a, b &#125;: C</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 但是，通常情况下更多的是指定默认值，解构默认值有些棘手。 首先，你需要在默认值之前设置其格式。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">&#123; a=<span class="string">&quot;&quot;</span>, b=<span class="number">0</span> &#125; = &#123;&#125;</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">f</span>();</span><br><span class="line"><span class="comment">// 上面的代码是一个类型推断的例子，将在本手册后文介绍。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 其次，你需要知道在解构属性上给予一个默认或可选的属性用来替换主初始化列表。 要知道 C 的定义有一个 b 可选属性：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">&#123; a, b = <span class="number">0</span> &#125; = &#123; a: <span class="string">&quot;&quot;</span> &#125;</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">f</span>(&#123; <span class="attr">a</span>: <span class="string">&quot;yes&quot;</span> &#125;); <span class="comment">// ok, default b = 0</span></span><br><span class="line"><span class="title function_">f</span>(); <span class="comment">// ok, default to &#123;a: &quot;&quot;&#125;, which then defaults b = 0</span></span><br><span class="line"><span class="title function_">f</span>(&#123;&#125;); <span class="comment">// error, &#x27;a&#x27; is required if you supply an argument</span></span><br><span class="line"><span class="comment">// 要小心使用解构。 从前面的例子可以看出，就算是最简单的解构表达式也是难以理解的。</span></span><br></pre></td></tr></table></figure>

<ul>
<li>展开<blockquote>
<p>展开操作符正与解构相反。 它允许你将一个数组展开为另一个数组，或将一个对象展开为另一个对象。 例如：</p>
</blockquote>
</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> first = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">let</span> second = [<span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> bothPlus = [<span class="number">0</span>, ...first, ...second, <span class="number">5</span>];<span class="comment">//[0, 1, 2, 3, 4, 5]</span></span><br><span class="line"><span class="comment">//展开操作创建了 first和second的一份浅拷贝。 它们不会被展开操作所改变。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//你还可以展开对象：</span></span><br><span class="line"><span class="keyword">let</span> defaults = &#123; <span class="attr">food</span>: <span class="string">&quot;spicy&quot;</span>, <span class="attr">price</span>: <span class="string">&quot;$$&quot;</span>, <span class="attr">ambiance</span>: <span class="string">&quot;noisy&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> search = &#123; ...defaults, <span class="attr">food</span>: <span class="string">&quot;rich&quot;</span> &#125;;</span><br><span class="line">search的值为&#123; <span class="attr">food</span>: <span class="string">&quot;rich&quot;</span>, <span class="attr">price</span>: <span class="string">&quot;$$&quot;</span>, <span class="attr">ambiance</span>: <span class="string">&quot;noisy&quot;</span> &#125;。</span><br><span class="line"><span class="comment">// 对象的展开比数组的展开要复杂的多。 像数组展开一样，它是从左至右进行处理，但结果仍为对象。 这就意味着出现在展开对象后面的属性会覆盖前面的属性。 因此，如果我们修改上面的例子，在结尾处进行展开的话：</span></span><br><span class="line"><span class="keyword">let</span> defaults = &#123; <span class="attr">food</span>: <span class="string">&quot;spicy&quot;</span>, <span class="attr">price</span>: <span class="string">&quot;$$&quot;</span>, <span class="attr">ambiance</span>: <span class="string">&quot;noisy&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> search = &#123; <span class="attr">food</span>: <span class="string">&quot;rich&quot;</span>, ...defaults &#125;;</span><br><span class="line"><span class="comment">//那么，defaults里的food属性会重写food: &quot;rich&quot;</span></span><br></pre></td></tr></table></figure>

<p>对象展开还有其它一些意想不到的限制。 首先，它仅包含对象 自身的可枚举属性。 大体上是说当你展开一个对象实例时，你会丢失其方法：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">  p = <span class="number">12</span>;</span><br><span class="line">  <span class="title function_">m</span>(<span class="params"></span>) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> c = <span class="keyword">new</span> <span class="title function_">C</span>();</span><br><span class="line"><span class="keyword">let</span> clone = &#123; ...c &#125;;</span><br><span class="line">clone.<span class="property">p</span>; <span class="comment">// ok</span></span><br><span class="line">clone.<span class="title function_">m</span>(); <span class="comment">// error!</span></span><br></pre></td></tr></table></figure>

<p>其次，TypeScript 编译器不允许展开泛型函数上的类型参数。 这个特性会在 TypeScript 的未来版本中考虑实现。</p>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><h2 id="react-ts"><a href="#react-ts" class="headerlink" title="react+ts"></a>react+ts</h2><p>新建项目使用 typescript<br>如果你是要新建一个使用 typescript 的 react 项目，并且你用脚手架 Create React App 去创建，那没就非常的容易，你只需要在创建的时候将命令改为<br><code>yarn create react-app xxx --template typescript</code></p>
<p>已有 react 项目<br>1、安装 ts<br>npm i typescript -g 全局安装<br>npm i typescript -D 当前项目安装</p>
<p>tsc –init<br>修改 tsconfig 配置文件</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">     <span class="string">&quot;target&quot;</span>: <span class="string">&quot;es5&quot;</span>, <span class="comment">/**指定ECMAScript目标版本**/</span></span><br><span class="line">     <span class="string">&quot;module&quot;</span>: <span class="string">&quot;commonjs&quot;</span>, <span class="comment">/**指定生成哪个模块系统代码**/</span></span><br><span class="line">     <span class="string">&quot;allowJs&quot;</span>: <span class="literal">true</span>,  <span class="comment">/**允许编译js文件**/</span></span><br><span class="line">     <span class="string">&quot;jsx&quot;</span>: <span class="string">&quot;preserve&quot;</span>,  <span class="comment">/**支持JSX**/</span></span><br><span class="line">     <span class="string">&quot;outDir&quot;</span>: <span class="string">&quot;build&quot;</span>,  <span class="comment">/**编译输出目录**/</span></span><br><span class="line">     <span class="string">&quot;strict&quot;</span>: <span class="literal">true</span>, <span class="comment">/**启用所有严格类型检查选项**/</span></span><br><span class="line">     <span class="string">&quot;noImplicitAny&quot;</span>: <span class="literal">false</span>, <span class="comment">/**在表达式和声明上有隐含的any类型时报错**/</span></span><br><span class="line">     <span class="string">&quot;skipLibCheck&quot;</span>: <span class="literal">true</span>,  <span class="comment">/**忽略所有的声明文件的类型检查**/</span></span><br><span class="line">     <span class="string">&quot;forceConsistentCasingInFileNames&quot;</span>: <span class="literal">true</span>   <span class="comment">/**禁止对同一个文件的不一致的引用**/</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;include&quot;</span>: [<span class="string">&quot;src&quot;</span>] <span class="comment">/**指定编译目录**/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>安装 react 的声明文件<br><code>npm install --save typescript @types/node @types/react @types/react-dom @types/jest</code></p>
<h2 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h2><ul>
<li><p>Cannot use JSX unless the ‘–jsx’ flag is provided 报错或 React‘ refers to a UMD global 或者 Cannot use JSX unless the ‘–jsx‘ flag is provided.<br>在 tsconfig.json 中加入：<br>“jsx”: “react-jsx”,</p>
</li>
<li><p>Cannot find module ‘./index.module.less’ or its corresponding type declarations</p>
</li>
</ul>
<p>给ts的CSS文件加上类型的声明<br>*.d.ts文件：ts专用的类型声明文件，只包含类型的声明，不包含逻辑，不会被编译，也不会被webpack打包</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="variable language_">module</span> <span class="string">&quot;*.css&quot;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="attr">css</span>: &#123;[<span class="attr">key</span>: <span class="built_in">string</span>]: <span class="built_in">string</span>&#125;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> css</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">declare</span> <span class="variable language_">module</span> <span class="string">&#x27;*.scss&#x27;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="attr">content</span>: &#123; [<span class="attr">className</span>: <span class="built_in">string</span>]: <span class="built_in">string</span>&#125;;</span><br><span class="line">  <span class="keyword">export</span> = content;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><code>“AsyncThunkAction&lt;any，void，&#123;&#125;&gt;”</code>类型的参数不能分配给“AnyAction”类型的参数</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// app/store.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; configureStore &#125; <span class="keyword">from</span> <span class="string">&#x27;@reduxjs/toolkit&#x27;</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> store = <span class="title function_">configureStore</span>(&#123;</span><br><span class="line">  <span class="attr">reducer</span>: &#123;</span><br><span class="line">    <span class="attr">posts</span>: postsReducer,</span><br><span class="line">    <span class="attr">comments</span>: commentsReducer,</span><br><span class="line">    <span class="attr">users</span>: usersReducer,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Infer the `RootState` and `AppDispatch` types from the store itself</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> <span class="title class_">RootState</span> = <span class="title class_">ReturnType</span>&lt;<span class="keyword">typeof</span> store.<span class="property">getState</span>&gt;</span><br><span class="line"><span class="comment">// Inferred type: &#123;posts: PostsState, comments: CommentsState, users: UsersState&#125;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> <span class="title class_">AppDispatch</span> = <span class="keyword">typeof</span> store.<span class="property">dispatch</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// app/hooks.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">TypedUseSelectorHook</span>, useDispatch, useSelector &#125; <span class="keyword">from</span> <span class="string">&#x27;react-redux&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">type</span> &#123; <span class="title class_">RootState</span>, <span class="title class_">AppDispatch</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./store&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Use throughout your app instead of plain `useDispatch` and `useSelector`</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">useAppDispatch</span> = (<span class="params"></span>) =&gt; useDispatch&lt;<span class="title class_">AppDispatch</span>&gt;()</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="attr">useAppSelector</span>: <span class="title class_">TypedUseSelectorHook</span>&lt;<span class="title class_">RootState</span>&gt; = useSelector</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.baidu.com/2022/01/12/20-11-33/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="KK">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KK">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/12/20-11-33/" class="post-title-link" itemprop="url">全栈项目</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-01-12 20:11:33" itemprop="dateCreated datePublished" datetime="2022-01-12T20:11:33+08:00">2022-01-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-05-16 23:50:36" itemprop="dateModified" datetime="2023-05-16T23:50:36+08:00">2023-05-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/web/" itemprop="url" rel="index"><span itemprop="name">web</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="全栈"><a href="#全栈" class="headerlink" title="全栈"></a>全栈</h1><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><h3 id="创建前端项目"><a href="#创建前端项目" class="headerlink" title="创建前端项目"></a>创建前端项目</h3><h4 id="vue"><a href="#vue" class="headerlink" title="vue"></a>vue</h4><h5 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h5><p><code>vue create 项目名称</code></p>
<h5 id="使用-Vue-Styleguidist-编写组件文档"><a href="#使用-Vue-Styleguidist-编写组件文档" class="headerlink" title="使用 Vue Styleguidist 编写组件文档"></a>使用 Vue Styleguidist 编写组件文档</h5><p><a target="_blank" rel="noopener" href="https://vue-styleguidist.github.io/">Vue Styleguidist官网</a></p>
<p>首先，Vue Styleguidist 只能适用于 Webpack 打包的项目，在此基础上，我们需要安装 vue-styleguidist 这个包</p>
<p><code>npm install vue-styleguidist --save-dev</code><br>然后在 package.json 配置下面两行命令，分别用于开发预览和部署打包</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;styleguide&quot;: &quot;vue-styleguidist server&quot;,</span><br><span class="line">    &quot;styleguide:build&quot;: &quot;vue-styleguidist build&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果是使用 @vue/cli 3 生成的项目，可以直接使用 <code>vue-cli-plugin-styleguidist</code> 这个插件进行更快捷的安装和配置</p>
<ul>
<li><p>Props<br>Props 是组件最基本的 API，用于为组件传递数据,实际上，在配置好 Vue Styleguidist 之后，如果有写 prop，就已经能生成一个这样的文档</p>
</li>
<li><p>Events<br>除了 Props，Event 事件也是 Vue 的一个重要的 API 之一，可以通过 v-on 为组件绑定事件。Vue 的事件使用 vm.$(‘event’, …params) 的方法进行定义，我们只需要在这个方法之前，加上必要的注释就可以了。如果事件名不是字符串，可以使用 @event 进行标注，事件的参数使用 @type 进行标注</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">methods: &#123;</span><br><span class="line">  handleClick(e) &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 单击事件</span><br><span class="line">     * @type &#123;Event&#125;</span><br><span class="line">     */</span><br><span class="line">    this.$emit(&#x27;click&#x27;, e);</span><br><span class="line">  &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>Slots<br>Slot 插槽是 Vue 的自定义元素之一，Slot 向一个组件传递内容，也是封装公共组件常见的 API 之一,与 Props 和 Events 不同的是，Slots 通常是定义在<code>&lt;template&gt;</code>部分，不能使用 JS 注释进行标注，需要使用 HTML 注释，并且在注释里使用 @slot 进行标注</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  &lt;button</span><br><span class="line">class=&quot;btn&quot;</span><br><span class="line">:type=&quot;htmlType&quot;</span><br><span class="line">:class=&quot;btnClass&quot;</span><br><span class="line">:disabled=&quot;disabled&quot;</span><br><span class="line">@click=&quot;handleClick&quot;</span><br><span class="line">  &gt;</span><br><span class="line">&lt;!-- @slot 按钮的内容 --&gt;</span><br><span class="line">&lt;slot /&gt;</span><br><span class="line">&lt;/button&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>Methods<br>看到这里可能各位会有个疑问，Methods 和 Events 有什么区别？区别主要有以下两个：定义方式不同：Methods 只要在 methods 里定义函数即可，Events 则需要使用 <code>vm.$(&#39;event&#39;, ...params)</code> 进行定义,调用方式不同：Methods 使用<code>vm.$refs.ref.method()</code>这样的方式进行调用，Events 使用 v-on 指令或者 <code>vm.$on(&#39;event&#39;)</code> 进行监听。实际上，使用 Methods 方法封装组件 API 的情况是比较少的，但是依然不能排除这种情况。对于 Methods 方法，我们只需要像使用 JSDoc 一样为函数进行注释就可以了，最后再附上 @public 进行标识</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">methods: &#123;</span><br><span class="line">  /**</span><br><span class="line">   * 单击事件</span><br><span class="line">   * @param &#123;Event&#125; e</span><br><span class="line">   * @public</span><br><span class="line">   */</span><br><span class="line">  click(e) &#123;</span><br><span class="line">    // some code</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;,&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>组件样例<br>README 方式,在组件的同个目录下，新建一个文件 <code>README.md</code>，比如 <code>src/components/AppButton/README.md</code>然后直接调用组件代码<br>可以直接在组件下方增加一个组件 <code>&lt;docs&gt;&lt;/docs&gt;</code>，并在里面直接使用 Markdown 编写样例，这种方式适用于项目结构比较简单的项目，但是我认为会使组件的代码变得很冗长，在此不再赘述</p>
</li>
<li><p>配置<br>Vue Styleguidist 支持自定义配置，只需要在项目根目录下，创建 styleguide.config.js，就可以参照官方文档进行配置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// styleguide.config.js</span><br><span class="line">module.exports = &#123;</span><br><span class="line">title: &#x27;Default Style Guide&#x27;,          // 文档的标题</span><br><span class="line">components: &#x27;src/components/**/*.vue&#x27;, // 组件的目录</span><br><span class="line">defaultExample: false,                 // 是否使用默认样例</span><br><span class="line">usageMode: &#x27;expand&#x27;,                   // 是否展开用法</span><br><span class="line">exampleMode: &#x27;expand&#x27;,                 // 是否展开示例代码</span><br><span class="line">styleguideDir: &#x27;styleguide&#x27;,           // 打包的目录</span><br><span class="line">codeSplit: true,                       // 打包时是否进行分片</span><br><span class="line">skipComponentsWithoutExample: true,    // 是否跳过没有样例的组件</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>注意<br>JSDoc 的标签仍然有效。TypeScript、Flow 和 Class 组件同样可以使用，只是使用方法稍有不同。JSX 也可以使用。实际上 Vue Styleguidist 来源于 React Styleguidist（也依赖于这个项目），使用方法大同小异，不同于 Vue 组件的是，React 组件的 API 只有 Props 一项</p>
</li>
</ul>
<h4 id="react"><a href="#react" class="headerlink" title="react"></a>react</h4><h5 id="安装脚手架"><a href="#安装脚手架" class="headerlink" title="安装脚手架"></a>安装脚手架</h5><p><code>npm i create-react-app -g</code></p>
<h5 id="创建文件夹并初始化"><a href="#创建文件夹并初始化" class="headerlink" title="创建文件夹并初始化"></a>创建文件夹并初始化</h5><p><code>create-react-app test_project</code><br><code>cd test_project</code><br><code>npm run start</code></p>
<h5 id="安装路由"><a href="#安装路由" class="headerlink" title="安装路由"></a>安装路由</h5><p><code>npm i react-router-dom</code><br>创建 router/index.js 文件,写入路由表</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">import React from &quot;react&quot;;</span><br><span class="line">import &#123; lazy, Suspense,  &#125; from &quot;react&quot;;</span><br><span class="line">import &#123; Navigate &#125; from &quot;react-router-dom&quot;;</span><br><span class="line">import LoadingPage from &quot;../pages/LoadingPage&quot;;</span><br><span class="line">const Home = lazy(() =&gt; import(&quot;../pages/Home&quot;));</span><br><span class="line">const ErrorBlock = lazy(() =&gt; import(&quot;../pages/ErrorBlock&quot;));</span><br><span class="line">let route = [</span><br><span class="line">	&#123;</span><br><span class="line">		path: &quot;/Home&quot;,</span><br><span class="line">		element: (</span><br><span class="line">			&lt;Suspense fallback=&#123;&lt;LoadingPage /&gt;&#125;&gt;</span><br><span class="line">				&lt;Home /&gt;</span><br><span class="line">			&lt;/Suspense&gt;</span><br><span class="line">		),</span><br><span class="line">	&#125;,</span><br><span class="line">	&#123;</span><br><span class="line">		path: &quot;/ErrorBlock&quot;,</span><br><span class="line">		element: (</span><br><span class="line">			&lt;Suspense fallback=&#123;&lt;LoadingPage /&gt;&#125;&gt;</span><br><span class="line">				&lt;ErrorBlock /&gt;</span><br><span class="line">			&lt;/Suspense&gt;</span><br><span class="line">		),</span><br><span class="line">	&#125;,</span><br><span class="line">	&#123;</span><br><span class="line">		path: &quot;/&quot;,</span><br><span class="line">		element: &lt;Navigate to=&quot;/Home&quot;&gt;&lt;/Navigate&gt;,</span><br><span class="line">	&#125;,</span><br><span class="line">];</span><br><span class="line">export default route;</span><br></pre></td></tr></table></figure>

<p>入口文件 index.js 中加入</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import &#123;BrowserRouter&#125; from &#x27;react-router-dom&#x27;</span><br><span class="line">&lt;BrowserRouter&gt;</span><br><span class="line">&lt;App/&gt;</span><br><span class="line">&lt;/BrowserRouter&gt;</span><br></pre></td></tr></table></figure>

<pre><code>App.js 中引入路由表
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import &#x27;./App.scss&#x27;;</span><br><span class="line">import route from &#x27;./route/&#x27;</span><br><span class="line">import &#123; useRoutes &#125; from &#x27;react-router-dom&#x27;</span><br><span class="line">function App() &#123;</span><br><span class="line">const element = useRoutes(route)</span><br><span class="line">return (</span><br><span class="line">&lt;div className=&quot;App&quot;&gt;</span><br><span class="line">&#123;element&#125;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line">export default App;</span><br></pre></td></tr></table></figure>

<h5 id="安装-redux"><a href="#安装-redux" class="headerlink" title="安装 redux"></a>安装 redux</h5><p><code>npm i redux react-redux</code><br>新建 store/index.js、store/actions/test/index.js、store/reducers/test/index.js,<br>在 store/index.js 中写入</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import &#123;createStore&#125; from &#x27;redux&#x27;</span><br><span class="line">import test from &#x27;./reducers/test/index.js&#x27;</span><br><span class="line">export default createStore(test)</span><br></pre></td></tr></table></figure>

<p>在 store/actions/test/index.js 中写入</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import store from &#x27;../../index.js&#x27;</span><br><span class="line">export const test1=(data)=&gt;&#123;</span><br><span class="line">return store.dispatch( &#123;type:&#x27;test1&#x27;,data&#125; )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 store/reducers/test/index.js 中写入</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const initState=&#123;&#125;</span><br><span class="line">export default function userInfo(preState=initState,action)&#123;</span><br><span class="line">const &#123;type,data&#125;=action</span><br><span class="line">console.log(&#x27;xxxinfo&#x27;,preState,action)</span><br><span class="line">return preState</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 入口文件 src/index.js 中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import &#123; BrowserRouter &#125; from &#x27;react-router-dom&#x27;;</span><br><span class="line">import &#123; Provider &#125; from &#x27;react-redux&#x27;;</span><br><span class="line">import store from &#x27;./store&#x27;</span><br><span class="line">const root = ReactDOM.createRoot(document.getElementById(&#x27;root&#x27;));</span><br><span class="line">root.render(</span><br><span class="line">&lt;React.StrictMode&gt;</span><br><span class="line">&lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">&lt;BrowserRouter&gt;</span><br><span class="line">&lt;App /&gt;&lt;/BrowserRouter&gt;</span><br><span class="line">&lt;/Provider&gt;</span><br><span class="line">&lt;/React.StrictMode&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h5 id="设置代理"><a href="#设置代理" class="headerlink" title="设置代理"></a>设置代理</h5><p>在 src 中创建 setupProxy.js,在 react18 中使用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">const proxy = require(&quot;http-proxy-middleware&quot;).createProxyMiddleware;</span><br><span class="line">module.exports = function (app) &#123;</span><br><span class="line">app.use(</span><br><span class="line">proxy(&quot;/apis&quot;, &#123;</span><br><span class="line">target: &quot;http://xxx:xxx&quot;,</span><br><span class="line">changeOrigin: true, //控制服务器收到的响应头中的 Host 字段值</span><br><span class="line">//apis 前缀置空</span><br><span class="line">pathRewrite: &#123; &quot;^/apis&quot;: &quot;&quot; &#125;,</span><br><span class="line">&#125;),</span><br><span class="line">proxy(&quot;/api2&quot;, &#123;</span><br><span class="line">target: &quot;http://xxx:xxx&quot;,</span><br><span class="line">changeOrigin: true, //控制服务器收到的响应头中的 Host 字段值,true 时为代理服务 ip,false 为当前 ip，默认为 false</span><br><span class="line">pathRewrite: &#123; &quot;^/api2&quot;: &quot;&quot; &#125;,</span><br><span class="line">&#125;)</span><br><span class="line">);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="使用-sass"><a href="#使用-sass" class="headerlink" title="使用 sass"></a>使用 sass</h5><p>安装：<code>npm install node-sass --save</code></p>
<h5 id="修改本地调试启动端口"><a href="#修改本地调试启动端口" class="headerlink" title="修改本地调试启动端口"></a>修改本地调试启动端口</h5><ol>
<li> 依次打开“node_modules”- “react-scripts”-“scripts”文件夹，找到并打开 start.js 文件；在 start.js 文件中查找并修改“DEFAULT_PORT”项的值即可</li>
<li> 修改 package.json 文件中</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">&quot;start&quot;: &quot;set PORT=9000 &amp;&amp; react-scripts start&quot;,</span><br><span class="line">&quot;build&quot;: &quot;react-scripts build&quot;,</span><br><span class="line">&quot;test&quot;: &quot;react-scripts test --env=jsdom&quot;,</span><br><span class="line">&quot;eject&quot;: &quot;react-scripts eject&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="修改-elint-语法检测"><a href="#修改-elint-语法检测" class="headerlink" title="修改 elint 语法检测"></a>修改 elint 语法检测</h5><p>修改 package.json 文件中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&quot;eslintConfig&quot;: &#123;</span><br><span class="line">&quot;extends&quot;: [</span><br><span class="line">&quot;react-app&quot;,</span><br><span class="line">&quot;react-app/jest&quot;</span><br><span class="line">],</span><br><span class="line">&quot;rules&quot;: &#123;</span><br><span class="line">&quot;no-unused-vars&quot;: &quot;off&quot;,</span><br><span class="line">&quot;no-undef&quot;: &quot;off&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="安装-antd"><a href="#安装-antd" class="headerlink" title="安装 antd"></a>安装 antd</h5><p><code>npm i antd --save</code><br>/src/index.js 入口文件中引入样式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &#x27;antd/dist/antd.min.css&#x27;;</span><br></pre></td></tr></table></figure>

<h3 id="创建后端项目"><a href="#创建后端项目" class="headerlink" title="创建后端项目"></a>创建后端项目</h3><p><code>npm install express-generator -g</code><br><code>express --view=ejs 项目名称</code></p>
<ul>
<li>启动项目</li>
</ul>
<p>`<a target="_blank" rel="noopener" href="http://dd/">http://dd</a></p>
<h4 id="node-实例"><a href="#node-实例" class="headerlink" title="node 实例"></a>node 实例</h4><p><strong>使用 nodejs 将 base64 文件转成图片和将图片转成 base64</strong></p>
<ul>
<li>将 base64 转成 png 图片格式</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">const fs = require(&#x27;fs&#x27;);</span><br><span class="line">const path = &#x27;你想要填写的路径/&#x27;+ Date.now() +&#x27;.png&#x27;;</span><br><span class="line">const base64 = data.replace(/^data:image\/\w+;base64,/, &quot;&quot;);//去掉图片base64码前面部分data:image/png;base64</span><br><span class="line">const dataBuffer = new Buffer(base64, &#x27;base64&#x27;); //把base64码转成buffer对象，</span><br><span class="line">fs.writeFile(path, dataBuffer, function(err)&#123;//用fs写入文件</span><br><span class="line">    if(err)&#123;</span><br><span class="line">        console.log(err);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        console.log(&#x27;写入成功！&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>将图片转成 base64</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">const fs = require(&quot;fs&quot;);</span><br><span class="line">const util = require(&quot;util&quot;);</span><br><span class="line">const imageData = await util.promisify(fs.readFileSync(fileUrl)); // 例：xxx/xx/xx.png</span><br><span class="line">const imageBase64 = imageData.toString(&quot;base64&quot;);</span><br><span class="line">const imagePrefix = &quot;data:image/png;base64,&quot;;</span><br><span class="line">console.log(imagePrefix + imageBase64);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h3><ul>
<li>引入 antd 样式</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Failed to parse source map: &#x27;webpack://antd/./components/icon/style/index.less&#x27; URL is not supported</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>解决方法: antd-mobile 导入组件样式时加这个 min<br><code>import &#39;antd/dist/antd.min.css&#39;; </code></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.baidu.com/2022/01/10/20-22-22/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="KK">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KK">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/10/20-22-22/" class="post-title-link" itemprop="url">Centos7安装</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-01-10 20:22:22" itemprop="dateCreated datePublished" datetime="2022-01-10T20:22:22+08:00">2022-01-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-05-16 23:50:36" itemprop="dateModified" datetime="2023-05-16T23:50:36+08:00">2023-05-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="could-not-retrieve-mirrorlist解决"><a href="#could-not-retrieve-mirrorlist解决" class="headerlink" title="could not retrieve mirrorlist解决"></a>could not retrieve mirrorlist解决</h3><p>在执行yum指令的时候出现这个问题,先尝试一下ping指令:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ping 127.0.0.1</span><br><span class="line">ping www.baidu.com</span><br></pre></td></tr></table></figure>

<p>如果第一个正常,第二个错误,那就可能是你没有IP或者你没有启用联网功能;<br>没有IP就查查怎么配静态或者动态IP;<br><code>sudo vi /etc/sysconfig/network-scripts/ifcfg-ens33</code><br>修改配置<code>ONBOOT=no</code>—–&gt;<code>ONBOOT=yes</code><br>wq保存退出<br><code>service network restart</code>重启网络服务</p>
<p>如果你能ping通百度,还是报这个问题,这个就可能是你的DNS解析不了你的请求,修改DNS啊</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/resolv.conf</span><br><span class="line">nameserver 改成 8.8.8.8</span><br></pre></td></tr></table></figure>
<h3 id="启用ifconfig-命令"><a href="#启用ifconfig-命令" class="headerlink" title="启用ifconfig 命令"></a>启用ifconfig 命令</h3><p>依赖于 net-tools 软件</p>
<p><code> yum install -y net-tools</code></p>
<p>CentOS7最小化安装后没有wget软件，但是以后我们会经常用到这个组件，所以我们安装一下</p>
<p><code>yum install -y wget</code></p>
<h3 id="CentOS自带的国外源有时候会很慢，替换成国内的阿里源"><a href="#CentOS自带的国外源有时候会很慢，替换成国内的阿里源" class="headerlink" title="CentOS自带的国外源有时候会很慢，替换成国内的阿里源"></a>CentOS自带的国外源有时候会很慢，替换成国内的阿里源</h3><p>先进入源的目录<br><code>cd /etc/yum.repos.d </code><br>备份一下官方源<br><code>mv CentOS-Base.repo CentOS-Base.repo.bak </code><br>将阿里源文件下载下来<br><code>wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo </code><br>重建源数据缓存<br><code>yum clean all</code>     # 清除系统所有的yum缓存<br><code>yum makecache </code># 生成yum缓存<br>ok,换源完成</p>
<h3 id="在某些特定的情况下，执行-configure的时候会报错："><a href="#在某些特定的情况下，执行-configure的时候会报错：" class="headerlink" title="在某些特定的情况下，执行./configure的时候会报错："></a>在某些特定的情况下，执行./configure的时候会报错：</h3><p>error:newly created file is older than distributed files!<br>这是由于configure文件时间大于当前系统时间。</p>
<p>解决方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">方法一：</span><br><span class="line">cp configure configure_bak</span><br><span class="line">rm -f configure</span><br><span class="line">cp configure_bak configure</span><br><span class="line"></span><br><span class="line">方法二：修改当前系统时间</span><br><span class="line">hwclock --set --date=&quot;月/日/年 小时：分钟：秒钟&quot;</span><br><span class="line">hwclock --hctosys</span><br></pre></td></tr></table></figure>


<h3 id="一、正常的编译安装-卸载"><a href="#一、正常的编译安装-卸载" class="headerlink" title="一、正常的编译安装/卸载"></a>一、正常的编译安装/卸载</h3><p>源码的安装一般由3个步骤组成：配置(configure)、编译(make)、安装(make install)。<br>configure文件是一个可执行的脚本文件，它有很多选项，在待安装的源码目录下使用命令<code>./configure –help</code>可以输出详细的选项列表。</p>
<p>其中<code>--prefix</code>选项是配置安装目录，如果不配置该选项，安装后可执行文件默认放在<code>/usr/local/bin</code>，库文件默认放在<code>/usr/local/lib</code>，</p>
<p>配置文件默认放在<code>/usr/local/etc</code>，其它的资源文件放在<code>/usr/local/share</code>，比较凌乱。</p>
<p>如果配置了<code>--prefix</code>，如：</p>
<p><code>./configure --prefix=/usr/local/test</code><br>安装后的所有资源文件都会被放在<code>/usr/local/test</code>目录中，不会分散到其他目录。</p>
<p>使用<code>--prefix</code>选项的另一个好处是方便卸载软件或移植软件</p>
<p>当某个安装的软件不再需要时，只须简单的删除该安装目录，就可以把软件卸载干净；<br>移植软件只需拷贝整个目录到另外一个机器即可（相同的操作系统下）<br>当然要卸载程序，也可以在原来的<code>make</code>目录下用一次<code>make uninstall</code>，但前提是<code>Makefile</code>文件有<code>uninstall</code>命令。</p>
<h3 id="二、关于卸载"><a href="#二、关于卸载" class="headerlink" title="二、关于卸载"></a>二、关于卸载</h3><p>如果没有配置<code>--prefix</code>选项，源码包也没有提供<code>make uninstall</code>，则可以通过以下方式可以完整卸载：</p>
<p>一个临时目录重新安装一遍，如：</p>
<p>  <code>./configure --prefix=/tmp/to_remove &amp;&amp; make install</code><br>然后遍历<code>/tmp/to_remove</code>的文件，如vim的<code>/bin/vimdiff =&gt;find /usr/ -name vimdiff</code></p>
<p>删除对应安装位置的文件即可（因为<code>/tmp/to_remove</code>里的目录结构就是没有配置<code>--prefix</code>选项时的目录结构）。</p>
<h3 id="安装桌面"><a href="#安装桌面" class="headerlink" title="安装桌面"></a>安装桌面</h3><ol>
<li>yum 的 group 指令</li>
</ol>
<p>yum 可以以程序组的模式来安装成套的软件包。支持的软件包可以通过，对于 CentOS 6，Desktop、Desktop Platform、KDE Desktop、X Window System 是主要的桌面环境。对于 CentOS 7，有 KDE Plasma Workspaces 和 Gnome Desktop 两大桌面环境。</p>
<ol start="2">
<li>安装图形桌面环境</li>
</ol>
<p>CENTOS 7<br>CentOS 7 上的桌面环境安装包组合进行了调整，比以前要简单了。主要有两大阵营，KDE 和 GNOME。</p>
<p>因为没时间测试，只是预估着下面的指令应该能完成任务，请注意！</p>
<p>要安装 KDE 桌面环境（使用的是 Plasma 作为默认的桌面管理器了，很漂亮，看这里），</p>
<p>复制代码代码如下:<br><code># yum groupinstall &quot;KDE Plasma Workspaces&quot;</code></p>
<p>要安装 GNOME 环境，</p>
<p>复制代码代码如下:<br><code># yum groupinstall &quot;GNOME Desktop&quot;</code></p>
<p>安装程序会自动解决安装包和组件的依赖关系。</p>
<p>CENTOS 6<br>要安装 KDE 桌面环境，执行指令，</p>
<p>复制代码代码如下:<br><code># yum groupinstall &quot;X Window System&quot; &quot;KDE Desktop&quot; Desktop</code></p>
<p>即可，同时安装了 3 个软件包。注意，因为 KDE Desktop 和  X Window System 两个软件包名称中间都包含空格，需要用引号引起来才行。</p>
<p>要安装 Gnome 桌面环境，执行指令，</p>
<p>复制代码代码如下:<br><code># yum groupinstall &quot;X Window System&quot; &quot;Desktop Platform&quot; Desktop</code></p>
<p>即可，也是同时安装了 3 个软件包，其中 X Window System 是必须的，不管是 Gnome 还是 KDE。</p>
<p>既然是桌面环境，可能还需要诸如字体、管理工具之类的，如，</p>
<p>复制代码代码如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># yum -y groupinstall &quot;Graphical Administration Tools&quot;</span><br><span class="line"># yum -y groupinstall &quot;Internet Browser&quot;</span><br><span class="line"># yum -y groupinstall &quot;General Purpose Desktop&quot;</span><br><span class="line"># yum -y groupinstall &quot;Office Suite and Productivity&quot;</span><br><span class="line"># yum -y groupinstall &quot;Graphics Creation Tools&quot;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>启用</li>
</ol>
<p>从命令行直接启动图形桌面环境，</p>
<p><code># startx</code><br>这样就会启动默认的 Gnome 或者 KDE 桌面环境。如果有人喜欢同时安装 GNOME 和 KDE，切换方法可以参考 CentOS 文档。</p>
<p>如果希望启动时自动启动到图形桌面，需要修改启动配置。因为 CentOS 7 开始使用 systemd 管理器，其操作方式与之前版本有所不同。</p>
<p>CENTOS 7：<br>CentOS 7 中直接使用 systemd 指令修改启动目的状态即可。</p>
<p>使用，</p>
<p>复制代码代码如下:<br><code># systemctl get-default</code></p>
<p>可以查询到当前所设定的状态。multi-user.target 相当于以前的 level 3，也就是命令行终端；而 graphical.target 相当于以前的 level 5，也就是图形界面。</p>
<p>所以如果要设置默认启动到图形界面，则执行，</p>
<p>复制代码代码如下:<br><code># systemctl set-default graphical.target </code></p>
<p>CENTOS 6 等：<br>编辑 /etc/inittab，将 id:3:initdefault: 改为 id:5:initdefault:。（请注意这里的英文半角冒号。）参考这里。</p>
<p>直接用 sed 会很方便，</p>
<p>复制代码代码如下:<br><code>sed -i &#39;s/id:3:initdefault:/id:5:initdefault:/&#39; /etc/inittab</code></p>
<p>启动图形界面后，如果希望从图形界面切换到命令行界面，可以用 Ctrl + Alt + F6（实际上 F1 到 F6 都行，不过它们代表 Linux 中不同的控制台），或者反过来 Ctrl + Alt + F7 回到刚才的图形界面。</p>
<p>4.开机跳过图形化界面</p>
<p>复制代码代码如下:<br><code>#vi /etc/inittab--编辑/etc/inittab文件</code></p>
<p>找到下面语句：</p>
<p>复制代码代码如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># Default runlevel. The runlevels used by RHS are:</span><br><span class="line"># 0 - halt (Do NOT set initdefault to this)--停机</span><br><span class="line"># 1 - Single user mode --单用户模式</span><br><span class="line"># 2 - Multiuser, without NFS (The same as 3, if you do not havenetworking) --多用户模式，不支持NFS</span><br><span class="line"># 3 - Full multiuser mode--多用户模式</span><br><span class="line"># 4 - unused--没有使用</span><br><span class="line"># 5 - X11--图形界面方式</span><br><span class="line"># 6 - reboot (Do NOT set initdefault to this)--重新启动</span><br><span class="line">#</span><br><span class="line">id:5:initdefault:--默认运行等级是5，只要将此处改成 id:3:initdefault:即可</span><br></pre></td></tr></table></figure>
<p>在文本模式想启动图形界面，可以打如下命令：</p>
<p>复制代码代码如下:<br><code>#startx</code></p>
<h2 id="CentOS离线状态下安装Python3-7-0"><a href="#CentOS离线状态下安装Python3-7-0" class="headerlink" title="CentOS离线状态下安装Python3.7.0"></a>CentOS离线状态下安装Python3.7.0</h2><ul>
<li><p>python安装包：Python-3.7.0</p>
</li>
<li><p>依赖安装包<br>zlib-devel　　　　　krb5-devel     　　　　ibselinux-devel<br>bzip2-devel　　　　openssl-devel　　　　ncurses-devel 　　　<br>sqlite-devel   　　　 readline-devel　　　  tk-devel<br>gdbm-devel     　　  db4-devel　　　　　   libpcap-devel 　　　　xz-devel     </p>
</li>
<li><p>解压python安装包: tar -xvJf  Python-3.7.0.tar.xz</p>
</li>
<li><p>编译安装</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir /usr/local/python3 # 创建编译安装目录</span><br><span class="line">cd Python-3.7.0　　　　　　# 进入python的解压目录</span><br><span class="line">./configure --prefix=/usr/local/python3</span><br><span class="line">make &amp;&amp; make install　　　# 编译$安装</span><br></pre></td></tr></table></figure></li>
<li><p>创建软连接</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ln -s /usr/local/python3/bin/python3 /usr/local/bin/python3</span><br><span class="line">ln -s /usr/local/python3/bin/pip3 /usr/local/bin/pip3</span><br></pre></td></tr></table></figure>

<ul>
<li>验证是否安装成功<br>python3 -V<br>pip3 -V</li>
</ul>
<h2 id="CentOS7离线安装Nginx"><a href="#CentOS7离线安装Nginx" class="headerlink" title="CentOS7离线安装Nginx"></a>CentOS7离线安装Nginx</h2><ul>
<li>准备准备离线安装包</li>
</ul>
<p>openssl</p>
<p>zlib</p>
<p>pcre</p>
<p>nginx</p>
<ul>
<li><p>rpm -ivh *.rpm –nodeps –force</p>
</li>
<li><p>安装nginx</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">下载解压</span><br><span class="line"></span><br><span class="line">tar -xzvf  nginx-1.8.1.tar.gz</span><br><span class="line"></span><br><span class="line">cd  nginx-1.8.1</span><br><span class="line"></span><br><span class="line">./configure --prefix=/home/work/nginx</span><br><span class="line"></span><br><span class="line">编译并安装</span><br><span class="line"></span><br><span class="line">make &amp;&amp; make install</span><br><span class="line"></span><br><span class="line">运行nginx</span><br><span class="line">cd //home/work/nginx/sbin</span><br><span class="line">./nginx</span><br></pre></td></tr></table></figure>

<ul>
<li>防火墙<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@rhel7 ~]# systemctl status firewalld.service</span><br><span class="line">[root@rhel7 ~]# systemctl stop firewalld.service</span><br><span class="line">[root@rhel7 ~]# systemctl disable firewalld.service</span><br><span class="line">[root@rhel7 ~]# systemctl status firewalld.service</span><br></pre></td></tr></table></figure></li>
<li>Nginx相关命令</li>
</ul>
<p>4.1 版本查看</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@nginx ~]# nginx  -v</span><br><span class="line">nginx version: nginx/1.12.2</span><br></pre></td></tr></table></figure>
<p>4.2 查看加载的模块</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@nginx ~]# nginx -V</span><br><span class="line">nginx version: nginx/1.12.2</span><br><span class="line">built by gcc 4.8.5 20150623 (Red Hat 4.8.5-28) (GCC) </span><br><span class="line">configure arguments: --add-module=/root/nginx-sticky-1.2.5/</span><br></pre></td></tr></table></figure>
<p>4.3 启停命令</p>
<p>4.3.1 启动</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@nginx nginx-1.12.2]# nginx</span><br></pre></td></tr></table></figure>

<p>4.3.2 停止</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@nginx nginx-1.12.2]# nginx -s stop</span><br><span class="line">[root@nginx nginx-1.12.2]# nginx -s quit</span><br></pre></td></tr></table></figure>

<p>4.3.3 动态加载</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@nginx nginx-1.12.2]# ngins -s reload</span><br></pre></td></tr></table></figure>

<p>4.3.4 测试配置文件nginx.conf正确性</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@nginx ~]# nginx  -t</span><br><span class="line">nginx: the configuration file /usr/local/nginx/conf/nginx.conf syntax is ok</span><br><span class="line">nginx: configuration file /usr/local/nginx/conf/nginx.conf test is successful</span><br></pre></td></tr></table></figure>

<p><code>nginx -s stop</code>:此方式相当于先查出nginx进程id再使用kill命令强制杀掉进程。</p>
<p><code>nginx -s reload</code>:动态加载，当配置文件nginx.conf有变化时执行该命令动态加载。</p>
<p>4.4 开机自启动</p>
<p>编辑/etc/rc.d/rc.local文件，新增一行/usr/local/nginx/sbin/nginx</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@nginx rc.d]# cd /etc/rc.d</span><br><span class="line">[root@nginx rc.d]# sed -i &#x27;13a /usr/local/nginx/sbin/nginx&#x27; /etc/rc.d/rc.local </span><br><span class="line">[root@nginx rc.d]# chmod u+x rc.local</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.baidu.com/2021/12/01/10-12-33/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="KK">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KK">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/01/10-12-33/" class="post-title-link" itemprop="url">MySql</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-12-01 10:12:33" itemprop="dateCreated datePublished" datetime="2021-12-01T10:12:33+08:00">2021-12-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-05-16 23:50:36" itemprop="dateModified" datetime="2023-05-16T23:50:36+08:00">2023-05-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/database/" itemprop="url" rel="index"><span itemprop="name">database</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="MySql"><a href="#MySql" class="headerlink" title="MySql"></a>MySql</h1><blockquote>
<p>关系型数据库：建立在关系模型上，由多张相互连接的二维表组成的数据库</p>
</blockquote>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ul>
<li>MySQL 官网下载最新版<a target="_blank" rel="noopener" href="https://dev.mysql.com/downloads/installer/">https://dev.mysql.com/downloads/installer/</a></li>
<li>然后在 cmd 里面 cd 到<code>D:\mysql-8.0.11</code>安装目录</li>
<li>在该文件夹下创建 my.ini 配置文件编辑 my.ini 配置以下基本信息</li>
</ul>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[client]</span></span><br><span class="line"><span class="comment"># 设置mysql客户端默认字符集</span></span><br><span class="line"><span class="attr">default-character-set</span>=utf8</span><br><span class="line"></span><br><span class="line"><span class="section">[mysqld]</span></span><br><span class="line"><span class="comment"># 设置3306端口</span></span><br><span class="line"><span class="attr">port</span> = <span class="number">3306</span></span><br><span class="line"><span class="comment"># 设置mysql的安装目录</span></span><br><span class="line"><span class="attr">basedir</span>=C:\\web\\mysql-<span class="number">8.0</span>.<span class="number">11</span></span><br><span class="line"><span class="comment"># 设置 mysql数据库的数据的存放目录MySQL 8+ 不需要以下配置，系统自己生成即可否则有可能报错</span></span><br><span class="line"><span class="comment"># datadir=C:\\web\\sqldata</span></span><br><span class="line"><span class="comment"># 允许最大连接数</span></span><br><span class="line"><span class="attr">max_connections</span>=<span class="number">20</span></span><br><span class="line"><span class="comment"># 服务端使用的字符集默认为8比特编码的latin1字符集</span></span><br><span class="line"><span class="attr">character-set-server</span>=utf8</span><br><span class="line"><span class="comment"># 创建新表时将使用的默认存储引擎</span></span><br><span class="line"><span class="attr">default-storage-engine</span>=INNODB</span><br></pre></td></tr></table></figure>

<blockquote>
<p>MySQL 数据库进行初始化命令操作时提示 my.ini 配置文件错误的解决方法<br>通过修改 MySQL 数据库中 my.ini 配置文件编码格式的方法解决此问题。<br>步骤：用记事本打开 my.ini 文件——》点击“文件”选择“另存为”——》将编码选为 ANSI——》保存覆盖——》重启 MySQL 。</p>
</blockquote>
<ol>
<li>以管理员身份打开 cmd 命令行工具切换目录<code>cd D:\mysql-8.0.11\bin</code></li>
<li>初始化数据库<code>mysqld --initialize --console</code>执行完成后会输出 root 用户的初始默认密码!!!!</li>
<li>安装<code>mysqld install</code></li>
<li>启动输入以下命令<code>net start mysql</code></li>
<li>停止<code>net stop mysql</code></li>
<li>登录 MySQL<code>mysql -u root -p</code></li>
<li>修改初始密码<code>ALTER USER USER() IDENTIFIED BY &#39;123456&#39;;</code></li>
</ol>
<h2 id="mysql-数据类型"><a href="#mysql-数据类型" class="headerlink" title="mysql 数据类型"></a>mysql 数据类型</h2><table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
</tr>
</thead>
<tbody><tr>
<td>整数类型</td>
<td>tinyint\smallint\mediumint\int\bigint</td>
</tr>
<tr>
<td>浮点小数类型</td>
<td>float\double</td>
</tr>
<tr>
<td>定点小数类型</td>
<td>decimal</td>
</tr>
<tr>
<td>时间、日期类型</td>
<td>year\time\date\datetime\timestamp</td>
</tr>
<tr>
<td>文本字符串</td>
<td>char\varchar\tinytext\text\mediumtext\longtext\enum\set</td>
</tr>
<tr>
<td>二进制字符串</td>
<td>bit\binary\varbinary\tinyblob\blog\mediumblob\longblob</td>
</tr>
</tbody></table>
<blockquote>
<p>char(n)和 varchar(n)中括号中 n 代表字符的个数并不代表字节个数比如 CHAR(30)就可以存储 30 个字符。</p>
</blockquote>
<h2 id="sql-语句"><a href="#sql-语句" class="headerlink" title="sql 语句"></a>sql 语句</h2><p>语法:</p>
<ul>
<li>单行或多行书写，已分号结尾</li>
<li>可使用空格缩进</li>
<li>不区分大小写，关键词推荐大写</li>
<li>注释：两横杆加空格<code>-- 注释...</code>或<code>/* ... */</code>或 mysql 特有的<code>#</code></li>
</ul>
<p>分类：</p>
<ul>
<li>DDL（data definition language）数据定义语句，建表、字段、数据库</li>
<li>DML（data manipulation language）数据操作语句，增删改</li>
<li>DQL（data query language）数据查询语句</li>
<li>DCL（data control language）数据控制语句，创建数据库用户，权限访问控制</li>
</ul>
<h2 id="sql-常用语句"><a href="#sql-常用语句" class="headerlink" title="sql 常用语句"></a>sql 常用语句</h2><ul>
<li><p>DDL</p>
<table>
<thead>
<tr>
<th>语句</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>show databases;</td>
<td>显示数据库</td>
</tr>
<tr>
<td>show create database 数据库名;</td>
<td>查看数据库信息</td>
</tr>
<tr>
<td>select databases();</td>
<td>查询当前数据库</td>
</tr>
<tr>
<td>use 数据库名;</td>
<td>选择数据库</td>
</tr>
<tr>
<td>create database [ IF NOT EXISTS] 数据库名 [DEFAULT CHARSET 字符集] [COLLATE 排序规则];</td>
<td>创建数据库</td>
</tr>
<tr>
<td>drop database [ IF EXISTS] 数据库名;</td>
<td>删除数据库</td>
</tr>
<tr>
<td>alter database 库名 选项信息;</td>
<td>修改库信息</td>
</tr>
<tr>
<td>show tables;</td>
<td>查看所有表</td>
</tr>
<tr>
<td>show tables from 数据库名;</td>
<td>查看所有表</td>
</tr>
<tr>
<td>show create table 表名;</td>
<td>查询指定表建表语句</td>
</tr>
<tr>
<td>desc 表名;</td>
<td>表结构</td>
</tr>
<tr>
<td>show 列 from 表名;</td>
<td>获取表的一个列</td>
</tr>
<tr>
<td>create table 表名(字段名 字段类型[COMMENT 注释],….)[COMMENT 注释];</td>
<td>创建表，最后一个字段后面没有逗号</td>
</tr>
<tr>
<td>RENAME TABLE 原表名 TO 新表名</td>
<td>对表进行重命名</td>
</tr>
<tr>
<td>RENAME TABLE 原表名 TO 库名.表名</td>
<td>可将表移动到另一个数据库</td>
</tr>
<tr>
<td>DROP TABLE[ IF EXISTS] 表名</td>
<td>删除表</td>
</tr>
<tr>
<td>TRUNCATE [TABLE] 表名</td>
<td>清空表</td>
</tr>
<tr>
<td>ALTER TABLE 表名 操作名</td>
<td>修改表信息，操作如下</td>
</tr>
<tr>
<td>操作名</td>
<td></td>
</tr>
<tr>
<td><code>ADD[ COLUMN] 字段名</code>– 增加字段;</td>
<td></td>
</tr>
<tr>
<td><code>AFTER 字段名</code>– 表示增加在该字段名后面;</td>
<td></td>
</tr>
<tr>
<td><code>FIRST</code>– 表示增加在第一个;</td>
<td></td>
</tr>
<tr>
<td><code>ADD PRIMARY KEY(字段名)</code>– 创建主键;</td>
<td></td>
</tr>
<tr>
<td><code>ADD UNIQUE [索引名] (字段名)</code>– 创建唯一索引;</td>
<td></td>
</tr>
<tr>
<td><code>ADD INDEX [索引名] (字段名)</code>– 创建普通索引;</td>
<td></td>
</tr>
<tr>
<td><code>DROP[ COLUMN] 字段名</code>– 删除字段;</td>
<td></td>
</tr>
<tr>
<td><code>MODIFY[ COLUMN] 字段名 字段属性</code>– 支持对字段属性进行修改不能修改字段名(所有原有属性也需写上);</td>
<td></td>
</tr>
<tr>
<td><code>CHANGE[ COLUMN] 原字段名 新字段名 字段属性</code>– 支持对字段名修改;</td>
<td></td>
</tr>
<tr>
<td><code>DROP PRIMARY KEY</code>– 删除主键(删除主键前需删除其 AUTO_INCREMENT 属性);</td>
<td></td>
</tr>
<tr>
<td><code>DROP INDEX 索引名</code>– 删除索引;</td>
<td></td>
</tr>
<tr>
<td><code>DROP FOREIGN KEY 外键</code> – 删除外键;</td>
<td></td>
</tr>
</tbody></table>
<p>数据类型</p>
<ul>
<li>整型<table>
<thead>
<tr>
<th>整型</th>
<th>占用字节</th>
<th>范围</th>
<th>范围</th>
</tr>
</thead>
<tbody><tr>
<td>tinyint</td>
<td>1</td>
<td>-2^7^~2^7-1^</td>
<td>-128~127</td>
</tr>
<tr>
<td>smallint</td>
<td>2</td>
<td>-2^15^~2^15-1^</td>
<td>-32768~32767</td>
</tr>
<tr>
<td>mediumint</td>
<td>3</td>
<td>-2^23^~2^23-1^</td>
<td>-8388608~8388607</td>
</tr>
<tr>
<td>int</td>
<td>4</td>
<td>-2^31^~2^31-1^</td>
<td>-2147483648~2147483647</td>
</tr>
<tr>
<td>bigint</td>
<td>8</td>
<td>-2^63^~2^63-1^</td>
<td></td>
</tr>
<tr>
<td>一个字节=8 位</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>无符号数（unsigned）:就是没有负数，无符号数的正数的范围是有符号数正数范围的 2 倍。</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
</li>
<li>浮点数<table>
<thead>
<tr>
<th>浮点数</th>
<th>占用字节</th>
<th>范围</th>
</tr>
</thead>
<tbody><tr>
<td>float(单精度)</td>
<td>4</td>
<td>-3.4E+38~3.4E+38</td>
</tr>
<tr>
<td>double(双精度)</td>
<td>8</td>
<td>-1.8E+308~1.8E+308</td>
</tr>
<tr>
<td>浮点数的声明：float(M,D)，double(M,D)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>M：总位数 D：小数位数</td>
<td></td>
<td></td>
</tr>
<tr>
<td>没有指定小数位数，默认小数位数是 0 位</td>
<td></td>
<td></td>
</tr>
<tr>
<td>MySQL 浮点数支持科学计数法</td>
<td></td>
<td></td>
</tr>
<tr>
<td>浮点数的精度会丢失</td>
<td></td>
<td></td>
</tr>
</tbody></table>
</li>
<li>定点数<br>语法：decimal(M,D)<br>M 的最大值是 65，D 的最大值是 30，默认是(10,0)<br>decimal 是变长的，大致每 9 个数字用 4 个字节存储，整数和小数分开存储。定点数占用的资源可能会比浮点数大很多。</li>
<li>字符型<table>
<thead>
<tr>
<th>数据类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>char(L)</td>
<td>定长字符</td>
</tr>
<tr>
<td>varchar(L)</td>
<td>可变长度字符</td>
</tr>
<tr>
<td>tinytext</td>
<td>大段文本（大块数据） 28-1=255 个字符</td>
</tr>
<tr>
<td>text</td>
<td>大段文本（大块数据） 216-1=65535 个字符</td>
</tr>
<tr>
<td>mediumtext</td>
<td>2^24^-1</td>
</tr>
<tr>
<td>longtext</td>
<td>2^32^-1</td>
</tr>
<tr>
<td>char</td>
<td></td>
</tr>
<tr>
<td>1、 char(L)：MySQL 不回收多余的空间</td>
<td></td>
</tr>
<tr>
<td>2、 L 的最大长度是 255</td>
<td></td>
</tr>
<tr>
<td>varchar</td>
<td></td>
</tr>
<tr>
<td>1、 varchar(L):MySQL 回收多余的空间</td>
<td></td>
</tr>
<tr>
<td>2、 L 的理论最大长度是 65535，但事实上达不到，因为有的字符是多字节字符，比如一个 utf8 的字符占用 3 个字节，65535/3 大约保存 2 万多字符；如果是 gbk,一个字符占两个字节，65535/2 大约保存 3 万多个字符。</td>
<td></td>
</tr>
<tr>
<td>一个记录的所有字段（不包含大数据）的总长度不能超过 65535 个字节</td>
<td></td>
</tr>
</tbody></table>
</li>
<li>枚举（enum）<br>从集合中选择一个值作为数据（单选）,MySQL 管理枚举值是通过整型的数字来管理的，第一个值是 1，第二个值是 2，以此类推。枚举优点<br>1、 限制值<br>2、 节省空间<br>3、 运行速度快（整数比字符串运行速度快）<br>思考题：已知枚举占用 2 个字节，请问最多可以有多个枚举值。<br>答：2 个字节 16 位，可以保存 216 方个值（65536，0-65535），因为枚举值从 1 开始，所以最多可以有 65535 个枚举值</li>
<li>集合（set）<br>从集合中选择一些值作为数据（多选）,集合和枚举一样，在 MySQL 内部也是通过数字来管理的。MySQL 为每个集合元素分配一个固定的值。分配方式从前往后依次是 20,21,22，…。如果有多个选项，值是单个选项的和<br>集合是一个按位或的关系<blockquote>
<p>按位或和按位与</p>
<blockquote>
<p>按位与：所有的位都是 1 结果才是 1<br>按位或：只要有一位是 1 结果就是 1<br>思考题：一直集合占用 8 个字节，可以表示多少个选项？<br>答：8 个字节是 64 个位，可以表示 64 个选项</p>
</blockquote>
</blockquote>
</li>
<li>日期时间型<table>
<thead>
<tr>
<th>数据类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>datetime</td>
<td>日期时间 占 8 个字节</td>
</tr>
<tr>
<td>date</td>
<td>日期 占四个字节</td>
</tr>
<tr>
<td>time</td>
<td>时间</td>
</tr>
<tr>
<td>year</td>
<td>年份，占用 1 个字节</td>
</tr>
<tr>
<td>timestamp</td>
<td>时间戳，占用 4 个字节</td>
</tr>
<tr>
<td>datetime (日期时间)</td>
<td></td>
</tr>
<tr>
<td>格式：年-月-日 小时:分钟:秒</td>
<td></td>
</tr>
<tr>
<td>timestamp （时间戳）</td>
<td></td>
</tr>
<tr>
<td>datetime 和 timestamp 在表现上是一样的，他们的区别在于：Datetime 从 1 到 9999，而 timestamp 从 1970 年到 2038 年（原因是 timestamp 只占用了 4 个字节），2038 年 01 月 19 日 11:14:07 秒后就超过了 4 个字节的长度。</td>
<td></td>
</tr>
<tr>
<td>year</td>
<td></td>
</tr>
<tr>
<td>因为 year 占用 1 个字节，所以只能保存 255 个年份，范围是 1901~2155</td>
<td></td>
</tr>
<tr>
<td>time</td>
<td></td>
</tr>
<tr>
<td>可以表示时间，还可以表示时间间隔，范围是-838:59:59~838:59:59，time 也支持以天的方式表示时间间隔</td>
<td></td>
</tr>
</tbody></table>
</li>
<li>boolean<br>MySQL 不支持 boolean 型，true 和 false 在数据库中对应的是 1 和 0</li>
</ul>
</li>
</ul>
<h3 id="对于字段的定义"><a href="#对于字段的定义" class="headerlink" title="对于字段的定义"></a>对于字段的定义</h3><p>字段名 数据类型 <code>[NOT NULL | NULL] [DEFAULT default_value] [AUTO_INCREMENT] [UNIQUE [KEY] | [PRIMARY] KEY] [COMMENT &#39;string&#39;]</code></p>
<h3 id="表选项"><a href="#表选项" class="headerlink" title="表选项"></a>表选项</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 字符集</span></span><br><span class="line">    CHARSET <span class="operator">=</span> charset_name</span><br><span class="line">    如果表没有设定则使用数据库字符集</span><br><span class="line"><span class="comment">-- 存储引擎</span></span><br><span class="line">    ENGINE <span class="operator">=</span> engine_name</span><br><span class="line">    表在管理数据时采用的不同的数据结构结构不同会导致处理方式、提供的特性操作等不同</span><br><span class="line">    常见的引擎InnoDB MyISAM Memory<span class="operator">/</span>Heap BDB <span class="keyword">Merge</span> Example CSV MaxDB Archive</span><br><span class="line">    不同的引擎在保存表的结构和数据时采用不同的方式</span><br><span class="line">    MyISAM表文件含义.frm表定义.MYD表数据.MYI表索引</span><br><span class="line">    InnoDB表文件含义.frm表定义表空间数据和日志文件</span><br><span class="line">    <span class="keyword">SHOW</span> ENGINES <span class="comment">-- 显示存储引擎的状态信息</span></span><br><span class="line">    <span class="keyword">SHOW</span> ENGINE 引擎名 &#123;LOGS<span class="operator">|</span>STATUS&#125; <span class="comment">-- 显示存储引擎的日志或状态信息</span></span><br><span class="line"><span class="comment">-- 数据文件目录</span></span><br><span class="line">    DATA DIRECTORY <span class="operator">=</span> <span class="string">&#x27;目录&#x27;</span></span><br><span class="line"><span class="comment">-- 索引文件目录</span></span><br><span class="line">    INDEX DIRECTORY <span class="operator">=</span> <span class="string">&#x27;目录&#x27;</span></span><br><span class="line"><span class="comment">-- 表注释</span></span><br><span class="line">    COMMENT <span class="operator">=</span> <span class="string">&#x27;string&#x27;</span></span><br><span class="line"><span class="comment">-- 分区选项</span></span><br><span class="line">    <span class="keyword">PARTITION</span> <span class="keyword">BY</span> ... (详细见手册)</span><br></pre></td></tr></table></figure>

<h3 id="列属性列约束"><a href="#列属性列约束" class="headerlink" title="列属性列约束"></a>列属性列约束</h3><ol>
<li>主键约束<ul>
<li>主键的作用 1、 保证数据完整性 2、 加快查询速度</li>
<li>能唯一标识记录的字段可以作为主键。</li>
<li>一个表只能有一个主键。</li>
<li>主键具有唯一性。</li>
<li>声明字段时用 primary key 标识。<br>也可以在字段列表之后声明，例 <code>create table tab ( id int, stu varchar(10), primary key (id));</code></li>
<li>主键字段的值不能为 null。</li>
<li>选择主键的原则 1、 最少性：尽量选择单个键做主键 2、 稳定性：尽量选择更新少的列做主键。3、 能用数字做主键的就不要用字符串</li>
<li>主键可以由多个字段共同组成。此时需要在字段列表后声明的方法。<br>例 create table tab ( id int, stu varchar(10), age int, primary key (stu, age));</li>
</ul>
</li>
<li>unique 唯一约束<ul>
<li>不能重复可以为空</li>
<li>一个表可以有多个唯一键</li>
</ul>
</li>
<li>null 约束<ul>
<li>null 不是数据类型是列的一个属性。<br>表示当前列是否可以为 null 表示什么都没有。</li>
<li>null, 允许为空。默认。</li>
<li>not null, 不允许为空。<br>例如： <code>insert into tab values (null, &#39;val&#39;);</code><br>此时表示将第一个字段的值设为 null, 取决于该字段是否允许为 null</li>
</ul>
</li>
<li>default 默认值属性<ul>
<li>当前字段的默认值。</li>
<li><code>insert into tab values (default, &#39;val&#39;);</code> – 此时表示强制使用默认值。</li>
<li><code>create table tab ( add_time timestamp default current_timestamp );</code>– 表示将当前时间的时间戳设为默认值。<code>current_date, current_time</code></li>
</ul>
</li>
<li>auto_increment 自动增长约束<ul>
<li>自动增长必须为<code>索引主键</code>或<code>unique</code></li>
<li>只能存在一个字段为自动增长。</li>
<li>默认为 1 开始自动增长。可以通过表属性<code>auto_increment = x</code> 进行设置或 <code>alter table tbl auto_increment = x;</code>，一般和 unsigned 一起使用（使用无符号整数）</li>
<li>自动增长列上的数据被删除，默认不再重复使用。</li>
<li>delete from 清空数据后编号继续增长，truncate table 清空表后编号从 1 开始增长.因为 truncate table 是删除原来的表创建一个新表。</li>
</ul>
</li>
<li>comment 注释<ul>
<li>例：<code>create table tab ( id int ) comment &#39;注释内容&#39;;</code></li>
</ul>
</li>
<li>foreign key 外键约束<ul>
<li>用于限制主表与从表数据完整性。</li>
<li><code>create table 表名(字段名 类型)[constraint] [外键名称] foreign key(外键字段名) references 主表(主表列名)</code></li>
<li><code>alter table 表名 add constraint 外键名称 foreign key (外键字段名) references 主表(主表列名);</code>将表的外键关联到主表的字段。每个外键都有一个名字可以通过 constraint 指定</li>
<li>存在外键的表称之为从表子表外键指向的表称之为主表父表。</li>
<li>作用保持数据一致性完整性主要目的是控制存储在外键表从表中的数据。</li>
<li><code>alter table 表名 drop foreign key 外键名称</code>删除外键<br>删除、更新外键行为<table>
<thead>
<tr>
<th>行为</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>no action/restrict</td>
<td>父表操作时，检查是否有对应外键，若有则不允许删除、更新</td>
</tr>
<tr>
<td>cascade</td>
<td>级联，若有，则也删除、更新外键在子表中的记录</td>
</tr>
<tr>
<td>set null</td>
<td>若有，则设置子表中该外键值为 null，外键值必须允许取 null</td>
</tr>
<tr>
<td>set default</td>
<td>若有，则设置子表中该外键值为默认值，innodb 不支持</td>
</tr>
<tr>
<td><code>create table 表名(字段名 类型)[constraint] [外键名称] foreign key(外键字段名) references 主表(主表列名) on update cascade on delete cascade</code></td>
<td></td>
</tr>
</tbody></table>
</li>
</ul>
</li>
</ol>
<h3 id="MySQL-中可以对-InnoDB-引擎使用外键约束"><a href="#MySQL-中可以对-InnoDB-引擎使用外键约束" class="headerlink" title="MySQL 中可以对 InnoDB 引擎使用外键约束"></a>MySQL 中可以对 InnoDB 引擎使用外键约束</h3><p>语法：<br><code>foreign key (外键字段 references 主表名 (关联字段) [主表记录删除时的动作] [主表记录更新时的动作]</code></p>
<p>此时需要检测一个从表的外键需要约束为主表的已存在的值。外键在没有关联的情况下可以设置为 <code>null</code>，前提是该外键列没有 <code>not null</code>。</p>
<p>可以不指定主表记录更改或更新时的动作那么此时主表的操作被拒绝。</p>
<p>如果指定了 <code>on update</code> 或 <code>on delete</code> 在删除或更新时有如下几个操作可以选择</p>
<ol>
<li><p>cascade 级联操作。主表数据被更新主键值更新从表也被更新外键值更新。主表记录被删除从表相关记录也被删除。</p>
</li>
<li><p>set null 设置为 null。主表数据被更新主键值更新从表的外键被设置为 null。主表记录被删除从表相关记录外键被设置成 null。但注意要求该外键列没有 not null 属性约束。</p>
</li>
<li><p>restrict 拒绝父表删除和更新。</p>
</li>
</ol>
<p>注意外键只被 InnoDB 存储引擎所支持。其他引擎是不支持的。</p>
<h3 id="DML（增删改）"><a href="#DML（增删改）" class="headerlink" title="DML（增删改）"></a>DML（增删改）</h3><ul>
<li>增</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> [<span class="keyword">INTO</span>] 表名 [(字段列表)] <span class="keyword">VALUES</span> (值列表)[, (值列表), ...]</span><br><span class="line">        <span class="comment">-- 如果要插入的值列表包含所有字段并且顺序一致，则可以省略字段列表。</span></span><br><span class="line">        <span class="comment">-- 可同时插入多条数据记录！</span></span><br><span class="line">        <span class="comment">-- 字符串和日期数据应包含在引号中</span></span><br><span class="line">        REPLACE 与 <span class="keyword">INSERT</span> 完全一样，可互换。</span><br><span class="line"><span class="keyword">INSERT</span> [<span class="keyword">INTO</span>] 表名 <span class="keyword">SET</span> 字段名<span class="operator">=</span>值[, 字段名<span class="operator">=</span>值, ...]</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>删</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> 表名[ 删除条件子句]</span><br><span class="line"></span><br><span class="line">没有条件子句则会删除全部</span><br></pre></td></tr></table></figure>

<ul>
<li>改</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> table_name <span class="keyword">SET</span> field1<span class="operator">=</span><span class="keyword">new</span><span class="operator">-</span>value1, field2<span class="operator">=</span><span class="keyword">new</span><span class="operator">-</span>value2</span><br><span class="line">[<span class="keyword">WHERE</span> Clause]</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">from</span> runoob_tbl <span class="keyword">WHERE</span> runoob_id<span class="operator">=</span><span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<h3 id="DQL"><a href="#DQL" class="headerlink" title="DQL"></a>DQL</h3><blockquote>
<p>执行顺序<code>form</code>&gt;<code>where</code>&gt;<code>group by</code>&gt;<code>having</code>&gt;<code>select</code>&gt;<code>order by</code>&gt;<code>limit</code></p>
</blockquote>
<h4 id="单表查询"><a href="#单表查询" class="headerlink" title="单表查询"></a>单表查询</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name,column_name</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line">[<span class="keyword">WHERE</span> Clause]</span><br><span class="line">[LIMIT N][ <span class="keyword">OFFSET</span> M]</span><br><span class="line">        <span class="comment">-- 可来自多个表的多个字段</span></span><br><span class="line">        <span class="comment">-- 其他子句可以不使用</span></span><br><span class="line">        <span class="comment">-- 字段列表可以用*代替表示所有字段</span></span><br><span class="line">        你可以使用 LIMIT 属性来设定返回的记录数。</span><br><span class="line">你可以通过<span class="keyword">OFFSET</span>指定<span class="keyword">SELECT</span>语句开始查询的数据偏移量。默认情况下偏移量为<span class="number">0</span>。</span><br></pre></td></tr></table></figure>

<ul>
<li><p>去除重复记录<br><code>select distinct 字段列表 from 表名</code></p>
</li>
<li><p>设置别名 AS</p>
</li>
</ul>
<p><code>SELECT 字段1[AS 别名], 字段2[AS 别名] FROM 表名;-- AS可省略</code></p>
<ul>
<li>WHERE 子句</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">SELECT</span> field1, field2,...fieldN <span class="keyword">FROM</span> table_name1, table_name2...</span><br><span class="line">[<span class="keyword">WHERE</span> condition1 [<span class="keyword">AND</span> [<span class="keyword">OR</span>]] condition2.....</span><br></pre></td></tr></table></figure>

<blockquote>
<p>MySQL 的 WHERE 子句的字符串比较是不区分大小写的。 你可以使用 BINARY 关键字来设定 WHERE 子句的字符串比较是区分大小写的。<br>字符串用单引号</p>
</blockquote>
<p>条件判断：<code>列 操作符 值</code></p>
<p>操作符：<br><code>= &lt; &gt; &lt;= &gt;=  !=</code><br><code>BETWEEN...AND...</code> 在某个范围（含最小最大值）<br><code>IN(...)</code>在 in 之后的列表中的值，多选一<br><code>IS NULL</code> 是 null</p>
<p>逻辑运算符<br><code>AND</code>或<code>&amp;&amp;</code> 多个条件同时成立<br><code>OR</code>或<code>||</code> 多个条件成立一个<br><code>NOT</code>或<code>!</code> 非</p>
<p>LIKE 子句</p>
<p>LIKE 子句中使用百分号 <code>%</code>字符来表示任意个字符，类似于 <code>UNIX</code> 或<code>正则表达式中</code>的星号<code>*</code>。如果没有使用百分号 <code>%</code>, LIKE 子句与等号<code>=</code>的效果是一样的。<code>_</code>下划线匹配单个字符</p>
<p><code>mysql&gt; SELECT * from runoob_tbl WHERE runoob_author LIKE &#39;%COM&#39;;</code></p>
<ul>
<li>分组聚合<br><code>select 列,聚合函数 from 表 [where条件] group by 列 [having 分组后的过滤条件]</code></li>
</ul>
<p>聚合函数（将一列数据作为一个整体进行纵向计算）:</p>
<blockquote>
<p>null 值不参与聚合函数计算</p>
</blockquote>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sum(列)-- 求和</span><br><span class="line">avg(列)--平均</span><br><span class="line">min(列)</span><br><span class="line">max(列)</span><br><span class="line">count(列|*)-- 数量</span><br></pre></td></tr></table></figure>

<p>where 与 having:<br>where 是分组前过滤，不满足 where 条件不参与分组。having 是分组后对结果进行过滤。where 不能对聚合函数进行判断，而 having 可以</p>
<p>分组后，查询字段一般为聚合函数和分组的字段，查询其他字段只会显示第一个值</p>
<ul>
<li>排序</li>
</ul>
<p><code>select 字段, from 表  order by 关键字 [asc|desc],关键词2 [asc|desc]</code></p>
<p>如果是多字段排序，当第一个字段值相同的时候，才会根据第二个字段进行排序</p>
<ul>
<li>分页（mysql)</li>
</ul>
<p><code>select * from table limit n[,m]</code><br>n：起始索引,跳过前 n 条，m：取出 m 条</p>
<h4 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h4><blockquote>
<p>多表关系</p>
<blockquote>
<p>一对一(用户和用户详情)：多用于单表拆分，将用户和用户详情拆分成两个表，提升操作效率。任意一方加入外键，并设置外键为唯一<br>一对多(一个部门对于多个员工，一个员工对应一个部门)：多的一方建立外键，指向一的一方<br>多对多(一个学生对于多个课程，一个课程对应多个学生)：只能建立第三张表，包含两个外键，分别关联两方主键</p>
</blockquote>
</blockquote>
<ul>
<li><p>多表查询语法(它会让参与的表先产生笛卡尔积【如两个集合 a，b 的所有组合情况】，然后在 where 过滤，性能差)</p>
<p><code>select  字段1,字段2... from 表1,表2... [where 条件]</code></p>
</li>
</ul>
<p>as 别名<br><code>select  字段1,字段2... from 表1 as 别名,表2 as 别名... [where 条件]</code></p>
<ul>
<li>多表链接查询</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表<span class="number">1</span>  [,<span class="keyword">INNER</span>]<span class="operator">|</span>[<span class="keyword">LEFT</span><span class="operator">|</span><span class="keyword">RIGHT</span>,[<span class="keyword">OUTER</span>]] <span class="keyword">JOIN</span>  表<span class="number">2</span> <span class="keyword">ON</span> 表<span class="number">1.</span>字段 <span class="operator">=</span> 表<span class="number">2.</span>字段;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>内关联是求交集，必须双向匹配才能查出</p>
</li>
<li><p>外关联：左外连接查询 (左边表中的数据优先全部显示，不用匹配右边),右外连接查询 (右边表中的数据优先全部显示，不用匹配左边)</p>
</li>
<li><p>全连接查询(联合查询)，联合查询不会使索引失效，而 or 会</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 全连接查询：是在内连接的基础上增加 左右两边没有显示的数据</span></span><br><span class="line"><span class="comment">-- 注意: mysql并不支持全连接 full JOIN 关键字</span></span><br><span class="line"><span class="comment">-- 注意: 但是mysql 提供了 UNION 关键字.使用 UNION 可以间接实现 full JOIN 功能</span></span><br><span class="line"><span class="comment">-- 联合查询多张表的列数，类型必须保持一致</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student <span class="keyword">left</span> <span class="keyword">join</span> sc <span class="keyword">on</span> student.sid <span class="operator">=</span> sc.sid</span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student <span class="keyword">right</span> <span class="keyword">join</span> sc <span class="keyword">on</span> student.sid <span class="operator">=</span> sc.sid;</span><br><span class="line"><span class="comment">-- 注意: UNION 和 UNION ALL 的区别:UNION 会去掉重复的数据,而 UNION ALL 则直接显示结果/</span></span><br></pre></td></tr></table></figure></li>
<li><p>自连接，必须起别名，可以内联也可以外联<br><code>select 字段 from 表1 别名1 join 表1 别名2 on 条件...</code></p>
</li>
</ol>
<ul>
<li>三表查询</li>
</ul>
<p><code>select 表1.字段,表2.字段,表3.字段 from 表1 join 表2 on 表1.关联字段 = 表2.关联字段 join 表3 on 表2.关联字段 = 表3.关联字段 where....;</code></p>
<ul>
<li>子查询（嵌套查询）<ul>
<li>标量子查询（子查询结果返回的结果为单个值）</li>
<li>列子查询（返回的一列）<br>常用操作：<code>in</code>在集合范围内多选一,<code>not in</code>不在集合范围,<code>any</code>任意一个满足即可,<code>some</code>等同 any,<code>all</code>必须全部满足</li>
<li>行子查询（返回的一行）<br>常用操作：<code>in</code>在集合范围内多选一,<code>not in</code>不在集合范围,<code>=</code>等于,<code>!=</code>不等于</li>
<li>表子查询(多行多列)<br>常用操作：<code>in</code>在集合范围内多选一,</li>
</ul>
</li>
</ul>
<h3 id="DCL-管理用户管理权限"><a href="#DCL-管理用户管理权限" class="headerlink" title="DCL 管理用户管理权限"></a>DCL 管理用户管理权限</h3><ul>
<li><p>查询用户</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">use mysql;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>创建用户<br><code>create user &#39;用户名&#39;@&#39;主机名&#39; identified by &#39;密码&#39;</code><br>主机名指在哪个主机上才能登陆访问数据库，可改为<code>%</code>，即可在任何主机登陆</p>
</li>
<li><p>修改用户密码<br><code>alter user &#39;用户名&#39;@&#39;主机名&#39; identified width mysql_nativev_password by &#39;密码&#39;</code></p>
</li>
<li><p>删除用户<br><code>drop user &#39;用户名&#39;@&#39;主机名&#39;</code></p>
</li>
<li><p>权限控制<br>常用权限：</p>
<table>
<thead>
<tr>
<th>权限</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>ALL,ALLPRIVILEGES</td>
<td>所有权限</td>
</tr>
<tr>
<td>SELECT</td>
<td>查询</td>
</tr>
<tr>
<td>INSERT</td>
<td>插入数据</td>
</tr>
<tr>
<td>UPDATE</td>
<td>修改数据</td>
</tr>
<tr>
<td>DELETE</td>
<td>删除数据</td>
</tr>
<tr>
<td>ALTER</td>
<td>修改表</td>
</tr>
<tr>
<td>DROP</td>
<td>删除表，数据库，视图</td>
</tr>
<tr>
<td>CREATE</td>
<td>创建表，数据库</td>
</tr>
<tr>
<td>INDEX</td>
<td>授予用户可以在表上定义索引的权限</td>
</tr>
<tr>
<td>super</td>
<td>允许执行一系列数据库管理命令</td>
</tr>
<tr>
<td>file</td>
<td>file 权限指的是对服务器主机上文件的访问，数据库用户拥有 file 权限才可以执行 select ..into outfile，load data infile…操作.</td>
</tr>
<tr>
<td>但是不要把 file, process, super 权限授予管理员以外的账号，这样存在严重的安全隐患。</td>
<td></td>
</tr>
</tbody></table>
<p>查询权限<br><code>show grants for &#39;用户名&#39;@&#39;主机名&#39;</code></p>
<p>授权<br><code>grant 权限,权限2 on 数据库.表名 to&#39;用户名&#39;@&#39;主机名&#39;</code><br>数据库名和表名可以通配符<code>*</code>代表所有</p>
<p>撤销权限<br><code>revoke 权限,权限2 on 数据库.表名 from  &#39;用户名&#39;@&#39;主机名&#39;</code></p>
</li>
</ul>
<h2 id="mysql-函数"><a href="#mysql-函数" class="headerlink" title="mysql 函数"></a>mysql 函数</h2><h3 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h3><table>
<thead>
<tr>
<th>函数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>concat(s1,s2…)</td>
<td>字符串拼接</td>
</tr>
<tr>
<td>lower(str)</td>
<td>转小写</td>
</tr>
<tr>
<td>upper(str)</td>
<td>转大写</td>
</tr>
<tr>
<td>trim(str)</td>
<td>去除首尾空格</td>
</tr>
<tr>
<td>substring(str,strart,len)</td>
<td>返回 start 起 len 个字符串</td>
</tr>
</tbody></table>
<h3 id="数值函数"><a href="#数值函数" class="headerlink" title="数值函数"></a>数值函数</h3><table>
<thead>
<tr>
<th>函数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>ceil(x)</td>
<td>向上取整</td>
</tr>
<tr>
<td>floor(x)</td>
<td>向下取整</td>
</tr>
<tr>
<td>mod(x,y)</td>
<td>返回 x/y 的模</td>
</tr>
<tr>
<td>rand()</td>
<td>0-1 随机数</td>
</tr>
<tr>
<td>round(x,y)</td>
<td>x 的四舍五入，暴露 y 位小数</td>
</tr>
</tbody></table>
<h3 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h3><table>
<thead>
<tr>
<th>函数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>curdate()</td>
<td>当前日期</td>
</tr>
<tr>
<td>curtime()</td>
<td>当前时间</td>
</tr>
<tr>
<td>now()</td>
<td>当前日期时间</td>
</tr>
<tr>
<td>year(date)</td>
<td>获取指定 date 的年</td>
</tr>
<tr>
<td>month(date)</td>
<td>获取指定 date 的月</td>
</tr>
<tr>
<td>day(date)</td>
<td>获取指定 date 的日</td>
</tr>
<tr>
<td>date_add(date,interval expr type)</td>
<td>返回 date 加上时间间隔 expr 后的时间值 ,type 为单位(day,month,year…)</td>
</tr>
<tr>
<td>date_sub(date,interval expr type)</td>
<td>返回 date 减去时间间隔 expr 后的时间值 ,type 为单位(day,month,year…)</td>
</tr>
<tr>
<td>datediff(date1,date2)</td>
<td>返回 date1 和 date2 之间的天数</td>
</tr>
</tbody></table>
<h3 id="流程函数"><a href="#流程函数" class="headerlink" title="流程函数"></a>流程函数</h3><table>
<thead>
<tr>
<th>函数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>if(value,t,f)</td>
<td>如果 value 为真返回 t，否则返回 f</td>
</tr>
<tr>
<td>ifnull(val1,val2)</td>
<td>如果 val1 为不为空，返回 val1，否则返回 val2</td>
</tr>
<tr>
<td>case when [val1] then [res1]when [val2] then [res2]…else [default] end</td>
<td>如果 val1 为真，返回 res1，…否则返回 default 值</td>
</tr>
<tr>
<td>case [expr] when [val1] then [res1]…else [default] end</td>
<td>如果 expr 等于 val1 ，返回 res1，…否则返回 default 值</td>
</tr>
</tbody></table>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ul>
<li>原子性：事务是不可分割的最小操作单元，要么全部成功，要么去全部失败；</li>
<li>一致性：事务完成时，必须使所有的数据都保持一致状态。</li>
<li>隔离性：数据库系统提供的隔离机制，保证事务在不受外部并发操作的独立环境下运行</li>
<li>持久性：事务一旦提交或回滚，它对数据库的数据的改变是永久的</li>
</ul>
<h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><ul>
<li>查看设置事务提交方式</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@autocommit</span>;</span><br><span class="line"><span class="keyword">Set</span> @<span class="variable">@autocommit</span><span class="operator">=</span><span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>开启事务</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line">或</span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>提交事务</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>回滚事务</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ROLLBACK</span>;</span><br></pre></td></tr></table></figure>

<h3 id="并发事务问题"><a href="#并发事务问题" class="headerlink" title="并发事务问题"></a>并发事务问题</h3><ul>
<li><p>脏读：一个事务读到另一个事务还没有提交的数据</p>
</li>
<li><p>不可重复读：一个事务先后读取同一条记录，但两次读取的数据不同</p>
</li>
<li><p>幻读：一个事务按照条件查询数据时，没有对应的数据行，但是插入数据时，又提示该行数据已经存在。</p>
</li>
<li><p>事务隔离级别</p>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody><tr>
<td>Read uncommitted</td>
<td>出现</td>
<td>出现</td>
<td>出现</td>
</tr>
<tr>
<td>Read committed</td>
<td>不出现</td>
<td>出现</td>
<td>出现</td>
</tr>
<tr>
<td>Repeatable Read(mysql 默认)</td>
<td>不出现</td>
<td>不出现</td>
<td>出现</td>
</tr>
<tr>
<td>Serializable</td>
<td>不出现</td>
<td>不出现</td>
<td>不出现</td>
</tr>
</tbody></table>
</li>
<li><p>查看事务隔离级别</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> @<span class="variable">@TRANSACTION</span>_ISOLATION;</span><br></pre></td></tr></table></figure>

<ul>
<li>设置事务隔离级别</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> [SEEESION<span class="operator">|</span><span class="keyword">GLOBAL</span>] TRANSACTION ISOLATION LEVEL&#123;READ UNCOMMITTED<span class="operator">|</span>READ COMMITTED<span class="operator">|</span>REPEATABLE READ<span class="operator">|</span>SERIALIZABLE&#125;</span><br></pre></td></tr></table></figure>

<h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h2><blockquote>
<p>就是存储数据、建立索引、更新查找数据等技术的实现方式。存储引擎是基于表的，而不是基于库的，所以存储引擎也可以被称为表类型</p>
</blockquote>
<ul>
<li><p>innoDB</p>
<blockquote>
<p>兼顾高可靠性和高性能的通用存储引擎，在 mysql5.5 之后为默认引擎<br>特点：DM 操作遵循 ACID 模型，支持<code>事务</code>支持<code>级锁</code>提高并发访问性能；支持<code>外键</code>，保证数据的完整性和正确性;最大 64TB，空间和内存使用高，批量插入慢，适用除读操作和插入操作外，还有大量的更新、删除操作的应用。<br>文件：xxx.idb:存储该表的表结构和数据和索引</p>
</blockquote>
</li>
<li><p>MyISAM</p>
<blockquote>
<p>早期 mysql 默认引擎<br>特点：不支持事务、外键、行锁；支持表锁，访问速度快;空间和内存使用低，批量插入快，适用于读操作和插入操作为主的应用。</p>
</blockquote>
</li>
<li><p>Memory</p>
<blockquote>
<p>表数据存在内存中，常用于临时表、缓存使用<br>特点：内存存放、hash 索引<br>文件：xxx.sdi:存储表结构信息</p>
</blockquote>
</li>
<li><p>创建表时，指定存储引擎</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名(字段<span class="number">1</span> 类型 [comment 注释],...)engine<span class="operator">=</span>innoDB [comment 表注释];</span><br></pre></td></tr></table></figure>

<ul>
<li>查看当前数据库支持的存储引擎</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> engines;</span><br></pre></td></tr></table></figure>

<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><blockquote>
<p>帮助 mysql 高效获取数据的数据结构（有序）。在数据之外，数据库还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用数据，这样就可以在这些数据结构上实现高级的查找算法，这种数据结构就是索引<br>优势：提高数据检索效率，降低数据库的 io 成本。对数据进行排序时，降低 cpu 消耗。<br>缺点：索引需要额外的磁盘空间。降低表的更新速度，效率降低。</p>
</blockquote>
<h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><table>
<thead>
<tr>
<th>索引结构</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>B+Tree 索引</td>
<td>最常见的索引，大部分引擎都支持</td>
</tr>
<tr>
<td>Hash 索引</td>
<td>利用哈希表实现，只有精确匹配索引的查询才有效，不支持范围查找</td>
</tr>
<tr>
<td>R-tree 空间索引</td>
<td>MyISAM 引擎的一个特殊索引类型，常用于地理空间数据类型</td>
</tr>
<tr>
<td>Full-text 全文索引</td>
<td>通过建立到排索引，快速匹配文档的方式，类似 ES</td>
</tr>
</tbody></table>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><table>
<thead>
<tr>
<th>分类</th>
<th>说明</th>
<th>特点</th>
<th>关键词</th>
</tr>
</thead>
<tbody><tr>
<td>主键索引</td>
<td>针对表中的主键创建的索引</td>
<td>默认自动创建，只能有一个</td>
<td>primary</td>
</tr>
<tr>
<td>唯一索引</td>
<td>避免同一个表中数据列的值重复</td>
<td>可以多个</td>
<td>unique</td>
</tr>
<tr>
<td>常规索引</td>
<td>快速定位特定数据</td>
<td>可以多个</td>
<td></td>
</tr>
<tr>
<td>全文索引</td>
<td>全文索引查找的是文本中的关键词，而不是比较索引中的值</td>
<td>可以多个</td>
<td>fulltext</td>
</tr>
</tbody></table>
<p>innoDB 根据索引的存储类型又可以分为下面两种</p>
<ul>
<li>聚集索引 clustered Index：将数据存储和索引放到一块，索引结构的叶子节点保存了行数据（必须有，且只有一个）<ul>
<li>如果主键存在，主键索引就是聚集索引</li>
<li>若无主键，将使用第一个唯一索引作为聚集索引</li>
<li>若表既无主键也无唯一索引，innoDB 将自动生成 rowid 作为隐藏的聚集索引</li>
</ul>
</li>
<li>二级索引 Secondary Index：将数据和索引分开存储，索引结构的叶子节点关联的是对应的主键（可以存在多个）</li>
</ul>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><ul>
<li>创建索引<br><code>create [unique|fulltext] INDEX 索引名 ON 表名(字段名,...)</code></li>
<li>查看索引<br><code>show index from 表名</code></li>
<li>删除索引<br><code>drop idnex 索引名 on 表名</code></li>
</ul>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ul>
<li><p>最左前缀法则：如果索引了多列，查询从索引的最左列开始，并且不跳过索引中列，若跳过某一列，索引将部分失效即后面的字段索引失效</p>
</li>
<li><p>范围查询：如果索引了多列，出现范围查询（<code>&gt;</code>，<code>&lt;</code>），范围查询右侧的列索引失效。可使用<code>&gt;-</code>，<code>&lt;=</code>避免出现这种情况</p>
</li>
<li><p>索引列运算：索引列进行运算操作，索引将失效</p>
</li>
<li><p>字符串不加引号：字符串不加引号，索引将失效</p>
</li>
<li><p>模糊查询：尾部模糊匹配，索引不失效，头部模糊索引失效。</p>
</li>
<li><p>or 连接：or 前后都有索引，索引才不会失效</p>
</li>
<li><p>数据分布影响：若 mysql 评估索引查询比全表查询慢，将不会使用索引</p>
</li>
<li><p>覆盖索引：尽量使用覆盖索引（查询使用了索引，兵器需要返回的列，在该索引中已经全部能够找到），减少 select *</p>
</li>
<li><p>单列索引与联合索引：若存在多个查询条件，建议建立联合索引。使用单列索引时，mysql 会根据评估，自动选择，并不会全用上索引</p>
</li>
<li><p>sql 提示：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 表 use index(索引名) where...</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 表 ignore index(索引名) where...</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 表 force index(索引名) where...</span><br></pre></td></tr></table></figure></li>
<li><p>前缀索引：字段类型为 varchar 或 text，建立的索引会变得非常大。通过截取字符串前一部分建立索引提交索引效率</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#n为截取的个数</span><br><span class="line"><span class="keyword">create</span> index 索引名 <span class="keyword">on</span> 表(列名(n));</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><ul>
<li>查看操作次数<br><code>show [global|session] status link &#39;com_______&#39;;</code>七个下划线</li>
</ul>
<h3 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h3><blockquote>
<p>记录所有执行超过指定参数（long_query_time,单位：秒，默认 10s）的所有 sql 语句日志，默认没有开启</p>
</blockquote>
<ul>
<li>查看是否开启：<code>show variables like &#39;slow_query_log&#39;;</code></li>
<li>开启：编辑/etc/my.cng</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">show_query_log=1</span><br><span class="line">long_query_time=2</span><br></pre></td></tr></table></figure>

<ul>
<li>日志文件：<code>/var/lib/mysql/localhost-slow.log</code></li>
</ul>
<h3 id="profile-详情"><a href="#profile-详情" class="headerlink" title="profile 详情"></a>profile 详情</h3><blockquote>
<p>查看 sql 语句具体详情</p>
</blockquote>
<ul>
<li>查看是否支持：<code>select @@have_profiling;</code></li>
<li>启动：<code>set profiling=1;</code></li>
<li>查看：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#查看全部</span><br><span class="line"><span class="keyword">show</span> profiles;</span><br><span class="line">#指定id</span><br><span class="line"><span class="keyword">show</span> profile <span class="keyword">for</span> query <span class="keyword">sql</span>语句id;</span><br><span class="line">#查看cup情况</span><br><span class="line"><span class="keyword">show</span> profile cpu <span class="keyword">for</span> query <span class="keyword">sql</span>语句id;</span><br></pre></td></tr></table></figure>

<h3 id="explain-执行计划"><a href="#explain-执行计划" class="headerlink" title="explain 执行计划"></a>explain 执行计划</h3><blockquote>
<p>获取 mysql 如何执行 select 语句信息。</p>
</blockquote>
<ul>
<li>使用</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 表</span><br><span class="line">或</span><br><span class="line"><span class="keyword">desc</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 表</span><br></pre></td></tr></table></figure>

<ul>
<li>结果字段说明:<ul>
<li>id：操作顺序，id 相同，从上到下，否则值也大，越先执行</li>
<li>select_type：查询类型</li>
<li>type：连接类型，由好到差-&gt;null、system、cons、eq_ref、ref、range、index、all</li>
<li>prossible_key：显示可能应用在这张表上的索引</li>
<li>key：实际使用的索引</li>
<li>key_len：索引中使用的字节数，该值为最大可能长达，并非实际使用长度</li>
<li>rows：必须要执行查询的行数，是个估值</li>
<li>filterd：表示返回结果的行数占需读取行数的百分百，越大越好</li>
</ul>
</li>
</ul>
<h3 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h3><ul>
<li><p>主键顺序插入</p>
</li>
<li><p>多条插入尽可以使用批量插入<code>insert into 表 values(1,&#39;1&#39;),(2,&#39;2&#39;)</code></p>
</li>
<li><p>手动提交事务</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">start</span> transaction;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">to</span> 表 <span class="keyword">values</span>(..)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">to</span> 表 <span class="keyword">values</span>(..)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">to</span> 表 <span class="keyword">values</span>(..)</span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>大批量插入数据：使用 mysql 的 load 指令进行插入操作</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql --local-infile -u root -p</span><br><span class="line"><span class="built_in">set</span> global local_infile=1;</span><br><span class="line">load data <span class="built_in">local</span> infile <span class="string">&#x27;/home/sql.log&#x27;</span> into table <span class="string">&#x27;表名&#x27;</span> fields terminated by <span class="string">&#x27;字段间的分割符&#x27;</span> lines teminated by <span class="string">&#x27;每一行的分隔符&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="主键优化"><a href="#主键优化" class="headerlink" title="主键优化"></a>主键优化</h3><ul>
<li>尽量降低主键长度–减少 b+tree 空间</li>
<li>插入数据时尽量顺序插入–避免页分裂</li>
<li>尽量不要使用 uuid 做主键–避免页分裂</li>
<li>避免对主键修改–重新构建 b+tree</li>
</ul>
<h2 id="MySQL-分页查询的-5-种方法"><a href="#MySQL-分页查询的-5-种方法" class="headerlink" title="MySQL 分页查询的 5 种方法"></a>MySQL 分页查询的 5 种方法</h2><p>方式 1：直接使用数据库提供的 SQL 语句</p>
<p>适应场景: 适用于数据量较少的情况(元组百/千级)。很简单，该语句的意思就是查询 m+n 条记录，去掉前 m 条，返回后 n 条。无疑该查询能够实现分页，但 m 越大，查询性能就越低，因为 MySQL 需要扫描全部 m+n 条记录。</p>
<p>方式 2：基于索引再排序</p>
<p><code>select \* from table order by id limit m, n;</code></p>
<p>很简单，该语句的意思就是查询 m+n 条记录，去掉前 m 条，返回后 n 条。无疑该查询能够实现分页，但 m 越大，查询性能就越低，因为 MySQL 需要扫描全部 m+n 条记录。</p>
<p>方式 2：</p>
<p><code>select \* from table where id &gt; #max_id# order by id limit n;</code></p>
<p>该查询同样会返回后 n 条记录，却无需像方式 1 扫描前 m 条记录，但必须在每次查询时拿到上一次查询（上一页）的最大 id（或最小 id），是比较常用的方式。</p>
<p>当然该查询的问题也在于我们不一定能拿到这个 id，比如当前在第 3 页，需要查询第 5 页的数据，就不行了。</p>
<p>方式 3：</p>
<p>方式 3：基于索引再排序<br>为了避免方式 2 不能实现的跨页查询，就需要结合方式 1。</p>
<p>性能需要，m 得尽量小。比如当前在第 3 页，需要查询第 5 页，每页 10 条数据，且当前第 3 页的最大 id 为#max_id#，则：</p>
<p><code>select \* from table where id &gt; #max_id# order by id limit 10, 10;</code></p>
<p>该方式就部分解决了方式 2 的问题，但如果当前在第 2 页，要查第 1000 页，性能仍然较差。</p>
<p>方式 4：</p>
<p><code>select \* from table as a inner join (select id from table order by id limit m, n) as b on a.id = b.id order by a.id;</code></p>
<p>该查询同方式 1 一样，m 的值可能很大，但由于内部的子查询只扫描了 id 字段，而非全表，所以性能要强于方式 1，并且能够解决跨页查询问题。</p>
<p>方式 5：</p>
<p><code>select \* from table where id &gt; (select id from table order by id limit m, 1) limit n;</code></p>
<p>该查询同样是通过子查询扫描字段 id，效果同方式 4。但方式 5 的性能会略好于方式 4，因为它不需要进行表的关联，而是一个简单的比较，在不知道上一页最大 id 的情况下，是比较推荐的用法。</p>
<p>方法 6: 基于索引使用 prepare,<br>语句样式: MySQL 中,可用如下方法:<br>代码如下:<br><code>PREPARE stmt*name FROM SELECT * FROM 表名称 WHERE id*pk &gt; (？* ？) ORDER BY id_pk ASC LIMIT M</code><br>（第一个问号表示 pageNum，第二个？表示每页元组数）<br>适应场景: 大数据量。<br>原因: 索引扫描,速度会很快. prepare 语句又比一般的查询语句快一点。</p>
<p>方法 7:利用 MySQL 支持 ORDER 操作可以利用索引快速定位部分元组,避免全表扫描<br>比如: 读第 1000 到 1019 行元组(pk 是主键/唯一键)。<br>代码如下:<br><code>SELECT \* FROM your_table WHERE pk&gt;=1000 ORDER BY pk ASC LIMIT 0,20</code></p>
<h2 id="插入表情"><a href="#插入表情" class="headerlink" title="插入表情"></a>插入表情</h2><ol>
<li>MySQL 的版本<br><code>utf8mb4</code> 的最低 mysql 版本支持版本为 <code>5.5.3+</code>，若不是，请升级到较新版本。</li>
<li>MySQL 驱动<br><code>5.1.34</code> 可用,最低不能低于 <code>5.1.13</code></li>
<li>修改 MySQL 配置文件<br>修改 mysql 配置文件 <code>my.cnf</code>，<code>my.cnf</code> 一般在 <code>etc/mysql/my.cnf</code> 位置。找到后请在以下三部分里添加如下内容：</li>
</ol>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[client]</span></span><br><span class="line"><span class="attr">default-character-set</span> = utf8mb4</span><br><span class="line"></span><br><span class="line"><span class="section">[mysql]</span></span><br><span class="line"><span class="attr">default-character-set</span> = utf8mb4</span><br><span class="line"></span><br><span class="line"><span class="section">[mysqld]</span></span><br><span class="line"><span class="attr">character-set-client-handshake</span> = <span class="literal">FALSE</span></span><br><span class="line"><span class="attr">character-set-server</span> = utf8mb4</span><br><span class="line"><span class="attr">collation-server</span> = utf8mb4_unicode_ci</span><br><span class="line"><span class="attr">init_connect</span>=<span class="string">&#x27;SET NAMES utf8mb4&#x27;</span></span><br></pre></td></tr></table></figure>

<p>重启 mysql:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">一、MySQL启动方式</span><br><span class="line">1、使用 service 启动：service mysqld start</span><br><span class="line">2、使用 mysqld 脚本启动：/etc/init.d/mysqld start</span><br><span class="line">3、使用 safe_mysqld 启动：safe_mysqld&amp;</span><br><span class="line">二、MySQL停止</span><br><span class="line">1、使用 service 启动： service mysqld stop</span><br><span class="line">2、使用 mysqld 脚本启动：/etc/init.d/mysqld stop</span><br><span class="line">3、mysqladmin shutdown</span><br><span class="line">三、MySQL重启</span><br><span class="line">1、使用 service 启动：service mysqld restart</span><br><span class="line">2、使用 mysqld 脚本启动：/etc/init.d/mysqld restart</span><br><span class="line">四、强制关闭</span><br><span class="line">以上方法都无效的时候，可以通过强行命令：“killall mysql”来关闭MySQL，但是不建议用这样的方式，</span><br><span class="line">据库服务，有可能导致表损坏……所以自己掂量着用。</span><br><span class="line">Windows下重启MySQL服务,对于没装mysql图形管理端的用户来说启动和停止mysql服务：</span><br><span class="line">…\…\bin&gt;net stop mysql</span><br><span class="line">…\…\bin&gt;net start mysql</span><br></pre></td></tr></table></figure>

<p>当数据库中涉及编码类型改变的时候，需要统一数据库，表，字段的编码类型，少一个都不行。<br>修改数据库字符集：<br><code>ALTER DATABASE database_name CHARACTER SET = utf8mb4 COLLATE = utf8mb4_unicode_ci;</code><br>修改表的字符集：<br><code>ALTER TABLE table_name CONVERT TO CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;</code><br>修改字段的字符集：<br><code>ALTER TABLE table_name CHANGE column_name column_name VARCHAR(191) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;</code> 4. 查看是否成功修改<br>使用<code>SHOW VARIABLES WHERE Variable_name LIKE &#39;character_set_%&#39; OR Variable_name LIKE &#39;collation%&#39;;</code>查看当前编码,结果中的 <code>collation_connection</code> 、<code>collation_database</code> 、<code>collation_server</code> 是什么没关系。但必须保证系统变量 描述</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">character_set_client (客户端来源数据使用的字符集)</span><br><span class="line">character_set_connection (连接层字符集)</span><br><span class="line">character_set_database (当前选中数据库的默认字符集)</span><br><span class="line">character_set_results (查询结果字符集)</span><br><span class="line">character_set_server (默认的内部操作字符集)</span><br></pre></td></tr></table></figure>

<p>这几个变量必须是 utf8mb4,才能插入表情。<br>查看表编码<br><code>mysql&gt; show create table dictionary; # dictionary 是表名</code> 5. 数据库连接的配置<br>数据库连接参数中也要设置为 utf8bm4 格式，否则是无法插入的 <code>charset=utf8mb4</code></p>
<h2 id="数据库备份与还原"><a href="#数据库备份与还原" class="headerlink" title="数据库备份与还原"></a>数据库备份与还原</h2><ol>
<li><p>备份原文件<br>MySQL 中的每一个数据库和数据表分别对应文件系统中的目录和其下的文件。在 Linux 下数据库文件的存放目录一般为/var/lib/mysql。在 Windows 下这个目录视 MySQL 的安装路径而定。备份文件前，需要将 MySQL 服务停止，然后将数据库目录拷贝即可。恢复数据数据库时，需要先创建好一个数据库(不一定同名)，然后将备份出来的文件(注意，不是目录)复制到对应的 MySQL 数据库目录中。使用这一方法备份和恢复数据库时，需要新旧的 MySQL 版本一致，否则可能会出现错误。</p>
</li>
<li><p>使用命令</p>
</li>
</ol>
<p>备份数据库(不需要进入 mysql)：<br><code>mysqldump –user=root –password=root密码 –lock-all-tables 数据库名 &gt; 备份文件.sql</code><br>恢复数据库：<br><code>mysql -u root –password=root密码 数据库名 &lt; 备份文件.sql</code></p>
<h2 id="nodejs-连接数据库"><a href="#nodejs-连接数据库" class="headerlink" title="nodejs 连接数据库"></a>nodejs 连接数据库</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">client does <span class="keyword">not</span> support authentication protocol requested <span class="keyword">by</span> server</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>出现连接失败的原因mysql8之前的版本中加密规则是mysql_native_password,而在mysql8之后,加密规则是caching_sha2_password。并提供了两种解决方案</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>把用户密码登录的加密规则还原成mysql_native_password这种加密方式</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;password&#x27;</span> PASSWORD EXPIRE NEVER;这里的password是你正在使用的密码</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">KK</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">59</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/a913481180" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;a913481180" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:kangkanghuang@foxmail.com" title="E-Mail → mailto:kangkanghuang@foxmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="http://www.baidu.com/" title="http:&#x2F;&#x2F;www.baidu.com">百度</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">KK</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>

<script src="/js/utils.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
