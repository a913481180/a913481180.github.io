<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/1.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/1.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"a913481180.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":false,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="KK">
<meta property="og:url" content="https://a913481180.github.io/index.html">
<meta property="og:site_name" content="KK">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="KK">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://a913481180.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>KK</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">KK</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://a913481180.github.io/2023/11/12/20-21-33/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="KK">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KK">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/11/12/20-21-33/" class="post-title-link" itemprop="url">Electron</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-11-12 20:21:33" itemprop="dateCreated datePublished" datetime="2023-11-12T20:21:33+08:00">2023-11-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-05-14 23:12:11" itemprop="dateModified" datetime="2024-05-14T23:12:11+08:00">2024-05-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/tool/" itemprop="url" rel="index"><span itemprop="name">tool</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ul>
<li><code>yarn create @quick-start/electron</code></li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">? Add TypeScript? » No / Yes</span><br><span class="line">是否使用TypeScript？选No，本教程使用JavaScript。如果喜欢TypeScript，请选择Yes。</span><br><span class="line">? Add Electron updater plugin? » No / Yes</span><br><span class="line">是否添加Electron updater插件？选择Yes。</span><br><span class="line">? Enable Electron download mirror proxy? » No / Yes</span><br><span class="line">是否开启Electron镜像下载代理。在国内网络环境，强烈建议选择Yes。</span><br></pre></td></tr></table></figure>

<p>支持 Less，执行以下命令安装：<code>yarn add -D less</code><br>引入 Ant Design 5.x：<code>yarn add antd</code><br>设置 Antd 为中文语言：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">&quot;react-dom/client&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&quot;./App&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; ConfigProvider &#125; <span class="keyword">from</span> <span class="string">&quot;antd&quot;</span>;</span><br><span class="line"><span class="comment">// 引入Ant Design中文语言包</span></span><br><span class="line"><span class="keyword">import</span> zhCN <span class="keyword">from</span> <span class="string">&quot;antd/locale/zh_CN&quot;</span>;</span><br><span class="line"><span class="comment">// 全局样式</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;@/common/styles/frame.styl&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> root = ReactDOM.createRoot(<span class="built_in">document</span>.getElementById(<span class="string">&quot;root&quot;</span>));</span><br><span class="line">root.render(</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">ConfigProvider</span> <span class="attr">locale</span>=<span class="string">&#123;zhCN&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">App</span> /&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">ConfigProvider</span>&gt;</span></span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="一、打开项目空白，重定向到-chrome-error-chromewebdat"><a href="#一、打开项目空白，重定向到-chrome-error-chromewebdat" class="headerlink" title="一、打开项目空白，重定向到 chrome-error://chromewebdat"></a>一、打开项目空白，重定向到 chrome-error://chromewebdat</h3><p>问题原因：打包好之后打开.exe 文件，项目空白，控制台查看是重定向到 chrome-error://chromewebdat 这个路径下。控制台也不会进行报错！</p>
<p>说明：</p>
<p>electron 项目在开发阶段，因为使用 webpack / vite 脚手架,启用了 webServer 提供的 http 服务，所以有路由功能，当我们运行 npm run electron:serve 的时候，最后可以直接加载 <a href="http://localhost:8080。在终端里面就可以显示页面。">http://localhost:8080。在终端里面就可以显示页面。</a></p>
<p>当 electron 项目打包之后，成为桌面程序，这个时候就没有 http 服务支撑，所以加载的是静态页面，win.loadURL(“file://./index.html”)。</p>
<p>解决方案：</p>
<ol>
<li><p>改变路由设置的模式，将 history 改为 hash，具体代码看下方写的《路由不跳转问题》</p>
</li>
<li><p>根据判断生产环境 mainWindow.loadFile(path.resolve(__dirname, ‘../dist/index.html’)) 在 electron main.js 中 无法使用 （.env.production / .env.development）中配置的环境变量 所以安装一个 cross-env 插件配置。</p>
</li>
</ol>
<h3 id="三、打包之后，请求不到后端数据，有的人是-app-有的人是-file"><a href="#三、打包之后，请求不到后端数据，有的人是-app-有的人是-file" class="headerlink" title="三、打包之后，请求不到后端数据，有的人是 app:// 有的人是 file://"></a>三、打包之后，请求不到后端数据，有的人是 app:// 有的人是 file://</h3><p>因为在本地环境 需要反向代理解决跨域问题，“/api”则是在 vite.config.js 中配置的 server。而生产环境配置的代理就不在管用了，需要将请求的路径(<a target="_blank" rel="noopener" href="http://www.baidu.com)配置成baseurl,如果跨域的话/">http://www.baidu.com)配置成baseURL，如果跨域的话</a> 就要看后端是否已经做了跨域处理，下方 import.meta.env.MODE 三元判断区也可以用《上方所提到的 isDev》</p>
<p>在 axios 配置的文件添加：</p>
<p>const BASEURL = import.meta.env.MODE == ‘development’ ? ‘/api’ : ‘<a target="_blank" rel="noopener" href="http://www.baidu.com&/#39;">http://www.baidu.com&#39;</a>;<br>axios.defaults.baseURL = BASEURL;</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://a913481180.github.io/2023/08/11/20-22-22/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="KK">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KK">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/08/11/20-22-22/" class="post-title-link" itemprop="url">NestJs</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-08-11 20:22:22" itemprop="dateCreated datePublished" datetime="2023-08-11T20:22:22+08:00">2023-08-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-05-14 23:12:11" itemprop="dateModified" datetime="2024-05-14T23:12:11+08:00">2024-05-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/web/" itemprop="url" rel="index"><span itemprop="name">web</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="NestJs"><a href="#NestJs" class="headerlink" title="NestJs"></a>NestJs</h1><p>NestJS 是运行在服务端的一个 JS 框架。它运行时是 JavaScript，编程时使用 TypeScript, 是结合灵活性、可扩展性的框架。并且结合了面向对象编程(OOP)、函数式编程(FP)和函数响应式编程(FRP)</p>
<p>它的特殊之处在于，以前使用 JS 方式写后台代码，现在通过写 TS, 再编译成 JS 运行。既包含了 JS 的灵活性，又有 TS 的约束。<br>NestJS 也主张的是 MVC 的格式。</p>
<ul>
<li>module 的作用是在程序运行时给模块处理依赖。好处是所有模块的依赖都可以在 module 中清晰明了的知道引用还是被引用</li>
<li>controller 的作用是处理请求，所有的请求会先到 controller，再经 controller 调用其他模块业务逻辑</li>
<li>service 是真正处理业务逻辑的地方，所有的业务逻辑都会在这里处理。它可经过 module 引用其他模块的 service，也可经过 module 暴露出去。</li>
</ul>
<h2 id="开发准备"><a href="#开发准备" class="headerlink" title="开发准备"></a>开发准备</h2><p>安装 NestJS cli</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -g @nestjs/cli</span><br></pre></td></tr></table></figure>

<p>创建 nest-test 项目</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nest new nest-test</span><br></pre></td></tr></table></figure>

<p>安装依赖或更新依赖</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure>

<p>启动</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run start</span><br></pre></td></tr></table></figure>

<h2 id="生成新模块"><a href="#生成新模块" class="headerlink" title="生成新模块"></a>生成新模块</h2><p>NestJS cli 也支持用命令行形式来创建，这样就不需要做重复的创建文件的动作了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">nest g controller students</span><br><span class="line">nest g service students</span><br><span class="line">nest g module students</span><br><span class="line"></span><br><span class="line"><span class="comment">#########目录结构变成如下</span></span><br><span class="line">src</span><br><span class="line">  |- app.controller.spec.ts</span><br><span class="line">  |- app.controller.ts</span><br><span class="line">  |- app.module.ts</span><br><span class="line">  |- app.service.ts</span><br><span class="line">  |- main.ts</span><br><span class="line">  |- students/</span><br><span class="line">        |- students.controller.spec.ts</span><br><span class="line">        |- students.controller.ts</span><br><span class="line">        |- students.module.ts</span><br><span class="line">        |- students.service.spec.ts</span><br><span class="line">        |- students.service.ts</span><br></pre></td></tr></table></figure>

<p>编辑文件</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// students.service.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; Injectable &#125; <span class="keyword">from</span> <span class="string">&quot;@nestjs/common&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Injectable</span>()</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentsService</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">ImStudent</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Im student&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// students.controller.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; Controller, Get &#125; <span class="keyword">from</span> <span class="string">&quot;@nestjs/common&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; StudentsService &#125; <span class="keyword">from</span> <span class="string">&quot;./students.service&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span>(<span class="string">&quot;students&quot;</span>)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentsController</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"><span class="keyword">private</span> <span class="keyword">readonly</span> studentsService: StudentsService</span>)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Get</span>(<span class="string">&quot;who-are-you&quot;</span>)</span><br><span class="line">  <span class="function"><span class="title">whoAreYou</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.studentsService.ImStudent();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://a913481180.github.io/2023/01/11/20-22-22/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="KK">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KK">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/01/11/20-22-22/" class="post-title-link" itemprop="url">PM2</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-01-11 20:22:22" itemprop="dateCreated datePublished" datetime="2023-01-11T20:22:22+08:00">2023-01-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-05-14 23:12:11" itemprop="dateModified" datetime="2024-05-14T23:12:11+08:00">2024-05-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>PM2 是常用的 node 进程管理工具，它可以提供 node.js 应用管理，如自动重载、性能监控、负载均衡等。同类工具有 Supervisor、Forever 等。</p>
<p>pm2 是一个进程管理工具,可以用它来管理你的 node 进程，并查看 node 进程的状态，当然也支持性能监控，进程守护，负载均衡等功能。pm2 基本是 Nodejs 应用程序不二的守护进程选择，事实上它并不仅仅可以启动 Nodejs 的程序，只要是一般的脚本的程序它同样可以胜任。</p>
<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul>
<li><p>内建负载均衡（使用 node cluster 集群模块，可以使用服务器上的所有 cpu）</p>
</li>
<li><p>后台运行（node app.js 这种命令是直接在前台运行的，不稳定，很容易断）</p>
</li>
<li><p>0 秒停机重载（应该是上线升级的时候 不需要停机）</p>
</li>
<li><p>停止不稳定的进程（避免无限循环）</p>
</li>
<li><p>控制台检测</p>
</li>
</ul>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><code>npm install -g pm2</code></p>
<h2 id="启动-PM2-项目"><a href="#启动-PM2-项目" class="headerlink" title="启动 PM2 项目"></a>启动 PM2 项目</h2><p>pm2 支持直接运行 server.js 启动项目，如下：<code>pm2 start server.js</code></p>
<ul>
<li><code>--watch</code>：监听应用目录的变化，一旦发生变化，自动重启。如果要精确监听、不见听的目录，最好通过配置文件。</li>
<li><code>-i --instances</code>：启用多少个实例，可用于负载均衡。如果-i 0 或者-i max，则根据当前机器核数确定实例数目。</li>
<li><code>--ignore-watch</code>：排除监听的目录/文件，可以是特定的文件名，也可以是正则。比如<code>--ignore-watch=&quot;test node_modules &quot;some scripts&quot;&quot;</code></li>
<li><code>-n --name</code>：应用的名称。查看应用信息的时候可以用到。</li>
<li><code>-o --output &lt;path&gt;</code>：标准输出日志文件的路径。</li>
<li><code>-e --error &lt;path&gt;</code>：错误输出日志文件的路径。</li>
<li><code>--interpreter &lt;interpreter&gt;</code>：the interpreter pm2 should use for executing app (bash, python…)。比如你用的 coffee script 来编写应用。</li>
</ul>
<h2 id="文件夹结构"><a href="#文件夹结构" class="headerlink" title="文件夹结构"></a>文件夹结构</h2><p>PM2 启动后，它将自动创建这些文件夹：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$HOME/.pm2：将包含所有PM2相关文件</span><br><span class="line"></span><br><span class="line">$HOME/.pm2/logs：将包含所有应用程序日志</span><br><span class="line"></span><br><span class="line">$HOME/.pm2/pids：将包含所有应用程序pids</span><br><span class="line"></span><br><span class="line">$HOME/.pm2/pm2.log：PM2 日志</span><br><span class="line"></span><br><span class="line">$HOME/.pm2/pm2.pid：PM2 pid</span><br><span class="line"></span><br><span class="line">$HOME/.pm2/rpc.sock：远程命令的套接字文件</span><br><span class="line"></span><br><span class="line">$HOME/.pm2/pub.sock：可发布事件的套接字文件</span><br><span class="line"></span><br><span class="line">$HOME/.pm2/conf.js：PM2配置</span><br></pre></td></tr></table></figure>

<p>在 Windows 中，$ HOME 环境变量可以是$ HOMEDRIVE + $ HOMEPATH</p>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><ul>
<li>查看应用列表（查看当前机器执行的所有进程）<br><code>pm2 list/ls/l</code></li>
<li>查看某个应用详情（查看某个进程信息）<br><code>pm2 show app_name|app_id</code>或者<code>pm2 describe app_name|app_id</code></li>
<li>重启<br><code>pm2 restart app.js</code>或<code>pm2 restart app_name|app_name</code></li>
<li>停止<br><code>pm2 stop app_name|app_id</code>或停止全部<code>pm2 stop all</code></li>
<li>删除<br>类似 pm2 stop，如下<br><code>pm2 delete app_name|app_id</code><br><code>pm2 delete all</code></li>
<li>日志查看<br>除了可以打开日志文件查看日志外，还可以通过<code>pm2 logs</code>来查看实时日志。这点对于线上问题排查非常重要。比如某个 node 服务突然异常重启了，那么可以通过 pm2 提供的日志工具来查看实时日志，看是不是脚本出错之类导致的异常重启。查看指定应用程序日志：<code>pm2 logs app_name|app_id</code>显示所有应用程序的日志：<code>pm2 logs</code></li>
</ul>
<h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><p>命令如下，表示开启三个进程。如果<code>-i 0</code>，则会根据机器当前核数自动开启尽可能多的进程。</p>
<p><code>pm2 start app.js -i 3</code> # 开启三个进程<br><code>pm2 start app.js -i max</code># 根据机器 CPU 核数，开启对应数目的进程</p>
<h2 id="开机自动启动"><a href="#开机自动启动" class="headerlink" title="开机自动启动"></a>开机自动启动</h2><p>可以通过<code>pm2 startup</code>来实现开机自启动。细节可参考。大致流程如下</p>
<p>通过<code>pm2 save</code>保存当前进程状态。</p>
<p>通过<code>pm2 startup [platform]</code>生成开机自启动的命令。（记得查看控制台输出）</p>
<p>将步骤 2 生成的命令，粘贴到控制台进行，搞定。</p>
<h2 id="监控-CPU-内存"><a href="#监控-CPU-内存" class="headerlink" title="监控 CPU/内存"></a>监控 CPU/内存</h2><p>运行如下命令，查看当前通过 pm2 运行的进程的状态。即可监控 CPU 和内存的使用情况，同时应用的报错信息也会打印在 Global Logs 窗口中，如下：</p>
<p><code>pm2 monit</code></p>
<h2 id="内存使用超过上限自动重启"><a href="#内存使用超过上限自动重启" class="headerlink" title="内存使用超过上限自动重启"></a>内存使用超过上限自动重启</h2><p>如果想要你的应用，在超过使用内存上限后自动重启，那么可以加上–max-memory-restart 参数。（有对应的配置项）</p>
<p><code>pm2 start big-array.js --max-memory-restart 20M</code></p>
<h2 id="pm2-编程接口"><a href="#pm2-编程接口" class="headerlink" title="pm2 编程接口"></a>pm2 编程接口</h2><p>如果想把 pm2 的进程监控，跟其他自动化流程整合起来，pm2 的编程接口就很有用了。细节可参考官方文档：<br><code>http://pm2.keymetrics.io/docs/usage/pm2-api/</code></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://a913481180.github.io/2023/01/01/00-00-00/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="KK">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KK">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/01/01/00-00-00/" class="post-title-link" itemprop="url">Python</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-01-01 00:00:00" itemprop="dateCreated datePublished" datetime="2023-01-01T00:00:00+08:00">2023-01-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-05-14 23:12:11" itemprop="dateModified" datetime="2024-05-14T23:12:11+08:00">2024-05-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python/" itemprop="url" rel="index"><span itemprop="name">python</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>python 国内常用镜像源</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">清华大学 ：https://pypi.tuna.tsinghua.edu.cn/simple/</span><br><span class="line">阿里云：http://mirrors.aliyun.com/pypi/simple/</span><br><span class="line">中国科学技术大学 ：http://pypi.mirrors.ustc.edu.cn/simple/</span><br><span class="line">华中科技大学：http://pypi.hustunique.com/</span><br><span class="line">豆瓣源：http://pypi.douban.com/simple/</span><br><span class="line">腾讯源：http://mirrors.cloud.tencent.com/pypi/simple</span><br><span class="line">华为镜像源：https://repo.huaweicloud.com/repository/pypi/simple/</span><br></pre></td></tr></table></figure>

<p>1、临时使用</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pip install [包名] -i [pip源URL]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例</span></span><br><span class="line">pip install pytest -i https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line">pip install -i https://pypi.tuna.tsinghua.edu.cn/simple pytest</span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line">pip install -r requirements.txt -i https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></table></figure>

<p>2、永久使用<br>前提 pip 版本 (&gt;=10.0.0) 方可使用此命令进行配置：</p>
<p>升级 pip 到最新的版本</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pip install pip -U</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line"></span><br><span class="line">python -m pip install --upgrade pip</span><br></pre></td></tr></table></figure>

<p>修改 pip 源为清华源</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip config <span class="built_in">set</span> global.index-url https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://a913481180.github.io/2022/12/12/22-23-33/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="KK">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KK">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/12/12/22-23-33/" class="post-title-link" itemprop="url">echarts/d3.js</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-12-12 22:23:33" itemprop="dateCreated datePublished" datetime="2022-12-12T22:23:33+08:00">2022-12-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-05-14 23:12:11" itemprop="dateModified" datetime="2024-05-14T23:12:11+08:00">2024-05-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/web/" itemprop="url" rel="index"><span itemprop="name">web</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="echarts"><a href="#echarts" class="headerlink" title="echarts"></a>echarts</h2><ol>
<li>echarts 的图表是画在 canvas 上的， 可以通过 grid 设置来调整图表与 canvas 的间距：grid:{ x:50, y:50,x2:50, y2:60,}</li>
<li>通过回调函数判断是否是第一个数据（params.dataIndex 的值）来决定是否显示相应的内容：formatter:(n)=&gt;{return n.dataIndex}</li>
<li>echarts3.0 已支持多标题的设置</li>
<li>Echarts 设置 tooltip 层级 z-index<br>tooltip 有一个 extraCssText 属性。所以可以设置该属性来修改它的样式：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tooltip:&#123;extraCssText:&#x27;z-index:2&#x27;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="svg-可缩放矢量图形（Scalable-Vector-Graphics）"><a href="#svg-可缩放矢量图形（Scalable-Vector-Graphics）" class="headerlink" title="svg 可缩放矢量图形（Scalable Vector Graphics）"></a>svg 可缩放矢量图形（Scalable Vector Graphics）</h2><h3 id="SVG-CSS-属性"><a href="#SVG-CSS-属性" class="headerlink" title="SVG CSS 属性"></a>SVG CSS 属性</h3><p>SVG 元素具有以下可以设置的 CSS 属性。并非所有元素都具有所有这些 CSS 属性。因此，CSS 属性被分为针对不同元素的多个表。</p>
<h4 id="形状-CSS-属性"><a href="#形状-CSS-属性" class="headerlink" title="形状 CSS 属性"></a>形状 CSS 属性</h4><p>path 元素和其他形状元素的 CSS 属性：</p>
<table>
<thead>
<tr>
<th>CSS 属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>fill</td>
<td>设置形状的填充颜色。</td>
</tr>
<tr>
<td>fill-opacity</td>
<td>设置形状的填充不透明度。</td>
</tr>
<tr>
<td>fill-rule</td>
<td>设置形状的填充规则。</td>
</tr>
<tr>
<td>marker</td>
<td>设置沿此形状的线（边）使用的标记。</td>
</tr>
<tr>
<td>marker-start</td>
<td>设置沿此形状的线（边）使用的开始标记。</td>
</tr>
<tr>
<td>marker-mid</td>
<td>设置沿此形状的线（边）使用的中间标记。</td>
</tr>
<tr>
<td>marker-end</td>
<td>设置沿此形状的线（边）使用的结束标记。</td>
</tr>
<tr>
<td>stroke</td>
<td>设置用于绘制此形状轮廓的笔触（线条）颜色。</td>
</tr>
<tr>
<td>stroke-dasharray</td>
<td>设置用于绘制此形状轮廓的笔划（虚线）。</td>
</tr>
<tr>
<td>stroke-dashoffset</td>
<td>设置用于绘制此形状轮廓的笔划（直线）破折号偏移量。</td>
</tr>
<tr>
<td>stroke-linecap</td>
<td>设置用于绘制此形状轮廓的笔划（线）线帽。有效值为 round，butt 和 square。</td>
</tr>
<tr>
<td>stroke-miterlimit</td>
<td>设置用于绘制此形状轮廓的笔划（直线）斜接限制。</td>
</tr>
<tr>
<td>stroke-opacity</td>
<td>设置用于绘制此形状轮廓的笔触（直线）不透明度。</td>
</tr>
<tr>
<td>stroke-width</td>
<td>设置用于绘制此形状轮廓的笔触（线条）宽度。</td>
</tr>
<tr>
<td>text-rendering</td>
<td>设置用于绘制此形状轮廓的文本渲染。</td>
</tr>
</tbody></table>
<p>文字 CSS 属性<br>text 元素的 CSS 属性：</p>
<table>
<thead>
<tr>
<th>CSS 属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>alignment-baseline</td>
<td>设置文本与其对齐方式 x 和 y 坐标。</td>
</tr>
<tr>
<td>baseline-shift</td>
<td>设置用于呈现文本的基线偏移。</td>
</tr>
<tr>
<td>dominant-baseline</td>
<td>设置主要基线。</td>
</tr>
<tr>
<td>glyph-orientation-horizontal</td>
<td>设置水平字形方向。</td>
</tr>
<tr>
<td>glyph-orientation-vertical</td>
<td>设置垂直字形方向。</td>
</tr>
<tr>
<td>kerning</td>
<td>设置渲染文本的字距（字距是字母间距）。</td>
</tr>
</tbody></table>
<p>渐变 CSS 属性<br>SVG 渐变的 CSS 属性：</p>
<table>
<thead>
<tr>
<th>CSS 属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>stop-color</td>
<td>设置在渐变中使用的 stop 元素中使用的终止色。</td>
</tr>
<tr>
<td>stop-opacity</td>
<td>设置 stop 在渐变中使用的元素中使用的停止不透明度。</td>
</tr>
</tbody></table>
<h4 id="class"><a href="#class" class="headerlink" title="class"></a>class</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns</span>=<span class="string">&quot;http://www.w3.org/2000/svg&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:xlink</span>=<span class="string">&quot;http://www.w3.org/1999/xlink&quot;</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="xml"></span></span><br><span class="line"><span class="xml">      &lt;![CDATA[</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">        circle.myGreen &#123;</span></span><br><span class="line"><span class="xml">           stroke: #006600;</span></span><br><span class="line"><span class="xml">           fill:   #00cc00;</span></span><br><span class="line"><span class="xml">        &#125;</span></span><br><span class="line"><span class="xml">       circle.myRed &#123;</span></span><br><span class="line"><span class="xml">       stroke: #660000;</span></span><br><span class="line"><span class="xml">       fill:   #cc0000;</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">      ]]&gt;</span></span><br><span class="line"><span class="xml">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">circle</span> <span class="attr">class</span>=<span class="string">&quot;myGreen&quot;</span> <span class="attr">cx</span>=<span class="string">&quot;40&quot;</span> <span class="attr">cy</span>=<span class="string">&quot;40&quot;</span> <span class="attr">r</span>=<span class="string">&quot;24&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">circle</span> <span class="attr">class</span>=<span class="string">&quot;myRed&quot;</span> <span class="attr">cx</span>=<span class="string">&quot;40&quot;</span> <span class="attr">cy</span>=<span class="string">&quot;100&quot;</span> <span class="attr">r</span>=<span class="string">&quot;24&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="style"><a href="#style" class="headerlink" title="style"></a>style</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">version</span>=<span class="string">&quot;1.1&quot;</span> <span class="attr">viewbox</span>=<span class="string">&quot;0 0 1000 500&quot;</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.w3.org/2000/svg&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">rect</span></span></span><br><span class="line"><span class="tag">    <span class="attr">height</span>=<span class="string">&quot;300&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">width</span>=<span class="string">&quot;600&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">x</span>=<span class="string">&quot;200&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">y</span>=<span class="string">&quot;100&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">style</span>=<span class="string">&quot;fill: red; stroke: blue; stroke-width: 3&quot;</span></span></span><br><span class="line"><span class="tag">  /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="svg"><a href="#svg" class="headerlink" title="svg"></a>svg</h3><p>属性</p>
<ul>
<li><code>width</code>宽</li>
<li><code>height</code>高</li>
<li><code>x</code>水平位置</li>
<li><code>y</code>垂直位置</li>
<li><code>version</code> 属性用于指明 SVG 文档遵循规范。它只允许在根元素<svg> 上使用。它纯粹是一个说明，对渲染或处理没有任何影响。虽然它接受任何数字，但是只有 1.0 和 1.1.这两个有效的选择。</li>
<li><code>viewBox</code> 属性允许指定一个给定的一组图形伸展以适应特定的容器元素(裁剪画面)。属性的值是一个包含 4 个参数的列表 min-x, min-y, width and height，以空格或者逗号分隔开，在用户空间中指定一个矩形区域映射到给定的元素,不允许宽度和高度为负值，0 则禁用元素的呈现。这个属性会受到 <code>preserveAspectRatio</code> 的影响。</li>
<li><code>preserveAspectRatio</code>:否强制进行统一缩放。</li>
</ul>
<h3 id="defs"><a href="#defs" class="headerlink" title="defs"></a>defs</h3><p>SVG 允许我们定义以后需要重复使用的图形元素。建议把所有需要再次使用的引用元素定义在 defs 元素里面。这样做可以增加 SVG 内容的易读性和无障碍。在 defs 元素中定义的图形元素不会直接呈现。你可以在你的视口的任意地方利用 <code>&lt;use&gt;</code>元素呈现这些元素。</p>
<h3 id="g"><a href="#g" class="headerlink" title="g"></a>g</h3><p>元素 g 是用来组合对象的容器。添加到 g 元素上的变换会应用到其所有的子元素上。添加到 g 元素的属性会被其所有的子元素继承。此外，g 元素也可以用来定义复杂的对象，之后可以通过<code>&lt;use&gt;</code>元素来引用它们。</p>
<h3 id="rect"><a href="#rect" class="headerlink" title="rect"></a>rect</h3><p>rect 元素是 SVG 的一个基本形状，用来创建矩形，基于一个角位置以及它的宽和高。它还可以用来创建圆角矩形</p>
<ul>
<li>x</li>
<li>y</li>
<li>width</li>
<li>height</li>
<li>rx 圆角</li>
<li>ry 圆角</li>
</ul>
<h3 id="patterns"><a href="#patterns" class="headerlink" title="patterns"></a>patterns</h3><p>在我看来 patterns（图案）是 SVG 中用到的最让人混淆的填充类型之一。它的功能非常强大，所以我认为他们值得讨论一下并且我们应至少对他们有最基本的了解。跟渐变一样，<code>&lt;pattern&gt;</code> 需要放在 SVG 文档的 <code>&lt;defs&gt;</code> 内部。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; standalone=&quot;no&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">&quot;200&quot;</span> <span class="attr">height</span>=<span class="string">&quot;200&quot;</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.w3.org/2000/svg&quot;</span> <span class="attr">version</span>=<span class="string">&quot;1.1&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">defs</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">linearGradient</span> <span class="attr">id</span>=<span class="string">&quot;Gradient1&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">stop</span> <span class="attr">offset</span>=<span class="string">&quot;5%&quot;</span> <span class="attr">stop-color</span>=<span class="string">&quot;white&quot;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">stop</span> <span class="attr">offset</span>=<span class="string">&quot;95%&quot;</span> <span class="attr">stop-color</span>=<span class="string">&quot;blue&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">linearGradient</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">linearGradient</span> <span class="attr">id</span>=<span class="string">&quot;Gradient2&quot;</span> <span class="attr">x1</span>=<span class="string">&quot;0&quot;</span> <span class="attr">x2</span>=<span class="string">&quot;0&quot;</span> <span class="attr">y1</span>=<span class="string">&quot;0&quot;</span> <span class="attr">y2</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">stop</span> <span class="attr">offset</span>=<span class="string">&quot;5%&quot;</span> <span class="attr">stop-color</span>=<span class="string">&quot;red&quot;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">stop</span> <span class="attr">offset</span>=<span class="string">&quot;95%&quot;</span> <span class="attr">stop-color</span>=<span class="string">&quot;orange&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">linearGradient</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">pattern</span> <span class="attr">id</span>=<span class="string">&quot;Pattern&quot;</span> <span class="attr">x</span>=<span class="string">&quot;0&quot;</span> <span class="attr">y</span>=<span class="string">&quot;0&quot;</span> <span class="attr">width</span>=<span class="string">&quot;.25&quot;</span> <span class="attr">height</span>=<span class="string">&quot;.25&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">rect</span> <span class="attr">x</span>=<span class="string">&quot;0&quot;</span> <span class="attr">y</span>=<span class="string">&quot;0&quot;</span> <span class="attr">width</span>=<span class="string">&quot;50&quot;</span> <span class="attr">height</span>=<span class="string">&quot;50&quot;</span> <span class="attr">fill</span>=<span class="string">&quot;skyblue&quot;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">rect</span> <span class="attr">x</span>=<span class="string">&quot;0&quot;</span> <span class="attr">y</span>=<span class="string">&quot;0&quot;</span> <span class="attr">width</span>=<span class="string">&quot;25&quot;</span> <span class="attr">height</span>=<span class="string">&quot;25&quot;</span> <span class="attr">fill</span>=<span class="string">&quot;url(#Gradient2)&quot;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">circle</span></span></span><br><span class="line"><span class="tag">        <span class="attr">cx</span>=<span class="string">&quot;25&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">cy</span>=<span class="string">&quot;25&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">r</span>=<span class="string">&quot;20&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">fill</span>=<span class="string">&quot;url(#Gradient1)&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">fill-opacity</span>=<span class="string">&quot;0.5&quot;</span></span></span><br><span class="line"><span class="tag">      /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">defs</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">rect</span></span></span><br><span class="line"><span class="tag">    <span class="attr">fill</span>=<span class="string">&quot;url(#Pattern)&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">stroke</span>=<span class="string">&quot;black&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">x</span>=<span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">y</span>=<span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">width</span>=<span class="string">&quot;200&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">height</span>=<span class="string">&quot;200&quot;</span></span></span><br><span class="line"><span class="tag">  /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>关于 pattern 容易混淆的事是，pattern 定义了一个单元系统以及他们的大小。上例中，我们在 pattern 元素上定义了 width 和 height 属性，用于描述在重复下一个图案之前应该跨过多远。如果你想要在绘制时偏移矩形的开始点，也可以使用 x 和 y 属性，原因如下。</p>
<p>就像前面使用了 gradientUnits 属性，同样的 pattern 也有一个属性 patternUnits 用于描述我们使用的属性单元。这同之前使用的 objectBoundingBox 默认值一样，所以当一个值为 1 时，它被缩放到应用 pattern 对象的宽高值。因此，我们希望 pattern 垂直和水平的重复 4 次，所以宽高被设置位 0.25，这一位置 pattern 的宽高仅为总外框大小的 0.25。</p>
<p>与渐变不同，pattern 有第二个属性 patternContentUnits，它描述了 pattern 元素基于基本形状使用的单元系统，这个属性默认值为 userSpaceOnUse，与 patternUnits 属性相反，这意味着除非你至少指定其中一个属性值（patternContentUnits 或 patternUnits），否则在 pattern 中绘制的形状将与 pattern 元素使用的坐标系不同，当你手写这部分时会容易混淆。为了使上例生效，我们必须考虑我们的边框（200 像素）大小和我们实际希望 pattern 垂直和水平重复 4 次的需求。这意味着每个 pattern 单元应该是 50x50 的方形，pattern 中的两个矩形和圆形的大小会被缩放适应到一个 50x50 的边框里，任何我们绘制在边框外的内容都不会显示。因为我们希望 pattern 从边框的左上角里开始，所以 pattern 也必须偏移 10 像素，也就是 pattern 的 x 和 y 属性需要调整为 10/200=0.05。</p>
<p>如果对象改变了大小，pattern 会自适应其大小，但是对象里面的内容不会自适应。所以当我们在 pattern 中还是放置 4 个重复的 pattern 时，组成 pattern 的对象将不会保持相同的大小，同时在他们之间会有大片空白区域。通过改变 patternContentUnits 属性，我们可以把所有的元素放到相同的单元系统中：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">pattern</span></span></span><br><span class="line"><span class="tag">  <span class="attr">id</span>=<span class="string">&quot;Pattern&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">width</span>=<span class="string">&quot;.25&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">height</span>=<span class="string">&quot;.25&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">patternContentUnits</span>=<span class="string">&quot;objectBoundingBox&quot;</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">rect</span> <span class="attr">x</span>=<span class="string">&quot;0&quot;</span> <span class="attr">y</span>=<span class="string">&quot;0&quot;</span> <span class="attr">width</span>=<span class="string">&quot;.25&quot;</span> <span class="attr">height</span>=<span class="string">&quot;.25&quot;</span> <span class="attr">fill</span>=<span class="string">&quot;skyblue&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">rect</span> <span class="attr">x</span>=<span class="string">&quot;0&quot;</span> <span class="attr">y</span>=<span class="string">&quot;0&quot;</span> <span class="attr">width</span>=<span class="string">&quot;.125&quot;</span> <span class="attr">height</span>=<span class="string">&quot;.125&quot;</span> <span class="attr">fill</span>=<span class="string">&quot;url(#Gradient2)&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">circle</span></span></span><br><span class="line"><span class="tag">    <span class="attr">cx</span>=<span class="string">&quot;.125&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">cy</span>=<span class="string">&quot;.125&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">r</span>=<span class="string">&quot;.1&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">fill</span>=<span class="string">&quot;url(#Gradient1)&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">fill-opacity</span>=<span class="string">&quot;0.5&quot;</span></span></span><br><span class="line"><span class="tag">  /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>现在，因为 pattern 内容与 pattern<br>本身处于相同的单元系统中，所以我们不用偏移边框以使 pattern<br>在正确的位置上开始，并且即使对象变大，pattern 也会自动的缩放以保证 pattern<br>内部的对象数目和重复不变。这与 userSpaceOnUse 系统不同，userSpaceOnUse<br>系统中如果对象改变大小，pattern 本身会保持不变，只是重复更多次去填满边框。<br>它有一点点的副作用，在 Gecko 中的圆如果半径设置得小于<br>0.075（尽管半径应该设置的比这个值大得多。这个可能是 pattern 元素中的一个<br>bug，或者也不算<br>bug，我也不太清楚）的话绘制的时候可能会出现问题，为了规避这个问题，可能最好的办法是尽量避免在<br>objectBoundingBox 单元中绘制图形。 在你想要使用 pattern<br>的时候，可能你并不中意这些方法中的任何一个，Pattern<br>通常都是有确认的大小并且重复他们自己，与对象形状独立开来。要想创建这种<br>pattern，pattern<br>和它的内容必须在当前用户空间中绘制，这样当对象在做如下操作时他们才不会改变形状：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">pattern</span></span></span><br><span class="line"><span class="tag">  <span class="attr">id</span>=<span class="string">&quot;Pattern&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">x</span>=<span class="string">&quot;10&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">y</span>=<span class="string">&quot;10&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">width</span>=<span class="string">&quot;50&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">height</span>=<span class="string">&quot;50&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">patternUnits</span>=<span class="string">&quot;userSpaceOnUse&quot;</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">rect</span> <span class="attr">x</span>=<span class="string">&quot;0&quot;</span> <span class="attr">y</span>=<span class="string">&quot;0&quot;</span> <span class="attr">width</span>=<span class="string">&quot;50&quot;</span> <span class="attr">height</span>=<span class="string">&quot;50&quot;</span> <span class="attr">fill</span>=<span class="string">&quot;skyblue&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">rect</span> <span class="attr">x</span>=<span class="string">&quot;0&quot;</span> <span class="attr">y</span>=<span class="string">&quot;0&quot;</span> <span class="attr">width</span>=<span class="string">&quot;25&quot;</span> <span class="attr">height</span>=<span class="string">&quot;25&quot;</span> <span class="attr">fill</span>=<span class="string">&quot;url(#Gradient2)&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">circle</span> <span class="attr">cx</span>=<span class="string">&quot;25&quot;</span> <span class="attr">cy</span>=<span class="string">&quot;25&quot;</span> <span class="attr">r</span>=<span class="string">&quot;20&quot;</span> <span class="attr">fill</span>=<span class="string">&quot;url(#Gradient1)&quot;</span> <span class="attr">fill-opacity</span>=<span class="string">&quot;0.5&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>当然，这意味着如果你后续改变了对象大小，pattern 也不会缩放。上述三个举例在下图中放在一个矩形中展示，高度被轻微拉伸到 300px，但是我注意到这不是完整的图片，并且有些其他选项可能你的应用不支持。</p>
<h2 id="d3-js"><a href="#d3-js" class="headerlink" title="d3.js"></a>d3.js</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/d3/d3/blob/main/API.md#dragging-d3-drag">https://github.com/d3/d3/blob/main/API.md#dragging-d3-drag</a></p>
</blockquote>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p><code>npm install d3</code>命令<br><code>&lt;script src=&quot;https://d3js.org/d3.v4.min.js&quot;&gt;&lt;/script&gt;</code></p>
<h3 id="选择元素"><a href="#选择元素" class="headerlink" title="选择元素"></a>选择元素</h3><blockquote>
<p>采用了链式语法。就是说，每次打点调用 d3 提供的函数方法，都会返回一个 d3 对象，这样可以继续调用 d3 的其他函数方法</p>
</blockquote>
<ul>
<li><code>select</code> 返回 css 选择器所匹配的第一个元素。</li>
<li><code>selectAll</code> 返回 css 选择器匹配的所有元素。<br>这两个函数返回的结果称为选择集。</li>
</ul>
<h3 id="操作元素"><a href="#操作元素" class="headerlink" title="操作元素"></a>操作元素</h3><ul>
<li>增加 ( append )元素后添加</li>
<li>插入 ( insert )元素前添加</li>
<li>删除元素 ( remove )</li>
<li>设置获取元素属性 ( attr )。</li>
<li>设置获取元素样式 ( style )。</li>
</ul>
<h3 id="数据绑定"><a href="#数据绑定" class="headerlink" title="数据绑定"></a>数据绑定</h3><blockquote>
<p>D3 有一个很独特的功能：能将数据绑定到 DOM 上，也就是绑定到文档上。这么说可能不好理解，例如：网页中有段落元素 <code>&lt;p&gt;</code> 和一个整数 5，于是可以将整数 5 与 <code>&lt;p&gt;</code>绑定到一起。绑定之后，当需要依靠这个数据才操作元素的时候，会很方便。数据就会添加到 DOM 元素的<code>__data__</code>属性中</p>
</blockquote>
<ul>
<li><code>datum(value)</code> 绑定一个数据到选择集上</li>
</ul>
<blockquote>
<p>这个方法不会进行数据绑定的计算(update、enter、exit)，只能在现有的元素上绑定数据。如果 value 是数组会自动转成字符串。<br>　　假设有一字符串 China，要将此字符串分别与三个段落元素绑定，代码如下：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;China&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> body = d3.select(<span class="string">&quot;body&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> p = body.selectAll(<span class="string">&quot;p&quot;</span>);</span><br><span class="line"></span><br><span class="line">p.datum(str);</span><br><span class="line"></span><br><span class="line">p.text(<span class="function"><span class="keyword">function</span>(<span class="params">d, i</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;第 &quot;</span>+ i + <span class="string">&quot; 个元素绑定的数据是 &quot;</span> + d;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">绑定数据后，使用此数据来修改三个段落元素的内容，其结果如下：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">第 0 个元素绑定的数据是 China</span></span><br><span class="line"><span class="comment">第 1 个元素绑定的数据是 China</span></span><br><span class="line"><span class="comment">第 2 个元素绑定的数据是 China</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">　　在上面的代码中，用到了一个无名函数 function(d, i)。当选择集需要使用被绑定的数据时，常需要这么使用。其包含两个参数，其中：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">　　（1）d 代表数据，也就是与某元素绑定的数据。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">　　（2） i 代表索引，代表数据的索引号，从 0 开始。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">　　例如，上述例子中：第 0 个元素 apple 绑定的数据是 China。</span></span><br><span class="line"><span class="comment"> * /</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>data([value])</code> 绑定一个数组到选择集上，数组的各项值分别与选择集的各元素绑定</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dataset = [<span class="string">&quot;I like dogs&quot;</span>, <span class="string">&quot;I like cats&quot;</span>, <span class="string">&quot;I like snakes&quot;</span>];</span><br><span class="line"><span class="keyword">var</span> body = d3.select(<span class="string">&quot;body&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> p = body.selectAll(<span class="string">&quot;p&quot;</span>);</span><br><span class="line"></span><br><span class="line">p.data(dataset).text(<span class="function"><span class="keyword">function</span> (<span class="params">d, i</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> d;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">当 i == 0 时， d 为 I like dogs。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">　　当 i == 1 时， d 为 I like cats。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">　　当 i == 2 时， d 为 I like snakes。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<ul>
<li>selection.data([data[, key]]) 1.如果选择集中只有一个分组，则入参 data 应该是一个数组，该数组会与选择集中的元素进行绑定。 2.如果选择集中含有多个分组（使用方法 selection.selectAll() 嵌套选择生成的选择集可能含有多个分组），则入参 data 应该是一个返回数组的函数，每一个分组都会调用该方法，并依次传入三个参数：</li>
</ul>
<p>当前所遍历的分组的父节点所绑定的数据 datum<code>d</code><br>当前所遍历的分组的索引 index <code>i</code><br>选择集的所有父节点 parent nodes <code>nodes</code></p>
<p>其中函数内的 <code>this</code> 指向当前所遍历的分组的父节点，即与 nodes[i] 相同<br>最后该函数返回一个数组，然后该数组的元素就用于与该分组的元素进行绑定</p>
<hr>
<p>默认基于索引来对选择集中的元素和数组中的数据进行匹配 join-by-index，即选择集的第一个元素和数组的第一个数据进行绑定，并依次类推，但我们可以通过第二个入参 key 来自定义匹配规则。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> data = [</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">&quot;Locke&quot;</span>, <span class="attr">number</span>: <span class="number">4</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">&quot;Reyes&quot;</span>, <span class="attr">number</span>: <span class="number">8</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">&quot;Ford&quot;</span>, <span class="attr">number</span>: <span class="number">15</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">&quot;Jarrah&quot;</span>, <span class="attr">number</span>: <span class="number">16</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">&quot;Shephard&quot;</span>, <span class="attr">number</span>: <span class="number">23</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">&quot;Kwon&quot;</span>, <span class="attr">number</span>: <span class="number">42</span> &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">d3.selectAll(<span class="string">&quot;div&quot;</span>)</span><br><span class="line">  .data(data, <span class="function"><span class="keyword">function</span> (<span class="params">d</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// key 函数，如果传入的 d 存在，则取其属性 name 作为键</span></span><br><span class="line">    <span class="comment">// 否则取元素的 id 属性（这是一个回退操作，因为在初始时，元素还没有绑定数据，所以 d 是 undefined）</span></span><br><span class="line">    <span class="keyword">return</span> d ? d.name : <span class="built_in">this</span>.id;</span><br><span class="line">  &#125;)</span><br><span class="line">  .text(<span class="function">(<span class="params">d</span>) =&gt;</span> d.number);</span><br></pre></td></tr></table></figure>

<hr>
<p>元素在绑定数据时，并不一定是一一对应的，可能会出现节点和数据元素个数不匹配的问题，针对这个问题，D3 提出三个概念：</p>
<p>如果 DOM 节点多出来，则未绑定数据的节点会进入名为 <code>exiting</code> 选择集（准备从页面「离去」的节点，一般在后续操作中删除）<br>如果数据元素多出来了，则对应多出来的「虚拟节点」会进入名为 <code>entering</code> 选择集（一般会在后续操作中实例化这些 DOM 节点，并插入在页面的相应位置）<br>可与数据对应上的 DOM 节点，进入名为 <code>updating</code>选择集，它是默认选择集，即 selection.data() 方法返回的对象就是 <code>update</code> 选择集（而 <code>enter</code> 选择集和 <code>exit</code> 选择集需要调用该对象的 enter() 和 exit() 方法才能获得）</p>
<hr>
<h2 id="在绑定数据后，D3-没有立即更新（增删）页面节点，而是生成-3-个选择集，这样为数据可视化提供了更大的灵活度和可定制性，例如对于-exiting-选择集的节点，可以在删除时设置一些淡出的动效；对于-entering-选择集的节点可以设置不一样的颜色，高亮出来它们是新增到页面上的"><a href="#在绑定数据后，D3-没有立即更新（增删）页面节点，而是生成-3-个选择集，这样为数据可视化提供了更大的灵活度和可定制性，例如对于-exiting-选择集的节点，可以在删除时设置一些淡出的动效；对于-entering-选择集的节点可以设置不一样的颜色，高亮出来它们是新增到页面上的" class="headerlink" title="在绑定数据后，D3 没有立即更新（增删）页面节点，而是生成 3 个选择集，这样为数据可视化提供了更大的灵活度和可定制性，例如对于 exiting 选择集的节点，可以在删除时设置一些淡出的动效；对于 entering 选择集的节点可以设置不一样的颜色，高亮出来它们是新增到页面上的"></a>在绑定数据后，D3 没有立即更新（增删）页面节点，而是生成 3 个选择集，这样为数据可视化提供了更大的灵活度和可定制性，例如对于 exiting 选择集的节点，可以在删除时设置一些淡出的动效；对于 entering 选择集的节点可以设置不一样的颜色，高亮出来它们是新增到页面上的</h2><p>选择集绑定数据后，返回的三个选择集 entering、exiting、updating 其中的元素次序会有所不同：</p>
<p>1.其中选择集 entering 和 updating 中元素会根据其绑定的数据在新数组中的索引顺序进行排列，而且会在相应的位置「留空」（使用 null 作为占位符），便于后续两者合并 merge 2.而 exiting 选择集会根据其原来绑定的数据在原来的数组中的位置来排序，也是在相应的位置「留空」，以便保持元素原有的索引值。<br>然后将 entering 选择集的「虚拟节点」添加 append 到页面时，元素会基于索引顺序「混入」页面的 updating 选择集的元素中（作为兄弟元素），这样可以确保最后页面的元素顺序与它们所绑定的数据在数组顺序一致。<br>但是由于 D3 会复用 updating 选择集的元素（以便提高性能），对于 updating 选择集中的元素，如果在新绑定的数组中，它们所对应的数据的索引发生了变化时，页面的相应元素的次序并不会更新，如果不进行「重排」，可能造成最后页面的元素无法与它们所绑定的数据在数组顺序一致。因此一般在选择集绑定新数据后调用 selection.order() 方法，以更新 updating 选择集在页面的元素的顺序</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/RRie1/article/details/119315788#:~:text=%E8%A7%A3%E5%86%B3%E6%96%B9%E5%BC%8F%20-%3E%20%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E7%9A%84%E7%BB%91%E5%AE%9A%E5%87%BD%E6%95%B0%E4%B8%BAdata%EF%BC%88data%2C,keyFunction%EF%BC%89%EF%BC%8C%E4%BD%BF%E7%94%A8keyFuntion%20%E4%B8%BA%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9Akey%E3%80%82%20%2F%2F%E6%AD%A3%E7%A1%AE%E7%BB%91%E5%AE%9A%E6%96%B9%E5%BC%8Fd3.selectAll%28%27rect%27%29.data%28data%2Cd%3D%3Ed.name%29.attr%28%27width%27%2Cd%3D%3Ed.value%29">more</a><br><a target="_blank" rel="noopener" href="https://juejin.cn/post/6999509011687014414">more</a></p>
<h3 id="绑定事件"><a href="#绑定事件" class="headerlink" title="绑定事件"></a>绑定事件</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">d3.select(<span class="string">&quot;svg rect&quot;</span>).on(<span class="string">&quot;click&quot;</span>, <span class="function">(<span class="params">event, data</span>) =&gt;</span> &#123;</span><br><span class="line">  d3.select(event.target);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="Panning-平移和-Zooming-缩放"><a href="#Panning-平移和-Zooming-缩放" class="headerlink" title="Panning 平移和 Zooming 缩放"></a>Panning 平移和 Zooming 缩放</h3><h4 id="创建缩放器"><a href="#创建缩放器" class="headerlink" title="创建缩放器"></a>创建缩放器</h4><blockquote>
<p>会和 mouseup 事件冲突</p>
</blockquote>
<p>使用方法 d3.zoom() 创建一个缩放器（以下称为 zoom）<br>它既是一个方法，可以接收选择集作为参数 zoom(selection)，为选择集中的元素（一般是包含数据的容器 <g> 元素）添加相应的缩放事件监听器，并为它们设置变换 transform 的初始值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一般通过 selection.call() 方法调用缩放器创建函数</span></span><br><span class="line"><span class="comment">// 这样 selection 选择集就会作为参数传递给缩放器创建函数</span></span><br><span class="line">selection.call(d3.zoom().on(<span class="string">&quot;zoom&quot;</span>, zoomed));</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">zoomed</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    g.attr(<span class="string">&quot;transform&quot;</span>, event.transform);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">如果希望移除缩放相关事件的监听器，可以为将相应事件回调函数设置为 <span class="literal">null</span></span><br><span class="line">selection.on(<span class="string">&quot;.zoom&quot;</span>, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以只移除特定的缩放事件的监听器，如滚轮缩放</span></span><br><span class="line">selection.on(<span class="string">&quot;wheel.zoom&quot;</span>, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>d3.zoomIdentity<br>在 d3.js 进行缩放的时候，有一个缩放的中心点，我们在 demo 进行测试的时候就会发现，这个缩放的中心点就是鼠标所在的位置，在鼠标所在的位置局部放大和缩小。<br>在默认情况下，这种中心点的位置在 svg 的[width/2,height/2]的位置，例如调用 scaleTo,scaleBy 方法的时候，就是已 svg 的中心为缩放的中心进行缩放；如果是调用 d3.zoomIdentity.scale(2)进行缩放，那么缩放的中心点则为[0,0]:<br>因为 d3.zoomIdentity 表示的是坐标位置[0,0]，当前缩放为 1 的一种状态，因此它将缩放中心的位置定在了[0,0]。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//直接缩放</span></span><br><span class="line">svg.call(</span><br><span class="line">    zoom.transform,</span><br><span class="line">    d3.zoomIdentity.translate(<span class="number">100</span>，<span class="number">100</span>)</span><br><span class="line">);</span><br><span class="line"><span class="comment">//多少时间内完成缩放</span></span><br><span class="line">svg.transition().duration(<span class="number">1000</span>).call(</span><br><span class="line">    zoom.transform,</span><br><span class="line">    d3.zoomIdentity.translate(<span class="number">100</span>，<span class="number">100</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h4 id="移除缩放"><a href="#移除缩放" class="headerlink" title="移除缩放"></a>移除缩放</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">d3.select(<span class="string">&quot;svg&quot;</span>).on(<span class="string">&quot;.zoom&quot;</span>, <span class="literal">null</span>);</span><br><span class="line"><span class="comment">//重新绑定</span></span><br><span class="line">d3.select(<span class="string">&quot;svg&quot;</span>).call(d3.zoom());</span><br></pre></td></tr></table></figure>

<h4 id="约束缩放"><a href="#约束缩放" class="headerlink" title="约束缩放"></a>约束缩放</h4><ul>
<li>zoom.constrain([constrain]) 对缩放平移操作进行约束。<br>其入参是一个函数，该函数依次接收三个参数，最后返回一个经过约束的变换值：</li>
</ul>
<p>transform 原本需要执行的缩放变换对象<br>extent 视图范围<br>translateExtent 平移的范围</p>
<p>默认的约束函数如下，其作用是确保视图范围不大于可平移的范围，这样用户就可以通过移动，将图像的各个部分移到视图的任何地方</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">constrain</span>(<span class="params">transform, extent, translateExtent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> dx0 = transform.invertX(extent[<span class="number">0</span>][<span class="number">0</span>]) - translateExtent[<span class="number">0</span>][<span class="number">0</span>],</span><br><span class="line">    dx1 = transform.invertX(extent[<span class="number">1</span>][<span class="number">0</span>]) - translateExtent[<span class="number">1</span>][<span class="number">0</span>],</span><br><span class="line">    dy0 = transform.invertY(extent[<span class="number">0</span>][<span class="number">1</span>]) - translateExtent[<span class="number">0</span>][<span class="number">1</span>],</span><br><span class="line">    dy1 = transform.invertY(extent[<span class="number">1</span>][<span class="number">1</span>]) - translateExtent[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">return</span> transform.translate(</span><br><span class="line">    dx1 &gt; dx0 ? (dx0 + dx1) / <span class="number">2</span> : <span class="built_in">Math</span>.min(<span class="number">0</span>, dx0) || <span class="built_in">Math</span>.max(<span class="number">0</span>, dx1),</span><br><span class="line">    dy1 &gt; dy0 ? (dy0 + dy1) / <span class="number">2</span> : <span class="built_in">Math</span>.min(<span class="number">0</span>, dy0) || <span class="built_in">Math</span>.max(<span class="number">0</span>, dy1)</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>zoom.extent([extent]) 设置视图范围 viewport extent。<br>参数 extent 是一个数组 [[x0, y0], [x1, y1]]，其中 [x0, y0] 表示视图范围的左上角，而 [x1, y1] 表示视图范围的右下角。<br>参数 extent 也可以是一个返回数组的函数，它会被选择集中的元素依次调用，并传递当前所遍历的元素所绑定的数据 datum d 作为参数。而函数内的 this 指向当前所遍历的元素节点。<br>💡 如果缩放器绑定的是普通的 HTML 元素，则视图范围的默认值 [[0, 0], [width, height]] 即与元素的宽高大小相同；如果缩放器绑定的是 SVG 类型的元素，则视图范围的默认值是 SVG 的 viewBox（如果没有设置 viewBox 属性，就使用 SVG 的宽高，即 viewport）。<br>视图的范围 viewport extent 对于一些函数有影响，如通过 zoom.scaleBy() 和 zoom.scaleTo() 方法触发的变换，其视图的中心会保持不变；视图中心和大小会影响使用插值器 d3.interpolateZoom 创建的过渡动画的路径；而平移范围 translate extent 的约束需要依赖视图范围（平移范围应该大于视图范围）。</p>
</li>
<li><p>zoom.translateExtent([extent]) 设置平移范围 translate extent。<br>参数 extent 是一个数组 [[x0, y0], [x1, y1]]，其中 [x0, y0] 表示平移范围的左上角，而 [x1, y1] 表示平移范围的右下角。默认值是 [[-∞, -∞], [+∞, +∞]]<br>💡 该方法虽然约束的是平移操作，但可能造成缩小时平移的发生。<br>⚠️ 该约束在通过 zoom.scaleBy()、zoom.scaleTo()、zoom.translateBy() 方法执行变换时生效；但是通过 zoom.transform() 方法执行变换时不生效</p>
</li>
</ul>
<p>以上三个方法提及的两个特殊的范围：viewport extent 视图范围、translate extent 平移范围。通过设置视图范围的大小，以及通过平移范围来约束视图（范围，一个数组）可以修改的位置，可以间接来限制元素可以平移的位置，通过这两个特殊范围的配合可以实现特定的元素不被移出画面外这一需求。</p>
<ul>
<li>zoom.scaleExtent([extent]) 设置缩放比例的范围。参数 extent 是一个的数组 [k0, k1]，表示缩放比例的范围，其中 k0 是可设置的最小缩放比例，k1 是可设置的最大缩放比例。默认范围是 [0,∞][0,\infty ][0,∞]<br>如果达到了约束的缩放比例极限时，即使用户继续滑动鼠标滚轮，缩放变换也会被忽略。<br>💡 以上方法限制视图的缩放，但可能会造成一个「副作用」，即当视图缩放达到了约束的缩放比例极限时，用户还继续滚动就会造成页面的滚动（如果当时页面是可滚动的），如果希望修正这个「副作用」，可以在相应的选择集上监听 wheel 事件并取消它的默认行为</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">selection</span><br><span class="line">  .on(zoom) <span class="comment">// 为选择集的元素设置了缩放监听器后，取消 wheel 事件的默认行为</span></span><br><span class="line">  .on(<span class="string">&quot;wheel&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> event.preventDefault());</span><br></pre></td></tr></table></figure>

<p>该约束在通过 zoom.scaleBy()、zoom.scaleTo()、zoom.translateBy() 方法执行变换时生效；但是通过 zoom.transform() 方法执行变换时不生效</p>
<ul>
<li>zoom.filter[(filter)] 用于判断是否执行缩放变换操作。参数 filter 是一个返回布尔值的函数，当返回的是 falsy 时忽略变换操作。它用以限制特定条件下不响应缩放变换操作。<br>函数 filter 接收当前的缩放事件 event 和当前调用缩放器的选择集的元素所绑定的数据 datum d 作为参数，而函数内的 this 指向当前元素节点。<br>其默认值如下，因此按下 Ctrl（但是可以在滚动鼠标滑轮时按下 Ctrl）或使用鼠标的次级按键（对于右手用户，次级按键一般是指鼠标的右键）时，默认是无法进行缩放平移操作，因为这些操作一般有其他用途</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">filter</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 对于设置为右手操作的鼠标</span></span><br><span class="line">  <span class="comment">// 当使用左键时，event.button 为 0</span></span><br><span class="line">  <span class="comment">// 当使用右键时，event.button 为 2</span></span><br><span class="line">  <span class="keyword">return</span> (!event.ctrlKey || event.type === <span class="string">&quot;wheel&quot;</span>) &amp;&amp; !event.button;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>zoom.wheelDelta([delta]) 设置鼠标滚轮的每次滚动的 delta 值，参数 delta 是一个函数，最后返回修改后的 delta 值 Δ\Delta Δ。<br>参数 delta 默认值如下</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">wheelDelta</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    -event.deltaY * (event.deltaMode === <span class="number">1</span> ? <span class="number">0.05</span> : event.deltaMode ? <span class="number">1</span> : <span class="number">0.002</span>)</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该值用于在鼠标滚轮时计算缩放比例 k×2Δk\times 2^{\Delta}k×2Δ（其中 kkk 是原始的缩放比例），例如当 Δ=1\Delta = 1Δ=1 时，视图的元素会缩小一半；当 Δ=−1\Delta = -1Δ=−1 时，视图的元素会放大一倍</p>
<ul>
<li><p>zoom.clickDistance([distance]) 设置点击事件中，鼠标按下与放开鼠标之间允许的最大距离（该距离通过点击事件的 event.clientX、event.clientY 计算得到），如果大于等于该距离，就不会抛出点击事件。<br>💡 可以想象以鼠标按下点为圆心，以参数 distance 为半径，在该圆内释放鼠标，都会抛出点击事件，在圆外（或圆周上）放开鼠标，点击事件都会被忽略（因为此时更应该触发拖拽事件）。参数默认值 distance 是 0<br>该方法可用于优化点击放大的场景，而原始画面中有大量较小的元素，从鼠标的按下到释放可能会发生微小的移动，避免识别为对该元素的拖拽操作，可以通过设置「可移动式点击的最大距离」，来区分点击事件和拖拽事件。</p>
</li>
<li><p>zoom.tapDistance([distance]) 对于触屏设备在双击时，两次点击允许的最大距离（该距离通过首次点击的 touchstart 和第二次点击的 touchend 事件的 event.clientX、event.clientY 计算得到），如果大于等于该距离，就不会抛出 dblclick 双击事件。<br>💡 其应用场景和前一个方法类似，一般是为了区分双击事件和拖拽事件，参数默认值 distance 是 10</p>
</li>
</ul>
<h3 id="比例尺"><a href="#比例尺" class="headerlink" title="比例尺"></a>比例尺</h3><h4 id="线性比例尺"><a href="#线性比例尺" class="headerlink" title="线性比例尺"></a>线性比例尺</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> scale = d3.scaleLinear().domain([<span class="number">0</span>, <span class="number">10000</span>]).range([<span class="number">0</span>, <span class="number">100</span>]);</span><br></pre></td></tr></table></figure>

<p>其中 scaleLinear() 对应法则，domain() 是定义域，range() 是值域。</p>
<h3 id="坐标轴"><a href="#坐标轴" class="headerlink" title="坐标轴"></a>坐标轴</h3><p>D3 中提供了专门的坐标轴模块 d3-axis，只需要几行代码就可以生成各种各样的坐标轴。一般情况下，坐标轴要与比例尺一起使用。记住这句话，离开比例尺的坐标轴就是耍流氓。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://a913481180.github.io/2022/12/12/12-34-21/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="KK">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KK">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/12/12/12-34-21/" class="post-title-link" itemprop="url">Java</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-12-12 12:34:21" itemprop="dateCreated datePublished" datetime="2022-12-12T12:34:21+08:00">2022-12-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-05-14 23:12:11" itemprop="dateModified" datetime="2024-05-14T23:12:11+08:00">2024-05-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1><h2 id="编写-Java-程序时，应注意以下几点"><a href="#编写-Java-程序时，应注意以下几点" class="headerlink" title="编写 Java 程序时，应注意以下几点"></a>编写 Java 程序时，应注意以下几点</h2><ul>
<li><p>大小写敏感：Java 是大小写敏感的，这就意味着标识符 Hello 与 hello 是不同的。</p>
</li>
<li><p>类名：对于所有的类来说，类名的首字母应该大写。如果类名由若干单词组成，那么每个单词的首字母应该大写，例如 MyFirstJavaClass 。</p>
</li>
<li><p>方法名：所有的方法名都应该以小写字母开头。如果方法名含有若干单词，则后面的每个单词首字母大写。</p>
</li>
<li><p>源文件名：源文件名必须和类名相同。当保存文件的时候，你应该使用类名作为文件名保存（切记 Java 是大小写敏感的），文件名的后缀为 .java。（如果文件名和类名不相同则会导致编译错误）。</p>
<p><code>MyClass.java</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\Your Name&gt;javac MyClass.java</span><br><span class="line"><span class="comment"># 这将编译您的代码。如果代码中没有错误，命令提示符将引导您进入下一行。现在输入 &quot;java MyClass&quot; 以运行该文件</span></span><br><span class="line">C:\Users\Your Name&gt;java MyClass</span><br></pre></td></tr></table></figure></li>
<li><p>主方法入口：所有的 Java 程序由 public static void main(String[] args) 方法开始执行。</p>
</li>
<li><p>每个 Java 程序都有一个必须与文件名匹配的 class 类名，并且每个程序都必须包含 main()方法</p>
</li>
</ul>
<h2 id="Java-标识符"><a href="#Java-标识符" class="headerlink" title="Java 标识符"></a>Java 标识符</h2><p>Java 所有的组成部分都需要名字。类名、变量名以及方法名都被称为标识符。</p>
<p>关于 Java 标识符，有以下几点需要注意：</p>
<ul>
<li>所有的标识符都应该以字母（A-Z 或者 a-z）,美元符（$）、或者下划线（_）开始</li>
<li>首字符之后可以是字母（A-Z 或者 a-z）,美元符（$）、下划线（_）或数字的任何字符组合</li>
<li>关键字不能用作标识符</li>
<li>标识符是大小写敏感的</li>
<li>合法标识符举例：age、$salary、_value、__1_value</li>
<li>非法标识符举例：123abc、-salary</li>
</ul>
<h2 id="Java-修饰符"><a href="#Java-修饰符" class="headerlink" title="Java 修饰符"></a>Java 修饰符</h2><p>像其他语言一样，Java 可以使用修饰符来修饰类中方法和属性。主要有两类修饰符：</p>
<ul>
<li>访问控制修饰符 : default, public , protected, private</li>
<li>非访问控制修饰符 : final, abstract, static, synchronized</li>
</ul>
<h2 id="Java-变量"><a href="#Java-变量" class="headerlink" title="Java 变量"></a>Java 变量</h2><p>Java 中主要有如下几种类型的变量</p>
<ul>
<li>局部变量</li>
<li>类变量（静态变量）</li>
<li>成员变量（非静态变量）</li>
</ul>
<p>要创建变量，必须指定类型并为其赋值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String name = <span class="string">&quot;John&quot;</span>;</span><br><span class="line"><span class="comment">//或</span></span><br><span class="line">String name;</span><br><span class="line">name=<span class="string">&quot;xxx&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>Java 数据类型</p>
<p>数据类型分为两组:<br>基本数据类型 - 包括 byte, short, int, long, float, double, boolean 和 char<br>|数据类型| 大小| 描述|<br>|:-|:-|:-|<br>|byte| 1 byte |存储从 -128 到 127 的整数|<br>|short| 2 bytes| 存储从 -32,768 到 32,767 的整数|<br>|int| 4 bytes |存储从 -2,147,483,648 到 2,147,483,647 的整数|<br>|long| 8 bytes| 存储从 -9,223,372,036,854,775,808 到 9,223,372,036,854,775,807 的整数|<br>|float| 4 bytes| 存储小数。 足以存储 6 到 7 个十进制数字|<br>|double| 8 bytes| 存储小数。 足以存储 15 位十进制数字, float 的精度只有 6 位或 7 位十进制数字，而 double 变量的精度约为 15 位|<br>|boolean| 1 bit |存储 true 或 false 值|<br>|char| 2 bytes |存储单个字符/字母或 ASCII 值|</p>
<p>非基本数据类型 - 例如 String, Arrays 和 Classes (您将在后面的章节中了解更多)</p>
<p>原始类型在 Java 中是预定义的（已经定义的）。 非原始类型由程序员创建，不是由 Java 定义的（String 除外）。<br>非原始类型可以用来调用方法来执行某些操作，而原始类型不能。<br>非原始数据类型称为引用类型，因为它们引用对象。<br>原始类型始终有一个值，而非原始类型可以为 null。<br>原始类型以小写字母开头，而非原始类型以大写字母开头。<br>原始类型的大小取决于数据类型，而非原始类型的大小都相同。</p>
<p>在 Java 中，有两种类型的数据转换：</p>
<p>隐式类型转换 (自动) - 从小类型到大类型，不需要强制转换符<br>byte -&gt; short -&gt; char -&gt; int -&gt; long -&gt; float -&gt; double</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> myInt = <span class="number">9</span>;</span><br><span class="line"><span class="keyword">double</span> myDouble = myInt; <span class="comment">// 自动转换: int 到 double</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>强制类型转换 (手动) - 从大类型到小类型，需要强制转换符实现强制转换<br>double -&gt; float -&gt; long -&gt; int -&gt; char -&gt; short -&gt; byte</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> myDouble = <span class="number">9.78</span>;</span><br><span class="line"><span class="keyword">int</span> myInt = (<span class="keyword">int</span>) myDouble; <span class="comment">// 手动转换：double 到 int</span></span><br></pre></td></tr></table></figure>

<h2 id="Java-关键字"><a href="#Java-关键字" class="headerlink" title="Java 关键字"></a>Java 关键字</h2><p>下面列出了 Java 关键字。这些保留字不能用于常量、变量、和任何标识符的名称。</p>
<ul>
<li><p>访问控制</p>
<table>
<thead>
<tr>
<th align="center">关键字</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">private</td>
<td align="center">私有的</td>
</tr>
<tr>
<td align="center">protected</td>
<td align="center">受保护的</td>
</tr>
<tr>
<td align="center">public</td>
<td align="center">公共的</td>
</tr>
<tr>
<td align="center">default</td>
<td align="center">默认</td>
</tr>
</tbody></table>
</li>
<li><p>类、方法和变量修饰符</p>
<table>
<thead>
<tr>
<th align="center">关键字</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">abstract</td>
<td align="center">声明抽象</td>
</tr>
<tr>
<td align="center">class</td>
<td align="center">类</td>
</tr>
<tr>
<td align="center">extends</td>
<td align="center">扩充,继承</td>
</tr>
<tr>
<td align="center">final</td>
<td align="center">最终值,不可改变的</td>
</tr>
<tr>
<td align="center">implements</td>
<td align="center">实现（接口）</td>
</tr>
<tr>
<td align="center">interface</td>
<td align="center">接口</td>
</tr>
<tr>
<td align="center">native</td>
<td align="center">本地，原生方法（非 Java 实现）</td>
</tr>
<tr>
<td align="center">new</td>
<td align="center">新,创建</td>
</tr>
<tr>
<td align="center">static</td>
<td align="center">静态</td>
</tr>
<tr>
<td align="center">strictfp</td>
<td align="center">严格,精准</td>
</tr>
<tr>
<td align="center">synchronized</td>
<td align="center">线程,同步</td>
</tr>
<tr>
<td align="center">transient</td>
<td align="center">短暂</td>
</tr>
<tr>
<td align="center">volatile</td>
<td align="center">易失</td>
</tr>
</tbody></table>
</li>
<li><p>程序控制语句</p>
<table>
<thead>
<tr>
<th align="center">关键字</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">break</td>
<td align="center">跳出循环</td>
</tr>
<tr>
<td align="center">case</td>
<td align="center">定义一个值以供 switch 选择</td>
</tr>
<tr>
<td align="center">continue</td>
<td align="center">继续</td>
</tr>
<tr>
<td align="center">do</td>
<td align="center">运行</td>
</tr>
<tr>
<td align="center">else</td>
<td align="center">否则</td>
</tr>
<tr>
<td align="center">for</td>
<td align="center">循环</td>
</tr>
<tr>
<td align="center">if</td>
<td align="center">如果</td>
</tr>
<tr>
<td align="center">instanceof</td>
<td align="center">实例</td>
</tr>
<tr>
<td align="center">return</td>
<td align="center">返回</td>
</tr>
<tr>
<td align="center">switch</td>
<td align="center">根据值选择执行</td>
</tr>
<tr>
<td align="center">while</td>
<td align="center">循环</td>
</tr>
</tbody></table>
</li>
<li><p>错误处理</p>
<table>
<thead>
<tr>
<th align="center">关键字</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">assert</td>
<td align="center">断言表达式是否为真</td>
</tr>
<tr>
<td align="center">catch</td>
<td align="center">捕捉异常</td>
</tr>
<tr>
<td align="center">finally</td>
<td align="center">有没有异常都执行</td>
</tr>
<tr>
<td align="center">throw</td>
<td align="center">抛出一个异常对象</td>
</tr>
<tr>
<td align="center">throws</td>
<td align="center">声明一个异常可能被抛出</td>
</tr>
<tr>
<td align="center">try</td>
<td align="center">捕获异常</td>
</tr>
</tbody></table>
</li>
<li><p>包相关</p>
<table>
<thead>
<tr>
<th align="center">关键字</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">import</td>
<td align="center">引入</td>
</tr>
<tr>
<td align="center">package</td>
<td align="center">包</td>
</tr>
</tbody></table>
</li>
<li><p>基本类型</p>
<table>
<thead>
<tr>
<th align="center">关键字</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">boolean</td>
<td align="center">布尔型</td>
</tr>
<tr>
<td align="center">byte</td>
<td align="center">字节型</td>
</tr>
<tr>
<td align="center">char</td>
<td align="center">字符型</td>
</tr>
<tr>
<td align="center">double</td>
<td align="center">双精度浮点</td>
</tr>
<tr>
<td align="center">float</td>
<td align="center">单精度浮点</td>
</tr>
<tr>
<td align="center">int</td>
<td align="center">整型</td>
</tr>
<tr>
<td align="center">long</td>
<td align="center">长整型</td>
</tr>
<tr>
<td align="center">short</td>
<td align="center">短整型</td>
</tr>
</tbody></table>
</li>
<li><p>变量引用</p>
<table>
<thead>
<tr>
<th align="center">关键字</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">super</td>
<td align="center">父类,超类</td>
</tr>
<tr>
<td align="center">this</td>
<td align="center">本类</td>
</tr>
<tr>
<td align="center">void</td>
<td align="center">无返回值</td>
</tr>
</tbody></table>
</li>
<li><p>保留关键字</p>
<table>
<thead>
<tr>
<th align="center">关键字</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">goto</td>
<td align="center">是关键字，但不能使用</td>
</tr>
<tr>
<td align="center">const</td>
<td align="center">是关键字，但不能使用</td>
</tr>
</tbody></table>
</li>
</ul>
<p>注意：Java 的 <code>null</code> 不是关键字，类似于 <code>true</code> 和 <code>false</code>，它是一个字面常量，不允许作为标识符使用。</p>
<h2 id="Java-方法"><a href="#Java-方法" class="headerlink" title="Java 方法"></a>Java 方法</h2><p>方法必须在类中声明。它是用方法的名称定义的，后跟括号()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">myMethod</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> z = myMethod(<span class="number">5</span>, <span class="number">3</span>);</span><br><span class="line">    System.out.println(z);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用方法重载，多个方法可以具有相同的名称和不同的参数,只要参数的数量或类型不同，多个方法就可以具有相同的名称。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">plusMethod</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">double</span> <span class="title">plusMethod</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> myNum1 = plusMethod(<span class="number">8</span>, <span class="number">5</span>);</span><br><span class="line">  <span class="keyword">double</span> myNum2 = plusMethod(<span class="number">4.3</span>, <span class="number">6.26</span>);</span><br><span class="line">  System.out.println(<span class="string">&quot;int: &quot;</span> + myNum1);</span><br><span class="line">  System.out.println(<span class="string">&quot;double: &quot;</span> + myNum2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Java-对象和类"><a href="#Java-对象和类" class="headerlink" title="Java 对象和类"></a>Java 对象和类</h2><ul>
<li>对象：对象是类的一个实例（对象不是找个女朋友），有状态和行为。例如，一条狗是一个对象，它的状态有：颜色、名字、品种；行为有：摇尾巴、叫、吃等。</li>
<li>类：类是一个模板，它描述一类对象的行为和状态。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line">    String breed;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    String colour;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">name</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个类可以包含以下类型变量：</p>
<ul>
<li>局部变量：在方法、构造方法或者语句块中定义的变量被称为局部变量。变量声明和初始化都是在方法中，方法结束后，变量就会自动销毁。</li>
<li>成员变量：成员变量是定义在类中，方法体之外的变量。这种变量在创建对象的时候实例化。成员变量可以被类中方法、构造方法和特定类的语句块访问。</li>
<li>类变量：类变量也声明在类中，方法体之外，但必须声明为 static 类型。<br>一个类可以拥有多个方法</li>
</ul>
<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>Java 中的构造函数是一种用于初始化对象的特殊方法。在创建类的对象时调用构造函数。它可用于设置对象属性的初始值<br>在创建一个对象的时候，至少要调用一个构造方法。构造方法的名称必须与类同名，并且不能有返回类型(如 void),一个类可以有多个构造方法。<br>每个类都有构造方法。如果没有显式地为类定义构造方法，Java 编译器将会为该类提供一个默认构造方法。但是，您无法设置对象属性的初始值。<br>下面是一个构造方法示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Puppy</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Puppy</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Puppy</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 这个构造器仅有一个参数：name</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><p>对象是根据类创建的。在 Java 中，使用关键字 new 来创建一个新的对象。创建对象需要以下三步：</p>
<p>声明：声明一个对象，包括对象名称和对象类型。<br>实例化：使用关键字 new 来创建一个对象。<br>初始化：使用 new 创建对象时，会调用构造方法初始化对象。<br>下面是一个创建对象的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Puppy</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> age;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Puppy</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">      <span class="comment">//这个构造器仅有一个参数：name</span></span><br><span class="line">      System.out.println(<span class="string">&quot;小狗的名字是 : &quot;</span> + name );</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">      <span class="comment">// 下面的语句将创建一个Puppy对象</span></span><br><span class="line">      Puppy myPuppy = <span class="keyword">new</span> Puppy( <span class="string">&quot;tommy&quot;</span> );</span><br><span class="line">      myPuppy.age=<span class="number">4</span></span><br><span class="line">      myPuppy.eat();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><h4 id="方法修饰符"><a href="#方法修饰符" class="headerlink" title="方法修饰符"></a>方法修饰符</h4><p>static 静态方法，这意味着可以在不创建类的对象的情况下访问该方法，而 public 只能由对象访问</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Static 方法</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">myStaticMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Static methods can be called without creating objects&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Public 方法</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myPublicMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Public methods must be called by creating objects&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Main 方法</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    myStaticMethod(); <span class="comment">// 调用静态方法</span></span><br><span class="line">    <span class="comment">// myPublicMethod(); 这会编译一个错误</span></span><br><span class="line"></span><br><span class="line">    MyClass myObj = <span class="keyword">new</span> MyClass(); <span class="comment">// 创建一个 MyClass 的对象</span></span><br><span class="line">    myObj.myPublicMethod(); <span class="comment">// 调用对象的公共方法</span></span><br><span class="line">    myObj.myStaticMethod(); <span class="comment">// 调用对象的静态方法</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="修饰符分为两组"><a href="#修饰符分为两组" class="headerlink" title="修饰符分为两组"></a>修饰符分为两组</h4><ul>
<li>访问修饰符 - 控制访问级别</li>
</ul>
<p>对于 classes，可以使用 public 或 default:</p>
<table>
<thead>
<tr>
<th>修饰符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>public</td>
<td>该类可由任何其他类访问</td>
</tr>
<tr>
<td>default</td>
<td>该类只能由同一包中的类访问。在不指定修改器时使用此选项。</td>
</tr>
</tbody></table>
<p>对于属性、方法和构造函数，可以使用以下选项之一：</p>
<table>
<thead>
<tr>
<th>修饰符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>public</td>
<td>所有类都可以访问该代码</td>
</tr>
<tr>
<td>private</td>
<td>代码只能在声明的类中访问</td>
</tr>
<tr>
<td>default</td>
<td>该类只能由同一包中的类访问。在不指定修改器时使用此选项。</td>
</tr>
<tr>
<td>protected</td>
<td>代码可以在相同的包和子类中访问。</td>
</tr>
</tbody></table>
<ul>
<li>非访问修饰符 - 不控制访问级别，但提供其他功能</li>
</ul>
<p>对于类，可以使用 final 或 abstract:</p>
<table>
<thead>
<tr>
<th>修饰符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>final</td>
<td>该类不能被其他类继承</td>
</tr>
<tr>
<td>abstract</td>
<td>该类不能用于创建对象（要访问抽象类，它必须从另一个类继承。）</td>
</tr>
</tbody></table>
<p>对于属性和方法，可以使用以下选项之一：</p>
<table>
<thead>
<tr>
<th>修饰符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>final</td>
<td>无法覆盖/修改属性和方法</td>
</tr>
<tr>
<td>static</td>
<td>属性和方法属于类，而不是对象</td>
</tr>
<tr>
<td>abstract</td>
<td>只能在抽象类中使用，并且只能在方法上使用。该方法没有主体，例如抽象 abstract void run();。主体由子类（继承自）提供。</td>
</tr>
<tr>
<td>transient</td>
<td>序列化包含属性和方法的对象时，将跳过属性和方法</td>
</tr>
<tr>
<td>synchronized</td>
<td>方法一次只能由一个线程访问</td>
</tr>
<tr>
<td>volatile</td>
<td>属性值不是本地缓存的线程，总是从”主内存”中读取</td>
</tr>
</tbody></table>
<h2 id="Java-包与-API"><a href="#Java-包与-API" class="headerlink" title="Java 包与 API"></a>Java 包与 API</h2><p>软件包分为两类：</p>
<h3 id="内置包（来自-Java-API-的包"><a href="#内置包（来自-Java-API-的包" class="headerlink" title="内置包（来自 Java API 的包"></a>内置包（来自 Java API 的包</h3><p>该库分为包和类。这意味着您可以导入单个类（及其方法和属性），也可以导入包含属于指定包的所有类的整个包。</p>
<p>要使用库中的类或包，需要使用 import 关键字：</p>
<p>语法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">package</span>.name.Class;   <span class="comment">// 导入 single 类</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">package</span>.name.*;   <span class="comment">// 导入整个包</span></span><br></pre></td></tr></table></figure>

<p>导入类<br>如果需找到要使用的类，例如用于获取用户输入的 Scanner 类，请编写以下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br></pre></td></tr></table></figure>

<h3 id="用户定义的包（创建自己的包）"><a href="#用户定义的包（创建自己的包）" class="headerlink" title="用户定义的包（创建自己的包）"></a>用户定义的包（创建自己的包）</h3>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://a913481180.github.io/2022/12/09/20-00-00/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="KK">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KK">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/12/09/20-00-00/" class="post-title-link" itemprop="url">react</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-12-09 20:00:00" itemprop="dateCreated datePublished" datetime="2022-12-09T20:00:00+08:00">2022-12-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-05-14 23:12:11" itemprop="dateModified" datetime="2024-05-14T23:12:11+08:00">2024-05-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="浏览器中编写"><a href="#浏览器中编写" class="headerlink" title="浏览器中编写"></a>浏览器中编写</h2><ul>
<li>准备容器</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;test&quot;</span>&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>引入库</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--react核心库--&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;react.development.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;!--react-dom，用于支持react操纵dom--&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;react-dom.development.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;!--babel，用于将jsx转化为js--&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;babel.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>JSX</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;text/babel&quot;</span>&gt;</span><br><span class="line">  <span class="comment">/*此处要写babel*/</span> <span class="comment">//创建虚拟dom const Vdom=(&lt;h1&gt;hello&lt;/h1&gt;)/*不用引号*/</span></span><br><span class="line">  <span class="comment">//渲染虚拟DOM到页面 ReactDOM.render(Vdom,document.getElementById(&#x27;test&#x27;));</span></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>js<blockquote>
<p>jsx 最终会翻译成 js 写法</p>
</blockquote>
</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line"><span class="comment">//创建虚拟dom</span></span><br><span class="line"><span class="keyword">const</span> Vdom=React.createElement(<span class="string">&#x27;h1&#x27;</span>,&#123;<span class="attr">id</span>:<span class="string">&#x27;title&#x27;</span>&#125;,React.createElement(<span class="string">&#x27;span&#x27;</span>,&#123;&#125;,<span class="string">&#x27;hello&#x27;</span>))</span><br><span class="line"><span class="comment">//渲染虚拟DOM到页面</span></span><br><span class="line">ReactDOM.render(Vdom,<span class="built_in">document</span>.getElementById(<span class="string">&#x27;test&#x27;</span>));</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>虚拟 DOM 本质是一个对象，虚拟 dom 比较轻量，真实 DOM 比较完整，虚拟 DOM 是 react 内部用，因此无需真实 DOM 那么多的属性。最终虚拟 DOM 会被 react 转化为真实 DOM 呈现在页面上。</p>
</blockquote>
<h2 id="JSX"><a href="#JSX" class="headerlink" title="JSX"></a>JSX</h2><blockquote>
<p>javascript XML,react 定义的类似与 XML 的 js 扩展语法，脚手架通过@babel/plugin-transform-react-jsx 包解析成 React.createElemnt(‘h1’,{className:’test’},’xx’)函数</p>
</blockquote>
<p>xml：早期用于存储和传输数据的格式</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">student</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>XIAOMI<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">age</span>&gt;</span>19<span class="tag">&lt;/<span class="name">age</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">student</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="jsx-语法规则"><a href="#jsx-语法规则" class="headerlink" title="jsx 语法规则"></a>jsx 语法规则</h3><ul>
<li>定义虚拟 dom，不要写引号</li>
<li>标签中混入 js 表达式要用｛｝，js 表达式会产生一个值(返回值)，可以放在任何需要值的地方，如<code>a</code>、<code>a+b</code>、<code>demo(1)</code>、<code>arr.map()</code>、<code>function test()&#123;&#125;</code>。js 语句：<code>if()&#123;&#125;</code>,<code>for()&#123;&#125;</code>,<code>switch()&#123;&#125;</code></li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> Vdom = <span class="xml"><span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&#123;a&#125;</span>&gt;</span>&#123;a.toString()&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>样式的类型指定不要用 class，要用 className</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Vdom = <span class="xml"><span class="tag">&lt;<span class="name">span</span> <span class="attr">className</span>=<span class="string">&quot;test&quot;</span>&gt;</span>xxx<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>内联样式<br>要用<code>style=&#123;&#123;fontSize:"20px"&#125;&#125;</code>的写法</p>
</li>
<li><p>虚拟 dom 只有一个根标签</p>
</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Vdom = (</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">className</span>=<span class="string">&quot;test&quot;</span>&gt;</span>xxx<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">className</span>=<span class="string">&quot;test&quot;</span>&gt;</span>xxx<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<ul>
<li>标签首字符为小写则直接转为 html 中同名元素，若为大写则去渲染对应组件</li>
</ul>
<h3 id="列表渲染"><a href="#列表渲染" class="headerlink" title="列表渲染"></a>列表渲染</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> (</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="xml">    &#123;list.map((item) =&gt; (</span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;item.id&#125;</span>&gt;</span>item.name<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">    ))&#125;</span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h3 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h3><p>三元表达式，逻辑&amp;&amp;||运算，函数</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isTrue = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">const</span> genSpan = <span class="function">(<span class="params">i</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (i) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>x<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">b</span>&gt;</span>x<span class="tag">&lt;/<span class="name">b</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    &#123;isTrue &amp;&amp; <span class="tag">&lt;<span class="name">span</span>&gt;</span>xx<span class="tag">&lt;/<span class="name">span</span>&gt;</span>&#125;</span></span><br><span class="line"><span class="xml">    &#123;isTrue ? <span class="tag">&lt;<span class="name">span</span>&gt;</span>xx<span class="tag">&lt;/<span class="name">span</span>&gt;</span> : <span class="tag">&lt;<span class="name">b</span>&gt;</span>xx<span class="tag">&lt;/<span class="name">b</span>&gt;</span>&#125;</span></span><br><span class="line"><span class="xml">    &#123;genSpan(isTrue)&#125;</span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h2 id="样式控制"><a href="#样式控制" class="headerlink" title="样式控制"></a>样式控制</h2><ul>
<li>内联</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> style = &#123; <span class="attr">color</span>: <span class="string">&quot;red&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">color:</span> &quot;<span class="attr">red</span>&quot; &#125;&#125;&gt;</span>xx<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;style&#125;</span>&gt;</span>xx<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/&gt;</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>类名<br>不能用对象和数组，只能是字符串</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;test&quot;</span>&gt;</span>xx<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;isTrue</span> ? &quot;<span class="attr">test</span>&quot; <span class="attr">:</span> &quot;&quot;&#125;&gt;</span>xx<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/&gt;</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="组件和模块"><a href="#组件和模块" class="headerlink" title="组件和模块"></a>组件和模块</h2><p>模块：提供特定功能的 js 程序<br>组件：实现局部功能效果的代码和资源集合（html、js、css、img 等）</p>
<h3 id="函数式组件"><a href="#函数式组件" class="headerlink" title="函数式组件"></a>函数式组件</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Demo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//组件必须首字母大写</span></span><br><span class="line">  <span class="comment">//this 为undefind,经过babel编译后开启严格模式，this便指向undefind，不开启严格模式则是window</span></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>test<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">  <span class="comment">//必须有返回值，若没有内容返回null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Demo</span> /&gt;</span></span>, <span class="built_in">document</span>.getElementById(<span class="string">&quot;test&quot;</span>));</span><br><span class="line"><span class="comment">//react解析组件标签,找到Demo组件，发现此组件是函数定义的，便调用该函数，将虚拟dom渲染成真实dom</span></span><br></pre></td></tr></table></figure>

<h3 id="类式组件"><a href="#类式组件" class="headerlink" title="类式组件"></a>类式组件</h3><h4 id="简单组件"><a href="#简单组件" class="headerlink" title="简单组件"></a>简单组件</h4><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在Demo的原型对象上</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">//必须提供render,极其返回值</span></span><br><span class="line">    <span class="comment">//this指向Demo的实例对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>test<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//react解析组件标签,找到Demo组件，发现此组件是类定义的，便new 出该类实例，通过该实例调用原型对象上的render方法。将虚拟dom渲染成真实dom</span></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Demo</span> /&gt;</span></span>, <span class="built_in">document</span>.getElementById(<span class="string">&quot;test&quot;</span>));</span><br></pre></td></tr></table></figure>

<h4 id="复杂组件"><a href="#复杂组件" class="headerlink" title="复杂组件"></a>复杂组件</h4><h5 id="state"><a href="#state" class="headerlink" title="state"></a>state</h5><blockquote>
<p>state 为组件的重要属性，值是对象，通过更新组件的 state 来更新对应的页面显示（重新渲染组件）</p>
</blockquote>
<h6 id="传统写法"><a href="#传统写法" class="headerlink" title="传统写法"></a>传统写法</h6><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">prop</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">super</span>(prop)</span><br><span class="line">    <span class="built_in">this</span>.state=&#123;</span><br><span class="line">      <span class="attr">a</span>:<span class="number">1</span>,</span><br><span class="line">      <span class="attr">b</span>:<span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="function"><span class="title">changValue</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"> <span class="comment">//类中的方法默认开启局部严格模式</span></span><br><span class="line"> <span class="comment">//所以this为undefind</span></span><br><span class="line"> <span class="comment">//只有通过Demo实例调用此实例，this才为Demo的实例</span></span><br><span class="line"> <span class="comment">//changeValue作为onClick的回调，不是实例调用</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">onClick</span>=<span class="string">&#123;test&#125;</span>&gt;</span>test&#123;this.state.a&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">onClick</span>=<span class="string">&#123;this.changeValue&#125;</span>&gt;</span>test&#123;this.state.b&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Demo</span>/&gt;</span></span>,<span class="built_in">document</span>.getElementById(<span class="string">&#x27;test&#x27;</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>解决 this 指向</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">prop</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(prop); <span class="comment">//构造器是否接受props，是否传给super取决于是否希望在构造器中通过this访问props</span></span><br><span class="line">    <span class="built_in">this</span>.state = &#123;</span><br><span class="line">      <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">      <span class="attr">b</span>: <span class="number">2</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//改变this指向</span></span><br><span class="line">    <span class="built_in">this</span>.changValue = <span class="built_in">this</span>.changValue.bind(<span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">changValue</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">//state不能直接更改</span></span><br><span class="line">    <span class="built_in">this</span>.state.a = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//必须通过api</span></span><br><span class="line">    <span class="built_in">this</span>.setState(&#123; <span class="attr">a</span>: <span class="number">2</span> &#125;); <span class="comment">//更新为合并，不是替换</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">onClick</span>=<span class="string">&#123;this.changeValue&#125;</span>&gt;</span>test&#123;this.state.b&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Demo</span> /&gt;</span></span>, <span class="built_in">document</span>.getElementById(<span class="string">&quot;test&quot;</span>));</span><br></pre></td></tr></table></figure>

<h6 id="简写"><a href="#简写" class="headerlink" title="简写"></a>简写</h6><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">//名称固定，就叫state</span></span><br><span class="line">  state = &#123;</span><br><span class="line">    <span class="comment">//等于号，代表给该类的实例追加属性</span></span><br><span class="line">    <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">b</span>: <span class="number">2</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">//必须用箭头函数,不需要通过constructor修改this指向</span></span><br><span class="line">  changValue = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.setState(&#123; <span class="attr">a</span>: <span class="number">2</span> &#125;); <span class="comment">//更新为合并，不是替换</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">onClick</span>=<span class="string">&#123;this.changeValue&#125;</span>&gt;</span>test&#123;this.state.b&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Demo</span> /&gt;</span></span>, <span class="built_in">document</span>.getElementById(<span class="string">&quot;test&quot;</span>));</span><br></pre></td></tr></table></figure>

<h5 id="状态不可变"><a href="#状态不可变" class="headerlink" title="状态不可变"></a>状态不可变</h5><p>不要直接修改 state 状态的值，而是基于当前状态创建新的状态值</p>
<ul>
<li>错误修改</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">state = &#123; <span class="attr">count</span>: <span class="number">0</span>, <span class="attr">list</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="attr">person</span>: &#123; <span class="attr">name</span>: <span class="string">&quot;xx&quot;</span>, <span class="attr">age</span>: <span class="number">18</span> &#125; &#125;;</span><br><span class="line"><span class="built_in">this</span>.state.count++;</span><br><span class="line"><span class="built_in">this</span>.state.count += <span class="number">1</span>;</span><br><span class="line"><span class="built_in">this</span>.state.count = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">this</span>.state.list.push(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">this</span>.state.list.splice(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">this</span>.state.person.name = <span class="string">&quot;aaa&quot;</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>正确修改</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.setState(&#123;</span><br><span class="line">  <span class="attr">count</span>:<span class="built_in">this</span>.state.count+<span class="number">1</span>,</span><br><span class="line">  <span class="comment">//增加</span></span><br><span class="line">  <span class="attr">list</span>:[...this.state.list,<span class="number">4</span>]</span><br><span class="line">  <span class="comment">//删除</span></span><br><span class="line">  <span class="attr">list</span>:<span class="built_in">this</span>.state.list.filter(<span class="function"><span class="params">item</span>=&gt;</span>item!==<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">  <span class="attr">person</span>:&#123;</span><br><span class="line">    ...this.state.person,</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;aaa&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h5 id="props"><a href="#props" class="headerlink" title="props"></a>props</h5><blockquote>
<p>组件的所有属性都保存在 props 中，props 是只读的，不能修改。可以传递任何数据包括函数，jsx<br>类式组件通过 this.props 获取 props 对象<br>函数式组件通过参数获取 props 对象<br>可使用 ts 来配置</p>
</blockquote>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>test&#123;this.props.b&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Demo</span> <span class="attr">a</span>=<span class="string">&#123;1&#125;</span> <span class="attr">b</span>=<span class="string">&quot;ss&quot;</span> /&gt;</span></span>, <span class="built_in">document</span>.getElementById(<span class="string">&quot;test1&quot;</span>)); <span class="comment">//数据类型要用｛｝</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span> &#125;;</span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Demo</span> &#123;<span class="attr">...obj</span>&#125; /&gt;</span></span>, <span class="built_in">document</span>.getElementById(<span class="string">&quot;test2&quot;</span>)); <span class="comment">//批量传属性</span></span><br></pre></td></tr></table></figure>

<ul>
<li>props 规则限制</li>
</ul>
<blockquote>
<p>常见规则：<br>必传：isRequired<br>基本类型：boolean , number,…<br>节点：element<br>指定对象：shape({})</p>
</blockquote>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//react16.x以上需引入prop-types.js</span></span><br><span class="line"><span class="comment">//导入prop-type包</span></span><br><span class="line"><span class="comment">//组件名.propTypes=&#123;&#125;给组件添加规则校验</span></span><br><span class="line"><span class="keyword">import</span> PropTypes <span class="keyword">from</span> <span class="string">&#x27;prop-types&#x27;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line"><span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">h1</span> &gt;</span>test&#123;this.props.b&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//限制类型</span></span><br><span class="line">Demo.propTypes=&#123;</span><br><span class="line">  <span class="attr">a</span>:PropTypes.number.isRequied</span><br><span class="line">  <span class="attr">test</span>:PropTypes.func</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//默认值</span></span><br><span class="line">Demo.defaultProps=&#123;</span><br><span class="line">  <span class="attr">b</span>:<span class="string">&#x27;xx&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Demo</span> <span class="attr">a</span>=<span class="string">&#123;1&#125;</span> <span class="attr">b</span>=<span class="string">&#x27;ss&#x27;</span> <span class="attr">handle</span>=<span class="string">&quot;test&quot;</span>/&gt;</span></span>,<span class="built_in">document</span>.getElementById(<span class="string">&#x27;test1&#x27;</span>))<span class="comment">//数据类型要用｛｝</span></span><br><span class="line"><span class="keyword">const</span> obj=&#123;<span class="attr">a</span>:<span class="number">1</span>,<span class="attr">b</span>:<span class="number">2</span>&#125;</span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Demo</span> &#123;<span class="attr">...obj</span>&#125;/&gt;</span></span>,<span class="built_in">document</span>.getElementById(<span class="string">&#x27;test2&#x27;</span>))<span class="comment">//批量传属性</span></span><br></pre></td></tr></table></figure>

<ul>
<li>简写</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> PropTypes <span class="keyword">from</span> <span class="string">&#x27;prop-types&#x27;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line"><span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">h1</span> &gt;</span>test&#123;this.props.b&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> propTypes=&#123; <span class="comment">//加上static代表给类本身添加属性</span></span><br><span class="line">  <span class="comment">//react16.x以上需引入prop-types.js</span></span><br><span class="line">  <span class="attr">a</span>:PropTypes.number.isRequied</span><br><span class="line">  <span class="attr">test</span>:PropTypes.func</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> defaultProps=&#123;</span><br><span class="line">  <span class="attr">b</span>:<span class="string">&#x27;xx&#x27;</span></span><br><span class="line">&#125;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Demo</span> <span class="attr">a</span>=<span class="string">&#123;1&#125;</span> <span class="attr">b</span>=<span class="string">&#x27;ss&#x27;</span> <span class="attr">handle</span>=<span class="string">&quot;test&quot;</span>/&gt;</span></span>,<span class="built_in">document</span>.getElementById(<span class="string">&#x27;test1&#x27;</span>))<span class="comment">//数据类型要用｛｝</span></span><br><span class="line"><span class="keyword">const</span> obj=&#123;<span class="attr">a</span>:<span class="number">1</span>,<span class="attr">b</span>:<span class="number">2</span>&#125;</span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Demo</span> &#123;<span class="attr">...obj</span>&#125;/&gt;</span></span>,<span class="built_in">document</span>.getElementById(<span class="string">&#x27;test2&#x27;</span>))<span class="comment">//批量传属性</span></span><br></pre></td></tr></table></figure>

<ul>
<li>函数式组件使用 props</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> propTypes <span class="keyword">from</span> <span class="string">&#x27;prop-types&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Demo</span>(<span class="params">props</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>test&#123;props.b&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"> Demo.propTypes=&#123;</span><br><span class="line">  <span class="comment">//react16.x以上需引入prop-types.js</span></span><br><span class="line">  <span class="attr">a</span>:PropTypes.number.isRequied</span><br><span class="line">  <span class="attr">test</span>:PropTypes.func</span><br><span class="line">&#125;</span><br><span class="line">Demo.defaultProps=&#123;</span><br><span class="line">  <span class="attr">b</span>:<span class="string">&#x27;xx&#x27;</span></span><br><span class="line">&#125;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Demo</span> <span class="attr">a</span>=<span class="string">&#123;1&#125;</span> <span class="attr">b</span>=<span class="string">&#x27;ss&#x27;</span> <span class="attr">handle</span>=<span class="string">&quot;test&quot;</span>/&gt;</span></span>,<span class="built_in">document</span>.getElementById(<span class="string">&#x27;test1&#x27;</span>))<span class="comment">//数据类型要用｛｝</span></span><br></pre></td></tr></table></figure>

<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> propTypes <span class="keyword">from</span> <span class="string">&#x27;prop-types&#x27;</span></span><br><span class="line"><span class="comment">//官方推荐</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Demo</span>(<span class="params">&#123;b:<span class="string">&#x27;xxx&#x27;</span>&#125;</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">h1</span> &gt;</span>test&#123;b&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">Demo.propTypes=&#123;</span><br><span class="line">  <span class="attr">a</span>:PropTypes.number.isRequied</span><br><span class="line">  <span class="attr">test</span>:PropTypes.func</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">  ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Demo</span> <span class="attr">a</span>=<span class="string">&#123;1&#125;</span> <span class="attr">b</span>=<span class="string">&#x27;ss&#x27;</span> <span class="attr">handle</span>=<span class="string">&quot;test&quot;</span>/&gt;</span></span>,<span class="built_in">document</span>.getElementById(<span class="string">&#x27;test1&#x27;</span>))<span class="comment">//数据类型要用｛｝</span></span><br></pre></td></tr></table></figure>

<h5 id="refs"><a href="#refs" class="headerlink" title="refs"></a>refs</h5><blockquote>
<p>组件内的标签可使用 ref 属性标识自己类似 id=’test’</p>
</blockquote>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line"><span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">ref</span>=<span class="string">&#x27;title1&#x27;</span> &gt;</span>官方不推荐String类型的ref写法，效率不高<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">ref</span>=<span class="string">&#123;(node)</span>=&gt;</span>&#123;this.title2=node&#125;&#125; &gt;ref的回调写法，内联写法在每次更新时会调用两次，第一次时为了清空旧的ref，所以为null，第二次才为DOM，可用类绑定函数替换<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">ref</span>=<span class="string">&#123;title3&#125;</span> &gt;</span>使用createRef<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">)</span><br><span class="line">&#125;</span><br><span class="line">title3=createRef()<span class="comment">//调用后返回一个容器，用于存储ref标识的节点，只能存一个</span></span><br><span class="line">test=<span class="function">()=&gt;</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>.refs.title1)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>.title2)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>.title3.current)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="受控组件"><a href="#受控组件" class="headerlink" title="受控组件"></a>受控组件</h5><blockquote>
<p>input 框的状态（value）被 React 组件状态（state）控制，就是可以被 react 状态控制的组件</p>
</blockquote>
<ul>
<li>在状态 state 中声明一个组件的状态数据</li>
<li>将状态数据设置为 input 标签元素的 value 属性的值</li>
<li>为 input 添加 change 时间</li>
<li>通过事件对象 e 获取文本框的值</li>
<li>调用 setState 方法，将文本框的值作为 state 状态的最新值</li>
</ul>
<h5 id="非受控组件"><a href="#非受控组件" class="headerlink" title="非受控组件"></a>非受控组件</h5><blockquote>
<p>就是手动操作 dm 的方式获取文本的值，文本框的状态不受 react 组件的 state 中的状态控制</p>
</blockquote>
<ul>
<li>导入 createRef 函数</li>
<li>调用 createRef 函数，创建一个 ref,存储到名为 myref 的实例属性中</li>
<li>为 input 添加 ref 属性</li>
<li>通过 myref.current 即可拿到 input 对应的 dom 元素</li>
</ul>
<h5 id="绑定事件"><a href="#绑定事件" class="headerlink" title="绑定事件"></a>绑定事件</h5><ol>
<li><p>通过 onXxx 属性指定事件处理函数（注意大小写）</p>
<ul>
<li>react 使用的自定义事件（原生小写-&gt;大写，原生大写-&gt;小写），而不是原生 DOM 事件</li>
<li>react 中的事件是通过事件委托方式处理的（委托给组件最外层的元素,事件冒泡）</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数式组件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">onClick</span>=<span class="string">&#123;(event)</span>=&gt;</span>&#123;&#125;&#125;&gt;xx<span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml">//类式组件</span></span><br><span class="line"><span class="xml">class App extends React.Component&#123;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">   /*避免this指向出现问题(undefined),使回调中的this指向当前组件实例对象*/</span></span><br><span class="line"><span class="xml">  handleClick=(event)=&gt;&#123;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"> &#125;</span></span><br><span class="line"><span class="xml">   //this为undefined,需要在constructor中通过bind改变this指向</span></span><br><span class="line"><span class="xml">  handleClick2(event)&#123;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"> &#125;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"> render()&#123;</span></span><br><span class="line"><span class="xml">   //render函数中的 this已被react修正为当前组件实例对象</span></span><br><span class="line"><span class="xml">   return (</span></span><br><span class="line"><span class="xml">   <span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="xml">   <span class="tag">&lt;<span class="name">div</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleClick&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">   &#123;/*不通过constuctor改变this指向，可用以下这种方法*/&#125;</span></span><br><span class="line"><span class="xml">   <span class="tag">&lt;<span class="name">div</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span>=&gt;</span>this.handleClick2()&#125;&gt;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">   <span class="tag">&lt;/&gt;</span>)</span></span><br><span class="line"><span class="xml"> &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure></li>
<li><p>可通过 event.target 得到的发生事件的 DOM 元素对象</p>
</li>
<li><p>阻止默认行为 event.preventDefault()</p>
</li>
</ol>
<h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><blockquote>
<p>类式组件才有生命周期,因为函数式组件不能实例化</p>
</blockquote>
<h5 id="旧-lt-16-4"><a href="#旧-lt-16-4" class="headerlink" title="旧(&lt;16.4)"></a>旧(&lt;16.4)</h5><ul>
<li>初始化阶段</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">constructor</span>(<span class="params"></span>); <span class="comment">//构造器</span></span><br><span class="line">componentWillMount(); <span class="comment">//组件将要挂载</span></span><br><span class="line">render();</span><br><span class="line">componentDidMount(); <span class="comment">//组件挂载完毕</span></span><br></pre></td></tr></table></figure>

<ul>
<li>更新数据时</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">setState();</span><br><span class="line">shouldComponentUpdate(); <span class="comment">//默认返回true，返回false时不执行更新</span></span><br><span class="line">componentWillUpdate(); <span class="comment">//组件将要更新</span></span><br><span class="line">render();</span><br><span class="line">componentDidUpdate(); <span class="comment">//组件更新更新完毕</span></span><br></pre></td></tr></table></figure>

<ul>
<li>强制更新时</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">forceUpdate(); <span class="comment">//不想更改状态中的数据，更新页面</span></span><br><span class="line">componentWillUpdate(); <span class="comment">//组件将要更新</span></span><br><span class="line">render();</span><br><span class="line">componentDidUpdate(); <span class="comment">//组件更新更新完毕</span></span><br></pre></td></tr></table></figure>

<ul>
<li>父组件渲染</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">componentWillReceiveProps(props); <span class="comment">//第一次不调用，接受新的props才调用</span></span><br><span class="line">shouldComponentUpdate(); <span class="comment">//默认返回true，返回false时不执行更新</span></span><br><span class="line">componentWillUpdate(); <span class="comment">//组件将要更新</span></span><br><span class="line">render();</span><br><span class="line">componentDidUpdate(); <span class="comment">//组件更新更新完毕</span></span><br></pre></td></tr></table></figure>

<ul>
<li>卸载组件</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//由React.unmountComponentAtNode()触发</span></span><br><span class="line">componentWillUnmount();</span><br></pre></td></tr></table></figure>

<h5 id="新"><a href="#新" class="headerlink" title="新"></a>新</h5><blockquote>
<p>因为新版本的异步渲染，因此 componentWillUpdate，componentWillReceive，componentWillMount 即将废弃，所以要加上 UNSAFE_防止误解和滥用</p>
</blockquote>
<ul>
<li>初始化阶段</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">constructor</span>(<span class="params"></span>)//构造器,初始化<span class="title">state</span>,创建<span class="title">ref</span>,<span class="title">bind</span>解决<span class="title">this</span>指向</span><br><span class="line">//<span class="title">UNSAFE_componentWillMount</span>(<span class="params"></span>)</span><br><span class="line"><span class="title">static</span> <span class="title">getDerivedStateFromProps</span>(<span class="params">props,state</span>)&#123;<span class="comment">//组件将要挂载，不能加到实例上，要加上static。</span></span><br><span class="line"><span class="comment">//必须返回状态对象，若包含state中的数据，将覆盖它。用于state的值任何时候取决于props</span></span><br><span class="line"><span class="keyword">return</span> &#123;<span class="attr">a</span>:<span class="number">1</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line">render()<span class="comment">//每次组件渲染都会触发，不要在里面调用setState()</span></span><br><span class="line">componentDidMount()<span class="comment">//组件挂载完毕</span></span><br></pre></td></tr></table></figure>

<ul>
<li>更新数据时，调用 setState()、forceUpdate()或父组件新 Props</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> getDerivedStateFromProps(props,state)<span class="comment">//组件将要挂载，不能加到实例上，要加上static。</span></span><br><span class="line">shouldComponentUpdate()<span class="comment">//默认返回true，返回false时不执行更新</span></span><br><span class="line"><span class="function"><span class="title">getSnapshotBeforeUpdate</span>(<span class="params">preProps,preState</span>)</span>&#123;<span class="comment">//更新前,必须和componentDidupdate一起使用</span></span><br><span class="line">    <span class="comment">//返回值会传入componentDidUpdate中</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;xxx&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">render()</span><br><span class="line">componentDidUpdate(preProps,preState,snapshotValue)<span class="comment">//之前的prop时和状态,不要在里面调用setState()</span></span><br></pre></td></tr></table></figure>

<ul>
<li>卸载组件</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//由React.unmountComponentAtNode()触发</span></span><br><span class="line">componentWillUnmount();</span><br></pre></td></tr></table></figure>

<h4 id="react-中的-key-作用"><a href="#react-中的-key-作用" class="headerlink" title="react 中的 key 作用"></a>react 中的 key 作用</h4><p>key 是虚拟 Dom 对象的标识，当状态中的数据变化时，react 会根据新数据形成新的虚拟 DOM，<br>随后将新的虚拟 DOM 与旧的虚拟 DOM 进行 diff 比较。<br>若旧虚拟 dom 中到了与新虚拟 dom 中相同的 key：</p>
<ul>
<li>虚拟 dom 中内容没有变化，使用之前的真实 dom</li>
<li>虚拟 dom 中内容变化了，则生成新的真实 dom，随后替换掉页面中的真实 dom</li>
</ul>
<p>若旧虚拟 dom 未找到与新虚拟 dom 相同的 key，则创建新的真实 dom 渲染到页面中</p>
<p>用 index 做 key 引发的问题</p>
<ol>
<li>若对数据进行逆序添加，逆序删除等破坏顺序操作时，产生没必要的真实 dom 更新，虽然界面没有问题</li>
<li>若结构中包含输入类的 DOM，会产生错误 DOM 更新，界面会出现异常</li>
<li>若仅用于渲染列表展示，没有逆序添加，逆序删除等破坏顺序操作，则用 index 做 key 没有任何问题</li>
</ol>
<h4 id="脚手架"><a href="#脚手架" class="headerlink" title="脚手架"></a>脚手架</h4><p>安装：<code>npm i create-react-app -g</code></p>
<p>创建文件夹：<code>create-ract-app test</code></p>
<p>进入创建的文件夹：<code>npm start</code></p>
<ul>
<li>入口文件 index.js</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//核心库</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="comment">//渲染</span></span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">&quot;react-dom&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&quot;./App&quot;</span>;</span><br><span class="line"><span class="comment">//react16.x</span></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span>, <span class="built_in">document</span>.getElementById(<span class="string">&quot;root&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//react 18.x</span></span><br><span class="line"><span class="comment">//const root=ReactDOM.createRoot(document.getElementById(&quot;root&quot;))</span></span><br><span class="line"><span class="comment">//root.render(</span></span><br><span class="line"><span class="comment">//严格模式会影响useEffect的执行时机，为了检测额外的副作用，会让每一个useEffect执行两次</span></span><br><span class="line"><span class="comment">//&lt;React.StrictMode&gt;</span></span><br><span class="line"><span class="comment">//&lt;App/&gt;</span></span><br><span class="line"><span class="comment">//&lt;/React.StrictMode&gt;</span></span><br><span class="line"><span class="comment">//)</span></span><br></pre></td></tr></table></figure>

<ul>
<li>App.js</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line">Class App <span class="keyword">extends</span> React.Component&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>xx<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App</span><br></pre></td></tr></table></figure>

<ul>
<li>样式模块化</li>
</ul>
<p>index.module.css</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.title</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hello form <span class="string">&#x27;./index.module.css&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> calss Test <span class="keyword">extends</span> Compont&#123;</span><br><span class="line"><span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;hello.title&#125;</span>&gt;</span>xx<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>代理</li>
</ul>
<p>setupProxy.js</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> proxy=<span class="built_in">require</span>(<span class="string">&#x27;http-proxy-middleware&#x27;</span>);</span><br><span class="line"><span class="built_in">module</span>.exports=<span class="function"><span class="keyword">function</span> (<span class="params">app</span>) </span>&#123;</span><br><span class="line">app.use(</span><br><span class="line">proxy.createProxyMiddleware(<span class="string">&#x27;/apis&#x27;</span>,&#123;</span><br><span class="line"><span class="attr">target</span>:<span class="string">&#x27;http://xxx:xxx&#x27;</span>,</span><br><span class="line"><span class="attr">changeOrigin</span>:<span class="literal">true</span>,<span class="comment">//控制服务器收到的响应头中的Host字段值</span></span><br><span class="line"><span class="attr">pathRewrite</span>:&#123;<span class="string">&#x27;^/apis&#x27;</span>:<span class="string">&#x27;&#x27;</span>&#125;</span><br><span class="line">&#125;)，</span><br><span class="line">proxy.createProxyMiddleware(<span class="string">&#x27;/api2&#x27;</span>,&#123;</span><br><span class="line"><span class="attr">target</span>:<span class="string">&#x27;http://xxx:xxx&#x27;</span>,</span><br><span class="line"><span class="attr">changeOrigin</span>:<span class="literal">true</span>,<span class="comment">//控制服务器收到的响应头中的Host字段值,true时为代理服务ip,false为当前ip，默认为false</span></span><br><span class="line"><span class="attr">pathRewrite</span>:&#123;<span class="string">&#x27;^/api2&#x27;</span>:<span class="string">&#x27;&#x27;</span>&#125;</span><br><span class="line">&#125;)，</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="组件间通信"><a href="#组件间通信" class="headerlink" title="组件间通信"></a>组件间通信</h4><ul>
<li><p>子-&gt;父<br>父给子组件间传入回调函数，子组件调用回调函数把数据传给父组件</p>
</li>
<li><p>消息订阅与发布<br>第三方库 pubsub.js</p>
</li>
</ul>
<h4 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h4><blockquote>
<p>依赖 H5 BOM 浏览器对象上的 history 或 hash 锚点，监听路由变化，匹配对应的组件<br>BrowserRouter 使用的 h5 的 histrory API,不兼容 IE9 以下版本<br>HashRouter 使用的 URL 的哈希值</p>
</blockquote>
<ul>
<li>react-router-dom</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//要统一由一个router管理，可包围在App外侧</span></span><br><span class="line">&lt;BrowserRouter&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">&#x27;/test&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/test&quot;</span> <span class="attr">component</span>=<span class="string">&#123;Test&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">BrowserRouter</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">HashRouter</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">&#x27;/test&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/test&quot;</span> <span class="attr">component</span>=<span class="string">&#123;Test&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">HashRouter</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>路由组件<blockquote>
<p>接受的 props 默认有 history，location，match</p>
</blockquote>
</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Route path=<span class="string">&quot;/test&quot;</span> component=&#123;Test&#125;&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>一般组件<br>props 传什么有什么</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Test /&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>NavLink<blockquote>
<p>可以通过 activeClassName 指定样式名,标签体内容是个特殊属性，通过 this.props.children 获取</p>
</blockquote>
</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;NavLink activeClassName=<span class="string">&quot;active_color&quot;</span>&gt;test</span><br><span class="line">&lt;/NavLink&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">NavLink</span> <span class="attr">activeClassName</span>=<span class="string">&quot;active_color&quot;</span> <span class="attr">children</span>=<span class="string">&#x27;test&#x27;</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">NavLink</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>Switch<blockquote>
<p>路由默认会全部匹配完，加上 switch 可实现单一匹配，提高效率</p>
</blockquote>
</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;Switch&gt;</span><br><span class="line">&lt;Route path=&quot;/test&quot; component=&#123;Test&#125;&gt;</span><br><span class="line">&lt;Route path=&quot;/test&quot; component=&#123;Test&#125;&gt;</span><br><span class="line">//默认模糊匹配,exact严格匹配，开启后无法匹配二级路由</span><br><span class="line">&lt;Route exact path=&quot;/test&quot; component=&#123;Test&#125;&gt;</span><br><span class="line">&lt;/Switch&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>Redirect<blockquote>
<p>重定向，写在路由最下方，当路由都不匹配时，跳转到 redirect 指定的路由</p>
</blockquote>
</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Redirect to=<span class="string">&quot;/test&quot;</span> &gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>二级路由</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;Switch&gt;</span><br><span class="line">&lt;Route path=&quot;/test&quot; component=&#123;Test&#125;&gt;</span><br><span class="line">&lt;Route path=&quot;/test/a&quot; component=&#123;Test&#125;&gt;</span><br><span class="line">&lt;Redirect to=&quot;/test&quot; &gt;</span><br><span class="line">&lt;/Switch&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>路由参数</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//params参数，this.props.match.params</span></span><br><span class="line">&lt;HashRouter&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=`/<span class="attr">test</span>/$&#123;<span class="attr">123</span>&#125;/$&#123;<span class="attr">123</span>&#125;`&gt;</span><span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/test/:id/:count&quot;</span> <span class="attr">component</span>=<span class="string">&#123;Test&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">HashRouter</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//search参数(为urlencoded编码字符串，需借助querystring解析)，this.location.match.search</span></span><br><span class="line"><span class="keyword">import</span> qs <span class="keyword">from</span> <span class="string">&#x27;querystring&#x27;</span></span><br><span class="line">&lt;HashRouter&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=`/<span class="attr">test</span>?<span class="attr">a</span>=<span class="string">$&#123;123&#125;&amp;b</span>=<span class="string">$&#123;123&#125;</span>`&gt;</span><span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/test&quot;</span> <span class="attr">component</span>=<span class="string">&#123;Test&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">//qs.parse(this.props.location.search)</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">HashRouter</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//state参数(不在地址栏显示，browser刷新页面不丢失，hashRouter刷新丢失)，this.props.location.state</span></span><br><span class="line">&lt;HashRouter&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">&#123;&#123;pathname:</span>&#x27;/<span class="attr">test</span>&#x27;<span class="attr">state:</span>&#123;<span class="attr">a</span>=<span class="string">123,b</span>=<span class="string">123&#125;&#125;&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/test&quot;</span> <span class="attr">component</span>=<span class="string">&#123;Test&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">HashRouter</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>编程式路由</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">goto</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">this</span>.props.history.push(<span class="string">&#x27;/test&#x27;</span>,&#123;</span><br><span class="line"><span class="attr">xx</span>:<span class="string">&#x27;xx&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">this</span>.props.history.replace(<span class="string">&#x27;/test&#x27;</span>,&#123;</span><br><span class="line"><span class="attr">xx</span>:<span class="string">&#x27;xx&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>withRouter<blockquote>
<p>加工一般组件，让一般组件用上路由 api</p>
</blockquote>
</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; withRouter &#125; <span class="keyword">from</span> <span class="string">&quot;react-router-dom&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> withRouter(Test); <span class="comment">//返回的是全新的组件</span></span><br></pre></td></tr></table></figure>

<h4 id="React-Router-6"><a href="#React-Router-6" class="headerlink" title="React Router 6"></a>React Router 6</h4><blockquote>
<p>移除<code>&lt;Switch/&gt;</code> ，新增<code>&lt;Routers/&gt;</code><br>移除<code>&lt;Redirect/&gt;</code>，新增<code>&lt;Navigate/&gt;</code> &gt; <code>component=&#123;About&#125;</code>变为 <code>element=&#123;&lt;About/&gt;&#125;</code><br>增加 hooks</p>
</blockquote>
<ul>
<li>Routers</li>
</ul>
<blockquote>
<p>提供路由出口，满足条件的路由组件会渲染到组件内部，相当与 vue-router 里的<router-view></router-view><br>必须用 Routers 包裹，不会匹配多个</p>
</blockquote>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;Routers,Route&#125; form <span class="string">&#x27;react-router-dom&#x27;</span></span><br><span class="line">&lt;Routers&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/test&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">Test</span>/&gt;</span>&#125;&gt;</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/TEST&quot;</span> <span class="attr">caseSensitive</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">Test2</span>/&gt;</span>&#125;&gt;//区分大小写</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">Routers</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>Navigate<blockquote>
<p>重定向,只要被渲染，就会切换路由</p>
</blockquote>
</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;Routers,Route,Navigate&#125; form <span class="string">&#x27;react-router-dom&#x27;</span></span><br><span class="line">&lt;Routers&gt;</span><br><span class="line">&lt;Route path=&quot;/test&quot; element=&#123;&lt;Test/&gt;&#125;&gt;</span><br><span class="line">&lt;Route path=&quot;/&quot; element=&#123;&lt;Navigate to=&quot;/test&quot;  /&gt;&#125;&gt;</span><br><span class="line">&lt;Route path=&quot;/&quot; element=&#123;&lt;Navigate to=&quot;/test&quot; replace /&gt;&#125;&gt;</span><br><span class="line">&lt;/Routers&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>NavLink</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;NavLink className=&#123;<span class="function">()=&gt;</span><span class="keyword">return</span> <span class="string">&#x27;activeColor&#x27;</span>&#125;&gt;&lt;/NavLink&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>路由表</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;lazy&#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123;useRoutes,Navigate&#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span></span><br><span class="line"><span class="comment">//生成路由</span></span><br><span class="line">cosnt About=lazy(<span class="function">()=&gt;</span><span class="keyword">import</span>(<span class="string">&#x27;../pages/About&#x27;</span>))</span><br><span class="line"><span class="keyword">const</span> element=useRoutes([</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>:<span class="string">&#x27;/test&#x27;</span>,</span><br><span class="line">    <span class="attr">element</span>:<span class="xml"><span class="tag">&lt;<span class="name">Test</span>/&gt;</span></span></span><br><span class="line">    children:[</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">path</span>:<span class="string">&#x27;new&#x27;</span>,</span><br><span class="line">        <span class="attr">element</span>:<span class="xml"><span class="tag">&lt;<span class="name">New</span>/&gt;</span></span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>:<span class="string">&#x27;/about&#x27;</span>,</span><br><span class="line">    <span class="attr">element</span>:<span class="xml"><span class="tag">&lt;<span class="name">About</span>/&gt;</span></span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="attr">path</span>:<span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">      <span class="comment">//实现路由重定向</span></span><br><span class="line">      <span class="attr">element</span>:<span class="xml"><span class="tag">&lt;<span class="name">Navigate</span> <span class="attr">to</span>=<span class="string">&#x27;/main&#x27;</span>/&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">&#123;/*引用路由表*/&#125;</span></span><br><span class="line"><span class="xml">&#123;element&#125;</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">)&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Outlet</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">Routers</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">Router</span> <span class="attr">path</span>=<span class="string">&quot;/test&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">Test</span> /&gt;</span>&#125;&gt;</span></span><br><span class="line"><span class="xml">        &#123;/*二级路由嵌套*/&#125;</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">Router</span> <span class="attr">path</span>=<span class="string">&quot;test1&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">Test1</span> /&gt;</span>&#125;&gt;<span class="tag">&lt;/<span class="name">Router</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">Router</span> <span class="attr">path</span>=<span class="string">&quot;test2&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">Test2</span> /&gt;</span>&#125;&gt;<span class="tag">&lt;/<span class="name">Router</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">Router</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">Routers</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;Outlet,NavLink&#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="comment">// 若要显示子路由，需在父级路由组件中引入Outlet！！！</span></span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">NavLink</span> <span class="attr">end</span> <span class="attr">to</span>=<span class="string">&quot;new&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">NavLink</span>&gt;</span>//end代表匹配子路由时，自己失去高亮</span></span><br><span class="line"><span class="xml">        &#123;/*指定路由组件呈现的位置*/&#125;</span></span><br><span class="line"><span class="xml">         <span class="tag">&lt;<span class="name">Outlet</span> /&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>路由参数</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//params参数，this.props.match.params</span></span><br><span class="line">&lt;Link to=<span class="string">`/test/<span class="subst">$&#123;<span class="number">123</span>&#125;</span>/<span class="subst">$&#123;<span class="number">123</span>&#125;</span>`</span>&gt;&lt;/Link&gt;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123;useParams,useMath&#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">Demo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">const</span> &#123;a,b&#125;=useParams()</span><br><span class="line"><span class="keyword">const</span> &#123;a,b&#125;=useParams(<span class="regexp">/test/</span>:a/:b&#125;)</span><br><span class="line"><span class="keyword">return</span> (&#123;a+b&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;Link to=<span class="string">`/test?a=<span class="subst">$&#123;<span class="number">123</span>&#125;</span>&amp;b=<span class="subst">$&#123;<span class="number">123</span>&#125;</span>`</span>&gt;&lt;/Link&gt;</span><br><span class="line"><span class="keyword">import</span> &#123;useSearchParams,useLocation&#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">Demo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">const</span> [search,setSearch]=useSearchParams()</span><br><span class="line"><span class="keyword">const</span> a=search.get(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> setData=<span class="function">()=&gt;</span>&#123;setSearch(<span class="number">1234</span>)&#125;<span class="comment">//更新a</span></span><br><span class="line"><span class="keyword">const</span> a1=useLocation()</span><br><span class="line"><span class="keyword">return</span> (&#123;a&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;Link to=<span class="string">&#x27;/test&#x27;</span> state=&#123;&#123;a=<span class="number">123</span>,b=<span class="number">123</span>&#125;&#125;&gt;&lt;/Link&gt;</span><br><span class="line"><span class="keyword">import</span> &#123;useLocation&#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">Demo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">const</span> obj=useLocation()</span><br><span class="line"><span class="keyword">return</span> (&#123;obj.a&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>编程式路由</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//导入useNavigate　函数</span></span><br><span class="line"><span class="keyword">import</span> &#123;useNavigate&#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span></span><br><span class="line"><span class="keyword">const</span> navigate=userNavigate()</span><br><span class="line"><span class="function"><span class="title">goto</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">//跳转</span></span><br><span class="line">  navigate(<span class="string">&#x27;/test&#x27;</span>)</span><br><span class="line">  navigate(<span class="string">&#x27;/test&#x27;</span>,&#123;</span><br><span class="line">    <span class="attr">replace</span>:<span class="literal">false</span>,</span><br><span class="line">    <span class="attr">state</span>:&#123;&#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  navigate(<span class="number">1</span>)<span class="comment">//前进</span></span><br><span class="line">  navigate(-<span class="number">1</span>)<span class="comment">//后退</span></span><br><span class="line"><span class="comment">//传参searchParams</span></span><br><span class="line">  navigate(<span class="string">&#x27;/test?id=1&amp;name=xigua&#x27;</span>)</span><br><span class="line"><span class="comment">//params参数</span></span><br><span class="line"><span class="comment">//需配置路由/test/:id/:name</span></span><br><span class="line">  navigate(<span class="string">&#x27;/test/1/xigua&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useParams, useSearchParams &#125; <span class="keyword">from</span> <span class="string">&quot;react-router-dom&quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [searchParams] = useSearchParams();</span><br><span class="line">  <span class="keyword">const</span> id = searchParams.get(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">  <span class="keyword">const</span> &#123; name &#125; = searchParams.getAll();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> [params] = useParams();</span><br><span class="line">  <span class="keyword">const</span> id = params.id;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>通配符</li>
</ul>
<blockquote>
<p>不匹配时，显示的内容</p>
</blockquote>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;Routes&gt;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">Home</span>&gt;</span><span class="tag">&lt;/<span class="name">Home</span>&gt;</span>&#125;&gt;</span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;*&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">NotFount</span>&gt;</span><span class="tag">&lt;/<span class="name">NotFount</span>&gt;</span>&#125;&gt;</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">Routes</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<h4 id="集中式状态管理工具-redux"><a href="#集中式状态管理工具-redux" class="headerlink" title="集中式状态管理工具 redux"></a>集中式状态管理工具 redux</h4><blockquote>
<p>状态管理 js 库，集中式管理 react 应用中多个组件共享的状态</p>
</blockquote>
<ul>
<li>store：联系 action 和 reducer 的对象，提供<code>getState()获取state</code>,<code>dispatch()发送action</code>,<code>subscribe()注册监听，返回值注销监听</code>方法<ul>
<li>action：本质是个对象，应用给 store 传递数据的载体，应用通过 store.dispatch()发送给 store</li>
<li>reducer:本质是个函数，用来响应发过来的 actions,处理后把 state 发给 store。（需要有 return 返回值，接受两个参数<code>初始化state</code>,<code>action</code>）</li>
<li>state:数据</li>
</ul>
</li>
</ul>
<h5 id="旧版"><a href="#旧版" class="headerlink" title="旧版"></a>旧版</h5><h6 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h6><ul>
<li>countAction.js</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个为count组件服务的action，</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">type</span>: <span class="string">&quot;xxxx&quot;</span>, data &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>countReducer.js</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个为count组件服务的reducer，reducer本质是一个函数</span></span><br><span class="line"><span class="comment">//第一次调用时是store自动触发的，传递的preState是undefin</span></span><br><span class="line"><span class="comment">//必须是纯函数（同样输入必定得到同样输出）不要在reducer中发起网络请求、改写prestate、使用Date.now() , Math.random()</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> (<span class="params">preState, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; type, data &#125; = action;</span><br><span class="line">  <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">      <span class="keyword">return</span> preState; <span class="comment">//当preState没有变化时，不会引起页面刷新（浅比较）</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">      <span class="keyword">return</span> preState + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>constants.js</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> ADD = <span class="string">&quot;add&quot;</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>test.jsx</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&#x27;../store/store.js&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123;test&#125; <span class="keyword">from</span> <span class="string">&#x27;../store/countAction.js&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">store.subscribe(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.setState(&#123;&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">increment</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  store.dispatch(test(<span class="number">123</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> （&lt;div&gt;&#123;&#123;store.getState()&#125;&#125;&lt;/div&gt;）</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="中间件实现异步-action"><a href="#中间件实现异步-action" class="headerlink" title="中间件实现异步 action"></a>中间件实现异步 action</h6><blockquote>
<p>异步 action 指 action 返回值为函数，同步 action 指 action 返回值为对象<br>redux-thunk 能让我们的 action 不仅能返回一个对象还能返回一个函数，在函数里面在进行一次 dispatch，这样就能把异步请求抽离到 action 里面</p>
</blockquote>
<ul>
<li><p>安装：<code>yarn add redux-thunk</code></p>
</li>
<li><p>store.js</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;createStore,applyMiddleware&#125;form <span class="string">&#x27;redux&#x27;</span></span><br><span class="line"><span class="comment">//引入异步action中间件</span></span><br><span class="line"><span class="keyword">import</span> thunk  <span class="keyword">from</span> <span class="string">&#x27;redux-thunk&#x27;</span></span><br><span class="line"><span class="keyword">import</span> countReducer <span class="keyword">from</span> <span class="string">&#x27;./countReducer&#x27;</span></span><br><span class="line"><span class="keyword">const</span> store=createStore(countReducer,applyMiddleware(thunk))</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store</span><br></pre></td></tr></table></figure>

<ul>
<li>action.js</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&#x27;./store&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> add=data=(&#123;<span class="attr">type</span>:<span class="string">&#x27;add&#x27;</span>,data&#125;)<span class="comment">//同步action,直接返回对象</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> addAsync=<span class="function">(<span class="params">data,a,b,c</span>)=&gt;</span>&#123;<span class="comment">//异步action,返回函数，函数参数是dispatch方法</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">dispatch</span>)=&gt;</span>&#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">          dispatch(&#123;<span class="attr">type</span>:<span class="string">&#x27;add&#x27;</span>,<span class="attr">data</span>:<span class="number">123</span>&#125;&#125;)</span><br><span class="line">      &#125;,<span class="number">50000</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h6 id="多个-reducer"><a href="#多个-reducer" class="headerlink" title="多个 reducer"></a>多个 reducer</h6><ul>
<li>store.js</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;createStore，applyMiddleware,combineReducers&#125;form <span class="string">&#x27;redux&#x27;</span></span><br><span class="line"><span class="keyword">import</span> countReducer1 <span class="keyword">from</span> <span class="string">&#x27;./reducer/count1&#x27;</span></span><br><span class="line"><span class="keyword">import</span> countReducer2 <span class="keyword">from</span> <span class="string">&#x27;./reducer/count2&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> allReducer=combineReducers(&#123;</span><br><span class="line">  <span class="attr">count1</span>:countReducer1</span><br><span class="line">  <span class="attr">count2</span>:countReducer2</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> createStore(allReducer)</span><br></pre></td></tr></table></figure>

<h5 id="react-redux"><a href="#react-redux" class="headerlink" title="react-redux"></a>react-redux</h5><p>官方用于配合 react 的库，使组件更加方便从 store 中读取数据，分发 action</p>
<blockquote>
<p>组件通过 props 传递状态、操作方法<br>不用再写 store.subscribe()</p>
</blockquote>
<h6 id="provide"><a href="#provide" class="headerlink" title="provide"></a>provide</h6><p>该组件能使整个 app 都能读取到 store 中的数据</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//index.js</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&quot;./store&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Provider &#125; <span class="keyword">from</span> <span class="string">&quot;react-redux&quot;</span>;</span><br><span class="line"><span class="comment">//自动匹配容器组件，添加上store</span></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">ProVider</span> <span class="attr">store</span>=<span class="string">&#123;store&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">App</span> /&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">ProVider</span>&gt;</span></span>,</span><br><span class="line">  <span class="built_in">document</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h6 id="connect"><a href="#connect" class="headerlink" title="connect"></a>connect</h6><p>该方法能使组件和 store 进行关联,使用<code>connect(参数)(组件)</code><br>常用参数</p>
<ul>
<li><code>mapStateToProps(state,ownProps)函数</code>将 store 中的数据作为 props 绑定到组件上</li>
<li><code>mapDispatchToProps(dispatch,ownProps)函数</code>将 action 作为 props 绑定到组件上</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="title">extend</span> <span class="title">Componet</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &lt;div onClick=&#123;()=&gt;&#123;this.props.add()&#125;&#125;&gt;&#123;this.props.state.value&#125;&lt;div&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let mapStateToProps = (state) =&gt; &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    a: 1,</span><br><span class="line">    b: state,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">let mapDisoatchToProps = (dispatch) =&gt; &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    d: (data) =&gt; &#123;</span><br><span class="line">      dispatch(&#123; type: &quot;xxx&quot;, data &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line">export default connect(</span><br><span class="line"> mapStateToProps,</span><br><span class="line"> mapDisoatchToProps</span><br><span class="line">)(Test)</span><br></pre></td></tr></table></figure>

<h5 id="新版"><a href="#新版" class="headerlink" title="新版"></a>新版</h5><p>使用 Redux Toolkit 简化 Redux</p>
<p><code>npm install @reduxjs/toolkit react-redux</code><br>react-redux 也需要单独安装</p>
<ul>
<li><p>configureStore</p>
<blockquote>
<p>configureStore 替代 createStore 配置简单,设置默认值也方便<br>src/store/index.js</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入</span></span><br><span class="line"><span class="keyword">import</span> &#123; configureStore &#125; <span class="keyword">from</span> <span class="string">&quot;@reduxjs/toolkit&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> counterSlice <span class="keyword">from</span> <span class="string">&quot;../pages/basic/counterSlice&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> mySlice <span class="keyword">from</span> <span class="string">&quot;../pages/mySlice&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> configureStore(&#123;</span><br><span class="line">  <span class="attr">reducer</span>: &#123;</span><br><span class="line">    <span class="attr">rootCounter</span>: counterSlice,</span><br><span class="line">    <span class="attr">rootMy</span>: mySlice,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
</ul>
<p>这里 reduer 直接合并成一个唯一的根 root 了,原有的 <code>combineReducers</code> 这个合并函数就用不到了<br>注意自己配置的 reducer 的 key 值 和 对应的 value 值</p>
<ul>
<li>根组件配置 store</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">入口index.js;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">&quot;react-dom/client&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&quot;./store&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Provider &#125; <span class="keyword">from</span> <span class="string">&quot;react-redux&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> root = ReactDOM.createRoot(<span class="built_in">document</span>.getElementById(<span class="string">&quot;root&quot;</span>));</span><br><span class="line">root.render(</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">React.StrictMode</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">Provider</span> <span class="attr">store</span>=<span class="string">&#123;store&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">App</span> /&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">Provider</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">React.StrictMode</span>&gt;</span></span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>createAction<br>创建一个 action，传入动作类型字符串，返回动作函数。<br>createAction 语法： function createAction(type, prepareAction?)<br>1，type：Redux 中的 actionTypes<br>2，prepareAction：Redux 中的 actions</p>
</li>
<li><p>createReducer<br>创建一个 reducer，action type 映射到 case reducer 函数中，不用写 switch-case，并集成 immer。<br>Builder 提供了三个方法：<br>1，addCase： 根据 action 添加一个 reducer case 的操作。<br>2，addMatcher： 在调用 actions 前，使用 matcher function 过滤<br>3，addDefaultCase： 默认值，等价于 switch 的 default case;</p>
</li>
<li><p>createSlice reducer 编写</p>
<blockquote>
<p>createSlice 对 actions、Reducer 的一个封装。</p>
</blockquote>
<ul>
<li><p>创建 slice<br>使用 createSlice 方法创建一个 slice。每一个 slice 里面包含了 reducer 和 actions，可以实现模块化的封装。<br>所有的相关操作都独立在一个文件中完成。</p>
</li>
<li><p>关键属性:</p>
<ul>
<li><code>name</code>：命名空间，可以自动的把每一个 action 进行独立，解决了 action 的 type 出现同名的文件。在使用的时候默认会把使用 <code>name/actionName</code></li>
<li><code>initialState</code>：state 数据的初始值</li>
</ul>
</li>
<li><p>reducers<br>定义的 action。由于内置了 immutable 插件，可以直接使用赋值的方式进行数据的改变，不需要每一次都返回一个新的 state 数据。</p>
</li>
<li><p>导出<br>counterSlice.actions 导出所有的修改函数方便页面使用<br>counterSlice.reducer 导出 reducer 在 store 里面使用<br>具体 reducer 函数的参数<br>参数 1: 当前 slice 的 state 数据<br>参数 2: 对象{type:””,payload:传参}</p>
</li>
</ul>
</li>
</ul>
<p>type:counterSpace/decrement<br>type 就是之前的 actions 用 switc/case 来匹配很麻烦,现在简洁了<br>type 构成 slice 的 name 命名空间/具体的修改函数</p>
<p>payload 要和传的时候保持一致</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createSlice &#125; <span class="keyword">from</span> <span class="string">&quot;@reduxjs/toolkit&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> initialState = &#123;</span><br><span class="line">  <span class="attr">counter</span>: <span class="number">100</span>,</span><br><span class="line">  <span class="attr">user</span>: &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;yzs&quot;</span>,</span><br><span class="line">    <span class="attr">job</span>: <span class="string">&quot;全栈&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">reducer切片</span></span><br><span class="line"><span class="comment">createSlice函数的作用：生成分片的reducer</span></span><br><span class="line"><span class="comment">内部调用的市createAction和createReducer</span></span><br><span class="line"><span class="comment">creatSlice可以帮助我们用更少的代码去生成配套的reducer和action,而且有很好的维护性</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> counterSlice = createSlice(&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;counterSpace&quot;</span>, <span class="comment">// 命名空间，在调用action的时候会默认的设置为action的前缀,保证唯一.不重名</span></span><br><span class="line">  initialState,</span><br><span class="line">  <span class="attr">reducers</span>: &#123;</span><br><span class="line">    <span class="comment">// reducer函数 state当前组件的数据</span></span><br><span class="line">    <span class="comment">//第二个参数为&#123;payload:&#123;&#125;,type:&quot;&quot;&quot;&#125; 想想旧写法或者vuex</span></span><br><span class="line">    <span class="function"><span class="title">increment</span>(<span class="params">state</span>)</span> &#123;</span><br><span class="line">      state.counter += <span class="number">100</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">decrement</span>(<span class="params">state, actions</span>)</span> &#123;</span><br><span class="line">      <span class="comment">// actions == &#123;payload:&#123;&#125;,type:&quot;&quot;&quot;&#125;</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;decrement---actions&quot;</span>, actions);</span><br><span class="line">      state.counter -= actions.payload;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">updateUser</span>(<span class="params">state, &#123; payload &#125;</span>)</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;updateUser-------payload&quot;</span>, payload);</span><br><span class="line">      <span class="comment">// 引用类型 注意 赋值的写法</span></span><br><span class="line">      state.user = &#123;</span><br><span class="line">        ...state.user,</span><br><span class="line">        ...payload,</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">切片对象会自动地帮助我们生成action</span></span><br><span class="line"><span class="comment">切片对象会根据我们地reducers方法来自动地创建action对象，这些action对象会保存到切片对象的actions中</span></span><br><span class="line"><span class="comment">&#123;type:name/函数名，payload:函数的参数&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> &#123; increment, decrement, updateUser &#125; = counterSlice.actions;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> selectCount = <span class="function">(<span class="params">state</span>) =&gt;</span> state.rootCounter.counter;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> selectUser = <span class="function">(<span class="params">state</span>) =&gt;</span> state.rootCounter.user;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> counterSlice.reducer;</span><br></pre></td></tr></table></figure>

<ul>
<li>页面使用<ol>
<li>useSelector()返回指定的 state</li>
</ol>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这样写太长了 麻烦</span></span><br><span class="line"><span class="keyword">const</span> counter = useSelector(<span class="function">(<span class="params">state</span>) =&gt;</span> state.rootCouter.counter);</span><br></pre></td></tr></table></figure>

<p>rootCouter 这个 key 来源于 根 store 里面配置的 reducer，这样写太长了，麻烦。在这个 slice 里面我做了统一处理</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> selectCount = <span class="function">(<span class="params">state</span>) =&gt;</span> state.rootCounter.counter;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> selectUser = <span class="function">(<span class="params">state</span>) =&gt;</span> state.rootCounter.user;</span><br></pre></td></tr></table></figure>

<p>页面使用</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useSelector, useDispatch &#125; <span class="keyword">from</span> <span class="string">&quot;react-redux&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  increment,</span><br><span class="line">  decrement,</span><br><span class="line">  updateUser,</span><br><span class="line">  selectCount,</span><br><span class="line">  selectUser,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">&quot;./normalSlice&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> dispatch = useDispatch();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// let counter = useSelector(state=&gt;state.rootCouter.counter)</span></span><br><span class="line">  <span class="keyword">const</span> counter = useSelector(selectCount);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;页面---counter:&quot;</span>, counter);</span><br><span class="line">  <span class="keyword">const</span> user = useSelector(selectUser);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这样可以直接解构出当前 slice所有的 state</span></span><br><span class="line"><span class="comment">// 具体用哪种 看自己心情</span></span><br><span class="line"> <span class="keyword">const</span> &#123; counter &#125; = useSelector(<span class="function">(<span class="params">state</span>) =&gt;</span> state.rootCouter);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ( <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span> 布局看下面 <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>useDispatch()<br>payload 传参和 reducer 保持一致<br>引用类型的 修改注意</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> dispatch = useDispatch(); 修改函数</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>reduxjs/toolkit 基础用法<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">hr</span> /&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> dispatch(increment())&#125;&gt;+<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;counter&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> dispatch(decrement(666))&#125;&gt;-<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">hr</span> /&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>姓名:&#123;user.name&#125; ---职业:&#123;user.job&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span>=&gt;</span>&#123;dispatch(updateUser(&#123;name:&#x27;Michael&#x27;&#125;))&#125;&#125;&gt;改名<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span>=&gt;</span>&#123;</span></span><br><span class="line"><span class="xml">        dispatch(updateUser(&#123;job:&#x27;自由职业者&#x27;&#125;))&#125;</span></span><br><span class="line"><span class="xml">        &#125;&gt;转行<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>异步 createAsyncThunk()<br>内置了 redux-thunk 处理异步 , 足够解决绝大部分的问题. 还有其他中间件比如:redux-saga 、redux-observable。<br>异步请求处理三种状态的 action :pending\fulfilled\rejected；<br>这三种状态的 action 自动触发, 防止外部手动调用,则使用属性 extraReducers , 则不会生成对外的的 action creator .</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">接受一个动作类型字符串和一个返回<span class="built_in">Promise</span>函数，并生成一个pending/fulfilled/rejected基于该<span class="built_in">Promise</span>分派动作类型的 thunk</span><br><span class="line">用 fetch请求模拟一个异步</span><br><span class="line"><span class="number">3.</span>createAsyncThunk(<span class="string">&quot;counterSpace/getList&quot;</span>,<span class="function">()=&gt;</span>&#123;&#125;)</span><br><span class="line">参数<span class="number">1</span>: slice的name/命名空间/函数名</span><br><span class="line"></span><br><span class="line"><span class="comment">// return 不要忘记</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> getList = <span class="function">( ) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fetch(<span class="string">&quot;https://.XX.cn/api/news&quot;</span>).then(<span class="function"><span class="params">res</span>=&gt;</span>res.json());</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span>  getListAsync =  createAsyncThunk(<span class="string">&quot;counterSpace/getList&quot;</span>,<span class="keyword">async</span>()=&gt;&#123;</span><br><span class="line">  <span class="keyword">const</span> res = <span class="keyword">await</span> getList()</span><br><span class="line">  <span class="keyword">return</span> res<span class="comment">// 此处的返回结果会在 .fulfilled中作为payload的值</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>extraReducers<br>异步函数配置</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">createSlice(&#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;counterSpace&quot;</span>,</span><br><span class="line">    initialState,</span><br><span class="line">    <span class="attr">reducers</span>:&#123;&#125;,</span><br><span class="line">    <span class="attr">extraReducers</span>: <span class="function">(<span class="params">builder</span>) =&gt;</span> &#123;</span><br><span class="line">    builder</span><br><span class="line">      .addCase(getListAsync.pending, <span class="function">(<span class="params">state</span>) =&gt;</span> &#123;</span><br><span class="line">         <span class="built_in">console</span>.log(<span class="string">&quot;pending&quot;</span>,state);</span><br><span class="line">      &#125;)</span><br><span class="line">      .addCase(getListAsync.rejected, <span class="function">(<span class="params">state, err</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;rejected 失败&quot;</span>,err);</span><br><span class="line"></span><br><span class="line">      &#125;)</span><br><span class="line">      .addCase(getListAsync.fulfilled, <span class="function">(<span class="params">state, action</span>) =&gt;</span> &#123;</span><br><span class="line">         <span class="built_in">console</span>.log(<span class="string">&quot;fulfilled 成功&quot;</span>,state);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;fulfilled action&quot;</span>,action);</span><br><span class="line"></span><br><span class="line">        state.list = action.payload</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line">这个配置基本就是套路</span><br><span class="line">只需要把函数名字改为通过createAsyncThunk()创建的函数名</span><br><span class="line">根据自己的业务场景 写赋值逻辑就行</span><br></pre></td></tr></table></figure>

<p>页面使用异步函数</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onClick=&#123;<span class="function">()=&gt;</span>dispatch(getListAsync(<span class="string">&#x27;异步模拟&#x27;</span>))&#125;&gt;异步&lt;/button&gt;</span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="xml">        &#123;</span></span><br><span class="line"><span class="xml">          listData.map((news)=&gt;&#123;</span></span><br><span class="line"><span class="xml">            return <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;news.id&#125;</span>&gt;</span>&#123;news.title&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">          &#125;)</span></span><br><span class="line"><span class="xml">        &#125;</span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<h5 id="集中式状态管理工具-Mobx"><a href="#集中式状态管理工具-Mobx" class="headerlink" title="集中式状态管理工具 Mobx"></a>集中式状态管理工具 Mobx</h5><blockquote>
<p>简单：编写无模板的极简代码<br>轻松实现最优渲染：依赖自动追踪最小渲染优化<br>自由：可移植，测试</p>
</blockquote>
<h6 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install mobx mobx-react</span><br></pre></td></tr></table></figure>

<h6 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h6><ul>
<li>stroe/counter.js</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; makeAutoObservable, computed &#125; <span class="keyword">from</span> <span class="string">&quot;mobx&quot;</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CounterStore</span> </span>&#123;</span><br><span class="line">  <span class="comment">//定义数据</span></span><br><span class="line">  count = <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">//把数据弄成响应式</span></span><br><span class="line">    makeAutoObservable(<span class="built_in">this</span>, &#123;</span><br><span class="line">      <span class="attr">count_2</span>: computed, <span class="comment">//标记为计算属性</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//修改数据</span></span><br><span class="line">  addCount = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.conut++;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> <span class="title">count_2</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.count * <span class="number">10</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实例化，导出</span></span><br><span class="line"><span class="keyword">const</span> counterStore = <span class="keyword">new</span> CounterStore();</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> counterStore;</span><br></pre></td></tr></table></figure>

<ul>
<li>App.js</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//导入store</span></span><br><span class="line"><span class="keyword">import</span> counterStore <span class="keyword">from</span> <span class="string">&quot;./store/counter.js&quot;</span>;</span><br><span class="line"><span class="comment">//导入中间件，链接mobx，react,完成响应式</span></span><br><span class="line"><span class="keyword">import</span> &#123; observer &#125; <span class="keyword">from</span> <span class="string">&quot;mobx-react&quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      &#123;counterSotre.count&#125;</span></span><br><span class="line"><span class="xml">      &#123;counterSotre.count_2&#125;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;counterStore.addCount&#125;</span>&gt;</span>add<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> observer(App);</span><br></pre></td></tr></table></figure>

<h6 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h6><ul>
<li>store/index.js</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//组合模块</span></span><br><span class="line"><span class="keyword">import</span> &#123; CounterStore &#125; <span class="keyword">from</span> <span class="string">&quot;./counter.Store.js&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//声明rootStore</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RootStore</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.counterStore = <span class="keyword">new</span> CounterSotre();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实例化根store</span></span><br><span class="line"><span class="keyword">const</span> rootStore = <span class="keyword">new</span> RootStore();</span><br><span class="line"><span class="comment">//使用context进行透传．也可以直接导出包一层observer</span></span><br><span class="line"><span class="comment">//查找机制：优先从Provider标签中value,若找不到则找createContext()方法中的传递过来的默认参数</span></span><br><span class="line"><span class="keyword">const</span> context = React.createContext(rootStore);</span><br><span class="line"><span class="keyword">const</span> useStore = <span class="function">() =&gt;</span> React.useContext(context);</span><br><span class="line"><span class="keyword">export</span> &#123; useStore &#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>store/counter.Stroe.js</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; makeAutoObservable, computed &#125; <span class="keyword">from</span> <span class="string">&quot;mobx&quot;</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CounterStore</span> </span>&#123;</span><br><span class="line">  <span class="comment">//定义数据</span></span><br><span class="line">  count = <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">//把数据弄成响应式</span></span><br><span class="line">    makeAutoObservable(<span class="built_in">this</span>, &#123;</span><br><span class="line">      <span class="attr">count_2</span>: computed, <span class="comment">//标记为计算属性</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//修改数据</span></span><br><span class="line">  addCount = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.conut++;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> <span class="title">count_2</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.count * <span class="number">10</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实例化，导出</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> CounterStore;</span><br></pre></td></tr></table></figure>

<p>App.js</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//导入store</span></span><br><span class="line"><span class="keyword">import</span> &#123; useStore &#125; <span class="keyword">from</span> <span class="string">&quot;./store/index.js&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; observer &#125; <span class="keyword">from</span> <span class="string">&quot;mobx-react&quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> rootStore = useStore();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      &#123;rootStore.counterSotre.count&#125;</span></span><br><span class="line"><span class="xml">      &#123;rootStore.counterSotre.count_2&#125;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;rootStore.counterStore.addCount&#125;</span>&gt;</span>add<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> observer(App);</span><br></pre></td></tr></table></figure>

<h5 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">a</span>: &#123; <span class="attr">b</span>: <span class="number">1</span> &#125; &#125;;</span><br><span class="line"><span class="keyword">const</span> &#123; a &#125; = obj;</span><br><span class="line"><span class="keyword">const</span> &#123;</span><br><span class="line">  <span class="attr">a</span>: &#123; b &#125;,</span><br><span class="line">&#125; = obj; <span class="comment">//连续解构赋值</span></span><br><span class="line"><span class="keyword">const</span> &#123;</span><br><span class="line">  <span class="attr">a</span>: &#123; <span class="attr">b</span>: value &#125;,</span><br><span class="line">&#125; = obj; <span class="comment">//连续解构赋值+重命名</span></span><br></pre></td></tr></table></figure>

<h5 id="高阶组件"><a href="#高阶组件" class="headerlink" title="高阶组件"></a>高阶组件</h5><blockquote>
<p>把一个组件当成另一个组件的参数传入，然后返回新的组件</p>
</blockquote>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">AuthComponent</span>(<span class="params">&#123;children&#125;</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> isToken=<span class="built_in">localStorage</span>.get(<span class="string">&#x27;token&#x27;</span>)</span><br><span class="line">  <span class="keyword">if</span>(isToken)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;&gt;</span>&#123;children&#125;<span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Navigate</span> <span class="attr">to</span>=<span class="string">&quot;/login&quot;</span> <span class="attr">replace</span> /&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line">&lt;AuthComponent&gt;</span><br><span class="line">  &lt;Home&gt;</span><br><span class="line">&lt;/AuthComponent&gt;</span><br></pre></td></tr></table></figure>

<h5 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h5><ul>
<li>若 a 函数，接收的参数是一个函数，那么 a 就可以称为高阶函数</li>
<li>若 a 函数，调用的返回值依然是一个函数，那么 a 就可以称为高阶函数<br>如 promise setTimeOut arr.map()</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">test=(type)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function">(<span class="params">e</span>)=&gt;</span>&#123;</span><br><span class="line">arr.push( &#123;[type]:e.target.value&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;input onChange=<span class="string">&quot;&#123;test(&#x27;1&#x27;)&#125;&quot;</span>/&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">onChange</span>=<span class="string">&quot;&#123;test(&#x27;2&#x27;)&#125;&quot;</span>/&gt;</span></span></span><br></pre></td></tr></table></figure>

<h5 id="函数的柯里化"><a href="#函数的柯里化" class="headerlink" title="函数的柯里化"></a>函数的柯里化</h5><p>通过函数调用继续返回函数的方式，实现多次接收参数最后统一处理的函数编码形式</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">test=(type)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function">(<span class="params">e</span>)=&gt;</span>&#123;</span><br><span class="line">arr.push( &#123;[type]:e.target.value&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum2</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">b</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">c</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> a + b + c;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">sum(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<h3 id="useState-和-setState-到底是同步还是异步"><a href="#useState-和-setState-到底是同步还是异步" class="headerlink" title="useState 和 setState 到底是同步还是异步"></a>useState 和 setState 到底是同步还是异步</h3><h4 id="18-x"><a href="#18-x" class="headerlink" title="18.x"></a>18.x</h4><p>均为异步</p>
<h4 id="18-x-以下"><a href="#18-x-以下" class="headerlink" title="18.x 以下"></a>18.x 以下</h4><h5 id="在正常的-react-的事件流里（如-onClick-等）"><a href="#在正常的-react-的事件流里（如-onClick-等）" class="headerlink" title="在正常的 react 的事件流里（如 onClick 等）"></a>在正常的 react 的事件流里（如 onClick 等）</h5><ul>
<li>setState 和 useState 是异步执行的（不会立即更新 state 的结果）</li>
<li>多次执行 setState 和 useState，只会调用一次重新渲染 render<br>不同的是，setState 会进行 state 的合并，而 useState 则不会</li>
</ul>
<h5 id="在-setTimeout，Promise-then-等异步事件中"><a href="#在-setTimeout，Promise-then-等异步事件中" class="headerlink" title="在 setTimeout，Promise.then 等异步事件中"></a>在 setTimeout，Promise.then 等异步事件中</h5><ul>
<li>setState 和 useState 是同步执行的（立即更新 state 的结果）</li>
<li>多次执行 setState 和 useState，每一次的执行 setState 和 useState，都会调用一次 render</li>
</ul>
<h4 id="前端发请求"><a href="#前端发请求" class="headerlink" title="前端发请求"></a>前端发请求</h4><h5 id="xhr"><a href="#xhr" class="headerlink" title="xhr"></a>xhr</h5><ul>
<li>jquery</li>
<li>axios（node 使用 axios 是封装 http 协议）</li>
</ul>
<h5 id="fetch"><a href="#fetch" class="headerlink" title="fetch"></a>fetch</h5><blockquote>
<p>原生函数,老版本兼容性差</p>
</blockquote>
<p>fetch(‘xxx’).then(res=&gt;{<br>//联系服务器成功<br>return res.json()<br>},err=&gt;{return new Promis(()=&gt;{})}).then(res=&gt;{},err=&gt;{})</p>
<h5 id="setState"><a href="#setState" class="headerlink" title="setState"></a>setState</h5><p>写法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">state = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"></span><br><span class="line">对象式setState;</span><br><span class="line"><span class="built_in">this</span>.setState(&#123; <span class="attr">a</span>: <span class="number">2</span> &#125;);</span><br><span class="line"><span class="built_in">this</span>.setState(&#123; <span class="attr">a</span>: <span class="number">2</span> &#125;, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//状态更新以及页面也更新后，才调用</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">函数式setState;</span><br><span class="line"><span class="built_in">this</span>.setState(</span><br><span class="line">  <span class="function">(<span class="params">state, props</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function">() =&gt;</span> &#123;&#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h4 id="lazyLoad"><a href="#lazyLoad" class="headerlink" title="lazyLoad"></a>lazyLoad</h4><blockquote>
<p>路由组件懒加载</p>
</blockquote>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;lazy,Component,Suspense&#125; form <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Loading <span class="keyword">from</span> <span class="string">&quot;./component/Loading.jsx&quot;</span></span><br><span class="line"><span class="keyword">const</span> Home=lazy(<span class="function">()=&gt;</span>&#123;<span class="keyword">import</span> (<span class="string">&#x27;./Home&#x27;</span>)&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> <span class="title">extend</span> <span class="title">Component</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&lt;Suspense fallback=&#123;<span class="xml"><span class="tag">&lt;<span class="name">Loading</span>/&gt;</span></span>&#125;&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">Route</span>  <span class="attr">path</span>=<span class="string">&quot;/home&quot;</span> <span class="attr">component</span>=<span class="string">&#123;Home&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">Route</span>&gt;</span></span></span><br><span class="line">&lt;/Suspense&gt;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="Hooks"><a href="#Hooks" class="headerlink" title="Hooks"></a>Hooks</h4><blockquote>
<p>hook 是 16.8 的新特性，可以让你在函数组件中使用 state 以及其他 react 特性<br>hook 本质是一套能够使函数组件更强大，灵活的‘钩子’(某一时刻下自动执行的函数)<br>解决组件逻辑复用的问题：hook 出现前，react 先后尝试了 mixins、HOC 高阶组件、render-props 等模式，但各自都有对应的问题。如 mixin 的数据来源不明，高阶组件的嵌套问题<br>解决了类式组件自身的问题：如属性过多，生命周期、this 指向</p>
</blockquote>
<h5 id="state-1"><a href="#state-1" class="headerlink" title="state"></a>state</h5><p>useState 返回的值是数组</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [a, set] = React.useState(<span class="number">123</span>); <span class="comment">//初始化会调用一次，下次调用时，会缓存数据，不会覆盖</span></span><br><span class="line">  <span class="comment">//不能在if/for/函数体中写（react会按照hooks调用顺序识别每一个hook）</span></span><br><span class="line">  <span class="keyword">let</span> add1 = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    set(<span class="number">456</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">let</span> add2 = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    set(<span class="function">(<span class="params">a</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> a + <span class="number">1</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;a&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="effect"><a href="#effect" class="headerlink" title="effect"></a>effect</h5><blockquote>
<p>函数组件里使用生命周期</p>
</blockquote>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React form <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">const</span> [count,setCount]=React.useState(<span class="number">123</span>)</span><br><span class="line"></span><br><span class="line">React.useEffect(<span class="function">()=&gt;</span>&#123;&#125;,[a])<span class="comment">//检测a,改变时调用------</span></span><br><span class="line">React.useEffect(<span class="function">()=&gt;</span>&#123;&#125;,[])<span class="comment">//谁也不监测,仅在挂载和卸载的时候执行----</span></span><br><span class="line">React.useEffect(<span class="function">()=&gt;</span>&#123;&#125;)<span class="comment">//检测所有,改变时调用----componentDidUpdate</span></span><br><span class="line">React.useEffect(<span class="function">()=&gt;</span>&#123;<span class="keyword">return</span> <span class="function">()=&gt;</span>&#123;组件卸载前执行&#125;&#125;,[])<span class="comment">//componentWillUnmount</span></span><br><span class="line"><span class="comment">//不要在useEffectd 的回调函数外层直接包裹await,因为异步会导致清理函数无法立即返回</span></span><br><span class="line">React.useEffect(<span class="keyword">async</span>()=&gt;&#123;</span><br><span class="line">  <span class="keyword">const</span> res=<span class="keyword">await</span> axios.get(<span class="string">&#x27;...&#x27;</span>)</span><br><span class="line">&#125;,[])</span><br><span class="line"><span class="comment">//正确写法</span></span><br><span class="line">React.useEffect(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getData</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> res=<span class="keyword">await</span> axios.get(<span class="string">&#x27;...&#x27;</span>)</span><br><span class="line">&#125;&#125;,[])</span><br><span class="line"><span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>a<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在 React 通知到 Renderer 渲染器后，渲染器又分了三个子阶段来处理：</p>
<p>beforeMutation 阶段（渲染视图前）<br>mutation 阶段（渲染试图）<br>layout 阶段（渲染视图后）<br>渲染器会在 mutation 阶段完成后， 在 layout 阶段同步的调用 useLayoutEffect，在子组件嵌套中于是如此。在类组件中，调用的是 componentDidMount 生命周期函数。也就是说，在 useLayoutEffect 中，无论是否有重新触发 setState，也不会在当前渲染里，重新更新界面。<br>而在整个渲染器渲染阶段（其实也叫 commit）渲染完成后，react 才会异步的执行 useEffect。当在 useEffect 中如果有 setState，则会重新触发渲染器，更新界面。</p>
<p>结论：</p>
<p>useLayoutEffect 的是在渲染器执行当前渲染界面任务时，同步执行。<br>在当前一轮的 Reconciler 任务调度过程中，在渲染器执行完当前任务后，才会异步调用 useEffect。<br>useLayoutEffect 先于 useEffect 执行，并且子组件优先执行。<br>componentDidMount()完全等价于 useLayoutEffect( fn , [ ] )，但是不等价于 useEffect( fn , [ ] )。</p>
<h5 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h5><blockquote>
<p>获取 dom 元素获取组件对象</p>
</blockquote>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React form <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">const</span> myRef=React.useRef()</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params"></span>)</span>&#123;myRef.style.color=<span class="string">&#x27;red&#x27;</span>&#125;</span><br><span class="line"><span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">&#123;myRef&#125;</span>&gt;</span>a<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Fragment"><a href="#Fragment" class="headerlink" title="Fragment"></a>Fragment</h4><blockquote>
<p>可以不用必须有一个真实 DOM 根标签，编译后会移除</p>
</blockquote>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">Fragment</span> <span class="attr">key</span>=<span class="string">&#123;&#125;</span>&gt;</span>//只能有一个属性：key</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;&gt;</span>//简写，但不能写任何属性</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/&gt;</span></span></span><br><span class="line">&lt;/Fragment&gt;</span><br><span class="line">)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h4><blockquote>
<p>常用与祖组件和后代组件通信<br>一般不用 Context,而是它的封装 react-redux</p>
</blockquote>
<p>类式组件</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> CountContext = React.createContext(); <span class="comment">//创建一个上下文,必须所有组件都访问得到</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="name">CountContext.Provider</span> <span class="attr">value</span>=<span class="string">&#123;this.state.a&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">B</span> /&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">CountContext.Provider</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">C</span> /&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> contextType = CountContext; <span class="comment">//声明接收context</span></span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.context;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>所有组件</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> CountContext=React.createContext()<span class="comment">//创建一个上下文,必须所有组件都访问得到</span></span><br><span class="line"><span class="keyword">const</span> &#123;Consumer,Provider&#125;=CountContext</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">state=&#123;<span class="attr">a</span>:<span class="number">1</span>&#125;</span><br><span class="line"><span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">Provider</span> <span class="attr">value</span>=<span class="string">&#123;this.state.a&#125;</span>&gt;</span><span class="tag">&lt;<span class="name">B</span>/&gt;</span><span class="tag">&lt;/<span class="name">Provider</span>&gt;</span></span>)&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line"><span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">C</span>/&gt;</span></span>)&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">C</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">static</span> contextType=CountContext<span class="comment">//声明接收context</span></span><br><span class="line"><span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">Consumer</span>&gt;</span>&#123;value=&gt;&#123;return (<span class="tag">&lt;<span class="name">span</span>&gt;</span>value<span class="tag">&lt;/<span class="name">span</span>&gt;</span>)&#125;<span class="tag">&lt;/<span class="name">Consumer</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>)&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="PureComponent"><a href="#PureComponent" class="headerlink" title="PureComponent"></a>PureComponent</h4><blockquote>
<p>只要执行 setState 即使不更新数据，组件也会重新 render9)<br>只要 render()调用，其子组件也会更新<br>原因：shouldComponentUpdate()默认总是为 true</p>
</blockquote>
<h5 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h5><ul>
<li>手动比较新旧值,不一样更新，否则禁止更新</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">shouldComponentUpdate</span>(<span class="params">nextProps,nextState</span>)</span>&#123;<span class="comment">//新的</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>.props,<span class="built_in">this</span>.state)<span class="comment">//旧的</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;PureComponent&#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">extends</span> <span class="title">PureComponent</span> </span>&#123;</span><br><span class="line"><span class="comment">//依赖的数据不更新时，不重新render</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj=<span class="built_in">this</span>.state</span><br><span class="line">obj.name=<span class="string">&#x27;xx&#x27;</span></span><br><span class="line"><span class="built_in">this</span>.setState(obj)<span class="comment">//浅比较，数据不会更新</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="render-Props"><a href="#render-Props" class="headerlink" title="render Props"></a>render Props</h4><blockquote>
<p>组件标签内可以直接写多个文本，标签、函数、jsx,会传入到组件 prpos 中的 chidren 属性中<br>vue 中的插槽</p>
</blockquote>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">state=&#123;<span class="attr">a</span>:<span class="number">1</span>&#125;</span><br><span class="line"><span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line">  <span class="xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">B</span>&gt;</span>aaa<span class="tag">&lt;/<span class="name">B</span>&gt;</span></span></span><br><span class="line"><span class="xml"> <span class="tag">&lt;<span class="name">B</span> <span class="attr">render</span>=<span class="string">&#123;(val)</span>=&gt;</span>&#123;<span class="tag">&lt;<span class="name">C</span> <span class="attr">b</span>=<span class="string">&#123;val&#125;</span> /&gt;</span>&#125;/&gt;</span></span><br><span class="line"><span class="xml"> <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">)&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">state=&#123;<span class="attr">b</span>:<span class="number">1</span>&#125;</span><br><span class="line"><span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line">  <span class="xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;this.props.children&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">this.props.render(this.state.b)</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/&gt;</span></span></span><br><span class="line">)&#125;<span class="comment">//aaa</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">C</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">static</span> contextType=CountContext<span class="comment">//声明接收context</span></span><br><span class="line"><span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">Consumer</span>&gt;</span>&#123;value=&gt;&#123;return (<span class="tag">&lt;<span class="name">span</span>&gt;</span>value<span class="tag">&lt;/<span class="name">span</span>&gt;</span>)&#125;<span class="tag">&lt;/<span class="name">Consumer</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>)&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ErrorBoundary-错误边界"><a href="#ErrorBoundary-错误边界" class="headerlink" title="ErrorBoundary 错误边界"></a>ErrorBoundary 错误边界</h4><blockquote>
<p>防止子组件出错导致整个页面出错,只能在生产环境使用<br>只能捕获后代组件生命周期产生的错误，不能捕获自己的</p>
</blockquote>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">state=&#123;<span class="attr">error</span>:<span class="string">&#x27;&#x27;</span>&#125;</span><br><span class="line"><span class="comment">//生命周期函数</span></span><br><span class="line"><span class="keyword">static</span> <span class="function"><span class="title">getDerivedStateFromError</span>(<span class="params">err</span>)</span>&#123;<span class="comment">//它的子组件出现报错时会调用</span></span><br><span class="line"><span class="function"><span class="title">componentDidCath</span>(<span class="params">err,info</span>)</span>&#123;&#125;<span class="comment">//发生错误时调用</span></span><br><span class="line"><span class="keyword">return</span> &#123;<span class="attr">error</span>:err&#125;<span class="comment">//返回新的state，在render前触发</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">&#123;error?error:&#x27;&#x27;&#125;</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="组件间通信-1"><a href="#组件间通信-1" class="headerlink" title="组件间通信"></a>组件间通信</h4><ul>
<li>props</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">children props</span><br><span class="line">render props</span><br></pre></td></tr></table></figure>

<ul>
<li>消息订阅-发布</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pubs-sub event</span><br></pre></td></tr></table></figure>

<ul>
<li>集中式管理</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redux、dva</span><br></pre></td></tr></table></figure>

<ul>
<li>conText</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">生产者 - 消费者模式;</span><br></pre></td></tr></table></figure>

<ul>
<li>搭配<br>父子：props<br>兄弟: 集中式管理、消息订阅发布，借助父组件<br>祖孙: 集中式管理、消息订阅发布、context（开发用的少，封装插件用得多）</li>
</ul>
<h3 id="关闭-eslint"><a href="#关闭-eslint" class="headerlink" title="关闭 eslint"></a>关闭 eslint</h3><p>第一步：执行以下命令：</p>
<p><code>npm run eject</code></p>
<p>第二步：在 package.json 中修改代码</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;eslintConfig&quot;</span>: &#123;</span><br><span class="line"><span class="attr">&quot;extends&quot;</span>: [</span><br><span class="line"><span class="string">&quot;react-app&quot;</span>,</span><br><span class="line"><span class="string">&quot;react-app/jest&quot;</span></span><br><span class="line">],</span><br><span class="line"><span class="attr">&quot;rules&quot;</span>:&#123;</span><br><span class="line"><span class="attr">&quot;no-undef&quot;</span>:<span class="string">&quot;off&quot;</span>,</span><br><span class="line"><span class="attr">&quot;no-restricted-globals&quot;</span>: <span class="string">&quot;off&quot;</span>,</span><br><span class="line"><span class="attr">&quot;no-unused-vars&quot;</span>: <span class="string">&quot;off&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>第三步：重启项目</p>
<h3 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h3><h4 id="并发模式下在-dev-时-render-phase-会执行两次"><a href="#并发模式下在-dev-时-render-phase-会执行两次" class="headerlink" title="并发模式下在 dev 时 render-phase 会执行两次"></a>并发模式下在 dev 时 render-phase 会执行两次</h4><p>这个是 react 的一个用来突出显示应用程序中潜在问题的工具（严格模式）</p>
<p>有一项检测意外的副作用，严格模式不能自动检测到你的副作用，但它可以帮助你发现它们，使它们更具确定性。通过故意重复调用以下函数来实现的该操作。</p>
<p>注意：这仅适用于开发模式。生产模式下生命周期不会被调用两次。strictMode，故意在开发环境中执行多次，暴雷出代码隐藏的 bug,把标签去掉即可</p>
<h4 id="antd-form，initialValue-值变化后不更新"><a href="#antd-form，initialValue-值变化后不更新" class="headerlink" title="antd+form，initialValue 值变化后不更新"></a>antd+form，initialValue 值变化后不更新</h4><p>当我们第一次点开 Modal 的时候， 会得到一个 initialValue,但是这个值只在组件挂载的时候执行了一次，后续数据的更新并不会造成重新渲染，所以当我们再次打开 Modal 窗口的时候并不会更新。</p>
<p>解决方案：<br>方法一：使用 form.resetFields()<br>使用 resetFields 方法会直接重置为 initialValue 的值，这样再次打开编辑表单就是我们想要的数据啦。</p>
<p>方法二：使用 form.setFieldsValue<br>对于 initialValue 不更新问题官方文档已经给出了解决方法</p>
<h4 id="react-获取上一轮的-props-和-state（接用-useEffect-useRef-实现）"><a href="#react-获取上一轮的-props-和-state（接用-useEffect-useRef-实现）" class="headerlink" title="react 获取上一轮的 props 和 state（接用 useEffect, useRef 实现）"></a>react 获取上一轮的 props 和 state（接用 useEffect, useRef 实现）</h4><p>如果只是 想实现 这个效果 下面的代码 也行 。就不用借助其它的了。 这个思路就是，在 改变 state 之前 就 备份一下 值 。</p>
<p>effect 的执行时机</p>
<p>与 componentDidMount、componentDidUpdate 不同的是，传给 useEffect 的函数会在浏览器完成布局与绘制之后，在一个延迟事件中被调用。这使得它适用于许多常见的副作用场景，比如设置订阅和事件处理等情况，因为绝大多数操作不应阻塞浏览器对屏幕的更新。</p>
<p>然而，并非所有 effect 都可以被延迟执行。例如，一个对用户可见的 DOM 变更就必须在浏览器执行下一次绘制前被同步执行，这样用户才不会感觉到视觉上的不一致。（概念上类似于被动监听事件和主动监听事件的区别。）React 为此提供了一个额外的 useLayoutEffect Hook 来处理这类 effect。它和 useEffect 的结构相同，区别只是调用时机不同。</p>
<p>此外，从 React 18 开始，当它是离散的用户输入（如点击）的结果时，或者当它是由 flushSync 包装的更新结果时，传递给 useEffect 的函数将在屏幕布局和绘制之前同步执行。这种行为便于事件系统或 flushSync 的调用者观察该效果的结果。</p>
<p>注意</p>
<p>这只影响传递给 useEffect 的函数被调用时 — 在这些 effect 中执行的更新仍会被推迟。这与 useLayoutEffect 不同，后者会立即启动该函数并处理其中的更新。</p>
<p>即使在 useEffect 被推迟到浏览器绘制之后的情况下，它也能保证在任何新的渲染前启动。React 在开始新的更新前，总会先刷新之前的渲染的 effect。<br>useRef</p>
<p>useRef 返回一个可变的 ref 对象，其 .current 属性被初始化为传入的参数（initialValue）。返回的 ref 对象在组件的整个生命周期内持续存在。<br>本质上，useRef 就像是可以在其 .current 属性中保存一个可变值的“盒子”。</p>
<p>你应该熟悉 ref 这一种访问 DOM 的主要方式。如果你将 ref 对象以 <code>&lt;div ref=&#123;myRef&#125; /&gt;</code> 形式传入组件，则无论该节点如何改变，React 都会将 ref 对象的 .current 属性设置为相应的 DOM 节点。</p>
<p>然而，useRef() 比 ref 属性更有用。它可以很方便地保存任何可变值，其类似于在 class 中使用实例字段的方式。</p>
<p>这是因为它创建的是一个普通 Javascript 对象。而 useRef() 和自建一个 {current: …} 对象的唯一区别是，useRef 会在每次渲染时返回同一个 ref 对象。</p>
<p>请记住，当 ref 对象内容发生变化时，useRef 并不会通知你。变更 .current 属性不会引发组件重新渲染。如果想要在 React 绑定或解绑 DOM 节点的 ref 时运行某些代码，则需要使用回调 ref 来实现。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> prevCountRef = useRef();</span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    prevCountRef.current = count;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">const</span> prevCount = prevCountRef.current;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml">      Now: &#123;count&#125;, before: &#123;prevCount&#125;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://a913481180.github.io/2022/11/11/22-22-22/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="KK">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KK">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/11/11/22-22-22/" class="post-title-link" itemprop="url">windows实用工具</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-11-11 22:22:22" itemprop="dateCreated datePublished" datetime="2022-11-11T22:22:22+08:00">2022-11-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-05-14 23:12:11" itemprop="dateModified" datetime="2024-05-14T23:12:11+08:00">2024-05-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/tool/" itemprop="url" rel="index"><span itemprop="name">tool</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="window10-实用软件"><a href="#window10-实用软件" class="headerlink" title="window10 实用软件"></a>window10 实用软件</h2><h3 id="chrome"><a href="#chrome" class="headerlink" title="chrome"></a>chrome</h3><p>插件：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://wwn.lanzouy.com/i6eOx0bmd9ub">油猴</a></li>
<li><a target="_blank" rel="noopener" href="https://wwn.lanzouy.com/iXH250bmd0li">adblockPlus</a></li>
<li><a target="_blank" rel="noopener" href="https://wwn.lanzouy.com/ineO40bme6qf">ublock</a></li>
<li><a target="_blank" rel="noopener" href="https://wwbk.lanzoue.com/iRIjx0bme6uj">草料二维码</a></li>
<li><a target="_blank" rel="noopener" href="https://wwk.lanzouq.com/i1VHd0bme6ti">github 加速</a></li>
<li><a target="_blank" rel="noopener" href="https://wwbk.lanzoue.com/i2ykx0ht4wfi">vue2</a></li>
<li><a target="_blank" rel="noopener" href="https://wwbk.lanzoue.com/iOqHN0ht4xaj">vue3</a></li>
<li><a target="_blank" rel="noopener" href="https://wwbk.lanzoue.com/i8wch0ht4xed">react</a></li>
<li><a target="_blank" rel="noopener" href="https://wwbk.lanzoue.com/i5baZ0ht4wwf">redux</a></li>
<li><a target="_blank" rel="noopener" href="https://wwbk.lanzoue.com/iBCXa0ht4wgj">vimiumC</a></li>
<li><a target="_blank" rel="noopener" href="https://wwbk.lanzoue.com/isrNg0ht4wle">editThisCookie</a></li>
<li><a target="_blank" rel="noopener" href="https://wwbk.lanzoum.com/ilPSS0wpm6vc">surfingkeys</a></li>
<li><a target="_blank" rel="noopener" href="https://wwk.lanzouq.com/iWL4U1wpulxi">FeHelper 前端助手</a></li>
<li><a target="_blank" rel="noopener" href="https://bytedance.larkoffice.com/docx/CMu2dZjXKojmGfxjibscjm2BnJh">字节火山翻译</a></li>
</ul>
<h3 id="other"><a href="#other" class="headerlink" title="other"></a>other</h3><ul>
<li><a target="_blank" rel="noopener" href="https://wwbk.lanzoue.com/iduIc0bmfhcd">IDM 下载工具</a></li>
<li><a target="_blank" rel="noopener" href="https://wwbk.lanzoue.com/i7IKb0hsyaid">winscp+putty</a></li>
<li><a target="_blank" rel="noopener" href="https://wwn.lanzouy.com/i0Lmyxe5nwh">截图工具 snipaste</a></li>
<li><a target="_blank" rel="noopener" href="https://wwn.lanzouy.com/iujpA0bm9jda">鼠标右键管理工具</a></li>
<li>无广告输入法：<a target="_blank" rel="noopener" href="http://www.xinshuru.com/">手心输入法</a></li>
<li><a target="_blank" rel="noopener" href="https://wwn.lanzouy.com/izNvH0bm9j9g">解压工具 bandizip 破解版</a></li>
<li><a target="_blank" rel="noopener" href="https://wwn.lanzouy.com/iR7jo0bmclsf">解压工具 7-zip</a></li>
<li>免费简洁思维导图<a target="_blank" rel="noopener" href="https://wwn.lanzouy.com/iEtBj0bm9hfa">blumind</a></li>
<li>精简小巧屏幕录制工具<a target="_blank" rel="noopener" href="https://wwn.lanzouy.com/ium4t0bmagsd">FSCature</a></li>
<li>电脑控制手机<a target="_blank" rel="noopener" href="https://wwn.lanzouy.com/iCzdu0bmc0cd">scrcpy</a></li>
<li>window 性能监控<a target="_blank" rel="noopener" href="https://wwbk.lanzoum.com/i2Pkr0o8tdej">Traffic Monitor</a></li>
<li>干净简单轻量级看图工具<a target="_blank" rel="noopener" href="https://wwbk.lanzoum.com/iBWdi0o8tfif">Honeyview</a></li>
<li>轻量级图片编辑工具<a href="">paint.NET</a></li>
<li>WPS 教育考试专用版，纯净无广告<a target="_blank" rel="noopener" href="https://ncre.neea.edu.cn/html1/report/1507/861-1.html">wps</a></li>
<li>WPS 校园版,去掉了附加的增值服务以及广告（停止维护）</li>
<li>windows 本地播放器<a target="_blank" rel="noopener" href="https://flowus.cn/share/4dc25551-ad00-4d81-9421-b3fee98757a9">potPlayer</a></li>
</ul>
<h3 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h3><blockquote>
<p>mono 等宽，serif 衬线, Sans-serif(无衬线) nerd(图标字符)<br>区分 0O、iIlL1</p>
</blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/googlefonts/noto-cjk">notoSansMonoCjkSc</a>：google 开源免费商,中国程序员中文字体</li>
<li><a target="_blank" rel="noopener" href="https://www.lanzouy.com/iOqD50bm9jcj">monaco</a>：苹果系统</li>
<li><a target="_blank" rel="noopener" href="https://design.ubuntu.com/font">ubuntuMono</a>：开源免费商用圆润</li>
<li><a target="_blank" rel="noopener" href="https://wwn.lanzouy.com/i5xTI0bm9jbi">droidSansMono</a>：安卓系统字体 0O、iIlL1 区别不行</li>
<li><a target="_blank" rel="noopener" href="https://gitee.com/mirrors/Sarasa-Gothic">arasa Gothic (更纱黑体) </a>由 Noto Sans / Iosevka 和思源黑体的汉字部分合并而来,开源免费字体</li>
<li><a target="_blank" rel="noopener" href="https://wwn.lanzouy.com/ifuCp0bm9jah">inconsolata</a>：google 开源字体等宽支持连字,不包含中文</li>
<li><a target="_blank" rel="noopener" href="https://www.jetbrains.com/lp/mono">jetBrainsMono</a>：jetbrains 公司开源商用等宽</li>
<li><a target="_blank" rel="noopener" href="https://wwk.lanzouq.com/iHqrW1wqqpab">FiraCode</a>：mozilla 开源支持连字,不包含中文</li>
<li><a target="_blank" rel="noopener" href="https://github.com/adobe-fonts/source-code-pro">SourceCodePro</a>：Adobe 开源免费商用</li>
<li><a target="_blank" rel="noopener" href="https://github.com/be5invis/Iosevka">losevka</a>：开源支持连字,不包含中文</li>
<li><a target="_blank" rel="noopener" href="https://github.com/adobe-fonts">sourceHanSans</a>google&amp;adobe 开源 adobe 中文字体</li>
<li><a target="_blank" rel="noopener" href="https://github.com/googlefonts">notoHanSans</a>google&amp;adobe 开源 google 中文字体</li>
<li><a target="_blank" rel="noopener" href="https://wwk.lanzouq.com/ijkmS1wqqzgh">oppo 字体</a></li>
<li><a target="_blank" rel="noopener" href="https://wwk.lanzouq.com/iXpUw1wqr5yb">harmoneyOs 字体</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://a913481180.github.io/2022/10/01/10-12-33/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="KK">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KK">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/01/10-12-33/" class="post-title-link" itemprop="url">Three.js</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-10-01 10:12:33" itemprop="dateCreated datePublished" datetime="2022-10-01T10:12:33+08:00">2022-10-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-05-14 23:12:11" itemprop="dateModified" datetime="2024-05-14T23:12:11+08:00">2024-05-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/web/" itemprop="url" rel="index"><span itemprop="name">web</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><h3 id="创建一个场景"><a href="#创建一个场景" class="headerlink" title="创建一个场景"></a>创建一个场景</h3><p>场景、相机和渲染器</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> scene = <span class="keyword">new</span> THREE.Scene();</span><br><span class="line"><span class="keyword">const</span> camera = <span class="keyword">new</span> THREE.PerspectiveCamera(</span><br><span class="line">  <span class="number">75</span>,</span><br><span class="line">  <span class="built_in">window</span>.innerWidth / <span class="built_in">window</span>.innerHeight,</span><br><span class="line">  <span class="number">0.1</span>,</span><br><span class="line">  <span class="number">1000</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> renderer = <span class="keyword">new</span> THREE.WebGLRenderer();</span><br><span class="line">renderer.setSize(<span class="built_in">window</span>.innerWidth, <span class="built_in">window</span>.innerHeight);</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(renderer.domElement);</span><br></pre></td></tr></table></figure>

<ul>
<li>相机：<br>three.js 里有几种不同的相机，在这里，我们使用的是 PerspectiveCamera（透视摄像机）。</li>
</ul>
<p>第一个参数是视野角度（FOV）。视野角度就是无论在什么时候，你所能在显示器上看到的场景的范围，它的单位是角度(与弧度区分开)。</p>
<p>第二个参数是长宽比（aspect ratio）。 也就是你用一个物体的宽除以它的高的值。比如说，当你在一个宽屏电视上播放老电影时，可以看到图像仿佛是被压扁的。</p>
<p>接下来的两个参数是近截面（near）和远截面（far）。 当物体某些部分比摄像机的远截面远或者比近截面近的时候，该这些部分将不会被渲染到场景中。或许现在你不用担心这个值的影响，但未来为了获得更好的渲染性能，你将可以在你的应用程序里去设置它。</p>
<ul>
<li>渲染器：<br>除了创建一个渲染器的实例之外，我们还需要在我们的应用程序里设置一个渲染器的尺寸。比如说，我们可以使用所需要的渲染区域的宽高，来让渲染器渲染出的场景填充满我们的应用程序。因此，我们可以将渲染器宽高设置为浏览器窗口宽高。对于性能比较敏感的应用程序来说，你可以使用 setSize 传入一个较小的值，例如 window.innerWidth/2 和 window.innerHeight/2，这将使得应用程序在渲染时，以一半的长宽尺寸渲染场景。</li>
</ul>
<p>如果你希望保持你的应用程序的尺寸，但是以较低的分辨率来渲染，你可以在调用 setSize 时，将 updateStyle（第三个参数）设为 false。例如，假设你的<code>&lt;canvas&gt;</code> 标签现在已经具有了 100%的宽和高，调用 setSize(window.innerWidth/2, window.innerHeight/2, false)将使得你的应用程序以一半的分辨率来进行渲染。</p>
<h3 id="创建一个立方体"><a href="#创建一个立方体" class="headerlink" title="创建一个立方体"></a>创建一个立方体</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> geometry = <span class="keyword">new</span> THREE.BoxGeometry();</span><br><span class="line"><span class="keyword">const</span> material = <span class="keyword">new</span> THREE.MeshBasicMaterial(&#123; <span class="attr">color</span>: <span class="number">0x00ff00</span> &#125;);</span><br><span class="line"><span class="keyword">const</span> cube = <span class="keyword">new</span> THREE.Mesh(geometry, material);</span><br><span class="line">scene.add(cube);</span><br><span class="line"></span><br><span class="line">camera.position.z = <span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<p>创建一个立方体，我们需要一个 BoxGeometry（立方体）对象. 这个对象包含了一个立方体中所有的顶点（vertices）和面（faces）。接下来，对于这个立方体，我们需要给它一个材质，来让它有颜色。第三步，我们需要一个 Mesh（网格）。 网格包含一个几何体以及作用在此几何体上的材质，我们可以直接将网格对象放入到我们的场景中，并让它在场景中自由移动。</p>
<h3 id="渲染场景"><a href="#渲染场景" class="headerlink" title="渲染场景"></a>渲染场景</h3><p>现在，如果将之前写好的代码复制到 HTML 文件中，你不会在页面中看到任何东西。这是因为我们还没有对它进行真正的渲染。为此，我们需要使用一个被叫做“渲染循环”（render loop）或者“动画循环”（animate loop）的东西。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">animate</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  requestAnimationFrame(animate);</span><br><span class="line">  renderer.render(scene, camera);</span><br><span class="line">&#125;</span><br><span class="line">animate();</span><br></pre></td></tr></table></figure>

<p>在这里我们创建了一个使渲染器能够在每次屏幕刷新时对场景进行绘制的循环（在大多数屏幕上，刷新率一般是 60 次/秒）。如果你是一个浏览器游戏开发的新手，你或许会说“为什么我们不直接用 setInterval 来实现刷新的功能呢？”当然啦，我们的确可以用 setInterval，但是，requestAnimationFrame 有很多的优点。最重要的一点或许就是当用户切换到其它的标签页时，它会暂停，因此不会浪费用户宝贵的处理器资源，也不会损耗电池的使用寿命。</p>
<h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h2><h3 id="相机"><a href="#相机" class="headerlink" title="相机"></a>相机</h3><h4 id="Camera"><a href="#Camera" class="headerlink" title="Camera"></a>Camera</h4><h5 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h5><p><code>Camera()</code><br>创建一个新的 Camera（摄像机）。注意：这个类并不是被直接调用的；你所想要的或许是一个 PerspectiveCamera（透视摄像机）或者 OrthographicCamera（正交摄像机）。</p>
<h5 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h5><p>共有属性请参见其基类 Object3D</p>
<p>.isCamera : Boolean<br>Read-only flag to check if a given object is of type Camera.</p>
<p>.layers : Layers<br>摄像机是一个 layers 的成员. 这是一个从 Object3D 继承而来的属性。</p>
<p>当摄像机的视点被渲染的时候，物体必须和当前被看到的摄像机共享至少一个层。</p>
<p>.matrixWorldInverse : Matrix4<br>这是 matrixWorld 矩阵的逆矩阵。 MatrixWorld 包含了相机的世界变换矩阵。</p>
<p>.projectionMatrix : Matrix4<br>这是投影变换矩阵。</p>
<p>.projectionMatrixInverse : Matrix4<br>这是投影变换矩阵的逆矩阵。</p>
<h5 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h5><p>共有方法请参见其基类 Object3D。</p>
<p>.clone ( ) : Camera<br>返回一个具有和当前相机的属性一样的新的相机。</p>
<p>.copy ( source : Camera, recursive : Boolean ) : this<br>将源摄像机的属性复制到新摄像机中。</p>
<p>.getWorldDirection ( target : Vector3 ) : Vector3<br>target — 调用该函数的结果将复制给该 Vector3 对象。</p>
<p>返回一个能够表示当前摄像机所正视的世界空间方向的 Vector3 对象。 （注意：摄像机俯视时，其 Z 轴坐标为负。）</p>
<h4 id="透视相机（PerspectiveCamera）"><a href="#透视相机（PerspectiveCamera）" class="headerlink" title="透视相机（PerspectiveCamera）"></a>透视相机（PerspectiveCamera）</h4><p>这一摄像机使用 perspective projection（透视投影）来进行投影。</p>
<p>这一投影模式被用来模拟人眼所看到的景象，它是 3D 场景的渲染中使用得最普遍的投影模式。<br>透视投影相机的四个参数 fov, aspect, near, far 构成一个四棱台 3D 空间，被称为视锥体，只有视锥体之内的物体，才会渲染出来，视锥体范围之外的物体不会显示在 Canvas 画布上。<br>透视投影相机的投影规律是远小近大，通过相机观察阵列立方体大小变化，可以看到距离相机越远，立方体的渲染视觉效果越小。增加相机视角 fov，视锥体范围更大，意味着可以看到渲染范围更大，远小近大的视觉效果更明显。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> camera = <span class="keyword">new</span> THREE.PerspectiveCamera(<span class="number">45</span>, width / height, <span class="number">1</span>, <span class="number">1000</span>);</span><br><span class="line">scene.add(camera);</span><br></pre></td></tr></table></figure>

<h5 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h5><p><code>PerspectiveCamera( fov : Number, aspect : Number, near : Number, far : Number )</code><br>fov — 摄像机视锥体垂直视野角度<br>aspect — 摄像机视锥体长宽比,一般设置为 Canvas 画布宽高比 width / height<br>near — 摄像机视锥体近端面<br>far — 摄像机视锥体远端面</p>
<h5 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h5><blockquote>
<p>共有属性请参见其基类 Camera 。</p>
</blockquote>
<p>请注意，在大多数属性发生改变之后，你将需要调用.updateProjectionMatrix 来使得这些改变生效。</p>
<p>.aspect : Float<br>摄像机视锥体的长宽比，通常是使用画布的宽/画布的高。默认值是 1（正方形画布）。</p>
<p>.far : Float<br>摄像机的远端面，默认值是 2000。</p>
<p>该值必须大于 near plane（摄像机视锥体近端面）的值。</p>
<p>.filmGauge : Float<br>胶片尺寸，其默认值为 35（毫米）。 这个参数不会影响摄像机的投影矩阵，除非.filmOffset 被设置为了一个非零的值。</p>
<p>.filmOffset : Float<br>水平偏离中心偏移量，和.filmGauge 单位相同。默认值为 0。</p>
<p>.focus : Float<br>用于立体视觉和景深效果的物体的距离。 这个参数不会影响摄像机的投影矩阵，除非使用了 StereoCamera。 默认值是 10。</p>
<p>.fov : Float<br>摄像机视锥体垂直视野角度，从视图的底部到顶部，以角度来表示。默认值是 50。</p>
<p>.isPerspectiveCamera : Boolean<br>Read-only flag to check if a given object is of type PerspectiveCamera.</p>
<p>.near : Float<br>摄像机的近端面，默认值是 0.1。</p>
<p>其有效值范围是 0 到当前摄像机 far plane（远端面）的值之间。 请注意，和 OrthographicCamera 不同，0 对于 PerspectiveCamera 的近端面来说不是一个有效值。</p>
<p>.view : Object<br>Frustum window specification or null. 这个值使用.setViewOffset 方法来进行设置，使用.clearViewOffset 方法来进行清除。</p>
<p>.zoom : number<br>获取或者设置摄像机的缩放倍数，其默认值为 1。</p>
<h5 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h5><blockquote>
<p>共有方法请参见其基类 Camera。</p>
</blockquote>
<p>.clearViewOffset () : undefined<br>清除任何由.setViewOffset 设置的偏移量。</p>
<p>.getEffectiveFOV () : Float<br>结合.zoom（缩放倍数），以角度返回当前垂直视野角度。</p>
<p>.getFilmHeight () : Float<br>返回当前胶片上图像的高，如果.aspect 小于或等于 1（肖像格式、纵向构图），则结果等于.filmGauge。</p>
<p>.getFilmWidth () : Float<br>返回当前胶片上图像的宽，如果.aspect 大于或等于 1（景观格式、横向构图），则结果等于.filmGauge。</p>
<p>.getFocalLength () : Float<br>返回当前.fov（视野角度）相对于.filmGauge（胶片尺寸）的焦距。</p>
<p>.setFocalLength ( focalLength : Float ) : undefined<br>通过相对于当前.filmGauge 的焦距，设置 FOV。</p>
<p>默认情况下，焦距是为 35mm（全画幅）摄像机而指定的。</p>
<p>.setViewOffset ( fullWidth : Float, fullHeight : Float, x : Float, y : Float, width : Float, height : Float ) : undefined<br>fullWidth — 多视图的全宽设置<br>fullHeight — 多视图的全高设置<br>x — 副摄像机的水平偏移<br>y — 副摄像机的垂直偏移<br>width — 副摄像机的宽度<br>height — 副摄像机的高度</p>
<p>在较大的 viewing frustum（视锥体）中设置偏移量，对于多窗口或者多显示器的设置是很有用的。</p>
<p>例如，如果你有一个 3x2 的显示器阵列，每个显示器分辨率都是 1920x1080，且这些显示器排列成像这样的网格：<br>+—+—+—+<br>| A | B | C |<br>+—+—+—+<br>| D | E | F |<br>+—+—+—+</p>
<p>那对于每个显示器，你可以这样来设置、调用：<br>const w = 1920;<br>const h = 1080;<br>const fullWidth = w <em>3;<br>const fullHeight = h</em> 2;</p>
<p>// A<br>camera.setViewOffset( fullWidth, fullHeight, w <em>0, h</em> 0, w, h );<br>// B<br>camera.setViewOffset( fullWidth, fullHeight, w <em>1, h</em> 0, w, h );<br>// C<br>camera.setViewOffset( fullWidth, fullHeight, w <em>2, h</em> 0, w, h );<br>// D<br>camera.setViewOffset( fullWidth, fullHeight, w <em>0, h</em> 1, w, h );<br>// E<br>camera.setViewOffset( fullWidth, fullHeight, w <em>1, h</em> 1, w, h );<br>// F<br>camera.setViewOffset( fullWidth, fullHeight, w <em>2, h</em> 1, w, h );请注意，显示器的不必具有相同的大小，或者不必在网格中。<br>.updateProjectionMatrix () : undefined<br>更新摄像机投影矩阵。在任何参数被改变以后必须被调用。</p>
<p>.toJSON (meta : Object) : Object<br>meta – 包含有元数据的对象，例如对象后代中的纹理或图像<br>将摄像机转换为 three.js JSON Object/Scene format（three.js JSON 物体/场景格式）。</p>
<h5 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h5><ul>
<li>相机位置.position<br><code>camera.position.set(200, 200, 200);</code></li>
<li>相机观察目标.lookAt()</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//相机观察目标指向Threejs 3D空间中某个位置</span></span><br><span class="line">camera.lookAt(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>); <span class="comment">//坐标原点</span></span><br><span class="line">camera.lookAt(<span class="number">0</span>, <span class="number">10</span>, <span class="number">0</span>); <span class="comment">//y轴上位置10</span></span><br><span class="line">camera.lookAt(mesh.position); <span class="comment">//指向mesh对应的位置</span></span><br></pre></td></tr></table></figure>

<h4 id="正交相机（OrthographicCamera）"><a href="#正交相机（OrthographicCamera）" class="headerlink" title="正交相机（OrthographicCamera）"></a>正交相机（OrthographicCamera）</h4><p>这一摄像机使用 orthographic projection（正交投影）来进行投影。</p>
<p>在这种投影模式下，无论物体距离相机距离远或者近，在最终渲染的图片中物体的大小都保持不变。</p>
<p>这对于渲染 2D 场景或者 UI 元素是非常有用的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> camera = <span class="keyword">new</span> THREE.OrthographicCamera(</span><br><span class="line">  width / -<span class="number">2</span>,</span><br><span class="line">  width / <span class="number">2</span>,</span><br><span class="line">  height / <span class="number">2</span>,</span><br><span class="line">  height / -<span class="number">2</span>,</span><br><span class="line">  <span class="number">1</span>,</span><br><span class="line">  <span class="number">1000</span></span><br><span class="line">);</span><br><span class="line">scene.add(camera);</span><br></pre></td></tr></table></figure>

<h5 id="构造器-1"><a href="#构造器-1" class="headerlink" title="构造器"></a>构造器</h5><p>OrthographicCamera( left : Number, right : Number, top : Number, bottom : Number, near : Number, far : Number )<br>left — 摄像机视锥体左侧面。<br>right — 摄像机视锥体右侧面。<br>top — 摄像机视锥体上侧面。<br>bottom — 摄像机视锥体下侧面。<br>near — 摄像机视锥体近端面。<br>far — 摄像机视锥体远端面。</p>
<h5 id="属性-2"><a href="#属性-2" class="headerlink" title="属性"></a>属性</h5><p>共有属性请参见其基类 Camera。<br>请注意，在大多数属性发生改变之后，你将需要调用.updateProjectionMatrix 来使得这些改变生效。</p>
<p>.bottom : Float<br>摄像机视锥体下侧面。</p>
<p>.far : Float<br>摄像机视锥体远端面，其默认值为 2000。</p>
<p>该值必须大于 near plane（摄像机视锥体近端面）的值。</p>
<p>.isOrthographicCamera : Boolean<br>Read-only flag to check if a given object is of type OrthographicCamera.</p>
<p>.left : Float<br>摄像机视锥体左侧面。</p>
<p>.near : Float<br>摄像机视锥体近端面。其默认值为 0.1.</p>
<p>其值的有效范围介于 0 和 far（摄像机视锥体远端面）之间。<br>请注意，和 PerspectiveCamera 不同，0 对于 OrthographicCamera 的近端面来说是一个有效值。</p>
<p>.right : Float<br>摄像机视锥体右侧面。</p>
<p>.top : Float<br>摄像机视锥体上侧面。</p>
<p>.view : Object<br>这个值是由 setViewOffset 来设置的，其默认值为 null。</p>
<p>.zoom : number<br>获取或者设置摄像机的缩放倍数，其默认值为 1。</p>
<h5 id="方法-2"><a href="#方法-2" class="headerlink" title="方法"></a>方法</h5><p>共有方法请参见其基类 Camera。</p>
<p>.setViewOffset ( fullWidth : Float, fullHeight : Float, x : Float, y : Float, width : Float, height : Float ) : undefined<br>fullWidth — 多视图的全宽设置<br>fullHeight — 多视图的全高设置<br>x — 副摄像机的水平偏移<br>y — 副摄像机的垂直偏移<br>width — 副摄像机的宽度<br>height — 副摄像机的高度</p>
<p>在较大的 viewing frustum（视锥体）中设置偏移量，对于多窗口或者多显示器的设置是很有用的。 对于如何使用它，请查看 PerspectiveCamera 中的示例。</p>
<p>.clearViewOffset () : undefined<br>清除任何由.setViewOffset 设置的偏移量。</p>
<p>.updateProjectionMatrix () : undefined<br>更新摄像机投影矩阵。在任何参数被改变以后必须被调用。</p>
<p>.toJSON (meta : Object) : Object<br>meta – 包含有元数据的对象，例如对象后代中的纹理或图像<br>将摄像机转换为 three.js JSON Object/Scene format（three.js JSON 物体/场景格式）。</p>
<h4 id="摄像机阵列（ArrayCamera）"><a href="#摄像机阵列（ArrayCamera）" class="headerlink" title="摄像机阵列（ArrayCamera）"></a>摄像机阵列（ArrayCamera）</h4><p>ArrayCamera 用于更加高效地使用一组已经预定义的摄像机来渲染一个场景。这将能够更好地提升 VR 场景的渲染性能。<br>一个 ArrayCamera 的实例中总是包含着一组子摄像机，应当为每一个子摄像机定义 viewport（视口）这个属性，这一属性决定了由该子摄像机所渲染的视口区域的大小。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cameras = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">const</span> subcamera = <span class="keyword">new</span> THREE.PerspectiveCamera(<span class="number">40</span>, <span class="number">1</span>, <span class="number">0.1</span>, <span class="number">10</span>);</span><br><span class="line">  subcamera.viewport = <span class="keyword">new</span> THREE.Vector4(</span><br><span class="line">    <span class="built_in">Math</span>.floor(i * <span class="number">200</span>),</span><br><span class="line">    <span class="built_in">Math</span>.floor(<span class="number">1</span> * <span class="number">200</span>), <span class="comment">//视口高</span></span><br><span class="line">    <span class="built_in">Math</span>.ceil(<span class="number">200</span>), <span class="comment">//宽</span></span><br><span class="line">    <span class="built_in">Math</span>.ceil(<span class="number">200</span>) <span class="comment">//视口高</span></span><br><span class="line">  );</span><br><span class="line">  subcamera.position.x = i / <span class="number">3</span> - <span class="number">0.5</span>;</span><br><span class="line">  subcamera.position.y = <span class="number">0.5</span> + i;</span><br><span class="line">  subcamera.position.z = <span class="number">1.5</span>;</span><br><span class="line">  subcamera.position.multiplyScalar(<span class="number">2</span>);</span><br><span class="line">  subcamera.lookAt(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  subcamera.updateMatrixWorld();</span><br><span class="line">  cameras.push(subcamera);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> camera = <span class="keyword">new</span> THREE.ArrayCamera(cameras);</span><br></pre></td></tr></table></figure>

<h4 id="立方相机（CubeCamera）"><a href="#立方相机（CubeCamera）" class="headerlink" title="立方相机（CubeCamera）"></a>立方相机（CubeCamera）</h4><p>创建 6 个渲染到 WebGLCubeRenderTarget 的摄像机<br>构造器<br>CubeCamera( near : Number, far : Number, renderTarget : WebGLCubeRenderTarget )<br>near – 近剪切面的距离<br>far – 远剪切面的距离<br>renderTarget – The destination cube render target.</p>
<p>构造一个包含 6 个 PerspectiveCameras（透视摄像机）的立方摄像机， 并将其拍摄的场景渲染到一个 WebGLCubeRenderTarget 上。</p>
<h4 id="立体相机（StereoCamera）"><a href="#立体相机（StereoCamera）" class="headerlink" title="立体相机（StereoCamera）"></a>立体相机（StereoCamera）</h4><p>双透视摄像机（立体相机）常被用于创建 3D Anaglyph（3D 立体影像） 或者 Parallax Barrier（视差屏障）。</p>
<h3 id="几何体"><a href="#几何体" class="headerlink" title="几何体"></a>几何体</h3><h4 id="缓冲属性-BufferAttribute"><a href="#缓冲属性-BufferAttribute" class="headerlink" title="缓冲属性 BufferAttribute"></a>缓冲属性 BufferAttribute</h4><p>这个类用于存储与 BufferGeometry 相关联的 attribute（例如顶点位置向量，面片索引，法向量，颜色值，UV 坐标以及任何自定义 attribute ）。 利用 BufferAttribute，可以更高效的向 GPU 传递数据。</p>
<blockquote>
<p>在 BufferAttribute 中，数据被存储为任意长度的矢量（通过 itemSize 进行定义），下列函数如无特别说明， 函数参数中的 index 会自动乘以矢量长度进行计算。 当想要处理类似向量的数据时， 可以使用在 Vector2，Vector3， Vector4 以及 Color 这些类中的.fromBufferAttribute( attribute, index ) 方法来更为便捷地处理。</p>
</blockquote>
<h5 id="构造函数-1"><a href="#构造函数-1" class="headerlink" title="构造函数"></a>构造函数</h5><p><code>BufferAttribute( array : TypedArray, itemSize : Integer, normalized : Boolean )</code><br>array – 必须是 TypedArray. 类型，用于实例化缓存。<br>该队列应该包含：<code>itemSize * numVertices</code>个元素，numVertices 是 BufferGeometry 中的顶点数目</p>
<p>itemSize – 队列中与顶点相关的数据值的大小。举例，如果 attribute 存储的是三元组（例如顶点空间坐标、法向量或颜色值）则 itemSize 的值应该是 3。</p>
<p>normalized – (可选) 指明缓存中的数据如何与 GLSL 代码中的数据对应。例如，如果 array 是 UInt16Array 类型，且 normalized 的值是 true，则队列中的值将会从 0 - +65535 映射为 GLSL 中的 0.0f - +1.0f。 如果 array 是 Int16Array (有符号)，则值将会从 -32768 - +32767 映射为 -1.0f - +1.0f。若 normalized 的值为 false，则数据映射不会归一化，而会直接映射为 float 值，例如，32767 将会映射为 32767.0f.</p>
<h5 id="属性-3"><a href="#属性-3" class="headerlink" title="属性"></a>属性</h5><ul>
<li><p><code>.array</code> : TypedArray<br>在 array 中保存着缓存中的数据。</p>
</li>
<li><p><code>.count</code> : Integer<br>保存 array 除以 itemSize 之后的大小。若缓存存储三元组（例如顶点位置、法向量、颜色值），则该值应等于队列中三元组的个数。</p>
</li>
<li><p><code>.isBufferAttribute</code> : Boolean<br>用于判断对象是否为 BufferAttribute 类型的只读标记.</p>
</li>
</ul>
<p><code>.itemSize</code> : Integer<br>保存在 array 中矢量的长度。</p>
<ul>
<li><p><code>.name</code> : String<br>该 attribute 实例的别名，默认值为空字符串。</p>
</li>
<li><p><code>.needsUpdate</code> : Boolean<br>该标志位指明当前 attribute 已经被修改过，且需要再次送入 GPU 处理。当开发者改变了该队列的值，则标志位需要设置为 true。</p>
</li>
</ul>
<p>将标志位设为 true 同样会增加 version 的值。</p>
<ul>
<li><p><code>.normalized</code> : Boolean<br>指明缓存中数据在转化为 GLSL 着色器代码中数据时是否需要被归一化。详见构造函数中的说明。</p>
</li>
<li><p><code>.onUploadCallback</code> : Function<br>attribute 数据传输到 GPU 后的回调函数。</p>
</li>
<li><p><code>.updateRange</code> : Object<br>对象包含如下成员:<br>offset: 默认值为 0。 指明更新的起始位置。<br>count: 默认值为 -1，表示不指定更新范围。</p>
</li>
</ul>
<p>该值只可以被用于更新某些矢量数据（例如，颜色相关数据）。</p>
<ul>
<li><p><code>.usage</code> : Usage<br>为输入的数据定义最优的预估使用方式。等同于在 WebGLRenderingContext.bufferData() 中的 usage 参数。默认为 StaticDrawUsage。在 usage constants 中查看可用值。</p>
</li>
<li><p><code>.version</code> : Integer<br>版本号，当 needsUpdate 被设置为 true 时，该值会自增。</p>
</li>
</ul>
<h5 id="方法-3"><a href="#方法-3" class="headerlink" title="方法"></a>方法</h5><ul>
<li><p><code>.applyMatrix3 ( m : Matrix3 ) : this</code><br>将矩阵 m 应用此 BufferAttribute 中的每一个 Vector3 元素中。</p>
</li>
<li><p><code>.applyMatrix4 ( m : Matrix4 ) : this</code><br>将矩阵 m 应用到此 BufferAttribute 的每一个 Vector3 元素中</p>
</li>
<li><p><code>.applyNormalMatrix ( m : Matrix3 ) : this</code><br>将正规矩阵 m 应用到此 BufferAttribute 的每一个 Vector3 元素中</p>
</li>
<li><p><code>.transformDirection ( m : Matrix4 ) : this</code><br>将矩阵 m 应用到此 BufferAttribute 的每一个 Vector3 元素中，并将所有元素解释为方向向量。</p>
</li>
<li><p><code>.clone () : BufferAttribute</code><br>返回该 BufferAttribute 的拷贝。</p>
</li>
<li><p><code>.copyArray ( array ) : this</code><br>将参数中所给定的普通队列或 TypedArray 拷贝到 array 中。</p>
</li>
</ul>
<p>拷贝 TypedArray 相关注意事项详见 TypedArray.set。</p>
<ul>
<li><p><code>.copyAt ( index1 : Integer, bufferAttribute : BufferAttribute, index2 : Integer ) : this</code><br>将一个矢量从 <code>bufferAttribute[index2]</code> 拷贝到 <code>array[index1]</code> 中。</p>
</li>
<li><p><code>.getX ( index : Integer ) : Number</code><br>获取给定索引的矢量的第一维元素 （即 X 值）。</p>
</li>
<li><p><code>.getY ( index : Integer ) : Number</code><br>获取给定索引的矢量的第二维元素 （即 Y 值）。</p>
</li>
<li><p><code>.getZ ( index : Integer ) : Number</code><br>获取给定索引的矢量的第三维元素 （即 Z 值）。</p>
</li>
<li><p><code>.getW ( index : Integer ) : Number</code><br>获取给定索引的矢量的第四维元素 （即 W 值）。</p>
</li>
<li><p><code>.onUpload ( callback : Function ) : this</code><br>见 onUploadCallback 属性。</p>
</li>
</ul>
<p>在 WebGL / Buffergeometry 中，该方在缓存数据传递给 GPU 后，用于释放内存。</p>
<ul>
<li><code>.set ( value : Array, offset : Integer ) : this</code><br>value – 被拷贝的 Array 或 TypedArray 类型的数据。<br>offset – (可选) array 中开始拷贝的位置索引。</li>
</ul>
<p>对 array，调用 TypedArray.set( value, offset ) 方法。</p>
<p>特别的, 对将 value 转为 TypedArray 的要求详见上述链接。</p>
<ul>
<li><p><code>.setUsage ( value : Usage ) : this</code><br>Set usage to value. See usage constants for all possible input values.</p>
</li>
<li><p><code>.setX ( index : Integer, x : Float ) : this</code><br>设置给定索引的矢量的第一维数据（设置 X 值）。</p>
</li>
<li><p><code>.setY ( index : Integer, y : Float ) : this</code><br>设置给定索引的矢量的第二维数据（设置 Y 值）。</p>
</li>
<li><p><code>.setZ ( index : Integer, z : Float ) : this</code><br>设置给定索引的矢量的第三维数据（设置 Z 值）。</p>
</li>
<li><p><code>.setW ( index : Integer, w : Float ) : this</code><br>设置给定索引的矢量的第四维数据（设置 W 值）。</p>
</li>
<li><p><code>.setXY ( index : Integer, x : Float, y : Float ) : this</code><br>设置给定索引的矢量的第一、二维数据（设置 X 和 Y 值）。</p>
</li>
<li><p><code>.setXYZ ( index : Integer, x : Float, y : Float, z : Float ) : this</code><br>设置给定索引的矢量的第一、二、三维数据（设置 X、Y 和 Z 值）。</p>
</li>
<li><p><code>.setXYZW ( index : Integer, x : Float, y : Float, z : Float, w : Float ) : this</code><br>设置给定索引的矢量的第一、二、三、四维数据（设置 X、Y、Z 和 W 值）。</p>
</li>
</ul>
<h4 id="缓冲几何体-BufferGeometry"><a href="#缓冲几何体-BufferGeometry" class="headerlink" title="缓冲几何体 BufferGeometry"></a>缓冲几何体 BufferGeometry</h4><p>是面片、线或点几何体的有效表述。包括顶点位置，面片索引、法相量、颜色值、UV 坐标和自定义缓存属性值。使用 BufferGeometry 可以有效减少向 GPU 传输上述数据所需的开销。<br>BufferGeometry 是一个没有任何形状的空几何体，你可以通过 BufferGeometry 自定义任何几何形状</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> geometry = <span class="keyword">new</span> THREE.BufferGeometry();</span><br><span class="line"><span class="comment">// 创建一个简单的矩形. 在这里我们左上和右下顶点被复制了两次。</span></span><br><span class="line"><span class="comment">// 因为在两个三角面片里，这两个顶点都需要被用到。</span></span><br><span class="line"><span class="comment">//通过javascript类型化数组 Float32Array创建一组xyz坐标数据用来表示几何体的顶点坐标</span></span><br><span class="line"><span class="keyword">const</span> vertices = <span class="keyword">new</span> <span class="built_in">Float32Array</span>([</span><br><span class="line">  -<span class="number">1.0</span>, -<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, -<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>,</span><br><span class="line"></span><br><span class="line">  <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, -<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, -<span class="number">1.0</span>, -<span class="number">1.0</span>, <span class="number">1.0</span>,</span><br><span class="line">]);</span><br><span class="line"><span class="comment">// 创建属性缓冲区对象</span></span><br><span class="line"><span class="comment">// itemSize = 3 因为每个顶点都是一个三元组。</span></span><br><span class="line"><span class="comment">//3个为一组，表示一个顶点的xyz坐标</span></span><br><span class="line">geometry.setAttribute(<span class="string">&quot;position&quot;</span>, <span class="keyword">new</span> THREE.BufferAttribute(vertices, <span class="number">3</span>)); <span class="comment">//设置几何体顶点</span></span><br><span class="line"><span class="keyword">const</span> material = <span class="keyword">new</span> THREE.MeshBasicMaterial(&#123; <span class="attr">color</span>: <span class="number">0xff0000</span> &#125;);</span><br><span class="line"><span class="keyword">const</span> mesh = <span class="keyword">new</span> THREE.Mesh(geometry, material);</span><br></pre></td></tr></table></figure>

<h5 id="构造函数-2"><a href="#构造函数-2" class="headerlink" title="构造函数"></a>构造函数</h5><p><code>BufferGeometry()</code>创建一个新的 BufferGeometry. 同时将预置属性设置为默认值.</p>
<h5 id="属性-4"><a href="#属性-4" class="headerlink" title="属性"></a>属性</h5><ul>
<li><p><code>.attributes</code> : Object<br>通过 hashmap 存储该几何体相关的属性，hashmap 的 id 是当前 attribute 的名称，值是相应的 buffer。 你可以通过 <code>.setAttribute</code> 和 <code>.getAttribute</code> 添加和访问与当前几何体有关的 attribute。</p>
</li>
<li><p><code>.boundingBox</code> : Box3<br>当前 bufferGeometry 的外边界矩形。可以通过 .computeBoundingBox() 计算。默认值是 null。</p>
</li>
<li><p><code>.boundingSphere</code> : Sphere<br>当前 bufferGeometry 的外边界球形。可以通过 .computeBoundingSphere() 计算。默认值是 null。</p>
</li>
<li><p><code>.drawRange</code> : Object<br>用于判断几何体的哪个部分需要被渲染。该值不应该直接被设置，而需要通过 .setDrawRange 进行设置。默认值为<code>&#123; start: 0, count: Infinity &#125;</code></p>
</li>
<li><p><code>.groups</code> : Array<br>将当前几何体分割成组进行渲染，每个部分都会在单独的 WebGL 的 draw call 中进行绘制。该方法可以让当前的 bufferGeometry 可以使用一个材质队列进行描述。分割后的每个部分都是一个如下的表单：<code>&#123; start: Integer, count: Integer, materialIndex: Integer &#125;</code>start 表明当前 draw call 中的没有索引的几何体的几何体的第一个顶点；或者第一个三角面片的索引。 count 指明当前分割包含多少顶点（或 indices）。 materialIndex 指出当前用到的材质队列的索引。通过 <code>.addGroup</code> 来增加组，而不是直接更改当前队列。</p>
</li>
<li><p><code>.id</code> : Integer<br>当前 bufferGeometry 的唯一编号。</p>
</li>
<li><p><code>.index</code> : BufferAttribute<br>允许顶点在多个三角面片间可以重用。这样的顶点被称为”已索引的三角面片(indexed triangles)。 每个三角面片都和三个顶点的索引相关。该 attribute 因此所存储的是每个三角面片的三个顶点的索引。 如果该 attribute 没有设置过，则 renderer 假设每三个连续的位置代表一个三角面片。 默认值是 null。</p>
</li>
</ul>
<p><code>.isBufferGeometry</code> : Boolean<br>用于判断对象是否为 BufferGeometry 的只读标记.</p>
<p><code>.morphAttributes</code> : Object<br>存储 BufferAttribute 的 Hashmap，存储了几何体 morph targets 的细节信息。<br>注意：当这个 geometry 渲染之后，morph attribute 数据无法更改。你需要调用.dispose()，并重新创建一个新的 BufferGeometry 实例。</p>
<p><code>.morphTargetsRelative</code> : Boolean<br>用于控制 morph target 的行为，如果设置为 true，morph target 数据作为相对的偏移量，而非绝对的位置/法向。 默认为 false。</p>
<p><code>.name</code> : String<br>当前 bufferGeometry 实例的可选别名。默认值是空字符串。</p>
<p><code>.userData</code> : Object<br>存储 BufferGeometry 的自定义数据的对象。为保持对象在克隆时完整，该对象不应该包括任何函数的引用。</p>
<p><code>.uuid</code> : String<br>当前对象实例的 UUID，该值会自动被分配，且不应被修改。</p>
<h5 id="方法-4"><a href="#方法-4" class="headerlink" title="方法"></a>方法</h5><blockquote>
<p>EventDispatcher 在该类上可用的所有方法。</p>
</blockquote>
<ul>
<li><p><code>.setAttribute ( name : String, attribute : BufferAttribute ) : this</code><br>为当前几何体设置一个 attribute 属性。在类的内部，有一个存储 .attributes 的 hashmap， 通过该 hashmap，遍历 attributes 的速度会更快。而使用该方法，可以向 hashmap 内部增加 attribute。 所以，你需要使用该方法来添加 attributes。</p>
</li>
<li><p><code>.addGroup ( start : Integer, count : Integer, materialIndex : Integer ) : undefined</code><br>为当前几何体增加一个 group，详见 groups 属性。</p>
</li>
<li><p><code>.applyMatrix4 ( matrix : Matrix4 ) : this</code><br>用给定矩阵转换几何体的顶点坐标。</p>
</li>
<li><p><code>.center () : this</code><br>根据边界矩形将几何体居中。</p>
</li>
<li><p><code>.clone () : BufferGeometrya</code><br>克隆当前的 BufferGeometry。</p>
</li>
<li><p><code>.copy ( bufferGeometry : BufferGeometry ) : this</code><br>将参数指定的 BufferGeometry 的值拷贝到当前 BufferGeometry 中。</p>
</li>
<li><p><code>.clearGroups ( ) : undefined</code><br>清空所有的 groups。</p>
</li>
<li><p><code>.computeBoundingBox () : undefined</code><br>计算当前几何体的的边界矩形，该操作会更新已有 <code>[param:.boundingBox]</code>。<br>边界矩形不会默认计算，需要调用该接口指定计算边界矩形，否则保持默认值 null。</p>
</li>
<li><p><code>.computeBoundingSphere () : undefined</code><br>计算当前几何体的的边界球形，该操作会更新已有 <code>[param:.boundingSphere]</code>。<br>边界球形不会默认计算，需要调用该接口指定计算边界球形，否则保持默认值 null。</p>
</li>
<li><p><code>.computeTangents () : undefined</code><br>计算并向此 geometry 中添加 tangent attribute。<br>只支持索引化的几何体对象，并且必须拥有 position(位置)，normal(法向)和 uv attributes。如果使用了切线空间法向贴图，最好使用 BufferGeometryUtils.computeMikkTSpaceTangents 中的 MikkTSpace 算法。</p>
</li>
<li><p><code>.computeVertexNormals () : undefined</code><br>通过面片法向量的平均值计算每个顶点的法向量。</p>
</li>
</ul>
<p><code>.dispose () : undefined</code><br>从内存中销毁对象。<br>如果在运行时需要从内存中删除 BufferGeometry，则需要调用该函数。</p>
<p><code>.getAttribute ( name : String ) : BufferAttribute</code><br>返回指定名称的 attribute。</p>
<p><code>.getIndex () : BufferAttribute</code><br>返回缓存相关的 .index。</p>
<p><code>.hasAttribute ( name : String ) : Boolean</code><br>检查是否存在有指定名称的 attribute，如果有返回 true。</p>
<p><code>.lookAt ( vector : Vector3 ) : this</code><br>vector - 几何体所朝向的世界坐标。</p>
<p>旋转几何体朝向控件中的一点。该过程通常在一次处理中完成，不会循环处理。典型的用法是过通过调用 Object3D.lookAt 实时改变 mesh 朝向。</p>
<p><code>.normalizeNormals () : undefined</code><br>几何体中的每个法向量长度将会为 1。这样操作会更正光线在表面的效果。</p>
<p><code>.deleteAttribute ( name : String ) : BufferAttribute</code><br>删除具有指定名称的 attribute。</p>
<p><code>.rotateX ( radians : Float ) : this</code><br>在 X 轴上旋转几何体。该操作一般在一次处理中完成，不会循环处理。典型的用法是通过调用 Object3D.rotation 实时旋转几何体。</p>
<p><code>.rotateY ( radians : Float ) : this</code><br>在 Y 轴上旋转几何体。该操作一般在一次处理中完成，不会循环处理。典型的用法是通过调用 Object3D.rotation 实时旋转几何体。</p>
<p><code>.rotateZ ( radians : Float ) : this</code><br>在 Z 轴上旋转几何体。该操作一般在一次处理中完成，不会循环处理。典型的用法是通过调用 Object3D.rotation 实时旋转几何体。</p>
<p><code>.scale ( x : Float, y : Float, z : Float ) : this</code><br>缩放几何体。该操作一般在一次处理中完成，不会循环处理。典型的用法是通过调用 Object3D.scale 实时旋转几何体。</p>
<p><code>.setIndex ( index : BufferAttribute ) : this</code><br>设置缓存的 .index。</p>
<p><code>.setDrawRange ( start : Integer, count : Integer ) : undefined</code><br>设置缓存的 .drawRange。详见相关属性说明。</p>
<p><code>.setFromPoints ( points : Array ) : this</code><br>通过点队列设置该 BufferGeometry 的 attribute。</p>
<p><code>.toJSON () : Object</code><br>返回代表该 BufferGeometry 的 JSON 对象。</p>
<p><code>.toNonIndexed () : BufferGeometry</code><br>返回已索引的 BufferGeometry 的非索引版本。</p>
<p><code>.translate ( x : Float, y : Float, z : Float ) : this</code><br>移动几何体。该操作一般在一次处理中完成，不会循环处理。典型的用法是通过调用 Object3D.rotation 实时旋转几何体。</p>
<h4 id="立方体（BoxGeometry）"><a href="#立方体（BoxGeometry）" class="headerlink" title="立方体（BoxGeometry）"></a>立方体（BoxGeometry）</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> geometry = <span class="keyword">new</span> THREE.BoxGeometry(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">const</span> material = <span class="keyword">new</span> THREE.MeshBasicMaterial(&#123; <span class="attr">color</span>: <span class="number">0x00ff00</span> &#125;);</span><br><span class="line"><span class="keyword">const</span> cube = <span class="keyword">new</span> THREE.Mesh(geometry, material);</span><br><span class="line">scene.add(cube);</span><br></pre></td></tr></table></figure>

<h5 id="构造器-2"><a href="#构造器-2" class="headerlink" title="构造器"></a>构造器</h5><p><code>BoxGeometry(width : Float, height : Float, depth : Float, widthSegments : Integer, heightSegments : Integer, depthSegments : Integer)</code><br>width — X 轴上面的宽度，默认值为 1。<br>height — Y 轴上面的高度，默认值为 1。<br>depth — Z 轴上面的深度，默认值为 1。<br>widthSegments — （可选）宽度的分段数，默认值是 1。<br>heightSegments — （可选）高度的分段数，默认值是 1。<br>depthSegments — （可选）深度的分段数，默认值是 1。</p>
<h5 id="属性-方法"><a href="#属性-方法" class="headerlink" title="属性|方法"></a>属性|方法</h5><blockquote>
<p>共有方法请参见其基类 BufferGeometry。<br>共有属性请参见其基类 BufferGeometry。</p>
</blockquote>
<p><code>.parameters</code> : Object<br>一个包含着构造函数中每个参数的对象。在对象实例化之后，对该属性的任何修改都不会改变这个几何体。</p>
<h4 id="圆形（CircleGeometry）"><a href="#圆形（CircleGeometry）" class="headerlink" title="圆形（CircleGeometry）"></a>圆形（CircleGeometry）</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> geometry = <span class="keyword">new</span> THREE.CircleGeometry(<span class="number">5</span>, <span class="number">32</span>);</span><br><span class="line"><span class="keyword">const</span> material = <span class="keyword">new</span> THREE.MeshBasicMaterial(&#123; <span class="attr">color</span>: <span class="number">0xffff00</span> &#125;);</span><br><span class="line"><span class="keyword">const</span> circle = <span class="keyword">new</span> THREE.Mesh(geometry, material);</span><br><span class="line">scene.add(circle);</span><br></pre></td></tr></table></figure>

<h5 id="构造器-3"><a href="#构造器-3" class="headerlink" title="构造器"></a>构造器</h5><p><code>CircleGeometry(radius : Float, segments : Integer, thetaStart : Float, thetaLength : Float)</code><br>radius — 圆形的半径，默认值为 1<br>segments — 分段（三角面）的数量，最小值为 3，默认值为 32。<br>thetaStart — 第一个分段的起始角度，默认为 0。（three o’clock position）<br>thetaLength — 圆形扇区的中心角，通常被称为“θ”（西塔）。默认值是 2*Pi，这使其成为一个完整的圆。</p>
<h5 id="属性-方法-1"><a href="#属性-方法-1" class="headerlink" title="属性|方法"></a>属性|方法</h5><blockquote>
<p>共有方法请参见其基类 BufferGeometry。<br>共有属性请参见其基类 BufferGeometry。</p>
</blockquote>
<p><code>.parameters</code> : Object<br>一个包含着构造函数中每个参数的对象。在对象实例化之后，对该属性的任何修改都不会改变这个几何体。</p>
<h4 id="平面（PlaneGeometry）"><a href="#平面（PlaneGeometry）" class="headerlink" title="平面（PlaneGeometry）"></a>平面（PlaneGeometry）</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> geometry = <span class="keyword">new</span> THREE.PlaneGeometry(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">const</span> material = <span class="keyword">new</span> THREE.MeshBasicMaterial(&#123;</span><br><span class="line">  <span class="attr">color</span>: <span class="number">0xffff00</span>,</span><br><span class="line">  <span class="attr">side</span>: THREE.DoubleSide,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> plane = <span class="keyword">new</span> THREE.Mesh(geometry, material);</span><br><span class="line">scene.add(plane);</span><br></pre></td></tr></table></figure>

<h5 id="构造器-4"><a href="#构造器-4" class="headerlink" title="构造器"></a>构造器</h5><p><code>PlaneGeometry(width : Float, height : Float, widthSegments : Integer, heightSegments : Integer)</code><br>width — 平面沿着 X 轴的宽度。默认值是 1。<br>height — 平面沿着 Y 轴的高度。默认值是 1。<br>widthSegments — （可选）平面的宽度分段数，默认值是 1。<br>heightSegments — （可选）平面的高度分段数，默认值是 1。</p>
<h5 id="属性-方法-2"><a href="#属性-方法-2" class="headerlink" title="属性|方法"></a>属性|方法</h5><blockquote>
<p>共有方法请参见其基类 BufferGeometry。<br>共有属性请参见其基类 BufferGeometry。</p>
</blockquote>
<p><code>.parameters</code> : Object<br>一个包含着构造函数中每个参数的对象。在对象实例化之后，对该属性的任何修改都不会改变这个几何体。</p>
<h4 id="圆柱（CylinderGeometry）"><a href="#圆柱（CylinderGeometry）" class="headerlink" title="圆柱（CylinderGeometry）"></a>圆柱（CylinderGeometry）</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> geometry = <span class="keyword">new</span> THREE.CylinderGeometry(<span class="number">5</span>, <span class="number">5</span>, <span class="number">20</span>, <span class="number">32</span>);</span><br><span class="line"><span class="keyword">const</span> material = <span class="keyword">new</span> THREE.MeshBasicMaterial(&#123; <span class="attr">color</span>: <span class="number">0xffff00</span> &#125;);</span><br><span class="line"><span class="keyword">const</span> cylinder = <span class="keyword">new</span> THREE.Mesh(geometry, material);</span><br><span class="line">scene.add(cylinder);</span><br></pre></td></tr></table></figure>

<h5 id="构造器-5"><a href="#构造器-5" class="headerlink" title="构造器"></a>构造器</h5><p><code>CylinderGeometry(radiusTop : Float, radiusBottom : Float, height : Float, radialSegments : Integer, heightSegments : Integer, openEnded : Boolean, thetaStart : Float, thetaLength : Float)</code><br>radiusTop — 圆柱的顶部半径，默认值是 1。<br>radiusBottom — 圆柱的底部半径，默认值是 1。<br>height — 圆柱的高度，默认值是 1。<br>radialSegments — 圆柱侧面周围的分段数，默认为 32。<br>heightSegments — 圆柱侧面沿着其高度的分段数，默认值为 1。<br>openEnded — 一个 Boolean 值，指明该圆锥的底面是开放的还是封顶的。默认值为 false，即其底面默认是封顶的。<br>thetaStart — 第一个分段的起始角度，默认为 0。（three o’clock position）<br>thetaLength — 圆柱底面圆扇区的中心角，通常被称为“θ”（西塔）。默认值是 2*Pi，这使其成为一个完整的圆柱。</p>
<h5 id="属性-方法-3"><a href="#属性-方法-3" class="headerlink" title="属性|方法"></a>属性|方法</h5><blockquote>
<p>共有方法请参见其基类 BufferGeometry。<br>共有属性请参见其基类 BufferGeometry。</p>
</blockquote>
<p><code>.parameters</code> : Object<br>一个包含着构造函数中每个参数的对象。在对象实例化之后，对该属性的任何修改都不会改变这个几何体。</p>
<h4 id="挤压（ExtrudeGeometry）"><a href="#挤压（ExtrudeGeometry）" class="headerlink" title="挤压（ExtrudeGeometry）"></a>挤压（ExtrudeGeometry）</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> length = <span class="number">12</span>,</span><br><span class="line">  width = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> shape = <span class="keyword">new</span> THREE.Shape();</span><br><span class="line">shape.moveTo(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">shape.lineTo(<span class="number">0</span>, width);</span><br><span class="line">shape.lineTo(length, width);</span><br><span class="line">shape.lineTo(length, <span class="number">0</span>);</span><br><span class="line">shape.lineTo(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> extrudeSettings = &#123;</span><br><span class="line">  <span class="attr">steps</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">depth</span>: <span class="number">16</span>,</span><br><span class="line">  <span class="attr">bevelEnabled</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">bevelThickness</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">bevelSize</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">bevelOffset</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">bevelSegments</span>: <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> geometry = <span class="keyword">new</span> THREE.ExtrudeGeometry(shape, extrudeSettings);</span><br><span class="line"><span class="keyword">const</span> material = <span class="keyword">new</span> THREE.MeshBasicMaterial(&#123; <span class="attr">color</span>: <span class="number">0x00ff00</span> &#125;);</span><br><span class="line"><span class="keyword">const</span> mesh = <span class="keyword">new</span> THREE.Mesh(geometry, material);</span><br><span class="line">scene.add(mesh);</span><br></pre></td></tr></table></figure>

<h5 id="构造器-6"><a href="#构造器-6" class="headerlink" title="构造器"></a>构造器</h5><p><code>ExtrudeGeometry(shapes : Array, options : Object)</code><br>shapes — 形状或者一个包含形状的数组。<br>options — 一个包含有下列参数的对象：</p>
<p>curveSegments — int，曲线上点的数量，默认值是 12。<br>steps — int，用于沿着挤出样条的深度细分的点的数量，默认值为 1。<br>depth — float，挤出的形状的深度，默认值为 1。<br>bevelEnabled — bool，对挤出的形状应用是否斜角，默认值为 true。<br>bevelThickness — float，设置原始形状上斜角的厚度。默认值为 0.2。<br>bevelSize — float。斜角与原始形状轮廓之间的延伸距离，默认值为 bevelThickness-0.1。<br>bevelOffset — float. Distance from the shape outline that the bevel starts. Default is 0.<br>bevelSegments — int。斜角的分段层数，默认值为 3。<br>extrudePath — THREE.Curve 对象。一条沿着被挤出形状的三维样条线。Bevels not supported for path extrusion.<br>UVGenerator — Object。提供了 UV 生成器函数的对象。<br>该对象将一个二维形状挤出为一个三维几何体。</p>
<p>当使用这个几何体创建 Mesh 的时候，如果你希望分别对它的表面和它挤出的侧面使用单独的材质，你可以使用一个材质数组。 第一个材质将用于其表面；第二个材质则将用于其挤压出的侧面。##### 属性|方法</p>
<blockquote>
<p>共有方法请参见其基类 BufferGeometry。<br>共有属性请参见其基类 BufferGeometry。</p>
</blockquote>
<p><code>.parameters</code> : Object<br>一个包含着构造函数中每个参数的对象。在对象实例化之后，对该属性的任何修改都不会改变这个几何体。</p>
<h4 id="形状（ShapeGeometry）"><a href="#形状（ShapeGeometry）" class="headerlink" title="形状（ShapeGeometry）"></a>形状（ShapeGeometry）</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> x = <span class="number">0</span>,</span><br><span class="line">  y = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> heartShape = <span class="keyword">new</span> THREE.Shape();</span><br><span class="line"></span><br><span class="line">heartShape.moveTo(x + <span class="number">5</span>, y + <span class="number">5</span>);</span><br><span class="line">heartShape.bezierCurveTo(x + <span class="number">5</span>, y + <span class="number">5</span>, x + <span class="number">4</span>, y, x, y);</span><br><span class="line">heartShape.bezierCurveTo(x - <span class="number">6</span>, y, x - <span class="number">6</span>, y + <span class="number">7</span>, x - <span class="number">6</span>, y + <span class="number">7</span>);</span><br><span class="line">heartShape.bezierCurveTo(x - <span class="number">6</span>, y + <span class="number">11</span>, x - <span class="number">3</span>, y + <span class="number">15.4</span>, x + <span class="number">5</span>, y + <span class="number">19</span>);</span><br><span class="line">heartShape.bezierCurveTo(x + <span class="number">12</span>, y + <span class="number">15.4</span>, x + <span class="number">16</span>, y + <span class="number">11</span>, x + <span class="number">16</span>, y + <span class="number">7</span>);</span><br><span class="line">heartShape.bezierCurveTo(x + <span class="number">16</span>, y + <span class="number">7</span>, x + <span class="number">16</span>, y, x + <span class="number">10</span>, y);</span><br><span class="line">heartShape.bezierCurveTo(x + <span class="number">7</span>, y, x + <span class="number">5</span>, y + <span class="number">5</span>, x + <span class="number">5</span>, y + <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> geometry = <span class="keyword">new</span> THREE.ShapeGeometry(heartShape);</span><br><span class="line"><span class="keyword">const</span> material = <span class="keyword">new</span> THREE.MeshBasicMaterial(&#123; <span class="attr">color</span>: <span class="number">0x00ff00</span> &#125;);</span><br><span class="line"><span class="keyword">const</span> mesh = <span class="keyword">new</span> THREE.Mesh(geometry, material);</span><br><span class="line">scene.add(mesh);</span><br></pre></td></tr></table></figure>

<h5 id="构造器-7"><a href="#构造器-7" class="headerlink" title="构造器"></a>构造器</h5><p><code>ShapeGeometry(shapes : Array, curveSegments : Integer)</code><br>shapes — 一个单独的 shape，或者一个包含形状的 Array。Default is a single triangle shape.<br>curveSegments - Integer - 每一个形状的分段数，默认值为 12。</p>
<h5 id="属性-方法-4"><a href="#属性-方法-4" class="headerlink" title="属性|方法"></a>属性|方法</h5><blockquote>
<p>共有方法请参见其基类 BufferGeometry。<br>共有属性请参见其基类 BufferGeometry。</p>
</blockquote>
<p><code>.parameters</code> : Object<br>一个包含着构造函数中每个参数的对象。在对象实例化之后，对该属性的任何修改都不会改变这个几何体。</p>
<h4 id="圆环（RingGeometry）"><a href="#圆环（RingGeometry）" class="headerlink" title="圆环（RingGeometry）"></a>圆环（RingGeometry）</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> geometry = <span class="keyword">new</span> THREE.RingGeometry(<span class="number">1</span>, <span class="number">5</span>, <span class="number">32</span>);</span><br><span class="line"><span class="keyword">const</span> material = <span class="keyword">new</span> THREE.MeshBasicMaterial(&#123;</span><br><span class="line">  <span class="attr">color</span>: <span class="number">0xffff00</span>,</span><br><span class="line">  <span class="attr">side</span>: THREE.DoubleSide,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> mesh = <span class="keyword">new</span> THREE.Mesh(geometry, material);</span><br><span class="line">scene.add(mesh);</span><br></pre></td></tr></table></figure>

<h5 id="构造器-8"><a href="#构造器-8" class="headerlink" title="构造器"></a>构造器</h5><p><code>RingGeometry(innerRadius : Float, outerRadius : Float, thetaSegments : Integer, phiSegments : Integer, thetaStart : Float, thetaLength : Float)</code><br>innerRadius — 内部半径，默认值为 0.5。<br>outerRadius — 外部半径，默认值为 1。<br>thetaSegments — 圆环的分段数。这个值越大，圆环就越圆。最小值为 3，默认值为 32。<br>phiSegments — 最小值为 1，默认值为 8。<br>thetaStart — 起始角度，默认值为 0。<br>thetaLength — 圆心角，默认值为 Math.PI * 2。</p>
<h5 id="属性-方法-5"><a href="#属性-方法-5" class="headerlink" title="属性|方法"></a>属性|方法</h5><blockquote>
<p>共有方法请参见其基类 BufferGeometry。<br>共有属性请参见其基类 BufferGeometry。</p>
</blockquote>
<p><code>.parameters</code> : Object<br>一个包含着构造函数中每个参数的对象。在对象实例化之后，对该属性的任何修改都不会改变这个几何体。</p>
<h4 id="圆锥（ConeGeometry）"><a href="#圆锥（ConeGeometry）" class="headerlink" title="圆锥（ConeGeometry）"></a>圆锥（ConeGeometry）</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> geometry = <span class="keyword">new</span> THREE.ConeGeometry(<span class="number">5</span>, <span class="number">20</span>, <span class="number">32</span>);</span><br><span class="line"><span class="keyword">const</span> material = <span class="keyword">new</span> THREE.MeshBasicMaterial(&#123; <span class="attr">color</span>: <span class="number">0xffff00</span> &#125;);</span><br><span class="line"><span class="keyword">const</span> cone = <span class="keyword">new</span> THREE.Mesh(geometry, material);</span><br><span class="line">scene.add(cone);</span><br></pre></td></tr></table></figure>

<h5 id="构造器-9"><a href="#构造器-9" class="headerlink" title="构造器"></a>构造器</h5><p><code>ConeGeometry(radius : Float, height : Float, radialSegments : Integer, heightSegments : Integer, openEnded : Boolean, thetaStart : Float, thetaLength : Float)</code><br>radius — 圆锥底部的半径，默认值为 1。<br>height — 圆锥的高度，默认值为 1。<br>radialSegments — 圆锥侧面周围的分段数，默认为 32。<br>heightSegments — 圆锥侧面沿着其高度的分段数，默认值为 1。<br>openEnded — 一个 Boolean 值，指明该圆锥的底面是开放的还是封顶的。默认值为 false，即其底面默认是封顶的。<br>thetaStart — 第一个分段的起始角度，默认为 0。（three o’clock position）<br>thetaLength — 圆锥底面圆扇区的中心角，通常被称为“θ”（西塔）。默认值是 2*Pi，这使其成为一个完整的圆锥。</p>
<h5 id="属性-方法-6"><a href="#属性-方法-6" class="headerlink" title="属性|方法"></a>属性|方法</h5><blockquote>
<p>共有方法请参见其基类 BufferGeometry。<br>共有属性请参见其基类 BufferGeometry。</p>
</blockquote>
<p><code>.parameters</code> : Object<br>一个包含着构造函数中每个参数的对象。在对象实例化之后，对该属性的任何修改都不会改变这个几何体。</p>
<h4 id="球（SphereGeometry）"><a href="#球（SphereGeometry）" class="headerlink" title="球（SphereGeometry）"></a>球（SphereGeometry）</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> geometry = <span class="keyword">new</span> THREE.SphereGeometry(<span class="number">15</span>, <span class="number">32</span>, <span class="number">16</span>);</span><br><span class="line"><span class="keyword">const</span> material = <span class="keyword">new</span> THREE.MeshBasicMaterial(&#123; <span class="attr">color</span>: <span class="number">0xffff00</span> &#125;);</span><br><span class="line"><span class="keyword">const</span> sphere = <span class="keyword">new</span> THREE.Mesh(geometry, material);</span><br><span class="line">scene.add(sphere);</span><br></pre></td></tr></table></figure>

<h5 id="构造器-10"><a href="#构造器-10" class="headerlink" title="构造器"></a>构造器</h5><p><code>SphereGeometry(radius : Float, widthSegments : Integer, heightSegments : Integer, phiStart : Float, phiLength : Float, thetaStart : Float, thetaLength : Float)</code><br>radius — 球体半径，默认为 1。<br>widthSegments — 水平分段数（沿着经线分段），最小值为 3，默认值为 32。<br>heightSegments — 垂直分段数（沿着纬线分段），最小值为 2，默认值为 16。<br>phiStart — 指定水平（经线）起始角度，默认值为 0。。<br>phiLength — 指定水平（经线）扫描角度的大小，默认值为 Math.PI * 2。<br>thetaStart — 指定垂直（纬线）起始角度，默认值为 0。<br>thetaLength — 指定垂直（纬线）扫描角度大小，默认值为 Math.PI。<br>该几何体是通过扫描并计算围绕着 Y 轴（水平扫描）和 X 轴（垂直扫描）的顶点来创建的。 因此，不完整的球体（类似球形切片）可以通过为 phiStart，phiLength，thetaStart 和 thetaLength 设置不同的值来创建， 以定义我们开始（或结束）计算这些顶点的起点（或终点）。</p>
<h5 id="属性-方法-7"><a href="#属性-方法-7" class="headerlink" title="属性|方法"></a>属性|方法</h5><blockquote>
<p>共有方法请参见其基类 BufferGeometry。<br>共有属性请参见其基类 BufferGeometry。</p>
</blockquote>
<p><code>.parameters</code> : Object<br>一个包含着构造函数中每个参数的对象。在对象实例化之后，对该属性的任何修改都不会改变这个几何体。</p>
<h4 id="圆环（TorusGeometry）"><a href="#圆环（TorusGeometry）" class="headerlink" title="圆环（TorusGeometry）"></a>圆环（TorusGeometry）</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> geometry = <span class="keyword">new</span> THREE.TorusGeometry(<span class="number">10</span>, <span class="number">3</span>, <span class="number">16</span>, <span class="number">100</span>);</span><br><span class="line"><span class="keyword">const</span> material = <span class="keyword">new</span> THREE.MeshBasicMaterial(&#123; <span class="attr">color</span>: <span class="number">0xffff00</span> &#125;);</span><br><span class="line"><span class="keyword">const</span> torus = <span class="keyword">new</span> THREE.Mesh(geometry, material);</span><br><span class="line">scene.add(torus);</span><br></pre></td></tr></table></figure>

<h5 id="构造器-11"><a href="#构造器-11" class="headerlink" title="构造器"></a>构造器</h5><p><code>TorusGeometry(radius : Float, tube : Float, radialSegments : Integer, tubularSegments : Integer, arc : Float)</code><br>radius - 环面的半径，从环面的中心到管道横截面的中心。默认值是 1。<br>tube — 管道的半径，默认值为 0.4。<br>radialSegments — 管道横截面的分段数，默认值为 12。<br>tubularSegments — 管道的分段数，默认值为 48。<br>arc — 圆环的圆心角（单位是弧度），默认值为 Math.PI * 2。</p>
<h5 id="属性-方法-8"><a href="#属性-方法-8" class="headerlink" title="属性|方法"></a>属性|方法</h5><blockquote>
<p>共有方法请参见其基类 BufferGeometry。<br>共有属性请参见其基类 BufferGeometry。</p>
</blockquote>
<p><code>.parameters</code> : Object<br>一个包含着构造函数中每个参数的对象。在对象实例化之后，对该属性的任何修改都不会改变这个几何体。</p>
<h4 id="管道（TubeGeometry）"><a href="#管道（TubeGeometry）" class="headerlink" title="管道（TubeGeometry）"></a>管道（TubeGeometry）</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomSinCurve</span> <span class="keyword">extends</span> <span class="title">THREE</span>.<span class="title">Curve</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">scale = <span class="number">1</span></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.scale = scale;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">getPoint</span>(<span class="params">t, optionalTarget = <span class="keyword">new</span> THREE.Vector3()</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> tx = t * <span class="number">3</span> - <span class="number">1.5</span>;</span><br><span class="line">    <span class="keyword">const</span> ty = <span class="built_in">Math</span>.sin(<span class="number">2</span> * <span class="built_in">Math</span>.PI * t);</span><br><span class="line">    <span class="keyword">const</span> tz = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> optionalTarget.set(tx, ty, tz).multiplyScalar(<span class="built_in">this</span>.scale);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> path = <span class="keyword">new</span> CustomSinCurve(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">const</span> geometry = <span class="keyword">new</span> THREE.TubeGeometry(path, <span class="number">20</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="literal">false</span>);</span><br><span class="line"><span class="keyword">const</span> material = <span class="keyword">new</span> THREE.MeshBasicMaterial(&#123; <span class="attr">color</span>: <span class="number">0x00ff00</span> &#125;);</span><br><span class="line"><span class="keyword">const</span> mesh = <span class="keyword">new</span> THREE.Mesh(geometry, material);</span><br><span class="line">scene.add(mesh);</span><br></pre></td></tr></table></figure>

<h5 id="构造器-12"><a href="#构造器-12" class="headerlink" title="构造器"></a>构造器</h5><p><code>TubeGeometry(path : Curve, tubularSegments : Integer, radius : Float, radialSegments : Integer, closed : Boolean)</code><br>path — Curve - 一个由基类 Curve 继承而来的 3D 路径。 Default is a quadratic bezier curve.<br>tubularSegments — Integer - 组成这一管道的分段数，默认值为 64。<br>radius — Float - 管道的半径，默认值为 1。<br>radialSegments — Integer - 管道横截面的分段数目，默认值为 8。<br>closed — Boolean 管道的两端是否闭合，默认值为 false。</p>
<h5 id="属性-方法-9"><a href="#属性-方法-9" class="headerlink" title="属性|方法"></a>属性|方法</h5><blockquote>
<p>共有方法请参见其基类 BufferGeometry。<br>共有属性请参见其基类 BufferGeometry。</p>
</blockquote>
<p><code>.parameters</code> : Object<br>一个包含着构造函数中每个参数的对象。在对象实例化之后，对该属性的任何修改都不会改变这个几何体。<br><code>.tangents</code> : Array<br>一个 Vector3 切线数组。</p>
<p><code>.normals</code> : Array<br>一个 Vector3 法线数组。</p>
<p><code>.binormals</code> : Array<br>一个 Vector3 次法线数组。</p>
<h4 id="多面缓冲几何体（PolyhedronGeometry）"><a href="#多面缓冲几何体（PolyhedronGeometry）" class="headerlink" title="多面缓冲几何体（PolyhedronGeometry）"></a>多面缓冲几何体（PolyhedronGeometry）</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> verticesOfCube = [</span><br><span class="line">  -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, -<span class="number">1</span>,</span><br><span class="line">  <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> indicesOfFaces = [</span><br><span class="line">  <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>,</span><br><span class="line">  <span class="number">7</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">4</span>,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> geometry = <span class="keyword">new</span> THREE.PolyhedronGeometry(</span><br><span class="line">  verticesOfCube,</span><br><span class="line">  indicesOfFaces,</span><br><span class="line">  <span class="number">6</span>,</span><br><span class="line">  <span class="number">2</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h5 id="构造器-13"><a href="#构造器-13" class="headerlink" title="构造器"></a>构造器</h5><p><code>PolyhedronGeometry(vertices : Array, indices : Array, radius : Float, detail : Integer)</code><br>vertices — 一个顶点 Array（数组）：[1,1,1, -1,-1,-1, … ]。<br>indices — 一个构成面的索引 Array（数组）， [0,1,2, 2,3,0, … ]。<br>radius — Float - 最终形状的半径。<br>detail — Integer - 将对这个几何体细分多少个级别。细节越多，形状就越平滑。</p>
<h5 id="属性-方法-10"><a href="#属性-方法-10" class="headerlink" title="属性|方法"></a>属性|方法</h5><blockquote>
<p>共有方法请参见其基类 BufferGeometry。<br>共有属性请参见其基类 BufferGeometry。</p>
</blockquote>
<p><code>.parameters</code> : Object<br>一个包含着构造函数中每个参数的对象。在对象实例化之后，对该属性的任何修改都不会改变这个几何体。</p>
<h4 id="边缘几何体（EdgesGeometry）"><a href="#边缘几何体（EdgesGeometry）" class="headerlink" title="边缘几何体（EdgesGeometry）"></a>边缘几何体（EdgesGeometry）</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> geometry = <span class="keyword">new</span> THREE.BoxGeometry(<span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line"><span class="keyword">const</span> edges = <span class="keyword">new</span> THREE.EdgesGeometry(geometry);</span><br><span class="line"><span class="keyword">const</span> line = <span class="keyword">new</span> THREE.LineSegments(</span><br><span class="line">  edges,</span><br><span class="line">  <span class="keyword">new</span> THREE.LineBasicMaterial(&#123; <span class="attr">color</span>: <span class="number">0xffffff</span> &#125;)</span><br><span class="line">);</span><br><span class="line">scene.add(line);</span><br></pre></td></tr></table></figure>

<h5 id="构造器-14"><a href="#构造器-14" class="headerlink" title="构造器"></a>构造器</h5><p><code>EdgesGeometry( geometry : BufferGeometry, thresholdAngle : Integer )</code><br>geometry — 任何一个几何体对象。<br>thresholdAngle — 仅当相邻面的法线之间的角度（单位为角度）超过这个值时，才会渲染边缘。默认值为 1。</p>
<h5 id="属性-方法-11"><a href="#属性-方法-11" class="headerlink" title="属性|方法"></a>属性|方法</h5><blockquote>
<p>共有方法请参见其基类 BufferGeometry。<br>共有属性请参见其基类 BufferGeometry。<br><code>.parameters</code> : Object<br>一个包含着构造函数中每个参数的对象。在对象实例化之后，对该属性的任何修改都不会改变这个几何体。</p>
</blockquote>
<h4 id="网格几何体（WireframeGeometry）"><a href="#网格几何体（WireframeGeometry）" class="headerlink" title="网格几何体（WireframeGeometry）"></a>网格几何体（WireframeGeometry）</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> geometry = <span class="keyword">new</span> THREE.SphereGeometry(<span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> wireframe = <span class="keyword">new</span> THREE.WireframeGeometry(geometry);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> line = <span class="keyword">new</span> THREE.LineSegments(wireframe);</span><br><span class="line">line.material.depthTest = <span class="literal">false</span>;</span><br><span class="line">line.material.opacity = <span class="number">0.25</span>;</span><br><span class="line">line.material.transparent = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">scene.add(line);</span><br></pre></td></tr></table></figure>

<h5 id="构造器-15"><a href="#构造器-15" class="headerlink" title="构造器"></a>构造器</h5><p><code>WireframeGeometry( geometry : BufferGeometry )</code><br>geometry — 任意几何体对象。</p>
<h5 id="属性-方法-12"><a href="#属性-方法-12" class="headerlink" title="属性|方法"></a>属性|方法</h5><blockquote>
<p>共有方法请参见其基类 BufferGeometry。<br>共有属性请参见其基类 BufferGeometry。</p>
</blockquote>
<h3 id="材质"><a href="#材质" class="headerlink" title="材质"></a>材质</h3><h4 id="Material"><a href="#Material" class="headerlink" title="Material"></a>Material</h4><p>材质描述了对象 objects 的外观。它们的定义方式与渲染器无关， 因此，如果您决定使用不同的渲染器，不必重写材质。</p>
<h5 id="构造器-16"><a href="#构造器-16" class="headerlink" title="构造器"></a>构造器</h5><p><code>Material()</code>该方法创建一个通用材质。</p>
<h4 id="属性-5"><a href="#属性-5" class="headerlink" title="属性"></a>属性</h4><ul>
<li><p><code>.alphaTest</code> : Float<br>设置运行 alphaTest 时要使用的 alpha 值。如果不透明度低于此值，则不会渲染材质。默认值为 0。</p>
</li>
<li><p><code>.alphaToCoverage</code> : Boolean<br>启用 alpha to coverage. 只能在开启了 MSAA 的渲染环境中使用 (当渲染器创建的时候 antialias 属性要 true 才能使用). 默认为 false.</p>
</li>
<li><p><code>.blendDst</code> : Integer<br>混合目标。默认值为 OneMinusSrcAlphaFactor。 目标因子所有可能的取值请参阅 constants。 必须将材质的 blending 设置为 CustomBlending 才能生效。</p>
</li>
<li><p><code>.blendDstAlpha</code> : Integer<br>.blendDst 的透明度。 默认值为 null.</p>
</li>
<li><p><code>.blendEquation</code> : Integer<br>使用混合时所采用的混合方程式。默认值为 AddEquation。 混合方程式所有可能的取值请参阅 constants。 必须将材质的 blending 设置为 CustomBlending 才能生效。<br>.blendEquationAlpha : Integer<br>.blendEquation 的透明度. 默认值为 null.</p>
</li>
<li><p><code>.blending</code> : Blending<br>在使用此材质显示对象时要使用何种混合。<br>必须将其设置为 CustomBlending 才能使用自定义 blendSrc, blendDst 或者 [page:Constant blendEquation]。 混合模式所有可能的取值请参阅 constants。默认值为 NormalBlending。</p>
</li>
<li><p><code>.blendSrc</code> : Integer<br>混合源。默认值为 SrcAlphaFactor。 源因子所有可能的取值请参阅 constants。<br>必须将材质的 blending 设置为 CustomBlending 才能生效。</p>
</li>
<li><p><code>.blendSrcAlpha</code> : Integer<br>.blendSrc 的透明度。 默认值为 null.</p>
</li>
<li><p><code>.clipIntersection</code> : Boolean<br>更改剪裁平面的行为，以便仅剪切其交叉点，而不是它们的并集。默认值为 false。</p>
</li>
<li><p><code>.clippingPlanes</code> : Array<br>用户定义的剪裁平面，在世界空间中指定为 THREE.Plane 对象。这些平面适用于所有使用此材质的对象。空间中与平面的有符号距离为负的点被剪裁（未渲染）。 这需要 WebGLRenderer.localClippingEnabled 为 true。 示例请参阅 WebGL / clipping /intersection。默认值为 null。</p>
</li>
<li><p><code>.clipShadows</code> : Boolean<br>定义是否根据此材质上指定的剪裁平面剪切阴影。默认值为 false。</p>
</li>
<li><p><code>.colorWrite</code> : Boolean<br>是否渲染材质的颜色。 这可以与网格的 renderOrder 属性结合使用，以创建遮挡其他对象的不可见对象。默认值为 true。</p>
</li>
<li><p><code>.defines</code> : Object<br>注入 shader 的自定义对象。 以键值对形式的对象传递，{ MY_CUSTOM_DEFINE: ‘’ , PI2: Math.PI * 2 }。 这些键值对在顶点和片元着色器中定义。默认值为 undefined。</p>
</li>
<li><p><code>.depthFunc</code> : Integer<br>使用何种深度函数。默认为 LessEqualDepth。 深度模式所有可能的取值请查阅 constants。</p>
</li>
<li><p><code>.depthTest</code> : Boolean<br>是否在渲染此材质时启用深度测试。默认为 true。</p>
</li>
<li><p><code>.depthWrite</code> : Boolean<br>渲染此材质是否对深度缓冲区有任何影响。默认为 true。</p>
</li>
</ul>
<p>在绘制 2D 叠加时，将多个事物分层在一起而不创建 z-index 时，禁用深度写入会很有用。</p>
<ul>
<li><code>.forceSinglePass</code> : Boolean<br>决定双面透明的东西是否强制使用单通道渲染，默认为 false。</li>
</ul>
<p>为了减少一些半透明物体的渲染错误，此引擎调用两次绘制来渲染渲染双面透明的东西。 但是此方案可能会导致在某些情况下使绘制调用次数翻倍，例如渲染一些平面的植物例如草精灵之类的。 在这些情况下，将 forceSinglePass 设置为 true 来使用单通道渲染来避免性能问题。</p>
<ul>
<li><p><code>.isMaterial</code> : Boolean<br>检查这个对象是否为材质 Material 的只读标记.</p>
</li>
<li><p><code>.stencilWrite</code> : Boolean<br>是否对模板缓冲执行模板操作，如果执行写入或者与模板缓冲进行比较，这个值需要设置为 true。默认为 false。</p>
</li>
<li><p><code>.stencilWriteMask</code> : Integer<br>写入模板缓冲区时所用的位元遮罩，默认为 0xFF。</p>
</li>
<li><p><code>.stencilFunc</code> : Integer<br>使用模板比较时所用的方法，默认为 AlwaysStencilFunc。在模板函数 constants 中查看可用的值</p>
</li>
<li><p><code>.stencilRef</code> : Integer<br>在进行模板比较或者模板操作的时候所用的基准值，默认为 0。</p>
</li>
<li><p><code>.stencilFuncMask</code> : Integer<br>与模板缓冲进行比较时所使用的位元遮罩，默认为 0xFF</p>
</li>
<li><p><code>.stencilFail</code> : Integer<br>当比较函数没有通过的时候要执行的模板操作，默认为 KeepStencilOp，在模板操作 constants 查看可用值。</p>
</li>
<li><p><code>.stencilZFail</code> : Integer<br>当比较函数通过了但是深度检测没有通过的时候要执行的模板操作， 默认为 KeepStencilOp，在模板操作 constants 查看可用值。</p>
</li>
<li><p><code>.stencilZPass</code> : Integer<br>当比较函数和深度检测都通过时要执行的模板操作，默认为 KeepStencilOp，在模板操作 constants 中查看可用值。</p>
</li>
<li><p><code>.id</code> : Integer<br>此材质实例的唯一编号。</p>
</li>
<li><p><code>.name</code> : String<br>对象的可选名称（不必是唯一的）。默认值为空字符串。</p>
</li>
<li><p><code>.needsUpdate</code> : Boolean<br>指定需要重新编译材质。</p>
</li>
<li><p><code>.opacity</code> : Float<br>在 0.0 - 1.0 的范围内的浮点数，表明材质的透明度。值 0.0 表示完全透明，1.0 表示完全不透明。<br>如果材质的 transparent 属性未设置为 true，则材质将保持完全不透明，此值仅影响其颜色。 默认值为 1.0。</p>
</li>
<li><p><code>.polygonOffset</code> : Boolean<br>是否使用多边形偏移。默认值为 false。这对应于 WebGL 的 GL_POLYGON_OFFSET_FILL 功能。</p>
</li>
<li><p><code>.polygonOffsetFactor</code> : Integer<br>设置多边形偏移系数。默认值为 0。</p>
</li>
<li><p><code>.polygonOffsetUnits</code> : Integer<br>设置多边形偏移单位。默认值为 0。</p>
</li>
<li><p><code>.precision</code> : String<br>重写此材质渲染器的默认精度。可以是”highp”, “mediump” 或 “lowp”。默认值为 null。</p>
</li>
<li><p><code>.premultipliedAlpha</code> : Boolean<br>是否预乘 alpha（透明度）值。有关差异的示例，请参阅 WebGL / Materials / Physical / Transmission。 默认值为 false。</p>
</li>
<li><p><code>.dithering</code> : Boolean<br>是否对颜色应用抖动以消除条带的外观。默认值为 false。</p>
</li>
<li><p><code>.shadowSide</code> : Integer<br>定义投影的面。设置时，可以是 THREE.FrontSide, THREE.BackSide, 或 Materials。默认值为 null。<br>如果为 null， 则面投射阴影确定如下：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>THREE.FrontSide</td>
<td>背面</td>
</tr>
<tr>
<td>THREE.BackSide</td>
<td>前面</td>
</tr>
<tr>
<td>THREE.DoubleSide</td>
<td>双面</td>
</tr>
</tbody></table>
</li>
<li><p><code>.side</code> : Integer<br>定义将要渲染哪一面 - 正面，背面或两者。 默认为 THREE.FrontSide。其他选项有 THREE.BackSide 和 THREE.DoubleSide。</p>
</li>
<li><p><code>.toneMapped</code> : Boolean<br>定义这个材质是否会被渲染器的 toneMapping 设置所影响，默认为 true 。</p>
</li>
<li><p><code>.transparent</code> : Boolean<br>定义此材质是否透明。这对渲染有影响，因为透明对象需要特殊处理，并在非透明对象之后渲染。<br>设置为 true 时，通过设置材质的 opacity 属性来控制材质透明的程度。<br>默认值为 false。</p>
</li>
<li><p><code>.type</code> : String<br>值是字符串’Material’。不应该被更改，并且可以用于在场景中查找此类型的所有对象。</p>
</li>
<li><p><code>.uuid</code> : String<br>此材质实例的 UUID，会自动分配，不应该被更改。</p>
</li>
<li><p><code>.version</code> : Integer<br>开始为 0，会记录 .needsUpdate : Boolean 设置为 true 的次数。</p>
</li>
<li><p><code>.vertexColors</code> : Boolean<br>是否使用顶点着色。默认值为 false。 此引擎支持 RGB 或者 RGBA 两种顶点颜色，取决于缓冲 attribute 使用的是三分量（RGB）还是四分量（RGBA）。</p>
</li>
<li><p><code>.visible</code> : Boolean<br>此材质是否可见。默认为 true。</p>
</li>
<li><p><code>.userData</code> : Object<br>一个对象，可用于存储有关 Material 的自定义数据。它不应该包含对函数的引用，因为这些函数不会被克隆。</p>
</li>
</ul>
<h5 id="方法-5"><a href="#方法-5" class="headerlink" title="方法"></a>方法</h5><blockquote>
<p>EventDispatcher 方法在此类中可用。</p>
</blockquote>
<ul>
<li><p><code>.clone ( ) : Material</code><br>返回与此材质具有相同参数的新材质。</p>
</li>
<li><p><code>.copy ( material : material ) : this</code><br>将被传入材质中的参数复制到此材质中。</p>
</li>
<li><p><code>.dispose () : undefined</code><br>处理材质。材质的纹理不会被处理。需要通过 Texture 处理。</p>
</li>
<li><p><code>.onBeforeCompile ( shader : Shader, renderer : WebGLRenderer ) : undefined</code><br>在编译 shader 程序之前立即执行的可选回调。此函数使用 shader 源码作为参数。用于修改内置材质。</p>
</li>
</ul>
<p>和其他属性不一样的是，这个回调在.clone()，.copy() 和 .toJSON() 中不支持。</p>
<ul>
<li><code>.customProgramCacheKey () : String</code><br>当用到 onBeforeCompile 回调的时候，这个回调函数可以用来定义在 onBeforeCompile 中使用的配置项，这样 three.js 就可以根据这个回调返回的字符串来判定使用一个缓存的编译好的着色器代码还是根据需求重新编译一段新的着色器代码。</li>
</ul>
<p>例如一个 onBeforeCompile 回调函数包含了下面的条件语句:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (black) &#123;</span><br><span class="line">  shader.fragmentShader = shader.fragmentShader.replace(</span><br><span class="line">    <span class="string">&quot;gl_FragColor = vec4(1)&quot;</span>,</span><br><span class="line">    <span class="string">&quot;gl_FragColor = vec4(0)&quot;</span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么 customProgramCacheKey 就可以设置为:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">material.customProgramCacheKey = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> black ? <span class="string">&quot;1&quot;</span> : <span class="string">&quot;0&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>和其他属性不一样的是，这个回调在.clone()，.copy() 和 .toJSON() 中不支持。</p>
<ul>
<li><code>.setValues ( values : Object ) : undefined</code><br>values – 具有参数的容器。 根据 values 设置属性。</li>
<li><code>.toJSON ( meta : Object ) : Object</code><br>meta – 包含有元数据的对象，例如该对象的纹理或图片。 将 material 对象转换为 three.js JSON Object/Scene format（three.js JSON 物体/场景格式）。</li>
</ul>
<h4 id="基础网格材质-MeshBasicMaterial"><a href="#基础网格材质-MeshBasicMaterial" class="headerlink" title="基础网格材质(MeshBasicMaterial)"></a>基础网格材质(MeshBasicMaterial)</h4><h5 id="构造器-17"><a href="#构造器-17" class="headerlink" title="构造器"></a>构造器</h5><p><code>MeshBasicMaterial( parameters : Object )</code><br>parameters - (可选)用于定义材质外观的对象，具有一个或多个属性。材质的任何属性都可以从此处传入(包括从 Material 继承的任何属性)。</p>
<p>属性 color 例外，其可以作为十六进制字符串传递，默认情况下为 0xffffff（白色），内部调用 Color.set(color)。</p>
<h5 id="属性-方法-13"><a href="#属性-方法-13" class="headerlink" title="属性|方法"></a>属性|方法</h5><blockquote>
<p>共有方法请参见其基类 Material。<br>共有属性请参见其基类 Material。</p>
</blockquote>
<p><code>.alphaMap</code> : Texture<br>alpha 贴图是一张灰度纹理，用于控制整个表面的不透明度。（黑色：完全透明；白色：完全不透明）。 默认值为 null。</p>
<p>仅使用纹理的颜色，忽略 alpha 通道（如果存在）。 对于 RGB 和 RGBA 纹理，WebGL 渲染器在采样此纹理时将使用绿色通道， 因为在 DXT 压缩和未压缩 RGB 565 格式中为绿色提供了额外的精度。 Luminance-only 以及 luminance/alpha 纹理也仍然有效。</p>
<p><code>.aoMap</code> : Texture<br>该纹理的红色通道用作环境遮挡贴图。默认值为 null。aoMap 需要第二组 UV。</p>
<p><code>.aoMapIntensity</code> : Float<br>环境遮挡效果的强度。默认值为 1。零是不遮挡效果。</p>
<p><code>.color</code> : Color<br>材质的颜色(Color)，默认值为白色 (0xffffff)。</p>
<p><code>.combine</code> : Integer<br>如何将表面颜色的结果与环境贴图（如果有）结合起来。</p>
<p>选项为 THREE.MultiplyOperation（默认值），THREE.MixOperation， THREE.AddOperation。如果选择多个，则使用.reflectivity 在两种颜色之间进行混合。</p>
<p><code>.envMap</code> : Texture<br>环境贴图。默认值为 null。</p>
<p><code>.fog</code> : Boolean<br>材质是否受雾影响。默认为 true。</p>
<p><code>.lightMap</code> : Texture<br>光照贴图。默认值为 null。lightMap 需要第二组 UV。</p>
<p><code>.lightMapIntensity</code> : Float<br>烘焙光的强度。默认值为 1。</p>
<p><code>.map</code> : Texture<br>颜色贴图。可以选择包括一个 alpha 通道，通常与.transparent 或.alphaTest。默认为 null。</p>
<p><code>.reflectivity</code> : Float<br>环境贴图对表面的影响程度; 见.combine。默认值为 1，有效范围介于 0（无反射）和 1（完全反射）之间。</p>
<p><code>.refractionRatio</code> : Float<br>空气的折射率（IOR）（约为 1）除以材质的折射率。它与环境映射模式 THREE.CubeRefractionMapping 和 THREE.EquirectangularRefractionMapping 一起使用。 The index of refraction (IOR) of air (approximately 1) divided by the index of refraction of the material. It is used with environment mapping mode THREE.CubeRefractionMapping. 折射率不应超过 1。默认值为 0.98。</p>
<p><code>.specularMap</code> : Texture<br>材质使用的高光贴图。默认值为 null。</p>
<p><code>.wireframe</code> : Boolean<br>将几何体渲染为线框。默认值为 false（即渲染为平面多边形）。</p>
<p><code>.wireframeLinecap</code> : String<br>定义线两端的外观。可选值为 ‘butt’，’round’ 和 ‘square’。默认为’round’。</p>
<p>该属性对应 2D Canvas lineJoin 属性， 并且会被 WebGL 渲染器忽略。</p>
<p><code>.wireframeLinejoin</code> : String<br>定义线连接节点的样式。可选值为 ‘round’, ‘bevel’ 和 ‘miter’。默认值为 ‘round’。</p>
<p>该属性对应 2D Canvas lineJoin 属性， 并且会被 WebGL 渲染器忽略。</p>
<p><code>.wireframeLinewidth</code> : Float<br>控制线框宽度。默认值为 1。</p>
<p>由于 OpenGL Core Profile 与大多数平台上 WebGL 渲染器的限制， 无论如何设置该值，线宽始终为 1。</p>
<h4 id="Lambert-网格材质-MeshLambertMaterial"><a href="#Lambert-网格材质-MeshLambertMaterial" class="headerlink" title="Lambert 网格材质(MeshLambertMaterial)"></a>Lambert 网格材质(MeshLambertMaterial)</h4><p>一种非光泽表面的材质，没有镜面高光。<br>由于反射率和光照模型的简单性，MeshPhongMaterial，MeshStandardMaterial 或者 MeshPhysicalMaterial 上使用这种材质时会以一些图形精度为代价，得到更高的性能。</p>
<h5 id="构造器-18"><a href="#构造器-18" class="headerlink" title="构造器"></a>构造器</h5><p><code>MeshLambertMaterial( parameters : Object )</code><br>parameters - (可选)用于定义材质外观的对象，具有一个或多个属性。 材质的任何属性都可以从此处传入(包括从 Material 继承的任何属性)。</p>
<p>属性 color 例外，其可以作为十六进制字符串传递，默认情况下为 0xffffff（白色），内部调用 Color.set(color)。</p>
<h5 id="属性-方法-14"><a href="#属性-方法-14" class="headerlink" title="属性|方法"></a>属性|方法</h5><blockquote>
<p>共有方法请参见其基类 Material。<br>共有属性请参见其基类 Material。</p>
</blockquote>
<p>.alphaMap : Texture<br>alpha 贴图是一张灰度纹理，用于控制整个表面的不透明度。（黑色：完全透明；白色：完全不透明）。 默认值为 null。</p>
<p>仅使用纹理的颜色，忽略 alpha 通道（如果存在）。 对于 RGB 和 RGBA 纹理，WebGL 渲染器在采样此纹理时将使用绿色通道， 因为在 DXT 压缩和未压缩 RGB 565 格式中为绿色提供了额外的精度。 Luminance-only 以及 luminance/alpha 纹理也仍然有效。</p>
<p>.aoMap : Texture<br>该纹理的红色通道用作环境遮挡贴图。默认值为 null。aoMap 需要第二组 UV。</p>
<p>.aoMapIntensity : Float<br>环境遮挡效果的强度。默认值为 1。零是不遮挡效果。</p>
<p>.bumpMap : Texture<br>用于创建凹凸贴图的纹理。黑色和白色值映射到与光照相关的感知深度。凹凸实际上不会影响对象的几何形状，只影响光照。如果定义了法线贴图，则将忽略该贴图。</p>
<p>.bumpScale : Float<br>凹凸贴图会对材质产生多大影响。典型范围是 0-1。默认值为 1。</p>
<p>.color : Color<br>材质的颜色(Color)，默认值为白色 (0xffffff)。</p>
<p>.combine : Integer<br>如何将表面颜色的结果与环境贴图（如果有）结合起来。</p>
<p>选项为 THREE.MultiplyOperation（默认值），THREE.MixOperation， THREE.AddOperation。如果选择多个，则使用.reflectivity 在两种颜色之间进行混合。</p>
<p>.displacementMap : Texture<br>位移贴图会影响网格顶点的位置，与仅影响材质的光照和阴影的其他贴图不同，移位的顶点可以投射阴影，阻挡其他对象， 以及充当真实的几何体。位移纹理是指：网格的所有顶点被映射为图像中每个像素的值（白色是最高的），并且被重定位。</p>
<p>.displacementScale : Float<br>位移贴图对网格的影响程度（黑色是无位移，白色是最大位移）。如果没有设置位移贴图，则不会应用此值。默认值为 1。</p>
<p>.displacementBias : Float<br>位移贴图在网格顶点上的偏移量。如果没有设置位移贴图，则不会应用此值。默认值为 0。</p>
<p>.emissive : Color<br>材质的放射（光）颜色，基本上是不受其他光照影响的固有颜色。默认为黑色。</p>
<p>.emissiveMap : Texture<br>设置放射（发光）贴图。默认值为 null。放射贴图颜色由放射颜色和强度所调节。 如果你有一个放射贴图，请务必将放射颜色设置为黑色以外的其他颜色。</p>
<p>.emissiveIntensity : Float<br>放射光强度。调节发光颜色。默认为 1。</p>
<p>.envMap : Texture<br>环境贴图。默认值为 null。</p>
<p>.flatShading : Boolean<br>定义材质是否使用平面着色进行渲染。默认值为 false。</p>
<p>.fog : Boolean<br>材质是否受雾影响。默认为 true。</p>
<p>.lightMap : Texture<br>光照贴图。默认值为 null。lightMap 需要第二组 UV。</p>
<p>.lightMapIntensity : Float<br>烘焙光的强度。默认值为 1。</p>
<p>.map : Texture<br>颜色贴图。可以选择包括一个 alpha 通道，通常与.transparent 或.alphaTest。默认为 null。</p>
<p>.normalMap : Texture<br>用于创建法线贴图的纹理。RGB 值会影响每个像素片段的曲面法线，并更改颜色照亮的方式。法线贴图不会改变曲面的实际形状，只会改变光照。 In case the material has a normal map authored using the left handed convention, the y component of normalScale should be negated to compensate for the different handedness.</p>
<p>.normalMapType : Integer<br>法线贴图的类型。</p>
<p>选项为 THREE.TangentSpaceNormalMap（默认）和 THREE.ObjectSpaceNormalMap。</p>
<p>.normalScale : Vector2<br>法线贴图对材质的影响程度。典型范围是 0-1。默认值是 Vector2 设置为（1,1）。</p>
<p>.reflectivity : Float<br>环境贴图对表面的影响程度; 见.combine。默认值为 1，有效范围介于 0（无反射）和 1（完全反射）之间。</p>
<p>.refractionRatio : Float<br>空气的折射率（IOR）（约为 1）除以材质的折射率。它与环境映射模式 THREE.CubeRefractionMapping 和 THREE.EquirectangularRefractionMapping 一起使用。 The index of refraction (IOR) of air (approximately 1) divided by the index of refraction of the material. It is used with environment mapping mode THREE.CubeRefractionMapping. 折射率不应超过 1。默认值为 0.98。</p>
<p>.specularMap : Texture<br>材质使用的高光贴图。默认值为 null。</p>
<p>.wireframe : Boolean<br>将几何体渲染为线框。默认值为 false（即渲染为平面多边形）。</p>
<p>.wireframeLinecap : String<br>定义线两端的外观。可选值为 ‘butt’，’round’ 和 ‘square’。默认为’round’。</p>
<p>该属性对应 2D Canvas lineJoin 属性， 并且会被 WebGL 渲染器忽略。</p>
<p>.wireframeLinejoin : String<br>定义线连接节点的样式。可选值为 ‘round’, ‘bevel’ 和 ‘miter’。默认值为 ‘round’。</p>
<p>该属性对应 2D Canvas lineJoin 属性， 并且会被 WebGL 渲染器忽略。</p>
<p>.wireframeLinewidth : Float<br>控制线框宽度。默认值为 1。</p>
<p>由于 OpenGL Core Profile 与 大多数平台上 WebGL 渲染器的限制，无论如何设置该值，线宽始终为 1。</p>
<h4 id="Phong-网格材质-MeshPhongMaterial"><a href="#Phong-网格材质-MeshPhongMaterial" class="headerlink" title="Phong 网格材质(MeshPhongMaterial)"></a>Phong 网格材质(MeshPhongMaterial)</h4><p>一种用于具有镜面高光的光泽表面的材质。</p>
<p>在 MeshStandardMaterial 或 MeshPhysicalMaterial 上使用此材质时，性能通常会更高 ，但会牺牲一些图形精度。</p>
<h5 id="构造器-19"><a href="#构造器-19" class="headerlink" title="构造器"></a>构造器</h5><p><code>MeshPhongMaterial( parameters : Object )</code></p>
<p>parameters - (可选)用于定义材质外观的对象，具有一个或多个属性。 材质的任何属性都可以从此处传入(包括从 Material 继承的任何属性)。</p>
<p>属性 color 例外，其可以作为十六进制字符串传递，默认情况下为 0xffffff（白色），内部调用 Color.set(color)。</p>
<h5 id="属性-方法-15"><a href="#属性-方法-15" class="headerlink" title="属性|方法"></a>属性|方法</h5><blockquote>
<p>共有方法请参见其基类 Material。<br>共有属性请参见其基类 Material。</p>
</blockquote>
<p>.alphaMap : Texture<br>alpha 贴图是一张灰度纹理，用于控制整个表面的不透明度。（黑色：完全透明；白色：完全不透明）。 默认值为 null。</p>
<p>仅使用纹理的颜色，忽略 alpha 通道（如果存在）。 对于 RGB 和 RGBA 纹理，WebGL 渲染器在采样此纹理时将使用绿色通道， 因为在 DXT 压缩和未压缩 RGB 565 格式中为绿色提供了额外的精度。 Luminance-only 以及 luminance/alpha 纹理也仍然有效。</p>
<p>.aoMap : Texture<br>该纹理的红色通道用作环境遮挡贴图。默认值为 null。aoMap 需要第二组 UV。</p>
<p>.aoMapIntensity : Float<br>环境遮挡效果的强度。默认值为 1。零是不遮挡效果。</p>
<p>.bumpMap : Texture<br>用于创建凹凸贴图的纹理。黑色和白色值映射到与光照相关的感知深度。凹凸实际上不会影响对象的几何形状，只影响光照。如果定义了法线贴图，则将忽略该贴图。</p>
<p>.bumpScale : Float<br>凹凸贴图会对材质产生多大影响。典型范围是 0-1。默认值为 1。</p>
<p>.color : Color<br>材质的颜色(Color)，默认值为白色 (0xffffff)。</p>
<p>.combine : Integer<br>如何将表面颜色的结果与环境贴图（如果有）结合起来。</p>
<p>选项为 THREE.MultiplyOperation（默认值），THREE.MixOperation， THREE.AddOperation。如果选择多个，则使用.reflectivity 在两种颜色之间进行混合。</p>
<p>.displacementMap : Texture<br>位移贴图会影响网格顶点的位置，与仅影响材质的光照和阴影的其他贴图不同，移位的顶点可以投射阴影，阻挡其他对象， 以及充当真实的几何体。位移纹理是指：网格的所有顶点被映射为图像中每个像素的值（白色是最高的），并且被重定位。</p>
<p>.displacementScale : Float<br>位移贴图对网格的影响程度（黑色是无位移，白色是最大位移）。如果没有设置位移贴图，则不会应用此值。默认值为 1。</p>
<p>.displacementBias : Float<br>位移贴图在网格顶点上的偏移量。如果没有设置位移贴图，则不会应用此值。默认值为 0。</p>
<p>.emissive : Color<br>材质的放射（光）颜色，基本上是不受其他光照影响的固有颜色。默认为黑色。</p>
<p>.emissiveMap : Texture<br>设置放射（发光）贴图。默认值为 null。放射贴图颜色由放射颜色和强度所调节。 如果你有一个放射贴图，请务必将放射颜色设置为黑色以外的其他颜色。</p>
<p>.emissiveIntensity : Float<br>放射光强度。调节发光颜色。默认为 1。</p>
<p>.envMap : Texture<br>环境贴图。默认值为 null。</p>
<p>.flatShading : Boolean<br>定义材质是否使用平面着色进行渲染。默认值为 false。</p>
<p>.fog : Boolean<br>材质是否受雾影响。默认为 true。</p>
<p>.lightMap : Texture<br>光照贴图。默认值为 null。lightMap 需要第二组 UV。</p>
<p>.lightMapIntensity : Float<br>烘焙光的强度。默认值为 1。</p>
<p>.map : Texture<br>颜色贴图。可以选择包括一个 alpha 通道，通常与.transparent 或.alphaTest。默认为 null。 纹理贴图颜色由漫反射颜色.color 调节。</p>
<p>.normalMap : Texture<br>用于创建法线贴图的纹理。RGB 值会影响每个像素片段的曲面法线，并更改颜色照亮的方式。法线贴图不会改变曲面的实际形状，只会改变光照。 In case the material has a normal map authored using the left handed convention, the y component of normalScale should be negated to compensate for the different handedness.</p>
<p>.normalMapType : Integer<br>法线贴图的类型。</p>
<p>选项为 THREE.TangentSpaceNormalMap（默认）和 THREE.ObjectSpaceNormalMap。</p>
<p>.normalScale : Vector2<br>法线贴图对材质的影响程度。典型范围是 0-1。默认值是 Vector2 设置为（1,1）。</p>
<p>.reflectivity : Float<br>环境贴图对表面的影响程度; 见.combine。默认值为 1，有效范围介于 0（无反射）和 1（完全反射）之间。</p>
<p>.refractionRatio : Float<br>空气的折射率（IOR）（约为 1）除以材质的折射率。它与环境映射模式 THREE.CubeRefractionMapping 和 THREE.EquirectangularRefractionMapping 一起使用。 The index of refraction (IOR) of air (approximately 1) divided by the index of refraction of the material. It is used with environment mapping mode THREE.CubeRefractionMapping. 折射率不应超过 1。默认值为 0.98。</p>
<p>.shininess : Float<br>.specular 高亮的程度，越高的值越闪亮。默认值为 30。</p>
<p>.specular : Color<br>材质的高光颜色。默认值为 0x111111（深灰色）的颜色 Color。</p>
<p>这定义了材质的光泽度和光泽的颜色。</p>
<p>.specularMap : Texture<br>镜面反射贴图值会影响镜面高光以及环境贴图对表面的影响程度。默认值为 null。</p>
<p>.wireframe : Boolean<br>将几何体渲染为线框。默认值为 false（即渲染为平面多边形）。</p>
<p>.wireframeLinecap : String<br>定义线两端的外观。可选值为 ‘butt’，’round’ 和 ‘square’。默认为’round’。</p>
<p>该属性对应 2D Canvas lineJoin 属性， 并且会被 WebGL 渲染器忽略。</p>
<p>.wireframeLinejoin : String<br>定义线连接节点的样式。可选值为 ‘round’, ‘bevel’ 和 ‘miter’。默认值为 ‘round’。</p>
<p>该属性对应 2D Canvas lineJoin 属性， 并且会被 WebGL 渲染器忽略。</p>
<p>.wireframeLinewidth : Float<br>控制线框宽度。默认值为 1。</p>
<p>由于 OpenGL Core Profile 与 大多数平台上 WebGL 渲染器的限制，无论如何设置该值，线宽始终为 1。</p>
<h4 id="标准网格材质-MeshStandardMaterial"><a href="#标准网格材质-MeshStandardMaterial" class="headerlink" title="标准网格材质(MeshStandardMaterial)"></a>标准网格材质(MeshStandardMaterial)</h4><p>一种基于物理的标准材质，使用 Metallic-Roughness 工作流程。</p>
<p>该材质提供了比 MeshLambertMaterial 或 MeshPhongMaterial 更精确和逼真的结果，代价是计算成本更高</p>
<h5 id="构造器-20"><a href="#构造器-20" class="headerlink" title="构造器"></a>构造器</h5><p><code>MeshStandardMaterial( parameters : Object )</code></p>
<p>parameters - (可选)用于定义材质外观的对象，具有一个或多个属性。 材质的任何属性都可以从此处传入(包括从 Material 继承的任何属性)。</p>
<p>属性 color 例外，其可以作为十六进制字符串传递，默认情况下为 0xffffff（白色），内部调用 Color.set(color)。</p>
<h5 id="属性-方法-16"><a href="#属性-方法-16" class="headerlink" title="属性|方法"></a>属性|方法</h5><blockquote>
<p>共有方法请参见其基类 Material。<br>共有属性请参见其基类 Material。</p>
</blockquote>
<p>.alphaMap : Texture<br>alpha 贴图是一张灰度纹理，用于控制整个表面的不透明度。（黑色：完全透明；白色：完全不透明）。 默认值为 null。</p>
<p>仅使用纹理的颜色，忽略 alpha 通道（如果存在）。 对于 RGB 和 RGBA 纹理，WebGL 渲染器在采样此纹理时将使用绿色通道， 因为在 DXT 压缩和未压缩 RGB 565 格式中为绿色提供了额外的精度。 Luminance-only 以及 luminance/alpha 纹理也仍然有效。</p>
<p>.aoMap : Texture<br>该纹理的红色通道用作环境遮挡贴图。默认值为 null。aoMap 需要第二组 UV。</p>
<p>.aoMapIntensity : Float<br>环境遮挡效果的强度。默认值为 1。零是不遮挡效果。</p>
<p>.bumpMap : Texture<br>用于创建凹凸贴图的纹理。黑色和白色值映射到与光照相关的感知深度。凹凸实际上不会影响对象的几何形状，只影响光照。如果定义了法线贴图，则将忽略该贴图。</p>
<p>.bumpScale : Float<br>凹凸贴图会对材质产生多大影响。典型范围是 0-1。默认值为 1。</p>
<p>.color : Color<br>材质的颜色(Color)，默认值为白色 (0xffffff)。</p>
<p>.defines : Object<br>如下形式的对象:<code>&#123; &#39;STANDARD&#39;: &#39;&#39; &#125;</code>;WebGLRenderer 使用它来选择 shaders。</p>
<p>.displacementMap : Texture<br>位移贴图会影响网格顶点的位置，与仅影响材质的光照和阴影的其他贴图不同，移位的顶点可以投射阴影，阻挡其他对象， 以及充当真实的几何体。位移纹理是指：网格的所有顶点被映射为图像中每个像素的值（白色是最高的），并且被重定位。</p>
<p>.displacementScale : Float<br>位移贴图对网格的影响程度（黑色是无位移，白色是最大位移）。如果没有设置位移贴图，则不会应用此值。默认值为 1。</p>
<p>.displacementBias : Float<br>位移贴图在网格顶点上的偏移量。如果没有设置位移贴图，则不会应用此值。默认值为 0。</p>
<p>.emissive : Color<br>材质的放射（光）颜色，基本上是不受其他光照影响的固有颜色。默认为黑色。</p>
<p>.emissiveMap : Texture<br>设置放射（发光）贴图。默认值为 null。放射贴图颜色由放射颜色和强度所调节。 如果你有一个放射贴图，请务必将放射颜色设置为黑色以外的其他颜色。</p>
<p>.emissiveIntensity : Float<br>放射光强度。调节发光颜色。默认为 1。</p>
<p>.envMap : Texture<br>环境贴图，为了能够保证物理渲染准确，您应该添加由 PMREMGenerator 预处理过的环境贴图，默认为 null。</p>
<p>.envMapIntensity : Float<br>通过乘以环境贴图的颜色来缩放环境贴图的效果。</p>
<p>.flatShading : Boolean<br>定义材质是否使用平面着色进行渲染。默认值为 false。</p>
<p>.fog : Boolean<br>材质是否受雾影响。默认为 true。</p>
<p>.isMeshStandardMaterial : Boolean<br>检查当前对象是否为标准网格材质的标记。</p>
<p>.lightMap : Texture<br>光照贴图。默认值为 null。lightMap 需要第二组 UV。</p>
<p>.lightMapIntensity : Float<br>烘焙光的强度。默认值为 1。</p>
<p>.map : Texture<br>颜色贴图。可以选择包括一个 alpha 通道，通常与.transparent 或.alphaTest。默认为 null。 纹理贴图颜色由漫反射颜色.color 调节。</p>
<p>.metalness : Float<br>材质与金属的相似度。非金属材质，如木材或石材，使用 0.0，金属使用 1.0，通常没有中间值。 默认值为 0.0。0.0 到 1.0 之间的值可用于生锈金属的外观。如果还提供了 metalnessMap，则两个值相乘。</p>
<p>.metalnessMap : Texture<br>该纹理的蓝色通道用于改变材质的金属度。</p>
<p>.normalMap : Texture<br>用于创建法线贴图的纹理。RGB 值会影响每个像素片段的曲面法线，并更改颜色照亮的方式。法线贴图不会改变曲面的实际形状，只会改变光照。 In case the material has a normal map authored using the left handed convention, the y component of normalScale should be negated to compensate for the different handedness.</p>
<p>.normalMapType : Integer<br>法线贴图的类型。</p>
<p>选项为 THREE.TangentSpaceNormalMap（默认）和 THREE.ObjectSpaceNormalMap。</p>
<p>.normalScale : Vector2<br>法线贴图对材质的影响程度。典型范围是 0-1。默认值是 Vector2 设置为（1,1）。</p>
<p>.refractionRatio : Float<br>空气的折射率（IOR）（约为 1）除以材质的折射率。它与环境映射模式 THREE.CubeRefractionMapping 和 THREE.EquirectangularRefractionMapping 一起使用。 The index of refraction (IOR) of air (approximately 1) divided by the index of refraction of the material. It is used with environment mapping mode THREE.CubeRefractionMapping. 折射率不应超过 1。默认值为 0.98。</p>
<p>.roughness : Float<br>材质的粗糙程度。0.0 表示平滑的镜面反射，1.0 表示完全漫反射。默认值为 1.0。如果还提供 roughnessMap，则两个值相乘。</p>
<p>.roughnessMap : Texture<br>该纹理的绿色通道用于改变材质的粗糙度。</p>
<p>.wireframe : Boolean<br>将几何体渲染为线框。默认值为 false（即渲染为平面多边形）。</p>
<p>.wireframeLinecap : String<br>定义线两端的外观。可选值为 ‘butt’，’round’ 和 ‘square’。默认为’round’。</p>
<p>该属性对应 2D Canvas lineJoin 属性， 并且会被 WebGL 渲染器忽略。</p>
<p>.wireframeLinejoin : String<br>定义线连接节点的样式。可选值为 ‘round’, ‘bevel’ 和 ‘miter’。默认值为 ‘round’。</p>
<p>该属性对应 2D Canvas lineJoin 属性， 并且会被 WebGL 渲染器忽略。</p>
<p>.wireframeLinewidth : Float<br>控制线框宽度。默认值为 1。<br>由于 OpenGL Core Profile 与 大多数平台上 WebGL 渲染器的限制，无论如何设置该值，线宽始终为 1。</p>
<h4 id="物理网格材质-MeshPhysicalMaterial"><a href="#物理网格材质-MeshPhysicalMaterial" class="headerlink" title="物理网格材质(MeshPhysicalMaterial)"></a>物理网格材质(MeshPhysicalMaterial)</h4><p>提供了更高级的基于物理的渲染属性<br>物理网格材质使用了更复杂的着色器功能，所以在每个像素的渲染都要比 three.js 中的其他材质更费性能，大部分的特性是默认关闭的，需要手动开启，每开启一项功能在开启的时候才会更耗性能。请注意，为获得最佳效果，您在使用此材质时应始终指定 environment map。</p>
<h5 id="构造器-21"><a href="#构造器-21" class="headerlink" title="构造器"></a>构造器</h5><p><code>MeshPhysicalMaterial( parameters : Object )</code><br>parameters - (可选)用于定义材质外观的对象，具有一个或多个属性。 材质的任何属性都可以从此处传入(包括从 Material 和 MeshStandardMaterial 继承的任何属性)</p>
<p>属性 color 例外，其可以作为十六进制字符串传递，默认情况下为 0xffffff（白色），内部调用 Color.set(color)。</p>
<h4 id="基础线条材质（LineBasicMaterial）"><a href="#基础线条材质（LineBasicMaterial）" class="headerlink" title="基础线条材质（LineBasicMaterial）"></a>基础线条材质（LineBasicMaterial）</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> material = <span class="keyword">new</span> THREE.LineBasicMaterial(&#123;</span><br><span class="line">  <span class="attr">color</span>: <span class="number">0xffffff</span>,</span><br><span class="line">  <span class="attr">linewidth</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">linecap</span>: <span class="string">&quot;round&quot;</span>, <span class="comment">//ignored by WebGLRenderer</span></span><br><span class="line">  <span class="attr">linejoin</span>: <span class="string">&quot;round&quot;</span>, <span class="comment">//ignored by WebGLRenderer</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h5 id="构造器-22"><a href="#构造器-22" class="headerlink" title="构造器"></a>构造器</h5><p><code>LineBasicMaterial( parameters : Object )</code><br>parameters - (可选)用于定义材质外观的对象，具有一个或多个属性。材质的任何属性都可以从此处传入(包括从 Material 继承的任何属性)。</p>
<p>属性 color 例外，其可以作为十六进制字符串传递，默认情况下为 0xffffff（白色），内部调用 Color.set(color)。</p>
<h5 id="属性-方法-17"><a href="#属性-方法-17" class="headerlink" title="属性|方法"></a>属性|方法</h5><blockquote>
<p>共有方法请参见其基类 Material。<br>共有属性请参见其基类 Material。</p>
</blockquote>
<ul>
<li><p><code>.color : Color</code><br>材质的颜色(Color)，默认值为白色 (0xffffff)。</p>
</li>
<li><p><code>.fog : Boolean</code><br>材质是否受雾影响。默认为 true。</p>
</li>
<li><p><code>.linewidth : Float</code><br>控制线宽。默认值为 1。</p>
</li>
</ul>
<p>由于 OpenGL Core Profile 与 大多数平台上 WebGL 渲染器的限制，无论如何设置该值，线宽始终为 1。</p>
<ul>
<li><code>.linecap : String</code><br>定义线两端的样式。可选值为 ‘butt’, ‘round’ 和 ‘square’。默认值为 ‘round’。</li>
</ul>
<p>该属性对应 2D Canvas lineCap 属性， 并且会被 WebGL 渲染器忽略。</p>
<ul>
<li><code>.linejoin : String</code><br>定义线连接节点的样式。可选值为 ‘round’, ‘bevel’ 和 ‘miter’。默认值为 ‘round’。</li>
</ul>
<p>该属性对应 2D Canvas lineJoin 属性， 并且会被 WebGL 渲染器忽略。</p>
<ul>
<li><code>.map : Texture</code><br>Sets the color of the lines using data from a Texture.</li>
</ul>
<h4 id="虚线材质-LineDashedMaterial"><a href="#虚线材质-LineDashedMaterial" class="headerlink" title="虚线材质(LineDashedMaterial)"></a>虚线材质(LineDashedMaterial)</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> material = <span class="keyword">new</span> THREE.LineDashedMaterial(&#123;</span><br><span class="line">  <span class="attr">color</span>: <span class="number">0xffffff</span>,</span><br><span class="line">  <span class="attr">linewidth</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">scale</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">dashSize</span>: <span class="number">3</span>,</span><br><span class="line">  <span class="attr">gapSize</span>: <span class="number">1</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h5 id="构造器-23"><a href="#构造器-23" class="headerlink" title="构造器"></a>构造器</h5><p><code>LineDashedMaterial( parameters : Object )</code><br>parameters - (可选)用于定义材质外观的对象，具有一个或多个属性。材质的任何属性都可以从此处传入(包括从 LineBasicMaterial 继承的任何属性)。</p>
<h5 id="属性-方法-18"><a href="#属性-方法-18" class="headerlink" title="属性|方法"></a>属性|方法</h5><blockquote>
<p>共有方法请参见其基类 Material。<br>共有属性请参见其基类 Material。</p>
</blockquote>
<ul>
<li><p><code>.dashSize</code> : number<br>虚线的大小，是指破折号和间隙之和。默认值为 3。</p>
</li>
<li><p><code>.gapSize</code> : number<br>间隙的大小，默认值为 1。</p>
</li>
<li><p><code>.isLineDashedMaterial</code> : Boolean<br>Read-only flag to check if a given object is of type LineDashedMaterial.</p>
</li>
<li><p><code>.scale</code> : number<br>线条中虚线部分的占比。默认值为 1。</p>
</li>
</ul>
<h4 id="卡通着色的材质（MeshToonMaterial）"><a href="#卡通着色的材质（MeshToonMaterial）" class="headerlink" title="卡通着色的材质（MeshToonMaterial）"></a>卡通着色的材质（MeshToonMaterial）</h4><h5 id="构造器-24"><a href="#构造器-24" class="headerlink" title="构造器"></a>构造器</h5><p><code>MeshToonMaterial( parameters : Object )</code><br>parameters - (可选)用于定义材质外观的对象，具有一个或多个属性。材质的任何属性都可以从此处传入(包括从 LineBasicMaterial 继承的任何属性)。</p>
<h4 id="阴影材质-ShadowMaterial"><a href="#阴影材质-ShadowMaterial" class="headerlink" title="阴影材质(ShadowMaterial)"></a>阴影材质(ShadowMaterial)</h4><p>此材质可以接收阴影，但在其他方面完全透明。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> geometry = <span class="keyword">new</span> THREE.PlaneGeometry(<span class="number">2000</span>, <span class="number">2000</span>);</span><br><span class="line">geometry.rotateX(-<span class="built_in">Math</span>.PI / <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> material = <span class="keyword">new</span> THREE.ShadowMaterial();</span><br><span class="line">material.opacity = <span class="number">0.2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> plane = <span class="keyword">new</span> THREE.Mesh(geometry, material);</span><br><span class="line">plane.position.y = -<span class="number">200</span>;</span><br><span class="line">plane.receiveShadow = <span class="literal">true</span>;</span><br><span class="line">scene.add(plane);</span><br></pre></td></tr></table></figure>

<h5 id="构造器-25"><a href="#构造器-25" class="headerlink" title="构造器"></a>构造器</h5><p><code>ShadowMaterial( parameters : Object )</code><br>parameters - (可选)用于定义材质外观的对象，具有一个或多个属性。材质的任何属性都可以从此处传入(包括从 LineBasicMaterial 继承的任何属性)。</p>
<h5 id="属性-方法-19"><a href="#属性-方法-19" class="headerlink" title="属性|方法"></a>属性|方法</h5><blockquote>
<p>共有方法请参见其基类 Material。<br>共有属性请参见其基类 Material。<br>.color : Color<br>Color of the material, by default set to black (0x000000).</p>
</blockquote>
<p>.fog : Boolean<br>材质是否受雾影响。默认为 true。</p>
<p>.transparent : Boolean<br>定义此材质是否透明。默认值为 true。</p>
<h4 id="点材质-PointsMaterial"><a href="#点材质-PointsMaterial" class="headerlink" title="点材质(PointsMaterial)"></a>点材质(PointsMaterial)</h4><h5 id="构造器-26"><a href="#构造器-26" class="headerlink" title="构造器"></a>构造器</h5><p><code>PointsMaterial( parameters : Object )</code><br>parameters - (可选)用于定义材质外观的对象，具有一个或多个属性。材质的任何属性都可以从此处传入(包括从 LineBasicMaterial 继承的任何属性)。<br>属性 color 例外，其可以作为十六进制字符串传递，默认情况下为 0xffffff（白色），内部调用 Color.set(color)。</p>
<h4 id="点精灵材质-SpriteMaterial"><a href="#点精灵材质-SpriteMaterial" class="headerlink" title="点精灵材质(SpriteMaterial)"></a>点精灵材质(SpriteMaterial)</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> THREE.TextureLoader().load(<span class="string">&quot;textures/sprite.png&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> material = <span class="keyword">new</span> THREE.SpriteMaterial(&#123; <span class="attr">map</span>: map, <span class="attr">color</span>: <span class="number">0xffffff</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sprite = <span class="keyword">new</span> THREE.Sprite(material);</span><br><span class="line">sprite.scale.set(<span class="number">200</span>, <span class="number">200</span>, <span class="number">1</span>);</span><br><span class="line">scene.add(sprite);</span><br></pre></td></tr></table></figure>

<h5 id="构造器-27"><a href="#构造器-27" class="headerlink" title="构造器"></a>构造器</h5><p><code>SpriteMaterial( parameters : Object )</code><br>parameters - (可选)用于定义材质外观的对象，具有一个或多个属性。 材质的任何属性都可以从此处传入(包括从 Material 和 ShaderMaterial 继承的任何属性)。</p>
<p>属性 color 例外，其可以作为十六进制字符串传递，默认情况下为 0xffffff（白色）， 内部调用 Color.set(color)。 SpriteMaterials 不会被 Material.clippingPlanes 裁剪。</p>
<h5 id="属性-方法-20"><a href="#属性-方法-20" class="headerlink" title="属性|方法"></a>属性|方法</h5><p>.alphaMap : Texture<br>alpha 贴图是一张灰度纹理，用于控制整个表面的不透明度。（黑色：完全透明；白色：完全不透明）。 默认值为 null。</p>
<p>仅使用纹理的颜色，忽略 alpha 通道（如果存在）。 对于 RGB 和 RGBA 纹理，WebGL 渲染器在采样此纹理时将使用绿色通道， 因为在 DXT 压缩和未压缩 RGB 565 格式中为绿色提供了额外的精度。 Luminance-only 以及 luminance/alpha 纹理也仍然有效。</p>
<p>.color : Color<br>材质的颜色(Color)，默认值为白色 (0xffffff)。 .map 会和 color 相乘。</p>
<p>.fog : Boolean<br>材质是否受雾影响。默认为 true。</p>
<p>.isSpriteMaterial : Boolean<br>Read-only flag to check if a given object is of type SpriteMaterial.</p>
<p>.map : Texture<br>颜色贴图。可以选择包括一个 alpha 通道，通常与.transparent 或.alphaTest。默认为 null。</p>
<p>.rotation : Radians<br>sprite 的转动，以弧度为单位。默认值为 0。</p>
<p>.sizeAttenuation : Boolean<br>精灵的大小是否会被相机深度衰减。（仅限透视摄像头。）默认为 true。</p>
<p>.transparent : Boolean<br>定义此材质是否透明。默认值为 true。</p>
<h3 id="物体"><a href="#物体" class="headerlink" title="物体"></a>物体</h3><h4 id="三维物体（Object3D）"><a href="#三维物体（Object3D）" class="headerlink" title="三维物体（Object3D）"></a>三维物体（Object3D）</h4><p>这是 Three.js 中大部分对象的基类，提供了一系列的属性和方法来对三维空间中的物体进行操纵。</p>
<p>请注意，可以通过.add( object )方法来将对象进行组合，该方法将对象添加为子对象，但为此最好使用 Group（来作为父对象）</p>
<h5 id="构造器-28"><a href="#构造器-28" class="headerlink" title="构造器"></a>构造器</h5><p><code>Object3D()</code><br>构造器中不带有参数。</p>
<h5 id="属性-6"><a href="#属性-6" class="headerlink" title="属性"></a>属性</h5><ul>
<li><p><code>.animations</code> : AnimationClip<br>三维物体所属的动画剪辑数组.</p>
</li>
<li><p><code>.castShadow</code> : Boolean<br>对象是否被渲染到阴影贴图中。默认值为 false。</p>
</li>
<li><p><code>.children</code> : Array<br>含有对象的子级的数组。请参阅 Group 来了解将手动对象进行分组的相关信息。</p>
</li>
<li><p><code>.customDepthMaterial</code> : Material<br>在渲染到深度图的时候所用的自定义深度材质。 只能在网格中使用。 当使用 DirectionalLight（平行光）或者 SpotLight（聚光灯光）生成影子的时候, 如果你调整过顶点着色器中的顶点位置，就需要定义一个自定义深度材质来生成正确的影子。默认为 undefined.</p>
</li>
<li><p><code>.customDistanceMaterial</code> : Material<br>与 customDepthMaterial 相同，但与 PointLight(点光源）一起使用。默认值为 undefined。</p>
</li>
<li><p><code>.frustumCulled</code> : Boolean<br>当这个设置了的时候，每一帧渲染前都会检测这个物体是不是在相机的视椎体范围内。 如果设置为 false 物体不管是不是在相机的视椎体范围内都会渲染。默认为 true。</p>
</li>
<li><p><code>.id</code> : Integer<br>只读 —— 表示该对象实例 ID 的唯一数字。</p>
</li>
<li><p><code>.isObject3D</code> : Boolean<br>查看所给对象是不是 Object3D 类型的只读标记.</p>
</li>
<li><p><code>.layers</code> : Layers<br>物体的层级关系。 物体只有和一个正在使用的 Camera 至少在同一个层时才可见。当使用 Raycaster 进行射线检测的时候此项属性可以用于过滤不参与检测的物体.</p>
</li>
<li><p><code>.matrix</code> : Matrix4<br>局部变换矩阵。</p>
</li>
<li><p><code>.matrixAutoUpdate</code> : Boolean<br>当这个属性设置了之后，它将计算每一帧的位移、旋转（四元变换）和缩放矩阵，并重新计算 matrixWorld 属性。默认值是 Object3D.DEFAULT_MATRIX_AUTO_UPDATE (true)。</p>
</li>
<li><p><code>.matrixWorld</code> : Matrix4<br>物体的世界变换。若这个 Object3D 没有父级，则它将和 local transform .matrix（局部变换矩阵）相同。</p>
</li>
<li><p><code>.matrixWorldAutoUpdate</code> : Boolean<br>默认为 true. 当设置的时候，渲染器在每一帧都会检查物体自身以及它的自带是否需要更新世界变换矩阵。 如果不需要的话它自身以及它的子代的所有世界变换矩阵都需要你来维护。</p>
</li>
<li><p><code>.matrixWorldNeedsUpdate</code> : Boolean<br>当这个属性设置了之后，它将计算在那一帧中的 matrixWorld，并将这个值重置为 false。默认值为 false。</p>
</li>
<li><p><code>.modelViewMatrix</code> : Matrix4<br>这个值传递给着色器，用于计算物体的位置。</p>
</li>
<li><p><code>.name</code> : String<br>对象的名称，可选、不必唯一。默认值是一个空字符串。</p>
</li>
<li><p><code>.normalMatrix</code> : Matrix3<br>这个值传递给着色器，用于计算物体的光照。 它是物体的 modelViewMatrix 矩阵中，左上角 3x3 子矩阵的逆的转置矩阵。</p>
</li>
</ul>
<p>使用这个特殊矩阵的原因，是只需使用 modelViewMatrix 就可以得出一个法线（缩放时）的非单位长度或者非垂直的方向（不规则缩放时）。</p>
<p>另一方面，modelViewMatrix 矩阵中的位移部分和法线的计算无关，因此 Matrix3 就已经足够了。</p>
<ul>
<li><code>.onAfterRender</code> : Function<br>一个可选的回调函数，在 Object3D 渲染之后直接执行。 使用以下参数来调用此函数：renderer，scene，camera，geometry，material，group。</li>
</ul>
<p>注意此回调函数只会在<em>可渲染</em>的 3D 物体上执行。可渲染的 3D 物体指的是那种拥有视觉表现的、定义了几何体与材质的物体，例如像是 Mesh、Line、Points 或者 Sprite。 Object3D、 Group 或者 Bone 这些是不可渲染的物体，因此此回调函数不会在这样的物体上执行。</p>
<ul>
<li><code>.onBeforeRender</code> : Function<br>一个可选的回调函数，在 Object3D 渲染之前直接执行。 使用以下参数来调用此函数：renderer，scene，camera，geometry，material，group。</li>
</ul>
<p>注意此回调函数只会在<em>可渲染</em>的 3D 物体上执行。可渲染的 3D 物体指的是那种拥有视觉表现的、定义了几何体与材质的物体，例如像是 Mesh、Line、Points 或者 Sprite。 Object3D、 Group 或者 Bone 这些是不可渲染的物体，因此此回调函数不会在这样的物体上执行。</p>
<ul>
<li><p><code>.parent</code> : Object3D<br>在 scene graph（场景图）中，一个对象的父级对象。 一个对象最多仅能有一个父级对象。</p>
</li>
<li><p><code>.position</code> : Vector3<br>表示对象局部位置的 Vector3。默认值为(0, 0, 0)。</p>
</li>
<li><p><code>.quaternion</code> : Quaternion<br>表示对象局部旋转的 Quaternion（四元数）。</p>
</li>
<li><p><code>.receiveShadow</code> : Boolean<br>材质是否接收阴影。默认值为 false。</p>
</li>
<li><p><code>.renderOrder</code> : Number<br>这个值将使得 scene graph（场景图）中默认的的渲染顺序被覆盖， 即使不透明对象和透明对象保持独立顺序。 渲染顺序是由低到高来排序的，默认值为 0。</p>
</li>
<li><p><code>.rotation</code> : Euler<br>物体的局部旋转，以弧度来表示。（请参阅 Euler angles-欧拉角）</p>
</li>
<li><p><code>.scale</code> : Vector3<br>物体的局部缩放。默认值是 Vector3( 1, 1, 1 )。</p>
</li>
<li><p><code>.up</code> : Vector3<br>这个属性由 lookAt 方法所使用，例如，来决定结果的朝向。 默认值是 Object3D.DEFAULT_UP，即( 0, 1, 0 )。</p>
</li>
<li><p><code>.userData</code> : Object<br>一个用于存储 Object3D 自定义数据的对象。 它不应当包含对函数的引用，因为这些函数将不会被克隆。</p>
</li>
<li><p><code>.uuid</code> : String<br>该对象实例的 UUID。 这是一个自动生成的值，不应当对其进行修改。</p>
</li>
<li><p><code>.visible</code> : Boolean<br>可见性。这个值为 true 时，物体将被渲染。默认值为 true。</p>
</li>
</ul>
<p>静态属性<br>静态属性和方法由每个类所定义，并非由每个类的实例所定义。 也就是说，改变 Object3D.DEFAULT_UP 或 Object3D.DEFAULT_MATRIX_AUTO_UPDATE 的值， 将改变每个在此之后由 Object3D 类（或派生类）创建的实例中的 up 和 matrixAutoUpdate 的值。（已经创建好的 Object3D 不会受到影响）。</p>
<ul>
<li><p><code>.DEFAULT_UP</code> : Vector3<br>默认的物体的 up 方向，同时也作为 DirectionalLight、HemisphereLight 和 Spotlight（自顶向下创建的灯光）的默认方向。 默认设为( 0, 1, 0 )。</p>
</li>
<li><p><code>.DEFAULT_MATRIX_AUTO_UPDATE</code> : Boolean<br>matrixAutoUpdate 的默认设置，用于新创建的 Object3D。<br>.DEFAULT_MATRIX_WORLD_AUTO_UPDATE : Boolean<br>matrixWorldAutoUpdate 的默认设置，用于新创建的 Object3D。</p>
</li>
</ul>
<h5 id="方法-6"><a href="#方法-6" class="headerlink" title="方法"></a>方法</h5><p>EventDispatcher 在该类上可用的所有方法。</p>
<ul>
<li><code>.add ( object : Object3D, ... ) : this</code><br>添加对象到这个对象的子级，可以添加任意数量的对象。 当前传入的对象中的父级将在这里被移除，因为一个对象仅能有一个父级。</li>
</ul>
<p>请参阅 Group 来查看手动编组对象的相关信息。</p>
<ul>
<li><p><code>.applyMatrix4 ( matrix : Matrix4 ) : undefined</code><br>对当前物体应用这个变换矩阵，并更新物体的位置、旋转和缩放。</p>
</li>
<li><p><code>.applyQuaternion ( quaternion : Quaternion ) : this</code><br>对当前物体应用由四元数所表示的变换。</p>
</li>
<li><p><code>.attach ( object : Object3D ) : this</code><br>将 object 作为子级来添加到该对象中，同时保持该 object 的世界变换。</p>
</li>
<li><p><code>.clone ( recursive : Boolean ) : Object3D</code><br>recursive —— 如果值为 true，则该物体的后代也会被克隆。默认值为 true。</p>
</li>
</ul>
<p>返回对象前物体的克隆（以及可选的所有后代）。</p>
<ul>
<li><code>.copy ( object : Object3D, recursive : Boolean ) : this</code><br>recursive —— 如果值为 true，则该物体的后代也会被复制。默认值为 true。</li>
</ul>
<p>复制给定的对象到这个对象中。 请注意，事件监听器和用户定义的回调函数（.onAfterRender 和 .onBeforeRender）不会被复制。</p>
<ul>
<li><code>.getObjectById ( id : Integer ) : Object3D</code><br>id —— 标识该对象实例的唯一数字。</li>
</ul>
<p>从该对象开始，搜索一个对象及其子级，返回第一个带有匹配 id 的子对象。<br>请注意，id 是按照时间顺序来分配的：1、2、3、……，每增加一个新的对象就自增 1。</p>
<ul>
<li><code>.getObjectByName ( name : String ) : Object3D</code><br>name —— 用于来匹配子物体中 Object3D.name 属性的字符串。</li>
</ul>
<p>从该对象开始，搜索一个对象及其子级，返回第一个带有匹配 name 的子对象。<br>请注意，大多数的对象中 name 默认是一个空字符串，要使用这个方法，你将需要手动地设置 name 属性。</p>
<ul>
<li><code>.getObjectByProperty ( name : String, value : Any ) : Object3D</code><br>name —— 将要用于查找的属性的名称。<br>value —— 给定的属性的值。</li>
</ul>
<p>从该对象开始，搜索一个对象及其子级，返回第一个给定的属性中包含有匹配的值的子对象。</p>
<ul>
<li><code>.getObjectsByProperty ( name : String, value : Any ) : Object3D</code><br>name —— 将要用于查找的属性的名称。<br>value —— 给定的属性的值。</li>
</ul>
<p>从此对象开始，搜索一个对象及其子对象，返回包含给定属性的匹配值的所有子对象。</p>
<ul>
<li><code>.getWorldPosition ( target : Vector3 ) : Vector3</code><br>target — 结果将被复制到这个 Vector3 中。</li>
</ul>
<p>返回一个表示该物体在世界空间中位置的矢量。</p>
<ul>
<li><code>.getWorldQuaternion ( target : Quaternion ) : Quaternion</code><br>target — 结果将被复制到这个 Quaternion 中。</li>
</ul>
<p>返回一个表示该物体在世界空间中旋转的四元数。</p>
<ul>
<li><code>.getWorldScale ( target : Vector3 ) : Vector3</code><br>target — 结果将被复制到这个 Vector3 中。</li>
</ul>
<p>返回一个包含着该物体在世界空间中各个轴向上所应用的缩放因数的矢量。</p>
<ul>
<li><code>.getWorldDirection ( target : Vector3 ) : Vector3</code><br>target — 结果将被复制到这个 Vector3 中。</li>
</ul>
<p>返回一个表示该物体在世界空间中 Z 轴正方向的矢量。</p>
<ul>
<li><code>.localToWorld ( vector : Vector3 ) : Vector3</code><br>vector - 一个表示在该物体局部空间中位置的向量。</li>
</ul>
<p>将该向量从物体的局部空间转换到世界空间。</p>
<ul>
<li><code>.lookAt ( vector : Vector3 ) : undefined</code><br>.lookAt ( x : Float, y : Float, z : Float ) : undefined<br>vector - 一个表示世界空间中位置的向量。</li>
</ul>
<p>也可以使用世界空间中 x、y 和 z 的位置分量。</p>
<p>旋转物体使其在世界空间中面朝一个点。</p>
<p>这一方法不支持其父级被旋转过或者被位移过的物体。</p>
<ul>
<li><p><code>.raycast ( raycaster : Raycaster, intersects : Array ) : undefined</code><br>抽象（空方法），在一条被投射出的射线与这个物体之间获得交点。 在一些子类，例如 Mesh, Line, and Points 实现了这个方法，以用于光线投射。</p>
</li>
<li><p><code>.remove ( object : Object3D, ... ) : this</code><br>从当前对象的子级中移除对象。可以移除任意数量的对象。</p>
</li>
<li><p><code>.removeFromParent () : this</code><br>Removes this object from its current parent.</p>
</li>
<li><p><code>.rotateOnAxis ( axis : Vector3, angle : Float ) : this</code><br>axis —— 一个在局部空间中的标准化向量。<br>angle —— 角度，以弧度来表示。</p>
</li>
</ul>
<p>在局部空间中绕着该物体的轴来旋转一个物体，假设这个轴已被标准化。</p>
<ul>
<li><code>.rotateOnWorldAxis ( axis : Vector3, angle : Float ) : this</code><br>axis – 一个在世界空间中的标准化向量。<br>angle – 角度，以弧度来表示。</li>
</ul>
<p>在世界空间中绕着该物体的轴来旋转一个物体，假设这个轴已被标准化。 方法假设该物体没有旋转过的父级。</p>
<ul>
<li><code>.rotateX ( rad : Float ) : this</code><br>rad - 将要旋转的角度（以弧度来表示）。</li>
</ul>
<p>绕局部空间的 X 轴旋转这个物体。</p>
<ul>
<li><code>.rotateY ( rad : Float ) : this</code><br>rad - 将要旋转的角度（以弧度来表示）。</li>
</ul>
<p>绕局部空间的 Y 轴旋转这个物体。</p>
<ul>
<li><code>.rotateZ ( rad : Float ) : this</code><br>rad - 将要旋转的角度（以弧度来表示）。</li>
</ul>
<p>绕局部空间的 Z 轴旋转这个物体。</p>
<ul>
<li><code>.setRotationFromAxisAngle ( axis : Vector3, angle : Float ) : undefined</code><br>axis – 一个在局部空间中的标准化向量。<br>angle – 角度（以弧度来表示）。</li>
</ul>
<p>调用.quaternion 中的 setFromAxisAngle( axis, angle )。</p>
<ul>
<li><p><code>.setRotationFromEuler ( euler : Euler ) : undefined</code><br>euler – 指定了旋转量的欧拉角。<br>调用.quaternion 中的 setRotationFromEuler( euler)。</p>
</li>
<li><p><code>.setRotationFromMatrix ( m : Matrix4 ) : undefined</code><br>m – 通过该矩阵中的旋转分量来旋转四元数。<br>调用.quaternion 中的 setFromRotationMatrix( m)。</p>
</li>
</ul>
<p>请注意，这里假设 m 上的 3x3 矩阵是一个纯旋转矩阵（即未缩放的矩阵）。</p>
<ul>
<li><code>.setRotationFromQuaternion ( q : Quaternion ) : undefined</code><br>q – 标准化的四元数。</li>
</ul>
<p>将所给的四元数复制到.quaternion 中。</p>
<ul>
<li><p><code>.toJSON ( meta : Object ) : Object</code><br>meta – 包含有元数据的对象，例如该对象的材质、纹理或图片。 将对象转换为 three.js JSON Object/Scene format（three.js JSON 物体/场景格式）。</p>
</li>
<li><p><code>.translateOnAxis ( axis : Vector3, distance : Float ) : this</code><br>axis – 一个在局部空间中的标准化向量。<br>distance – 将要平移的距离。</p>
</li>
</ul>
<p>在局部空间中沿着一条轴来平移物体，假设轴已被标准化。</p>
<ul>
<li><p><code>.translateX ( distance : Float ) : this</code><br>沿着 X 轴将平移 distance 个单位。</p>
</li>
<li><p><code>.translateY ( distance : Float ) : this</code><br>沿着 Y 轴将平移 distance 个单位。</p>
</li>
<li><p><code>.translateZ ( distance : Float ) : this</code><br>沿着 Z 轴将平移 distance 个单位。</p>
</li>
<li><p><code>.traverse ( callback : Function ) : undefined</code><br>callback - 以一个 object3D 对象作为第一个参数的函数。</p>
</li>
</ul>
<p>在对象以及后代中执行的回调函数。</p>
<ul>
<li><code>.traverseVisible ( callback : Function ) : undefined</code><br>callback - 以一个 object3D 对象作为第一个参数的函数。</li>
</ul>
<p>类似 traverse 函数，但在这里，回调函数仅对可见的对象执行，不可见对象的后代将不遍历。</p>
<ul>
<li><code>.traverseAncestors ( callback : Function ) : undefined</code><br>callback - 以一个 object3D 对象作为第一个参数的函数。</li>
</ul>
<p>在所有的祖先中执行回调函数。</p>
<ul>
<li><p><code>.updateMatrix () : undefined</code><br>更新局部变换。</p>
</li>
<li><p><code>.updateMatrixWorld ( force : Boolean ) : undefined</code><br>更新物体及其后代的全局变换。</p>
</li>
<li><p><code>.updateWorldMatrix ( updateParents : Boolean, updateChildren : Boolean ) : undefined</code><br>updateParents - 递归更新物体的所有祖先的全局变换.<br>updateChildren - 递归更新物体的所有后代的全局变换.</p>
</li>
</ul>
<p>更新物体的全局变换。</p>
<ul>
<li><code>.worldToLocal ( vector : Vector3 ) : Vector3</code><br>vector - 一个表示在世界空间中位置的向量。</li>
</ul>
<p>将该向量从世界空间转换到物体的局部空间。</p>
<h4 id="网格模型（Mesh）"><a href="#网格模型（Mesh）" class="headerlink" title="网格模型（Mesh）"></a>网格模型（Mesh）</h4><p>表示基于以三角形为 polygon mesh（多边形网格）的物体的类。 同时也作为其他类的基类<br>网格模型 Mesh 其实就一个一个三角形(面)拼接构成。使用使用网格模型 Mesh 渲染几何体 geometry，就是几何体所有顶点坐标三个为一组，构成一个三角形，多组顶点构成多个三角形，就可以用来模拟表示物体的表面。<br>空间中一个三角形有正反两面，相机对着三角形的一个面，如果三个顶点的顺序是逆时针方向，该面视为正面，如果三个顶点的顺序是顺时针方向，该面视为反面。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> geometry = <span class="keyword">new</span> THREE.BoxGeometry(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">const</span> material = <span class="keyword">new</span> THREE.MeshBasicMaterial(&#123; <span class="attr">color</span>: <span class="number">0xffff00</span> &#125;);</span><br><span class="line"><span class="keyword">const</span> mesh = <span class="keyword">new</span> THREE.Mesh(geometry, material);</span><br><span class="line">scene.add(mesh);</span><br></pre></td></tr></table></figure>

<p>网格模型 Mesh 对应的几何体 BufferGeometry，拆分为多个三角后，很多三角形重合的顶点位置坐标是相同的，这时候如果你想减少顶点坐标数据量，可以借助几何体顶点索引 geometry.index 来实现。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//每个三角形3个顶点坐标，矩形平面可以拆分为两个三角形，也就是6个顶点坐标。</span></span><br><span class="line"><span class="keyword">const</span> vertices = <span class="keyword">new</span> <span class="built_in">Float32Array</span>([</span><br><span class="line">  <span class="number">0</span>,</span><br><span class="line">  <span class="number">0</span>,</span><br><span class="line">  <span class="number">0</span>, <span class="comment">//顶点1坐标</span></span><br><span class="line">  <span class="number">80</span>,</span><br><span class="line">  <span class="number">0</span>,</span><br><span class="line">  <span class="number">0</span>, <span class="comment">//顶点2坐标</span></span><br><span class="line">  <span class="number">80</span>,</span><br><span class="line">  <span class="number">80</span>,</span><br><span class="line">  <span class="number">0</span>, <span class="comment">//顶点3坐标</span></span><br><span class="line">  <span class="number">0</span>,</span><br><span class="line">  <span class="number">0</span>,</span><br><span class="line">  <span class="number">0</span>, <span class="comment">//顶点4坐标   和顶点1位置相同</span></span><br><span class="line">  <span class="number">80</span>,</span><br><span class="line">  <span class="number">80</span>,</span><br><span class="line">  <span class="number">0</span>, <span class="comment">//顶点5坐标  和顶点3位置相同</span></span><br><span class="line">  <span class="number">0</span>,</span><br><span class="line">  <span class="number">80</span>,</span><br><span class="line">  <span class="number">0</span>, <span class="comment">//顶点6坐标</span></span><br><span class="line">]);</span><br><span class="line"><span class="comment">//如果几何体有顶点索引geometry.index，那么你可以吧三角形重复的顶点位置坐标删除。</span></span><br><span class="line"><span class="keyword">const</span> vertices = <span class="keyword">new</span> <span class="built_in">Float32Array</span>([</span><br><span class="line">  <span class="number">0</span>,</span><br><span class="line">  <span class="number">0</span>,</span><br><span class="line">  <span class="number">0</span>, <span class="comment">//顶点1坐标</span></span><br><span class="line">  <span class="number">80</span>,</span><br><span class="line">  <span class="number">0</span>,</span><br><span class="line">  <span class="number">0</span>, <span class="comment">//顶点2坐标</span></span><br><span class="line">  <span class="number">80</span>,</span><br><span class="line">  <span class="number">80</span>,</span><br><span class="line">  <span class="number">0</span>, <span class="comment">//顶点3坐标</span></span><br><span class="line">  <span class="number">0</span>,</span><br><span class="line">  <span class="number">80</span>,</span><br><span class="line">  <span class="number">0</span>, <span class="comment">//顶点4坐标</span></span><br><span class="line">]);</span><br></pre></td></tr></table></figure>

<p>BufferAttribute 定义顶点索引.index 数据<br>通过 javascript 类型化数组 Uint16Array 创建顶点索引.index 数据。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Uint16Array类型数组创建顶点索引数据</span></span><br><span class="line"><span class="keyword">const</span> indexes = <span class="keyword">new</span> <span class="built_in">Uint16Array</span>([</span><br><span class="line">  <span class="comment">// 下面索引值对应顶点位置数据中的顶点坐标</span></span><br><span class="line">  <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>,</span><br><span class="line">]);</span><br></pre></td></tr></table></figure>

<p>通过 threejs 的属性缓冲区对象 BufferAttribute 表示几何体顶点索引.index 数据。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 索引数据赋值给几何体的index属性</span></span><br><span class="line">geometry.index = <span class="keyword">new</span> THREE.BufferAttribute(indexes, <span class="number">1</span>); <span class="comment">//1个为一组</span></span><br></pre></td></tr></table></figure>

<h4 id="构造器-29"><a href="#构造器-29" class="headerlink" title="构造器"></a>构造器</h4><p><code>Mesh( geometry : BufferGeometry, material : Material )</code><br>geometry —— （可选）BufferGeometry 的实例，默认值是一个新的 BufferGeometry。<br>material —— （可选）一个 Material，或是一个包含有 Material 的数组，默认是一个新的 MeshBasicMa`terial。</p>
<h5 id="属性-7"><a href="#属性-7" class="headerlink" title="属性"></a>属性</h5><p>共有属性请参见其基类 Object3D。</p>
<p>.geometry : BufferGeometry<br>BufferGeometry 的实例或者派生类，定义了物体的结构。</p>
<p>.isMesh : Boolean<br>Read-only flag to check if a given object is of type Mesh.</p>
<p>.material : Material<br>由 Material 基类或者一个包含材质的数组派生而来的材质实例，定义了物体的外观。默认值是一个 MeshBasicMaterial。</p>
<p>.morphTargetInfluences : Array<br>一个包含有权重（值一般在 0-1 范围内）的数组，指定应用了多少变形。 默认情况下是未定义的，但是会被 updateMorphTargets 重置为一个空数组。</p>
<p>.morphTargetDictionary : Object<br>基于 morphTarget.name 属性的 morphTargets 字典。 默认情况下是未定义的，但是会被 updateMorphTargets 重建。</p>
<h5 id="方法-7"><a href="#方法-7" class="headerlink" title="方法"></a>方法</h5><p>共有方法请参见其基类 Object3D。</p>
<p>.clone () : Mesh<br>返回这个 Mesh 对象及其子级的克隆。</p>
<p>.raycast ( raycaster : Raycaster, intersects : Array ) : undefined<br>在一条投射出去的 Ray（射线）和这个网格之间产生交互。 Raycaster.intersectObject 将会调用这个方法。</p>
<p>.updateMorphTargets () : undefined<br>更新 morphTargets，使其不对对象产生影响，重置 morphTargetInfluences and morphTargetDictionary 属性。</p>
<h4 id="点（Points）"><a href="#点（Points）" class="headerlink" title="点（Points）"></a>点（Points）</h4><p>一个用于显示点的类。 由 WebGLRenderer 渲染的点使用 gl.POINTS。</p>
<h5 id="构造器-30"><a href="#构造器-30" class="headerlink" title="构造器"></a>构造器</h5><p><code>Points( geometry : BufferGeometry, material : Material )</code><br>geometry —— （可选）是一个 BufferGeometry 的实例，默认值是一个新的 BufferGeometry。几何体 geometry 作为点模型 Points 参数，会把几何体渲染为点<br>material —— （可选） 是一个对象，默认值是一个 PointsMaterial。</p>
<h5 id="属性-8"><a href="#属性-8" class="headerlink" title="属性"></a>属性</h5><p>共有属性请参见其基类 Object3D。</p>
<p>.geometry : BufferGeometry<br>一个 BufferGeometry 的实例（或者派生类），定义了物体的结构。</p>
<p>.isPoints : Boolean<br>Read-only flag to check if a given object is of type Points.</p>
<p>.material : Material<br>Material 的实例。定义了物体的外观。默认值是一个的 PointsMaterial。</p>
<p>.morphTargetInfluences : Array<br>一个包含有权重（值一般在 0-1 范围内）的数组，指定应用了多少变形。 默认情况下是未定义的，但是会被 updateMorphTargets 重置为一个空数组。</p>
<p>.morphTargetDictionary : Object<br>基于 morphTarget.name 属性的 morphTargets 字典。 默认情况下是未定义的，但是会被 updateMorphTargets 重建。</p>
<h5 id="方法-8"><a href="#方法-8" class="headerlink" title="方法"></a>方法</h5><p>共有方法请参见其基类 Object3D。</p>
<p>.clone () : Mesh<br>返回这个 Mesh 对象及其子级的克隆。</p>
<p>.raycast ( raycaster : Raycaster, intersects : Array ) : undefined<br>在一条投射出去的 Ray（射线）和这个网格之间产生交互。 Raycaster.intersectObject 将会调用这个方法。</p>
<p>.updateMorphTargets () : undefined<br>更新 morphTargets，使其不对对象产生影响，重置 morphTargetInfluences and morphTargetDictionary 属性。</p>
<h4 id="精灵（Sprite）"><a href="#精灵（Sprite）" class="headerlink" title="精灵（Sprite）"></a>精灵（Sprite）</h4><p>精灵是一个总是面朝着摄像机的平面，通常含有使用一个半透明的纹理。精灵不会投射任何阴影</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> THREE.TextureLoader().load(<span class="string">&quot;sprite.png&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> material = <span class="keyword">new</span> THREE.SpriteMaterial(&#123; <span class="attr">map</span>: map &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sprite = <span class="keyword">new</span> THREE.Sprite(material);</span><br><span class="line">scene.add(sprite);</span><br></pre></td></tr></table></figure>

<h5 id="构造器-31"><a href="#构造器-31" class="headerlink" title="构造器"></a>构造器</h5><p>Sprite( material : Material )<br>material - （可选值）是 SpriteMaterial 的一个实例。 默认值是一个白色的 SpriteMaterial。</p>
<p>创建一个新的 Sprite。</p>
<h5 id="属性-9"><a href="#属性-9" class="headerlink" title="属性"></a>属性</h5><p>共有属性请参见其基类 Object3D。</p>
<p>.isSprite : Boolean<br>Read-only flag to check if a given object is of type Sprite.</p>
<p>.material : SpriteMaterial<br>SpriteMaterial 的一个实例，定义了这个对象的外观。默认值是一个白色的 SpriteMaterial。</p>
<p>.center : Vector2<br>这个精灵的锚点，也就是精灵旋转时，围绕着旋转的点。当值为(0.5,0.5)时，对应着这个精灵的中心点；当值为(0,0)时，对应着这个精灵左下角的点。<br>其默认值是(0.5,0.5)。</p>
<h5 id="方法-9"><a href="#方法-9" class="headerlink" title="方法"></a>方法</h5><p>共有方法请参见其基类 Object3D。</p>
<p>.clone () : Sprite<br>返回当前 Sprite 对象的一个克隆及其任何后代。</p>
<p>.copy ( sprite : Sprite ) : this<br>将前一个 Sprite 对象的属性复制给当前的这个对象。</p>
<p>.raycast ( raycaster : Raycaster, intersects : Array ) : undefined<br>在投射的光线和精灵之前产生交互。Raycaster.intersectObject 将会调用这个方法。 在对 sprite 进行射线投射之前，射线投射必须通过调用 Raycaster.setFromCamera()来初始化。</p>
<h4 id="线（Line）"><a href="#线（Line）" class="headerlink" title="线（Line）"></a>线（Line）</h4><p>它几乎和 LineSegments 是一样的，唯一的区别是它在渲染时使用的是 gl.LINE_STRIP， 而不是 gl.LINES。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> material = <span class="keyword">new</span> THREE.LineBasicMaterial(&#123;</span><br><span class="line">  <span class="attr">color</span>: <span class="number">0x0000ff</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> points = [];</span><br><span class="line">points.push(<span class="keyword">new</span> THREE.Vector3(-<span class="number">10</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">points.push(<span class="keyword">new</span> THREE.Vector3(<span class="number">0</span>, <span class="number">10</span>, <span class="number">0</span>));</span><br><span class="line">points.push(<span class="keyword">new</span> THREE.Vector3(<span class="number">10</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> geometry = <span class="keyword">new</span> THREE.BufferGeometry().setFromPoints(points);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> line = <span class="keyword">new</span> THREE.Line(geometry, material);</span><br><span class="line">scene.add(line);</span><br></pre></td></tr></table></figure>

<h5 id="构造器-32"><a href="#构造器-32" class="headerlink" title="构造器"></a>构造器</h5><p><code>Line( geometry : BufferGeometry, material : Material )</code><br>geometry —— 表示线段的顶点，默认值是一个新的 BufferGeometry。几何体作为线模型 Line (opens new window)的参数，你会发现渲染效果是从第一个点开始到最后一个点，依次连成线。<br>material —— 线的材质，默认值是一个新的具有随机颜色的 LineBasicMaterial。</p>
<h5 id="属性-10"><a href="#属性-10" class="headerlink" title="属性"></a>属性</h5><p>共有属性请参见其基类 Object3D。</p>
<p>.geometry : BufferGeometry<br>表示线段的顶点。</p>
<p>.isLine : Boolean<br>Read-only flag to check if a given object is of type Line.</p>
<p>.material : Material<br>线的材质。</p>
<p>.morphTargetInfluences : Array<br>An array of weights typically from 0-1 that specify how much of the morph is applied. Undefined by default, but reset to a blank array by .updateMorphTargets().</p>
<p>.morphTargetDictionary : Object<br>A dictionary of morphTargets based on the morphTarget.name property. Undefined by default, but rebuilt .updateMorphTargets().</p>
<h5 id="方法-10"><a href="#方法-10" class="headerlink" title="方法"></a>方法</h5><p>共有方法请参见其基类 Object3D。</p>
<p>.computeLineDistances () : this<br>计算 LineDashedMaterial 所需的距离的值的数组。 对于几何体中的每一个顶点，这个方法计算出了当前点到线的起始点的累积长度。</p>
<p>.raycast ( raycaster : Raycaster, intersects : Array ) : undefined<br>在一条投射出去的 Ray（射线）和这条线之间产生交互。 Raycaster.intersectObject 将会调用这个方法。</p>
<p>.clone () : Line<br>返回这条线及其子集的一个克隆对象。</p>
<p>.updateMorphTargets () : undefined<br>Updates the morphTargets to have no influence on the object. Resets the .morphTargetInfluences and .morphTargetDictionary properties.</p>
<h4 id="组（Group）"><a href="#组（Group）" class="headerlink" title="组（Group）"></a>组（Group）</h4><p>它几乎和 Object3D 是相同的，其目的是使得组中对象在语法上的结构更加清晰。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> geometry = <span class="keyword">new</span> THREE.BoxGeometry(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">const</span> material = <span class="keyword">new</span> THREE.MeshBasicMaterial(&#123; <span class="attr">color</span>: <span class="number">0x00ff00</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cubeA = <span class="keyword">new</span> THREE.Mesh(geometry, material);</span><br><span class="line">cubeA.position.set(<span class="number">100</span>, <span class="number">100</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cubeB = <span class="keyword">new</span> THREE.Mesh(geometry, material);</span><br><span class="line">cubeB.position.set(-<span class="number">100</span>, -<span class="number">100</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//create a group and add the two cubes</span></span><br><span class="line"><span class="comment">//These cubes can now be rotated / scaled etc as a group</span></span><br><span class="line"><span class="keyword">const</span> group = <span class="keyword">new</span> THREE.Group();</span><br><span class="line">group.add(cubeA);</span><br><span class="line">group.add(cubeB);</span><br><span class="line"></span><br><span class="line">scene.add(group);</span><br></pre></td></tr></table></figure>

<h5 id="构造器-33"><a href="#构造器-33" class="headerlink" title="构造器"></a>构造器</h5><p><code>Group( )</code></p>
<h5 id="属性-方法-21"><a href="#属性-方法-21" class="headerlink" title="属性|方法"></a>属性|方法</h5><blockquote>
<p>共有属性请参见其基类 Object3D。<br>共有方法请参见其基类 Object3D。</p>
</blockquote>
<p>.isGroup : Boolean<br>Read-only flag to check if a given object is of type Group.</p>
<p>.type : String<br>一个字符串：“Group”。这个属性不应当被改变。</p>
<h4 id="实例化网格（InstancedMesh）"><a href="#实例化网格（InstancedMesh）" class="headerlink" title="实例化网格（InstancedMesh）"></a>实例化网格（InstancedMesh）</h4><p>一种具有实例化渲染支持的特殊版本的 Mesh。你可以使用 InstancedMesh 来渲染大量具有相同几何体与材质、但具有不同世界变换的物体。 使用 InstancedMesh 将帮助你减少 draw call 的数量，从而提升你应用程序的整体渲染性能。</p>
<h5 id="构造器-34"><a href="#构造器-34" class="headerlink" title="构造器"></a>构造器</h5><p><code>InstancedMesh( geometry : BufferGeometry, material : Material, count : Integer )</code><br>geometry - 一个 BufferGeometry 的实例。<br>material - 一个 Material 的实例。默认为一个新的 MeshBasicMaterial 。<br>count - 实例的数量</p>
<h3 id="渲染器"><a href="#渲染器" class="headerlink" title="渲染器"></a>渲染器</h3><h4 id="WebGLRenderer"><a href="#WebGLRenderer" class="headerlink" title="WebGLRenderer"></a>WebGLRenderer</h4><p>构造器<br><code>WebGLRenderer( parameters : Object )</code><br>parameters - (可选) 该对象的属性定义了渲染器的行为。也可以完全不传参数。在所有情况下，当缺少参数时，它将采用合理的默认值。 以下是合法参数：</p>
<p><code>canvas</code> - 一个供渲染器绘制其输出的 canvas 它和下面的 domElement 属性对应。 如果没有传这个参数，会创建一个新 canvas<br><code>context</code> - 可用于将渲染器附加到已有的渲染环境(RenderingContext)中。默认值是 null<br><code>precision</code> - 着色器精度. 可以是 “highp”, “mediump” 或者 “lowp”. 如果设备支持，默认为”highp” .<br><code>alpha</code> - controls the default clear alpha value. When set to true, the value is 0. Otherwise it’s 1. Default is false.<br><code>premultipliedAlpha</code> - renderer 是否假设颜色有 premultiplied alpha. 默认为 true<br><code>antialias</code> - 是否执行抗锯齿。默认为 false.<br><code>stencil</code> - 绘图缓存是否有一个至少 8 位的模板缓存(stencil buffer)。默认为 true<br><code>preserveDrawingBuffer</code> -是否保留缓直到手动清除或被覆盖。 默认 false.<br><code>powerPreference</code> - 提示用户代理怎样的配置更适用于当前 WebGL 环境。 可能是”high-performance”, “low-power” 或 “default”。默认是”default”. 详见 WebGL spec<br><code>failIfMajorPerformanceCaveat</code> - 检测渲染器是否会因性能过差而创建失败。默认为 false。详见 WebGL spec for details.<br><code>depth</code> - 绘图缓存是否有一个至少 6 位的深度缓存(depth buffer )。 默认是 true.<br><code>logarithmicDepthBuffer</code> - 是否使用对数深度缓存。如果要在单个场景中处理巨大的比例差异，就有必要使用。 Note that this setting uses gl_FragDepth if available which disables the Early Fragment Test optimization and can cause a decrease in performance. 默认是 false。 示例：camera / logarithmicdepthbuffer</p>
<h5 id="属性-11"><a href="#属性-11" class="headerlink" title="属性"></a>属性</h5><ul>
<li><p><code>.autoClear</code> : Boolean<br>定义渲染器是否在渲染每一帧之前自动清除其输出。</p>
</li>
<li><p><code>.autoClearColor</code> : Boolean<br>如果 autoClear 为 true, 定义 renderer 是否清除颜色缓存。 默认是 true</p>
</li>
<li><p><code>.autoClearDepth</code> : Boolean<br>如果 autoClear 是 true, 定义 renderer 是否清除深度缓存。 默认是 true</p>
</li>
<li><p><code>.autoClearStencil</code> : Boolean<br>如果 autoClear 是 true, 定义 renderer 是否清除模板缓存. 默认是 true</p>
</li>
<li><p><code>.debug</code> : Object</p>
<ul>
<li>checkShaderErrors: 如果为 true，定义是否检查材质着色器程序 编译和链接过程中的错误。 禁用此检查生产以获得性能增益可能很有用。 强烈建议在开发期间保持启用这些检查。 如果着色器没有编译和链接 - 它将无法工作，并且相关材料将不会呈现。 默认是 true</li>
<li>onShaderError( gl, program, glVertexShader, glFragmentShader ): A callback function that can be used for custom error reporting. The callback receives the WebGL context, an instance of WebGLProgram as well two instances of WebGLShader representing the vertex and fragment shader. Assigning a custom function disables the default error reporting. Default is null.</li>
</ul>
</li>
<li><p><code>.capabilities</code> : Object<br>一个包含当前渲染环境(RenderingContext)的功能细节的对象。</p>
<ul>
<li>floatFragmentTextures: 环境是否支持 OES_texture_float 扩展</li>
<li>floatVertexTextures: 如果 floatFragmentTextures 和 vertexTextures 都是 true， 则此值为 true</li>
<li>getMaxAnisotropy(): 返回最大可用各向异性。</li>
<li>getMaxPrecision(): 返回顶点着色器和片元着色器的最大可用精度。</li>
<li>isWebGL2: true if the context in use is a WebGL2RenderingContext object.</li>
<li>logarithmicDepthBuffer: 如果 logarithmicDepthBuffer 在构造器中被设为 true 且 环境支持 EXT_frag_depth 扩展，则此值为 true</li>
<li>maxAttributes: gl.MAX_VERTEX_ATTRIBS 的值</li>
<li>maxCubemapSize: gl.MAX_CUBE_MAP_TEXTURE_SIZE 的值，着色器可使用的立方体贴图纹理的最大宽度*高度</li>
<li>maxFragmentUniforms: gl.MAX_FRAGMENT_UNIFORM_VECTORS 的值，片元着色器可使用的全局变量(uniforms)数量</li>
<li>maxSamples: The value of gl.MAX_SAMPLES. Maximum number of samples in context of Multisample anti-aliasing (MSAA).</li>
<li>maxTextureSize: gl.MAX_TEXTURE_SIZE 的值，着色器可使用纹理的最大宽度*高度</li>
<li>maxTextures: *gl.MAX_TEXTURE_IMAGE_UNITS 的值，着色器可使用的纹理数量</li>
<li>maxVaryings: gl.MAX_VARYING_VECTORS 的值，着色器可使用矢量的数量</li>
<li>maxVertexTextures: gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS 的值，顶点着色器可使用的纹理数量。</li>
<li>maxVertexUniforms: gl.MAX_VERTEX_UNIFORM_VECTORS 的值，顶点着色器可使用的全局变量(uniforms)数量</li>
<li>precision: 渲染器当前使用的着色器的精度</li>
<li>vertexTextures: 如果 .maxVertexTextures : Integer 大于 0，此值为 true (即可以使用顶点纹理)</li>
</ul>
</li>
<li><p><code>.clippingPlanes</code> : Array<br>用户自定义的剪裁平面，在世界空间中被指定为 THREE.Plane 对象。 这些平面全局使用。空间中与该平面点积为负的点将被切掉。 默认值是[]</p>
</li>
<li><p><code>.domElement</code> : DOMElement<br>一个 canvas，渲染器在其上绘制输出。<br>渲染器的构造函数会自动创建(如果没有传入 canvas 参数);你需要做的仅仅是像下面这样将它加页面里去:<code>document.body.appendChild( renderer.domElement );</code></p>
</li>
<li><p><code>.extensions</code> : Object</p>
<ul>
<li>get( extensionName : String ): 用于检查是否支持各种扩展，并返回一个对象，其中包含扩展的详细信息。 该方法检查以下扩展：<br>WEBGL_depth_texture<br>EXT_texture_filter_anisotropic<br>WEBGL_compressed_texture_s3tc<br>WEBGL_compressed_texture_pvrtc<br>WEBGL_compressed_texture_etc1<br>.outputColorSpace : string<br>定义渲染器的输出编码。默认为 THREE.SRGBColorSpace</li>
</ul>
</li>
</ul>
<p>如果渲染目标已经使用 .setRenderTarget、之后将直接使用 renderTarget.texture.colorSpace</p>
<p>查看 texture constants 页面以获取其他格式细节</p>
<ul>
<li><code>.info</code> : Object<br>一个对象，包含有关图形板内存和渲染过程的一系列统计信息。这些信息可用于调试或仅仅满足下好奇心。该对象包含以下字段:</li>
</ul>
<p>memory:<br>geometries<br>textures<br>render:<br>calls<br>triangles<br>points<br>lines<br>frame<br>programs<br>默认情况下，这些字段在每次渲染调用时都会重置，但是当每帧有多个渲染通道时（例如，使用后处理时），最好使用自定义模式重置。先将 autoReset 设置为 false.<br>renderer.info.autoReset = false;然后在单个帧时渲染完成后调用 reset().<br>renderer.info.reset();</p>
<ul>
<li><p><code>.localClippingEnabled</code> : Boolean<br>定义渲染器是否考虑对象级剪切平面。 默认为 false.</p>
</li>
<li><p><code>.useLegacyLights</code> : Boolean<br>Whether to use the legacy lighting mode or not. 默认是 true。</p>
</li>
<li><p><code>.properties</code> : Object<br>渲染器内部使用，以跟踪各种子对象属性。</p>
</li>
<li><p><code>.renderLists</code> : WebGLRenderLists<br>在内部用于处理场景渲染对象的排序。</p>
</li>
<li><p><code>.shadowMap</code> : WebGLShadowMap<br>如果使用，它包含阴影贴图的引用。</p>
<ul>
<li>enabled: 如果设置开启，允许在场景中使用阴影贴图。默认是 false。</li>
<li>autoUpdate: 启用场景中的阴影自动更新。默认是 true<br>如果不需要动态光照/阴影, 则可以在实例化渲染器时将之设为 false</li>
<li>needsUpdate: 当被设为 true, 场景中的阴影贴图会在下次 render 调用时刷新。默认是 false<br>如果你已经禁用了阴影贴图的自动更新(shadowMap.autoUpdate = false), 那么想要在下一次渲染时更新阴影的话就需要将此值设为 true</li>
<li>type: 定义阴影贴图类型 (未过滤, 关闭部分过滤, 关闭部分双线性过滤), 可选值有:</li>
</ul>
</li>
</ul>
<p>THREE.BasicShadowMap<br>THREE.PCFShadowMap (默认)<br>THREE.PCFSoftShadowMap<br>THREE.VSMShadowMap<br>详见 Renderer constants</p>
<ul>
<li><code>.sortObjects</code> : Boolean<br>定义渲染器是否应对对象进行排序。默认是 true.</li>
</ul>
<p>说明: 排序用于尝试正确渲染出具有一定透明度的对象。根据定义，排序可能不总是有用。根据应用的需求，可能需要关闭排序并使其他方法来处理透明度的渲染，例如， 手动确定每个对象的渲染顺序。</p>
<ul>
<li><p><code>.state</code> : Object<br>包含设置 WebGLRenderer.context 状态的各种属性的函数。</p>
</li>
<li><p><code>.toneMapping</code> : Constant<br>默认是 NoToneMapping。查看 Renderer constants 以获取其它备选项</p>
</li>
<li><p><code>.toneMappingExposure</code> : Number<br>色调映射的曝光级别。默认是 1</p>
</li>
</ul>
<p>-<code>.xr</code> : WebXRManager<br>Provides access to the WebXR related interface of the renderer.</p>
<h5 id="方法-11"><a href="#方法-11" class="headerlink" title="方法"></a>方法</h5><ul>
<li><p><code>.render ( scene : Object3D, camera : Camera ) : undefined</code><br>用相机(camera)渲染一个场景(scene)或是其它类型的 object。<br>渲染一般是在 canvas 上完成的，或者是 renderTarget(如果有指定)<br>如果 forceClear 值是 true，那么颜色、深度及模板缓存将会在渲染之前清除，即使渲染器的 autoClear 属性值是 false<br>即便 forceClear 设为 true, 也可以通过将 autoClearColor、autoClearStencil 或 autoClearDepth 属性的值设为 false 来阻止对应缓存被清除。</p>
</li>
<li><p><code>.setSize ( width : Integer, height : Integer, updateStyle : Boolean ) : undefined</code><br>将输出 canvas 的大小调整为(width, height)并考虑设备像素比，且将视口从(0, 0)开始调整到适合大小 将 updateStyle 设置为 false 以阻止对 canvas 的样式做任何改变。</p>
</li>
<li><p><code>.setViewport ( x : Integer, y : Integer, width : Integer, height : Integer ) : undefined</code><br>将视口大小设置为(x, y)到 (x + width, y + height).</p>
</li>
<li><p><code>.clear ( color : Boolean, depth : Boolean, stencil : Boolean ) : undefined</code><br>告诉渲染器清除颜色、深度或模板缓存. 此方法将颜色缓存初始化为当前颜色。参数们默认都是 true</p>
</li>
<li><p><code>.clearColor ( ) : undefined</code><br>清除颜色缓存。 相当于调用.clear( true, false, false )</p>
</li>
<li><p><code>.clearDepth ( ) : undefined</code><br>清除深度缓存。相当于调用.clear( false, true, false )</p>
</li>
<li><p><code>.clearStencil ( ) : undefined</code><br>清除模板缓存。相当于调用.clear( false, false, true )</p>
</li>
<li><p><code>.compile ( scene : Object3D, camera : Camera ) : undefined</code><br>使用相机编译场景中的所有材质。这对于在首次渲染之前预编译着色器很有用。</p>
</li>
<li><p><code>.copyFramebufferToTexture ( position : Vector2, texture : FramebufferTexture, level : Number ) : undefined</code><br>将当前 WebGLFramebuffer 中的像素复制到 2D 纹理中。可访问 WebGLRenderingContext.copyTexImage2D.</p>
</li>
<li><p><code>.copyTextureToTexture ( position : Vector2, srcTexture : Texture, dstTexture : Texture, level : Number ) : undefined</code><br>将纹理的所有像素复制到一个已有的从给定位置开始的纹理中。可访问 WebGLRenderingContext.texSubImage2D.</p>
</li>
<li><p><code>.dispose ( ) : undefined</code><br>处理当前的渲染环境</p>
</li>
<li><p><code>.forceContextLoss () : undefined</code><br>模拟 WebGL 环境的丢失。需要支持 WEBGL_lose_context 扩展才能用。</p>
</li>
<li><p><code>.forceContextRestore ( ) : undefined</code><br>模拟 WebGL 环境的恢复。需要支持 WEBGL_lose_context 扩展才能用。</p>
</li>
<li><p><code>.getClearAlpha () : Float</code><br>返回一个表示当前 alpha 值的 float，范围 0 到 1</p>
</li>
<li><p><code>.getClearColor ( target : Color ) : Color</code><br>返回一个表示当前颜色值的 THREE.Color 实例</p>
</li>
<li><p><code>.getContext () : WebGL2RenderingContext</code><br>返回当前 WebGL 环境</p>
</li>
<li><p><code>.getContextAttributes () : WebGLContextAttributes</code><br>返回一个对象，这个对象中存有在 WebGL 环境在创建的时候所设置的属性</p>
</li>
<li><p><code>.getActiveCubeFace () : Integer</code><br>Returns the current active cube face.</p>
</li>
<li><p><code>.getActiveMipmapLevel () : Integer</code><br>Returns the current active mipmap level.</p>
</li>
<li><p><code>.getRenderTarget () : RenderTarget</code><br>如果当前存在 RenderTarget，则返回该值；否则返回 null。</p>
</li>
<li><p><code>.getCurrentViewport () : RenderTarget</code><br>返回当前视口</p>
</li>
<li><p><code>.getDrawingBufferSize () : Object</code><br>返回一个包含渲染器绘图缓存宽度和高度(单位像素)的对象。</p>
</li>
<li><p><code>.getPixelRatio () : number</code><br>返回当前使用设备像素比</p>
</li>
<li><p><code>.getSize ( target : Vector2 ) : Vector2</code><br>返回包含渲染器输出 canvas 的宽度和高度(单位像素)的对象。</p>
</li>
<li><p><code>.initTexture ( texture : Texture ) : undefined</code><br>初始化给定的纹理。用于预加载纹理而不是等到第一次渲染（可能会由于解码和 GPU 上传的开销而导致明显的延迟）.</p>
</li>
<li><p><code>.resetGLState ( ) : undefined</code><br>将 GL 状态重置为默认值。WebGL 环境丢失时会内部调用</p>
</li>
<li><p><code>.readRenderTargetPixels ( renderTarget : WebGLRenderTarget, x : Float, y : Float, width : Float, height : Float, buffer : TypedArray, activeCubeFaceIndex : Integer ) : undefined</code><br>buffer - Uint8Array is the only destination type supported in all cases, other types are renderTarget and platform dependent. See WebGL spec for details.</p>
</li>
</ul>
<p>将 renderTarget 中的像素数据读取到传入的缓冲区中。这是 WebGLRenderingContext.readPixels()的包装器<br>示例：interactive / cubes / gpu</p>
<p>For reading out a WebGLCubeRenderTarget use the optional parameter activeCubeFaceIndex to determine which face should be read.</p>
<ul>
<li><p><code>.resetState () : undefined</code><br>可用于重置内部 WebGL 状态。此方法主要与跨多个 WebGL 库共享单个 WebGL 上下文的应用程序相关。</p>
</li>
<li><p><code>.setAnimationLoop ( callback : Function ) : undefined</code><br>callback — 每个可用帧都会调用的函数。 如果传入‘null’,所有正在进行的动画都会停止。</p>
</li>
</ul>
<p>可用来代替 requestAnimationFrame 的内置函数. 对于 WebXR 项目，必须使用此函数。</p>
<ul>
<li><p><code>.setClearAlpha ( alpha : Float ) : undefined</code><br>设置 alpha。合法参数是一个 0.0 到 1.0 之间的浮点数</p>
</li>
<li><p><code>.setClearColor ( color : Color, alpha : Float ) : undefined</code><br>设置颜色及其透明度</p>
</li>
<li><p><code>.setPixelRatio ( value : number ) : undefined</code><br>设置设备像素比。通常用于避免 HiDPI 设备上绘图模糊</p>
</li>
<li><p><code>.setRenderTarget ( renderTarget : WebGLRenderTarget, activeCubeFace : Integer, activeMipmapLevel : Integer ) : undefined</code><br>renderTarget – 需要被激活的 renderTarget(可选)。若此参数为空，则将 canvas 设置成活跃 render target。<br>activeCubeFace – Specifies the active cube side (PX 0, NX 1, PY 2, NY 3, PZ 4, NZ 5) of WebGLCubeRenderTarget. When passing a WebGLArrayRenderTarget or WebGL3DRenderTarget this indicates the z layer to render in to (optional).<br>activeMipmapLevel – Specifies the active mipmap level (optional).</p>
</li>
</ul>
<p>该方法设置活跃 rendertarget。</p>
<ul>
<li><p><code>.setScissor ( x : Integer, y : Integer, width : Integer, height : Integer ) : undefined</code><br>将剪裁区域设为(x, y)到(x + width, y + height) Sets the scissor area from</p>
</li>
<li><p><code>.setScissorTest ( boolean : Boolean ) : undefined</code><br>启用或禁用剪裁检测. 若启用，则只有在所定义的裁剪区域内的像素才会受之后的渲染器影响。</p>
</li>
</ul>
<h4 id="WebGL1Renderer"><a href="#WebGL1Renderer" class="headerlink" title="WebGL1Renderer"></a>WebGL1Renderer</h4><p>自 r118 起，WebGLRenderer 会自动使用 WebGL 2 渲染上下文。当升级一个已存在的项目到 =&gt; r118 ， 应用程序可能会因为下列两种原因而损坏：</p>
<p>自定义着色器代码必须符合 GLSL 3.0。<br>WebGL 1 扩展检查到被更改<br>如果你不能够花时间来升级你的代码，但仍然想要使用最新版本，那你就可以使用 WebGL1Renderer。 这一版本的渲染器会强制使用 WebGL 1 渲染上下文。<br>构造函数<br>WebGL1Renderer( parameters : Object )<br>Creates a new WebGL1Renderer.</p>
<h4 id="SVG-渲染器（SVGRenderer）"><a href="#SVG-渲染器（SVGRenderer）" class="headerlink" title="SVG 渲染器（SVGRenderer）"></a>SVG 渲染器（SVGRenderer）</h4><p>SVGRenderer 被用于使用 SVG 来渲染几何数据，所产生的矢量图形在以下几个方面十分有用：</p>
<p>动画标志（logo）或者图标（icon）<br>可交互的 2D 或 3D 图表或图形<br>交互式地图<br>复杂的或包含动画的用户界面<br>SVGRenderer 具有很多优势。它产生清晰并且锐利的图像输出，它和实际视口分辨率无关。<br>SVG 元素可以通过 CSS 来控制样式；并且由于它可以添加诸如标题或者描述文字之类的元数据（对于搜索引擎或者屏幕阅读器十分有用），因此它具有十分良好的可访问性。</p>
<p>然而，SVG 也有一些十分重要的限制：</p>
<p>没有高级的着色器<br>不支持纹理<br>不支持阴影</p>
<p>SVGRenderer 是一个附加组件，必须显式导入。 See Installation / Addons.</p>
<p><code>import &#123; SVGRenderer &#125; from &#39;three/addons/renderers/SVGRenderer.js&#39;;</code></p>
<h4 id="CSS-3D-渲染器（CSS3DRenderer）"><a href="#CSS-3D-渲染器（CSS3DRenderer）" class="headerlink" title="CSS 3D 渲染器（CSS3DRenderer）"></a>CSS 3D 渲染器（CSS3DRenderer）</h4><p>CSS3DRenderer 用于通过 CSS3 的 transform 属性， 将层级的 3D 变换应用到 DOM 元素上。 如果你希望不借助基于 canvas 的渲染来在你的网站上应用 3D 变换，那么这一渲染器十分有趣。 同时，它也可以将 DOM 元素与 WebGL 的内容相结合。</p>
<p>然而，这一渲染器也有一些十分重要的限制：</p>
<p>它不可能使用 three.js 中的材质系统。<br>同时也不可能使用几何体。<br>CSS3DRenderer 仅支持 100%的浏览器和显示缩放。<br>因此，CSS3DRenderer 仅仅关注普通的 DOM 元素，这些元素被包含到了特殊的对象中（CSS3DObject 或者 CSS3DSprite），然后被加入到场景图中。<br>进口<br>CSS3DRenderer 是一个附加组件，必须显式导入。 See Installation / Addons.</p>
<p><code>import &#123; CSS3DRenderer &#125; from &#39;three/addons/renderers/CSS3DRenderer.js&#39;;</code></p>
<h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><h4 id="Scene"><a href="#Scene" class="headerlink" title="Scene"></a>Scene</h4><p>场景能够让你在什么地方、摆放什么东西来交给 three.js 来渲染，这是你放置物体、灯光和摄像机的地方。</p>
<h5 id="构造器-35"><a href="#构造器-35" class="headerlink" title="构造器"></a>构造器</h5><p>Scene()<br>创建一个新的场景对象。</p>
<h5 id="属性-12"><a href="#属性-12" class="headerlink" title="属性"></a>属性</h5><p>.background : Object<br>若不为空，在渲染场景的时候将设置背景，且背景总是首先被渲染的。 可以设置一个用于的“clear”的 Color（颜色）、一个覆盖 canvas 的 Texture（纹理）， 或是 a cubemap as a CubeTexture or an equirectangular as a Texture。默认值为 null。</p>
<p>.backgroundBlurriness : Float<br>Sets the blurriness of the background. Only influences environment maps assigned to Scene.background. Valid input is a float between 0 and 1. Default is 0.</p>
<p>.environment : Texture<br>若该值不为 null，则该纹理贴图将会被设为场景中所有物理材质的环境贴图。 然而，该属性不能够覆盖已存在的、已分配给 MeshStandardMaterial.envMap 的贴图。默认为 null。</p>
<p>.fog : Fog<br>一个 fog 实例定义了影响场景中的每个物体的雾的类型。默认值为 null。</p>
<p>.isScene : Boolean</p>
<p>.overrideMaterial : Material<br>如果不为空，它将强制场景中的每个物体使用这里的材质来渲染。默认值为 null。</p>
<h5 id="方法-12"><a href="#方法-12" class="headerlink" title="方法"></a>方法</h5><p>.toJSON : Object<br>meta – 包含有元数据的对象，例如场景中的的纹理或图片。 将 scene 对象转换为 three.js JSON Object/Scene format（three.js JSON 物体/场景格式）。</p>
<h4 id="雾（Fog）"><a href="#雾（Fog）" class="headerlink" title="雾（Fog）"></a>雾（Fog）</h4><p>这个类中的参数定义了线性雾。也就是说，雾的密度是随着距离线性增大的。</p>
<h5 id="构造器-36"><a href="#构造器-36" class="headerlink" title="构造器"></a>构造器</h5><p>Fog( color : Integer, near : Float, far : Float )<br>颜色参数传入 Color 构造函数中，来设置颜色属性。颜色可以是一个十六进制的整型数，或者是 CSS 风格的字符串。</p>
<h5 id="属性-13"><a href="#属性-13" class="headerlink" title="属性"></a>属性</h5><p>.isFog : Boolean<br>Read-only flag to check if a given object is of type Fog.</p>
<p>.name : String<br>对象的名称，可选、不必唯一。默认值是一个空字符串。</p>
<p>.color : Color<br>雾的颜色。比如说，如果将其设置为黑色，远处的物体将被渲染成黑色。</p>
<p>.near : Float<br>开始应用雾的最小距离。距离小于活动摄像机“near”个单位的物体将不会被雾所影响。</p>
<p>默认值是 1。</p>
<p>.far : Float<br>结束计算、应用雾的最大距离，距离大于活动摄像机“far”个单位的物体将不会被雾所影响。</p>
<p>默认值是 1000。</p>
<h5 id="方法-13"><a href="#方法-13" class="headerlink" title="方法"></a>方法</h5><p>.clone () : Fog<br>返回一个具有和当前雾参数相同的新的 Fog 实例。</p>
<p>.toJSON () : Object<br>以 JSON 格式返回 Fog 的数据。</p>
<h4 id="雾-指数（FogExp2）"><a href="#雾-指数（FogExp2）" class="headerlink" title="雾-指数（FogExp2）"></a>雾-指数（FogExp2）</h4><p>该类所包含的参数定义了指数雾，它可以在相机附近提供清晰的视野，且距离相机越远，雾的浓度随着指数增长越快。</p>
<h5 id="构造器-37"><a href="#构造器-37" class="headerlink" title="构造器"></a>构造器</h5><p>FogExp2( color : Integer, density : Float )<br>颜色参数传入 Color 构造函数中，来设置颜色属性。颜色可以是一个十六进制的整型数，或者是 CSS 风格的字符串。</p>
<h5 id="属性-14"><a href="#属性-14" class="headerlink" title="属性"></a>属性</h5><p>.isFogExp2 : Boolean<br>Read-only flag to check if a given object is of type FogExp2.</p>
<p>.name : String<br>对象的名称，可选、不必唯一。默认值是一个空字符串。</p>
<p>.color : Color<br>雾的颜色。比如说，如果将其设置为黑色，远处的物体将被渲染成黑色。</p>
<p>.density : Float<br>定义雾的密度将会增长多块。</p>
<p>默认值是 0.00025.</p>
<h5 id="方法-14"><a href="#方法-14" class="headerlink" title="方法"></a>方法</h5><p>.clone () : FogExp2<br>返回一个具有和当前雾参数相同的新的 FogExp2 实例。</p>
<p>.toJSON () : Object<br>以 JSON 格式返回 FogExp2 的数据。</p>
<h3 id="光源"><a href="#光源" class="headerlink" title="光源"></a>光源</h3><h4 id="Light"><a href="#Light" class="headerlink" title="Light"></a>Light</h4><h5 id="构造器（Constructor）"><a href="#构造器（Constructor）" class="headerlink" title="构造器（Constructor）"></a>构造器（Constructor）</h5><p><code>Light( color : Integer, intensity : Float )</code><br>color - (可选参数) 16 进制表示光的颜色。 缺省值 0xffffff (白色)。<br>intensity - (可选参数) 光照强度。 缺省值 1。</p>
<p>创造一个新的光源。注意，这并不是直接调用的（而是使用派生类之一）。</p>
<h5 id="属性（Properties）"><a href="#属性（Properties）" class="headerlink" title="属性（Properties）"></a>属性（Properties）</h5><p>公共属性请查看基类 Object3D。</p>
<p>.color : Color<br>光源的颜色。如果构造的时候没有传递，默认会创建一个新的 Color 并设置为白色。</p>
<p>.intensity : Float<br>光照的强度，或者说能量。 在 physically correct 模式下, color 和强度 的乘积被解析为以坎德拉（candela）为单位的发光强度。 默认值 - 1.0<br>.isLight : Boolean<br>Read-only flag to check if a given object is of type Light.</p>
<h5 id="Methods"><a href="#Methods" class="headerlink" title="Methods"></a>Methods</h5><p>公共方法请查看基类 Object3D。</p>
<p>.copy ( source : Light ) : this<br>从 source 复制 color, intensity 的值到当前光源对象中。</p>
<p>.toJSON ( meta : Object ) : Object<br>以 JSON 格式返回光数据。</p>
<p>meta – 包含有元数据的对象，例如该对象的材质、纹理或图片。 将该 light 对象转换为 three.js JSON Object/Scene format（three.js JSON 物体/场景格式）。</p>
<h4 id="环境光-AmbientLight"><a href="#环境光-AmbientLight" class="headerlink" title="环境光 AmbientLight"></a>环境光 AmbientLight</h4><p>环境光会均匀的照亮场景中的所有物体。环境光不能用来投射阴影，因为它没有方向。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> light = <span class="keyword">new</span> THREE.AmbientLight(<span class="number">0x404040</span>); <span class="comment">// soft white light</span></span><br><span class="line">scene.add(light);</span><br></pre></td></tr></table></figure>

<p>构造函数<br><code>AmbientLight( color : Integer, intensity : Float )</code><br>color - （参数可选）颜色的 rgb 数值。缺省值为 0xffffff。<br>intensity - (参数可选)光照的强度。缺省值为 1。</p>
<p>创建一个环境光对象。</p>
<h5 id="属性-方法-22"><a href="#属性-方法-22" class="headerlink" title="属性|方法"></a>属性|方法</h5><blockquote>
<p>公共属性请查看基类 Light。<br>公共方法请查看基类 Light。</p>
</blockquote>
<p>.castShadow : Boolean<br>这个参数在对象构造的时候就被设置成了 undefined 。因为环境光不能投射阴影。</p>
<p>.isAmbientLight : Boolean<br>Read-only flag to check if a given object is of type AmbientLight.</p>
<h4 id="平行光（DirectionalLight）"><a href="#平行光（DirectionalLight）" class="headerlink" title="平行光（DirectionalLight）"></a>平行光（DirectionalLight）</h4><p>平行光是沿着特定方向发射的光。这种光的表现像是无限远,从它发出的光线都是平行的。常常用平行光来模拟太阳光 的效果;</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> directionalLight = <span class="keyword">new</span> THREE.DirectionalLight(<span class="number">0xffffff</span>, <span class="number">0.5</span>);</span><br><span class="line">scene.add(directionalLight);</span><br></pre></td></tr></table></figure>

<h5 id="构造函数-3"><a href="#构造函数-3" class="headerlink" title="构造函数"></a>构造函数</h5><p><code>DirectionalLight( color : Integer, intensity : Float )</code><br>color - (可选参数) 16 进制表示光的颜色。 缺省值为 0xffffff (白色)。<br>intensity - (可选参数) 光照的强度。缺省值为 1。</p>
<h5 id="属性-方法-23"><a href="#属性-方法-23" class="headerlink" title="属性|方法"></a>属性|方法</h5><blockquote>
<p>公共属性请查看基类 Light。<br>公共方法请查看基类 Light。</p>
</blockquote>
<p>.castShadow : Boolean<br>如果设置为 true 该平行光会产生动态阴影。 警告: 这样做的代价比较高而且需要一直调整到阴影看起来正确. 查看 DirectionalLightShadow 了解详细信息。该属性默认为 false。</p>
<p>.isDirectionalLight : Boolean<br>Read-only flag to check if a given object is of type DirectionalLight.</p>
<p>.position : Vector3<br>假如这个值设置等于 Object3D.DEFAULT_UP (0, 1, 0),那么光线将会从上往下照射。</p>
<p>.shadow : DirectionalLightShadow<br>这个 DirectionalLightShadow 对象用来计算该平行光产生的阴影。</p>
<p>.target : Object3D<br>平行光的方向是从它的位置到目标位置。默认的目标位置为原点 (0,0,0)。<br>注意: 对于目标的位置，要将其更改为除缺省值之外的任何位置,它必须被添加到 scene 场景中去。<code>scene.add( light.target );</code><br>这使得属性 target 中的 matrixWorld 会每帧自动更新。</p>
<p>它也可以设置 target 为场景中的其他对象(任意拥有 position 属性的对象), 示例如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> targetObject = <span class="keyword">new</span> THREE.Object3D();</span><br><span class="line">scene.add(targetObject);</span><br><span class="line"></span><br><span class="line">light.target = targetObject;</span><br></pre></td></tr></table></figure>

<p>完成上述操作后，平行光现在就可以追踪到目标对像了。</p>
<h5 id="方法-15"><a href="#方法-15" class="headerlink" title="方法"></a>方法</h5><p><code>.copy ( source : DirectionalLight ) : this</code><br>复制 source 的值到这个平行光源对象。</p>
<h4 id="点光源（PointLight）"><a href="#点光源（PointLight）" class="headerlink" title="点光源（PointLight）"></a>点光源（PointLight）</h4><p>从一个点向各个方向发射的光源。一个常见的例子是模拟一个灯泡发出的光。该光源可以投射阴影</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> light = <span class="keyword">new</span> THREE.PointLight(<span class="number">0xff0000</span>, <span class="number">1</span>, <span class="number">100</span>);</span><br><span class="line">light.position.set(<span class="number">50</span>, <span class="number">50</span>, <span class="number">50</span>);</span><br><span class="line">scene.add(light);</span><br></pre></td></tr></table></figure>

<h5 id="构造函数-4"><a href="#构造函数-4" class="headerlink" title="构造函数"></a>构造函数</h5><p><code>PointLight( color : Integer, intensity : Float, distance : Number, decay : Float )</code><br>color - (可选参数)) 十六进制光照颜色。 缺省值 0xffffff (白色)。<br>intensity - (可选参数) 光照强度。 缺省值 1。<br>distance - 这个距离表示从光源到光照强度为 0 的位置。 当设置为 0 时，光永远不会消失(距离无穷大)。缺省值 0.<br>decay - 沿着光照距离的衰退量。缺省值 2。</p>
<h5 id="属性-方法-24"><a href="#属性-方法-24" class="headerlink" title="属性|方法"></a>属性|方法</h5><blockquote>
<p>公共属性请查看基类 Light。<br>公共方法请查看基类 Light。</p>
</blockquote>
<p>.castShadow : Boolean<br>如果设置为 true 该平行光会产生动态阴影。 警告: 这样做的代价比较高而且需要一直调整到阴影看起来正确. 查看 DirectionalLightShadow 了解详细信息。该属性默认为 false。<br>.distance : Float<br>如果非零，那么光强度将会从最大值当前灯光位置处按照距离线性衰减到 0。 缺省值为 0.0。</p>
<p>.power : Float<br>光功率<br>在 physically correct 模式中, 表示以”流明（光通量单位）”为单位的光功率。 缺省值 - 4Math.PI。</p>
<p>该值与 intensity 直接关联<br><code>power = intensity * 4π</code>修改该值也会导致光强度的改变。</p>
<p>.shadow : PointLightShadow<br>PointLightShadow 用与计算此光照的阴影。</p>
<p>此对象的摄像机被设置为 fov 为 90 度，aspect 为 1， 近裁剪面 near 为 0，远裁剪面 far 为 500 的透视摄像机 PerspectiveCamera。</p>
<p>.decay : Float<br>The amount the light dims along the distance of the light. Default is 2.<br>In context of physically-correct rendering the default value should not be changed.</p>
<h5 id="方法-16"><a href="#方法-16" class="headerlink" title="方法"></a>方法</h5><p><code>.copy ( source : PointLight ) : this</code><br>将所有属性的值从源 source 复制到此点光源对象。</p>
<h4 id="聚光灯（SpotLight）"><a href="#聚光灯（SpotLight）" class="headerlink" title="聚光灯（SpotLight）"></a>聚光灯（SpotLight）</h4><p>光线从一个点沿一个方向射出，随着光线照射的变远，光线圆锥体的尺寸也逐渐增大。该光源可以投射阴影</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> spotLight = <span class="keyword">new</span> THREE.SpotLight(<span class="number">0xffffff</span>);</span><br><span class="line">spotLight.position.set(<span class="number">100</span>, <span class="number">1000</span>, <span class="number">100</span>);</span><br><span class="line">spotLight.map = <span class="keyword">new</span> THREE.TextureLoader().load(url);</span><br><span class="line"></span><br><span class="line">spotLight.castShadow = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">spotLight.shadow.mapSize.width = <span class="number">1024</span>;</span><br><span class="line">spotLight.shadow.mapSize.height = <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">spotLight.shadow.camera.near = <span class="number">500</span>;</span><br><span class="line">spotLight.shadow.camera.far = <span class="number">4000</span>;</span><br><span class="line">spotLight.shadow.camera.fov = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">scene.add(spotLight);</span><br></pre></td></tr></table></figure>

<h5 id="构造函数-5"><a href="#构造函数-5" class="headerlink" title="构造函数"></a>构造函数</h5><p><code>SpotLight( color : Integer, intensity : Float, distance : Float, angle : Radians, penumbra : Float, decay : Float )</code><br>color - (可选参数) 十六进制光照颜色。 缺省值 0xffffff (白色)。<br>intensity - (可选参数) 光照强度。 缺省值 1。<br>distance - 从光源发出光的最大距离，其强度根据光源的距离线性衰减。<br>angle - 光线散射角度，最大为 Math.PI/2。<br>penumbra - 聚光锥的半影衰减百分比。在 0 和 1 之间的值。默认为 0。<br>decay - 沿着光照距离的衰减量。</p>
<h5 id="属性-方法-25"><a href="#属性-方法-25" class="headerlink" title="属性|方法"></a>属性|方法</h5><blockquote>
<p>公共属性请查看基类 Light。<br>公共方法请查看基类 Light。</p>
</blockquote>
<p>.angle : Float<br>从聚光灯的位置以弧度表示聚光灯的最大范围。应该不超过 Math.PI/2。默认值为 Math.PI/3。</p>
<p>.castShadow : Boolean<br>此属性设置为 true 聚光灯将投射阴影。警告: 这样做的代价比较高而且需要一直调整到阴影看起来正确。 查看 SpotLightShadow 了解详细信息。 默认值为 false</p>
<p>.decay : Float<br>The amount the light dims along the distance of the light. Default is 2.<br>In context of physically-correct rendering the default value should not be changed.</p>
<p>.distance : Float<br>如果非零，那么光强度将会从最大值当前灯光位置处按照距离线性衰减到 0。 缺省值为 0.0。</p>
<p>.isSpotLight : Boolean<br>Read-only flag to check if a given object is of type SpotLight.</p>
<p>.penumbra : Float<br>聚光锥的半影衰减百分比。在 0 和 1 之间的值。 默认值 — 0.0。</p>
<p>.position : Vector3<br>假如这个值设置等于 Object3D.DEFAULT_UP (0, 1, 0)，那么光线将会从上往下照射。</p>
<p>.power : Float<br>光功率<br>在 physically correct 模式中， 表示以”流明（光通量单位）”为单位的光功率。 缺省值 - 4Math.PI。</p>
<p>该值与 intensity 直接关联<br>power = intensity * 4π 修改该值也会导致光强度的改变。</p>
<p>.shadow : SpotLightShadow<br>SpotLightShadow 用与计算此光照的阴影。</p>
<p>.target : Object3D<br>聚光灯的方向是从它的位置到目标位置.默认的目标位置为原点 (0,0,0)。<br>注意: 对于目标的位置，要将其更改为除缺省值之外的任何位置，它必须被添加到 scene 场景中去。<br>scene.add( light.target );这使得属性 target 中的 matrixWorld 会每帧自动更新。</p>
<p>它也可以设置 target 为场景中的其他对象(任意拥有 position 属性的对象), 示例如下:<br>const targetObject = new THREE.Object3D();<br>scene.add(targetObject);</p>
<p>light.target = targetObject;完成上述操作后，聚光灯现在就可以追踪到目标对像了。</p>
<p>.map : Texture<br>A Texture used to modulate the color of the light. The spot light color is mixed with the RGB value of this texture, with a ratio corresponding to its alpha value. The cookie-like masking effect is reproduced using pixel values (0, 0, 0, 1-cookie_value). Warning: map : SpotLight is disabled if castShadow : SpotLight is false.</p>
<h5 id="方法（Methods）"><a href="#方法（Methods）" class="headerlink" title="方法（Methods）"></a>方法（Methods）</h5><p>公共方法请查看基类 Light。</p>
<p>.copy ( source : SpotLight ) : this<br>将所有属性的值从源 source 复制到此聚光灯光源对象。</p>
<h4 id="平面光光源（RectAreaLight）"><a href="#平面光光源（RectAreaLight）" class="headerlink" title="平面光光源（RectAreaLight）"></a>平面光光源（RectAreaLight）</h4><p>平面光光源从一个矩形平面上均匀地发射光线。这种光源可以用来模拟像明亮的窗户或者条状灯光光源。</p>
<p>注意事项:</p>
<p>不支持阴影。<br>只支持 MeshStandardMaterial 和 MeshPhysicalMaterial 两种材质。<br>你必须在你的场景中加入 RectAreaLightUniformsLib ，并调用 init()。</p>
<h3 id="三维坐标系"><a href="#三维坐标系" class="headerlink" title="三维坐标系"></a>三维坐标系</h3><p>AxesHelper 的 xyz 轴<br>three.js 坐标轴颜色红 R、绿 G、蓝 B 分别对应坐标系的 x、y、z 轴，对于 three.js 的 3D 坐标系默认 y 轴朝上。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AxesHelper：辅助观察的坐标系</span></span><br><span class="line"><span class="keyword">const</span> axesHelper = <span class="keyword">new</span> THREE.AxesHelper(<span class="number">150</span>);</span><br><span class="line">scene.add(axesHelper);</span><br></pre></td></tr></table></figure>

<h2 id="坐标系"><a href="#坐标系" class="headerlink" title="坐标系"></a>坐标系</h2><h3 id="屏幕坐标-空间坐标"><a href="#屏幕坐标-空间坐标" class="headerlink" title="屏幕坐标,空间坐标"></a>屏幕坐标,空间坐标</h3><p>ThreeJS 是使用了 canvas 画布绘制图形的，因此屏幕坐标系就是 canvas 中的坐标系，也就是左上角是坐标原点</p>
<p>Mesh 的坐标是用一个 Vector3 来表示的，Vector3 中包含了 x、y、z 坐标。</p>
<p>空间坐标系是三维的，其原点默认在屏幕中心，且 x y z 的范围是 [-1,1]，通过 Vector3 对象的方法 project，方法的参数是相机对象，语句 worldVector.project(camera);返回的结果是世界坐标 worldVector 在 camera 相机对象矩阵变化下对应的标准设备坐标， 标准设备坐标 xyz 的范围是[-1,1]。</p>
<p>ThreeJS 中，画布一般是全屏的，因此画布的宽高 w,h 就是：window.innerWidth 和 window.innerHeight，所以 Three 的空间坐标系中点 (cx, cy)在屏幕坐标系中就是：(w / 2,h / 2)。</p>
<p>假设 canvas 中有一点 (x,y)，这个点在空间坐标系中为 (x1,y1)，那么这个转换公式是：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">x1=(x/w)∗<span class="number">2</span>−<span class="number">1</span></span><br><span class="line">y1=−(y/h)∗<span class="number">2</span>+<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//推导如下</span></span><br><span class="line"><span class="comment">//#####################</span></span><br><span class="line">cx=w/<span class="number">2</span></span><br><span class="line">cy=h/<span class="number">2</span></span><br><span class="line"><span class="comment">//屏幕坐标系中的点(x,y),空间坐标中的点（x1,y1）</span></span><br><span class="line">x1=x-cx</span><br><span class="line">y2=cy-y</span><br><span class="line"><span class="comment">//标准化[-1,1]之间</span></span><br><span class="line">x1/cx=(x-cx)/cx=x/cx-<span class="number">1</span>=x/w/<span class="number">2</span>-<span class="number">1</span>=2x/w-<span class="number">1</span></span><br><span class="line">y1/cy=(cy-y)/cy=<span class="number">1</span>-y/cy=<span class="number">1</span>-2y/h</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> worldVetor = boxMesh.position.cone();</span><br><span class="line"><span class="comment">//世界坐标系转标准设备坐标</span></span><br><span class="line"><span class="comment">//提取相机参数的视图矩阵、投影矩阵对世界坐标进行转换</span></span><br><span class="line"><span class="keyword">let</span> standard = worldVetor.project(camera);</span><br><span class="line"><span class="comment">//</span></span><br></pre></td></tr></table></figure>

<h2 id="全屏"><a href="#全屏" class="headerlink" title="全屏"></a>全屏</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;dblclick&#x27;</span>,<span class="function">()=&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> isFull=<span class="built_in">document</span>.fullscreenElement;</span><br><span class="line">  <span class="keyword">if</span>(!isFull)&#123;</span><br><span class="line">    renderer.domElement.requestFullscreen();</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">document</span>.exitFullscreen();</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="自适应屏幕"><a href="#自适应屏幕" class="headerlink" title="自适应屏幕"></a>自适应屏幕</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;resize&#x27;</span>,<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  <span class="comment">//更新摄像头</span></span><br><span class="line">  camera.aspect=<span class="built_in">window</span>.innerWidth/<span class="built_in">window</span>.innerHeight</span><br><span class="line">   <span class="comment">// 渲染器执行render方法的时候会读取相机对象的投影矩阵属性projectionMatrix</span></span><br><span class="line">    <span class="comment">// 但是不会每渲染一帧，就通过相机的属性计算投影矩阵(节约计算资源)</span></span><br><span class="line">  <span class="comment">//更新摄像机投影矩阵</span></span><br><span class="line">  camera.updateProjectionMatrix();</span><br><span class="line">  <span class="comment">//更新渲染器</span></span><br><span class="line">  renderer.setSize(<span class="built_in">window</span>.innerWidth,<span class="built_in">window</span>.innerHeight)</span><br><span class="line">  <span class="comment">//设置渲染器的像素比</span></span><br><span class="line">  renderer.setPixelRatio(<span class="built_in">window</span>.devicePixelRatio)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://a913481180.github.io/2022/08/11/20-22-22/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="KK">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KK">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/11/20-22-22/" class="post-title-link" itemprop="url">nginx</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-08-11 20:22:22" itemprop="dateCreated datePublished" datetime="2022-08-11T20:22:22+08:00">2022-08-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-05-14 23:12:11" itemprop="dateModified" datetime="2024-05-14T23:12:11+08:00">2024-05-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h1><blockquote>
<p>负载均衡、反向代理、动静结合</p>
</blockquote>
<h2 id="配置文件匹配顺序"><a href="#配置文件匹配顺序" class="headerlink" title="配置文件匹配顺序"></a>配置文件匹配顺序</h2><p><code>/etc/nginx/conf.d/</code>多个配置文件时，会优先匹配配置了<code>server_name</code>且值不是<code>localhost</code>，接着是<code>localhost</code>，再接着是没有配置的。若端口号和<code>server_name</code>都一样则优先选择该目录下的第一个配置文件。</p>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">nginx -v</span><br><span class="line">nginx -V</span><br><span class="line">nginx -t //查看配置是否有问题</span><br><span class="line">nginx -s reload //重新加载配置</span><br><span class="line">nginx -s stop //强行停止</span><br><span class="line">nginx -s quit //安全退出</span><br><span class="line">ps -ef|grep nginx //查看进程</span><br><span class="line">systemctl <span class="built_in">enable</span> nginx //开机自动启动</span><br><span class="line">//防火墙</span><br><span class="line">systemctl status firewalld.service</span><br><span class="line">systemctl stop firewalld.service</span><br><span class="line">systemctl <span class="built_in">disable</span> firewalld.service</span><br><span class="line">systemctl status firewalld.service</span><br></pre></td></tr></table></figure>

<h2 id="开启-GZIP-压缩"><a href="#开启-GZIP-压缩" class="headerlink" title="开启 GZIP 压缩"></a>开启 GZIP 压缩</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">    gzip on;</span><br><span class="line">    gzip_types application/javascript;<span class="comment">#压缩类型，文本文件压缩效果最好,图片视频资源压缩作用不大，大文件资源会消耗大量cpu资源不推荐</span></span><br><span class="line">    gzip_min_length 1k;<span class="comment">#最小压缩单位，小于1k压缩意义不大</span></span><br><span class="line">    gzip_comp_level 5;<span class="comment">#压缩级别，1-9，数字越大压缩效果越好，但会加大cpu压力，高并发场景不建议调太高,建议5左右</span></span><br><span class="line">    gzip_vary on;<span class="comment">#在响应头添加very:accept-encoding,让代理服务器根据请求头识别是否启用了gzip压缩</span></span><br><span class="line">    gzip_http_version 1.1;<span class="comment">#启用gzip压缩的最低http版本，默认1.1</span></span><br><span class="line">    gzip_buffers 4 4k;<span class="comment">#设置压缩所需的缓冲区大小和申请内存的倍率，如4 4k代表以4k为单位，按照原始数据大小以4k为单位的4倍申请内存。默认是申请跟原始数据相同大小的内存空间。</span></span><br><span class="line">    gzip_static on;<span class="comment">#静态压缩，若提前已准备好了压缩文件.gz的压缩包或者提供静态文件服务，可以启用。它可避免动态压缩，提高性能</span></span><br><span class="line">    gzip_proxied off;<span class="comment">#nginx作为反向代理时，开启或关闭后端服务器返回的结果（前提是后端必须返回包含Via的请求头）。off-关闭所有代理结果数据的压缩。expired-若请求头包含‘Expires’信息，则启用。no-cache-若请求头包含‘Cache-Control:no-cache’信息，则启用。no-store-若请求头包含‘Cache-Control:no-store’信息，则启用。private-&gt;若请求头包含‘Cache-Control:private’信息，则启用。no_last_modified-&gt;若请求头不包含‘Last-Modified’信息，则启用。no_etag-&gt;若请求头不包含‘Etag’信息，则启用。auth-&gt;若请求头包含“Authorization&quot;信息，则启用。any-&gt;无条件启用压缩</span></span><br><span class="line">    gzip_disable MSIE[1-6]\.;<span class="comment">#设置禁用浏览器进行Gzip压缩，ie6对gzip压缩支持不好，会造成假死。</span></span><br><span class="line">    listen 8080;</span><br><span class="line">    server_name localhost;</span><br><span class="line">    location / &#123;</span><br><span class="line">        root /opt/<span class="built_in">test</span>/;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="开启-Brotli"><a href="#开启-Brotli" class="headerlink" title="开启 Brotli"></a>开启 Brotli</h2><blockquote>
<p>比 gzip 性能高，ie 浏览器不支持，仅支持 https，无法使用时，会降级为 gzip</p>
</blockquote>
<ol>
<li>下载源码</li>
<li>下载算法</li>
<li>重新编译，<code>./configure --prefix=安装目录 --with-http_ssl_module --add-module=brotli的安装目录</code></li>
<li>安装好后，将 objs 文件夹中 nginx 执行文件替换掉 sbin 中的执行文件</li>
<li>编辑文件</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">    ...</span><br><span class="line">brotli on；</span><br><span class="line">brotli_type application/javascript;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="请求限流"><a href="#请求限流" class="headerlink" title="请求限流"></a>请求限流</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">语法：limit_req zone=name [burst=number][nodelay|delay=number];</span><br><span class="line">上下文：http,server,location</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">http:&#123;</span><br><span class="line">limit_req_zone <span class="variable">$binary_remote_addr</span> zone=ip_limit:10m rate=1r/s;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>$binary_remote_addr</code>-&gt;通过 remote_addr 这个标识来做限制，限制的是同一客户端的 ip 地址，在这里，客户端 ip 地址作为关键。注意，不是<code>$ remote_addr</code>,<code>$ remote_addr</code>变量的大小可以从 7 到 15 个字节不等，存储状态在 32 位平台上占用 32 或 64 字节，在 64 位平台上总是 64 字节。对于 ipv4 地址，<code>$binary_remote_addr</code>变量始终是 4 个字节，对于 ipv6 地址则为 16 个字节，<br><code>zone=ip_limit:10m</code>-&gt;生成一个 10MB 大小，名字为 ip_limitd 的内存区域，主要用来存储访问频次信息。<br><code>rate=1r/s</code>-&gt;标识允许相同标识客户端的一个访问频次，1r 即 1 次</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">    ...</span><br><span class="line">location / &#123;</span><br><span class="line">limit_req zone=ip_limit burst=5 nodelay;</span><br><span class="line">...</span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure>

<p><code>zone</code>-&gt;表示使用哪个区域来做限制<br><code>burst</code>-&gt;设置了一个大小为 5 的缓存区，当有大量请求即 burst 时，超过访问频次限制的请求可以先放到此缓存区。<br><code>nodelay</code>-&gt;超过访问频次且缓存区也满了的时候，直接返回 503，若无设置，则请求会等待排队。</p>
<h2 id="连接限流"><a href="#连接限流" class="headerlink" title="连接限流"></a>连接限流</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">语法：limit_conn zone number;</span><br><span class="line">上下文：http,server,location</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">http:&#123;</span><br><span class="line">limit_conn_zone <span class="variable">$binary_remote_addr</span> zone=addr:10m;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>$binary_remote_addr</code>-&gt;通过 remote_addr 这个标识来做限制，限制的是同一客户端的 ip 地址.<br><code>zone=addr:10m</code>-&gt;生成一个 10MB 大小，名字为 addr 的内存区域，主要用来存储访问频次信息。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">...</span><br><span class="line">location / &#123;</span><br><span class="line">limit_conn addr 1;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>zone</code>-&gt;表示使用哪个区域来做限制<br><code>1</code>-&gt;允许相同标识客户端的一个访问频次，1 代表只允许每个 ip 地址 1 个连接。</p>
<h2 id="防盗链"><a href="#防盗链" class="headerlink" title="防盗链"></a>防盗链</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">server&#123;</span><br><span class="line">listen 8080;</span><br><span class="line">server_name localhost;</span><br><span class="line">location / &#123;</span><br><span class="line">root /opt/<span class="built_in">test</span>/;</span><br><span class="line">&#125;</span><br><span class="line">location ~_ ._\.(gif|jpg|png)<span class="variable">$&#123;</span></span><br><span class="line"><span class="variable">        root /opt/test/img/;</span></span><br><span class="line"><span class="variable">        valid_referers none blocked xxx.com;</span></span><br><span class="line"><span class="variable">        if($invalid_referer)&#123;</span></span><br><span class="line"><span class="variable">#return 403;返回错误页面</span></span><br><span class="line"><span class="variable">rewrite ^/ http://xxxx/error;</span></span><br><span class="line"><span class="variable">break;</span></span><br><span class="line"><span class="variable">&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>破解方法</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">header</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;referrer&quot;</span> <span class="attr">content</span>=<span class="string">&quot;no-referrer&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="如何利用-Nginx-代理获取真实-IP"><a href="#如何利用-Nginx-代理获取真实-IP" class="headerlink" title="如何利用 Nginx 代理获取真实 IP"></a>如何利用 Nginx 代理获取真实 IP</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">listen 80;</span><br><span class="line">server_name xxx.xxxx.com;</span><br><span class="line"></span><br><span class="line">location / &#123; <span class="comment">#保留代理之前的 host 包含客户端真实的域名和端口号</span></span><br><span class="line">proxy_set_header Host <span class="variable">$host</span>; <span class="comment">#保留代理之前的真实客户端 ip</span></span><br><span class="line">proxy_set_header X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line"> <span class="comment">#这个 Header 和 X-Real-IP 类似，但它在多级代理时会包含真实客户端及中间每个代理服务器的 IP</span></span><br><span class="line">proxy_set_header X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>; <span class="comment">#表示客户端真实的协议（http 还是 https）</span></span><br><span class="line">proxy_set_header X-Forwarded-Proto <span class="variable">$scheme</span>; <span class="comment">#指定修改被代理服务器返回的响应头中的 location 头域跟 refresh 头域数值 #如果使用&quot;default&quot;参数，将根据 location 和 proxy_pass 参数的设置来决定。</span></span><br><span class="line"><span class="comment">#proxy_redirect [ default|off|redirect replacement ];</span></span><br><span class="line">proxy_redirect off;</span><br><span class="line">proxy_pass http://IP:PORT;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>经过反向代理后，由于在客户端和 web 服务器之间增加了中间层，因此 web 服务器无法直接拿到客户端的 ip，通过<code>$remote_addr</code>变量拿到的将是反向代理服务器的 ip 地址。</p>
<p>这句话的意思是说，当你使用了 nginx 反向服务器后，在 web 端使用 <code>request.getRemoteAddr()</code>（本质上就是获取<code>$remote_addr</code>），取得的是 nginx 的地址，即<code>$remote_addr</code>变量中封装的是 nginx 的地址，当然是没法获得用户的真实 ip 的。但是，nginx 是可以获得用户的真实 ip 的，也就是说 nginx 使用<code>$remote_addr</code>变量时获得的是用户的真实 ip，如果我们想要在 web 端获得用户的真实 ip，就必须在 nginx 里作一个赋值操作，即我在上面的配置：</p>
<p><code>proxy_set_header X-Real-IP $remote_addr;</code>。</p>
<p><code>$remote_addr</code> 只能获取到与服务器本身直连的上层请求 ip，所以设置<code>$remote_addr</code> 一般都是设置第一个代理上面;</p>
<p>但是问题是，有时候是通过 cdn 访问过来的，那么后面 web 服务器获取到的，永远都是 cdn 的 ip 而非真是用户 ip,那么这个时候就要用到<code>X-Forwarded-For</code>了，这个变量的意思，其实就像是链路反追踪，从客户的真实 ip 为起点，穿过多层级的 proxy ，最终到达 web 服务器，都会记录下来，所以在获取用户真实 ip 的时候，一般就可以设置成下面的配置：</p>
<p><code>proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</code>。</p>
<p><code>X-Forwarded-For</code>变量，这是一个 squid 开发的，用于识别通过 HTTP 代理或负载平衡器原始 IP 一个连接到 Web 服务器的客户机地址的非 rfc 标准，如果有做<code>X-Forwarded-For</code>设置的话,每次经过 proxy 转发都会有记录,格式就是<code>client1,proxy1,proxy2</code>以逗号隔开各个地址，由于它是非 rfc 标准，所以默认是没有的，需要强制添加。在默认情况下经过 proxy 转发的请求，在后端看来远程地址都是 proxy 端的 ip 。也就是说在默认情况下我们使用<code>request.getAttribute(“X-Forwarded-For”)</code>获取不到用户的 ip，如果我们想要通过这个变量获得用户的 ip，我们需要自己在 nginx 添加配置：</p>
<p><code>proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</code></p>
<p>它意思是增加一个<code>$proxy_add_x_forwarded_for</code>到<code>X-Forwarded-For</code>里去，注意是增加，而不是覆盖，当然由于默认的<code>X-Forwarded-For</code>值是空的，所以我们总感觉<code>X-Forwarded-For</code>的值就等于<code>$proxy_add_x_forwarded_for</code>的值，实际上当你搭建两台 nginx 在不同的 ip 上，并且都使用了这段配置，那你会发现在 web 服务器端通过 <code>request.getAttribute(“X-Forwarded-For”)</code>获得的将会是客户端 ip 和第一台 nginx 的 ip。</p>
<p>那么<code>$proxy_add_x_forwarded_for</code>又是什么？</p>
<p><code>$proxy_add_x_forwarded_for</code>变量包含客户端请求头中的<code>X-Forwarded-For</code>与<code>$remote_addr</code>两部分，他们之间用逗号分开。</p>
<p>举个例子，有一个 web 应用，在它之前通过了两个 nginx 转发，<a target="_blank" rel="noopener" href="http://www.linuxidc.com即用户访问该web通过两台nginx./">www.linuxidc.com即用户访问该web通过两台nginx。</a></p>
<p>在第一台 nginx 中,使用：</p>
<p><code>proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</code></p>
<p>现在的<code>$proxy_add_x_forwarded_for</code>变量的<code>X-Forwarded-For</code>部分是空的，所以只有<code>$remote_addr</code>，而<code>$remote_addr</code>的值是用户的 ip，于是赋值以后，<code>X-Forwarded-For</code>变量的值就是用户的真实的 ip 地址了。</p>
<p>到了第二台 nginx，使用：</p>
<p><code>proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</code></p>
<p>现在的<code>$proxy_add_x_forwarded_for</code>变量，<code>X-Forwarded-For</code>部分包含的是用户的真实 ip，<code>$remote_addr</code>部分的值是上一台 nginx 的 ip 地址，于是通过这个赋值以后现在的<code>X-Forwarded-For</code>的值就变成了“用户的真实 ip，第一台 nginx 的 ip”，这样就清楚了吧。</p>
<h2 id="部署前端项目"><a href="#部署前端项目" class="headerlink" title="部署前端项目"></a>部署前端项目</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">  listen 8080;#监听的端口</span><br><span class="line">  location /&#123;</span><br><span class="line">    try_files $uri $uri/ /index.html;</span><br><span class="line">    root  /home/build;##/home/build为项目打包文件所在的目录</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  location /apis&#123;</span><br><span class="line">    rewrite ^.+apis/?(.*)$ $1 break;##除去/apis</span><br><span class="line">    proxy_pass http://192.168.2.16:8080;##接口代理到服务器</span><br><span class="line">    ## 真实ip</span><br><span class="line">    proxy_set_header Host $host;</span><br><span class="line">    proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">    ## 504 Gateway Time-out</span><br><span class="line">    proxy_connect_timeout 300s;</span><br><span class="line">    proxy_send_timeout 300s;</span><br><span class="line">    proxy_read_timeout 300s;</span><br><span class="line">    ## 日志</span><br><span class="line">    #access_log /var/log/nginx/access.foo.log main;</span><br><span class="line">    #error_log /var/log/nginx/error.foo.log;</span><br><span class="line">  &#125;</span><br><span class="line">  client_max_body_size 10m;#Nginx默认的request body为1M</span><br><span class="line">  gzip on;#开启gzip压缩</span><br><span class="line">  gzip_min_length 1k;#大于1k的文件才压缩</span><br><span class="line">  gzip_types text/plain text/css text/javascript application/xml application/x-javascript application/javascript;#压缩类型，文本文件压缩效果最好,图片视频资源压缩作用不大，大文件资源会消耗大量cpu资源不推荐</span><br><span class="line">  gzip_disable MSIE[1-6]\.;#设置禁用浏览器进行Gzip压缩，ie6对gzip压缩支持不好，会造成假死。</span><br><span class="line">  gzip_vary on;#在响应头添加very:accept-encoding,让代理服务器根据请求头识别是否启用了gzip压缩</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h2><h3 id="403-Forbidden"><a href="#403-Forbidden" class="headerlink" title="403 Forbidden"></a>403 Forbidden</h3><ul>
<li>资源路径是否填写正确</li>
<li>nginx 的启动用户要和当前用户一致<br>编辑<code>/etc/nginx/nginx.conf</code></li>
</ul>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="deletion">- user nginx;</span></span><br><span class="line"><span class="addition">+ user root;</span></span><br><span class="line">...</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="反向代理-504-Gateway-Time-out"><a href="#反向代理-504-Gateway-Time-out" class="headerlink" title="反向代理 504 Gateway Time-out"></a>反向代理 504 Gateway Time-out</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">proxy_connect_timeout 300s;</span><br><span class="line">proxy_send_timeout 300s;</span><br><span class="line">proxy_read_timeout 300s;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">KK</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">61</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/a913481180" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;a913481180" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:kangkanghuang@foxmail.com" title="E-Mail → mailto:kangkanghuang@foxmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="http://www.baidu.com/" title="http:&#x2F;&#x2F;www.baidu.com" rel="noopener" target="_blank">百度</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">KK</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>

<script src="/js/utils.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
